Implementation smell,Namespace,Class,File,Method,Description
Long Method,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method has 214 lines of code.
Long Method,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The method has 147 lines of code.
Long Method,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The method has 261 lines of code.
Long Method,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The method has 206 lines of code.
Long Method,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The method has 137 lines of code.
Long Method,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The method has 115 lines of code.
Long Method,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The method has 125 lines of code.
Long Method,Iffinator.Flash,StringTable,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,StringTable,The method has 129 lines of code.
Complex Method,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,Cyclomatic complexity of the method is 47
Complex Method,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,LstChunkTypes_SelectedIndexChanged,Cyclomatic complexity of the method is 17
Complex Method,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,LstSPR2s_Click,Cyclomatic complexity of the method is 26
Complex Method,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,BtnPrevFrame_Click,Cyclomatic complexity of the method is 27
Complex Method,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,BtnNextFrame_Click,Cyclomatic complexity of the method is 31
Complex Method,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,Cyclomatic complexity of the method is 26
Complex Method,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,Cyclomatic complexity of the method is 8
Complex Method,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,Cyclomatic complexity of the method is 151
Complex Method,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,Cyclomatic complexity of the method is 8
Complex Method,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,Cyclomatic complexity of the method is 29
Complex Method,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,Cyclomatic complexity of the method is 8
Complex Method,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,Cyclomatic complexity of the method is 25
Complex Method,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,Cyclomatic complexity of the method is 17
Complex Method,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,Cyclomatic complexity of the method is 26
Complex Method,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,Cyclomatic complexity of the method is 12
Complex Method,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,Cyclomatic complexity of the method is 41
Complex Method,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,Cyclomatic complexity of the method is 19
Complex Method,Iffinator.Flash,StringTable,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,StringTable,Cyclomatic complexity of the method is 37
Complex Method,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,Cyclomatic complexity of the method is 14
Long Parameter List,Iffinator.Flash,DrawGroupSprite,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupSprite.cs,DrawGroupSprite,The method has 5 parameters.
Long Statement,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,whatIsThisToolStripMenuItem_Click,The length of the statement  "	MessageBox.Show ("Here you can search for specific chunks in TSO's files.\r\n" + "Type in the name of a chunk' and then click 'Analyze'!"); " is 139.
Long Statement,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,aboutToolStripMenuItem_Click,The length of the statement  "	MessageBox.Show ("Iffinator\r\n" + "Original implementation' user-interface and framework by Mats 'Afr0' Vederhus\r\n" + "Fixes' extra functionality and format research by Nicholas Roth\r\n\r\n" + "Created for the TSO-Restoration project (http://www.tsorestoration.com)"); " is 272.
Long Statement,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The length of the statement  "	this.extractImageSpritesToolStripMenuItem.Click += new System.EventHandler (this.extractImageSpritesToolStripMenuItem_Click); " is 125.
Long Statement,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The length of the statement  "		P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")"); " is 153.
Long Statement,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The length of the statement  "			if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76) " is 131.
Long Statement,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The length of the statement  "				if (StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS") { " is 553.
Long Statement,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The length of the statement  "		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76) " is 131.
Long Statement,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The length of the statement  "		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76) " is 131.
Long Statement,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The length of the statement  "						Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error); " is 140.
Long Statement,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The length of the statement  "		Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error); " is 200.
Long Statement,Iffinator.Flash,UniqueRandom,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\UniqueRandom.cs,NewRandomNumber,The length of the statement  "		throw new System.InvalidOperationException ("All numbers in the range have now been used." + "Cannot continue selecting random numbers from a list with no members."); " is 166.
Complex Conditional,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The conditional expression  "P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF"  is complex.
Complex Conditional,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The conditional expression  "StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS""  is complex.
Complex Conditional,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ParseStrings,The conditional expression  "Chunk.Resource == "STR#" || Chunk.Resource == "TTAs" || Chunk.Resource == "CTSS" || Chunk.Resource == "CST""  is complex.
Complex Conditional,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The conditional expression  "m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11"  is complex.
Magic Number,Iffinator,BHAVEdit,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.LstInstructions.Location = new System.Drawing.Point (12' 12);  
Magic Number,Iffinator,BHAVEdit,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.LstInstructions.Location = new System.Drawing.Point (12' 12);  
Magic Number,Iffinator,BHAVEdit,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.LstInstructions.Size = new System.Drawing.Size (205' 381);  
Magic Number,Iffinator,BHAVEdit,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.LstInstructions.Size = new System.Drawing.Size (205' 381);  
Magic Number,Iffinator,BHAVEdit,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (468' 402);  
Magic Number,Iffinator,BHAVEdit,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (468' 402);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblTSOPath.Location = new System.Drawing.Point (13' 50);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblTSOPath.Location = new System.Drawing.Point (13' 50);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblTSOPath.Size = new System.Drawing.Size (56' 13);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblTSOPath.Size = new System.Drawing.Size (56' 13);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtChunkType.Location = new System.Drawing.Point (16' 179);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtChunkType.Location = new System.Drawing.Point (16' 179);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtChunkType.Size = new System.Drawing.Size (100' 20);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtChunkType.Size = new System.Drawing.Size (100' 20);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.Location = new System.Drawing.Point (13' 163);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.Location = new System.Drawing.Point (13' 163);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.Size = new System.Drawing.Size (91' 13);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.Size = new System.Drawing.Size (91' 13);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.TabIndex = 2;  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtTSOPath.Location = new System.Drawing.Point (12' 66);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtTSOPath.Location = new System.Drawing.Point (12' 66);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtTSOPath.Size = new System.Drawing.Size (145' 20);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtTSOPath.Size = new System.Drawing.Size (145' 20);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.Location = new System.Drawing.Point (320' 29);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.Location = new System.Drawing.Point (320' 29);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.Size = new System.Drawing.Size (205' 316);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.Size = new System.Drawing.Size (205' 316);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.TabIndex = 3;  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.Location = new System.Drawing.Point (541' 29);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.Location = new System.Drawing.Point (541' 29);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.Size = new System.Drawing.Size (220' 199);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.Size = new System.Drawing.Size (220' 199);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.TabIndex = 4;  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.Location = new System.Drawing.Point (19' 320);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.Location = new System.Drawing.Point (19' 320);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.Size = new System.Drawing.Size (75' 23);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.Size = new System.Drawing.Size (75' 23);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.TabIndex = 5;  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size (773' 24);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size (773' 24);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.TabIndex = 6;  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size (44' 20);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size (44' 20);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.whatIsThisToolStripMenuItem.Size = new System.Drawing.Size (140' 22);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.whatIsThisToolStripMenuItem.Size = new System.Drawing.Size (140' 22);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.Location = new System.Drawing.Point (16' 105);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.Location = new System.Drawing.Point (16' 105);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.Size = new System.Drawing.Size (55' 13);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.Size = new System.Drawing.Size (55' 13);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.TabIndex = 7;  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.Location = new System.Drawing.Point (100' 320);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.Location = new System.Drawing.Point (100' 320);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.Size = new System.Drawing.Size (75' 23);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.Size = new System.Drawing.Size (75' 23);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.TabIndex = 5;  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (773' 355);  
Magic Number,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (773' 355);  
Magic Number,Iffinator,Endian,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,Iffinator,Endian,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,Iffinator,Endian,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,Iffinator,Endian,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Lock,The following statement contains a magic number: if (m_IsAlpha) {  	byte[] Bytes = new byte[(m_Width * m_Height) * 4];  	m_RGBValues = new byte[Bytes.Length];  	Marshal.Copy (m_BMPPtr' m_RGBValues' 0' m_RGBValues.Length);  } else {  	byte[] Bytes = new byte[(m_Width * m_Height) * 3];  	m_RGBValues = new byte[Bytes.Length];  	Marshal.Copy (m_BMPPtr' m_RGBValues' 0' m_RGBValues.Length);  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Lock,The following statement contains a magic number: if (m_IsAlpha) {  	byte[] Bytes = new byte[(m_Width * m_Height) * 4];  	m_RGBValues = new byte[Bytes.Length];  	Marshal.Copy (m_BMPPtr' m_RGBValues' 0' m_RGBValues.Length);  } else {  	byte[] Bytes = new byte[(m_Width * m_Height) * 3];  	m_RGBValues = new byte[Bytes.Length];  	Marshal.Copy (m_BMPPtr' m_RGBValues' 0' m_RGBValues.Length);  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  } else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  } else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  } else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  } else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: if (m_IsAlpha) {  	for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  		m_RGBValues [i + 3] = Clr.A;  	}  } else {  	for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  		m_RGBValues [i] = Clr.B;  		m_RGBValues [i + 1] = Clr.G;  		m_RGBValues [i + 2] = Clr.R;  	}  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  	m_RGBValues [i + 3] = Clr.A;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  	m_RGBValues [i + 3] = Clr.A;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 4) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  	m_RGBValues [i + 3] = Clr.A;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: i = i + 4
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: m_RGBValues [i + 2] = Clr.R;  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: m_RGBValues [i + 3] = Clr.A;  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: for (int i = 0; i < m_RGBValues.Length; i = i + 3) {  	m_RGBValues [i] = Clr.B;  	m_RGBValues [i + 1] = Clr.G;  	m_RGBValues [i + 2] = Clr.R;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: i = i + 3
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: m_RGBValues [i + 2] = Clr.R;  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  } else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  } else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  } else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  } else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  	m_RGBValues [Index + 3] = Clr.A;  } else {  	int Index = ((Y * m_Width + X) * 3);  	m_RGBValues [Index] = Clr.B;  	m_RGBValues [Index + 1] = Clr.G;  	m_RGBValues [Index + 2] = Clr.R;  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: m_RGBValues [Index + 2] = Clr.R;  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: m_RGBValues [Index + 3] = Clr.A;  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: m_RGBValues [Index + 2] = Clr.R;  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  } else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  } else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  } else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  } else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,Iffinator,FastPixel,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,GetPixel,The following statement contains a magic number: if (m_IsAlpha) {  	int Index = ((Y * m_Width + X) * 4);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	int A = m_RGBValues [Index + 3];  	return Color.FromArgb (A' R' G' B);  } else {  	int Index = ((Y * m_Width + X) * 3);  	int B = m_RGBValues [Index];  	int G = m_RGBValues [Index + 1];  	int R = m_RGBValues [Index + 2];  	return Color.FromArgb (R' G' B);  }  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size (624' 24);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size (624' 24);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size (37' 20);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size (37' 20);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.openiffToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.openiffToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractiffToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractiffToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractImageSpritesToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractImageSpritesToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size (192' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.analyzeToolStripMenuItem.Size = new System.Drawing.Size (60' 20);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.analyzeToolStripMenuItem.Size = new System.Drawing.Size (60' 20);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.chunkAnalyzerToolStripMenuItem.Size = new System.Drawing.Size (155' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.chunkAnalyzerToolStripMenuItem.Size = new System.Drawing.Size (155' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size (44' 20);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size (44' 20);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size (116' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size (116' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblNumChunks.Location = new System.Drawing.Point (13' 44);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblNumChunks.Location = new System.Drawing.Point (13' 44);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblNumChunks.Size = new System.Drawing.Size (97' 13);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblNumChunks.Size = new System.Drawing.Size (97' 13);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.Location = new System.Drawing.Point (12' 168);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.Location = new System.Drawing.Point (12' 168);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.Size = new System.Drawing.Size (216' 218);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.Size = new System.Drawing.Size (216' 218);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.TabIndex = 2;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.Location = new System.Drawing.Point (12' 392);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.Location = new System.Drawing.Point (12' 392);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.Size = new System.Drawing.Size (30' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.Size = new System.Drawing.Size (30' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.TabIndex = 3;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.Location = new System.Drawing.Point (119' 392);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.Location = new System.Drawing.Point (119' 392);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.Size = new System.Drawing.Size (30' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.Size = new System.Drawing.Size (30' 22);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.TabIndex = 3;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.Location = new System.Drawing.Point (238' 46);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.Location = new System.Drawing.Point (238' 46);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.Size = new System.Drawing.Size (374' 368);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.Size = new System.Drawing.Size (374' 368);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.TabIndex = 4;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.Location = new System.Drawing.Point (174' 76);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.Location = new System.Drawing.Point (174' 76);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.Size = new System.Drawing.Size (58' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.Size = new System.Drawing.Size (58' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.TabIndex = 6;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.Location = new System.Drawing.Point (173' 122);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.Location = new System.Drawing.Point (173' 122);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.Size = new System.Drawing.Size (59' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.Size = new System.Drawing.Size (59' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.TabIndex = 7;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.Location = new System.Drawing.Point (174' 99);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.Location = new System.Drawing.Point (174' 99);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.Size = new System.Drawing.Size (61' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.Size = new System.Drawing.Size (61' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.TabIndex = 8;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.Location = new System.Drawing.Point (173' 145);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.Location = new System.Drawing.Point (173' 145);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.Size = new System.Drawing.Size (59' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.Size = new System.Drawing.Size (59' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.TabIndex = 7;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.Location = new System.Drawing.Point (173' 53);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.Location = new System.Drawing.Point (173' 53);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.Size = new System.Drawing.Size (52' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.Size = new System.Drawing.Size (52' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.TabIndex = 9;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip1.Size = new System.Drawing.Size (61' 4);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip1.Size = new System.Drawing.Size (61' 4);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.Location = new System.Drawing.Point (12' 145);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.Location = new System.Drawing.Point (12' 145);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.Size = new System.Drawing.Size (87' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.Size = new System.Drawing.Size (87' 17);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.TabIndex = 10;  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (624' 427);  
Magic Number,Iffinator,Form1,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (624' 427);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Signature = (ushort)((Header [1] << 8) | Header [0]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_HeaderLength = 12;  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Params = 4;  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_HeaderLength = 12;  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (Header [3] << 8) | Header [4];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Type = Header [5];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Params = Header [6];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Locals = (ushort)((Header [7] << 8) | Header [8]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Locals = (ushort)((Header [7] << 8) | Header [8]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Locals = (ushort)((Header [7] << 8) | Header [8]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [9] << 8) | Header [10]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [9] << 8) | Header [10]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [9] << 8) | Header [10]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_HeaderLength = 13;  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Type = Header [3];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Params = Header [4];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Locals = Header [5];  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [8] << 8) | Header [9]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [8] << 8) | Header [9]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Flags = (ushort)((Header [8] << 8) | Header [9]);  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: if (Count <= 0 || Count > 253)  	return;  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: for (int i = 0; i < Count; i++)  	m_Instructions.Add (Reader.ReadBytes (12));  
Magic Number,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Instructions.Add (Reader.ReadBytes (12));  
Magic Number,Iffinator.Flash,IFFDecode,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,Operand,The following statement contains a magic number: return (Instruction [i + 1] << 8) | Instruction [i];  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < 256) {  	DecodePrimitive (P);  	return;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (Name != "\0")  	P.OutStream.Append (Name);  else if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (Name != "\0")  	P.OutStream.Append (Name);  else if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (Name != "\0")  	P.OutStream.Append (Name);  else if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (Name != "\0")  	P.OutStream.Append (Name);  else if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < (uint)(m_GlobalSubsLen + 256))  	P.OutStream.Append (m_GlobalSubs [K - 256]);  else if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append (m_GlobalSubs [K - 256]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < 4096)  	P.OutStream.Append ("Call global[" + K + "]");  else if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (K < 8192)  	P.OutStream.Append ("Call local[" + K + "]");  else  	P.OutStream.Append ("Call semi-global[" + K + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: if (P.Operand (4) == 0xFFFF && P.Operand (6) == 0xFFFF && P.Operand (8) == 0xFFFF && P.Operand (10) == 0xFFFF)  	P.OutStream.Append ("(temps)");  else {  	P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.OutStream.Append ("(" + (short)(P.Operand (4)) + "' " + (short)(P.Operand (6)) + "' " + (short)(P.Operand (8)) + "' " + (short)(P.Operand (10)) + ")");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op) {  default:  	DefaultPrimitive (P);  	break;  case 0:  	P.OutStream.Append ("0: sleep ");  	DoExpressionOperation (9' P.Operand (4));  	P.OutStream.Append (" ticks");  	break;  case 1:  	//Generic sim call  	int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220 [0].Length) - 1;  	int T = P.Operand (4);  	if (T < BHAVStr220Len)  		P.OutStream.Append (BHAVStrings.BHAVString220 [T]);  	else  		P.OutStream.Append ("1: generic sim call " + T);  	break;  case 2:  	ExpressionPrimitive (P.Instruction);  	break;  case 3:  	P.OutStream.Append ("3: find best interaction");  	break;  case 4:  	P.OutStream.Append ("4: grab stack object");  	break;  case 5:  	P.OutStream.Append ("5: drop stack object");  	break;  case 6:  	ChangeSuitOrAccessoryPrimitive (P.Instruction);  	break;  case 7:  	//Update  	P.OutStream.Append ("7: refresh ");  	int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (P [4] < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  	else  		P.OutStream.Append ("WHO=" + (int)(P [4]));  	P.OutStream.Append (" ");  	int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212 [0].Length) - 1;  	if (P [6] < BHAVStr212Len)  		P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  	else  		P.OutStream.Append ("WHAT=" + (int)(P [6]));  	break;  case 8:  	//Random  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := random ");  	DoExpressionOperation (P [10]' P.Operand (8));  	break;  case 9:  	//Burn  	P.OutStream.Append ("9: burn ");  	int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231 [0].Length) - 1;  	if (P [4] < BHAVStr231Len)  		P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  	else  		P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  	break;  case 10:  	//Tutorial  	// STR#238 - situation action descriptions  	P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  	break;  case 11:  	//Distance  	DoExpressionOperation (8' P.Operand (4));  	P.OutStream.Append (" := distance from stack object to ");  	U = P.Operand (8);  	if (P [6] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 12:  	//Direction to  	DoExpressionOperation (P [6]' P.Operand (4));  	P.OutStream.Append (" := direction from stack object to ");  	U = P.Operand (10);  	if (P [8] == 0)  		P.OutStream.Append ("me");  	else if (P [9] == 3 && U == 11)  		P.OutStream.Append ("me");  	else  		DoExpressionOperation (P [9]' U);  	break;  case 13:  	//Push interaction  	P.OutStream.Append ("13: queue ");  	P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  	DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  	int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224 [0].Length) - 1;  	if (P [6] < BHAVString224Len) {  		if (P [6] > 0) {  			//cout << " pri=" << BhavStr224[p[6]];  		}  	} else  		P.OutStream.Append (" PRI=" + (int)(P [6]));  	if ((P [7] & 1) != 0) {  		P.OutStream.Append (" icon=");  		DoExpressionOperation (25' P.Operand (8));  	}  	if ((P [7] & 0x04) != 0)  		P.OutStream.Append ("' continue as current ");  	if ((P [7] & 0x08) != 0)  		P.OutStream.Append ("' use name ");  	break;  case 14:  	//Find the best object for...  	U = P.Operand (4);  	P.OutStream.Append ("14: find best object for ");  	int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj [0].Length) - 1;  	if (U < BHAVString201Len)  		P.OutStream.Append (BHAVStrings.BHAVString201Obj [U]);  	else  		P.OutStream.Append ("function " + (int)(U));  	int X = P.Operand (6)' Y = P.Operand (8)' Z = P.Operand (10);  	if (X == 0 && Y == 0 && Z == 0)  		break;  	P.OutStream.Append ("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");  	break;  case 15:  	//Tree breakpoint  	P.OutStream.Append ("15: tree breakpoint");  	U = P.Operand (4);  	if (P [6] != 7 || U == 0) {  		P.OutStream.Append (" if ");  		DoExpressionOperation (P [6]' U);  		P.OutStream.Append (" != 0");  	}  	break;  case 16:  	//Find location for  	P.OutStream.Append ("16: find: ");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("empty ");  	int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239 [0].Length) - 1;  	if (P [4] < BHAVStr239Len)  		P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  	else  		P.OutStream.Append ("LOC=" + (int)(P [4]));  	P.OutStream.Append (" loc");  	if ((P [6] & 1) != 0) {  		P.OutStream.Append (" start at ");  		DoExpressionOperation (25' P [5]);  	}  	if ((P [6] & 4) != 0)  		P.OutStream.Append (" user-editable");  	break;  case 17:  	//Idle for input  	P.OutStream.Append ("17: idle for input ");  	DoExpressionOperation (9' P.Operand (4));  	U = P.Operand (6);  	P.OutStream.Append (" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");  	break;  case 18:  	//Remove object instance  	P.OutStream.Append ("18: remove ");  	int Who = P.Operand (4);  	BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153 [0].Length) - 1;  	if (Who < BHAVStr153Len)  		P.OutStream.Append (BHAVStrings.BHAVString153 [Who]);  	else  		P.OutStream.Append ("object[" + Who + "]'s");  	P.OutStream.Append (" instance");  	if ((P [6] & 1) != 0)  		P.OutStream.Append ("' return immediately");  	if ((P [6] & 2) != 0)  		P.OutStream.Append ("' clean up all");  	break;  case 19:  	//Make new character  	P.OutStream.Append ("19: make new character(");  	DoExpressionOperation (25' P [4]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [5]);  	P.OutStream.Append ("'");  	DoExpressionOperation (25' P [6]);  	P.OutStream.Append (")");  	break;  case 20:  	//Run functional tree  	T = P.Operand (4);  	P.OutStream.Append ("20: run ");  	BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run [0].Length) - 1;  	if (T < BHAVString201Len)  		P.OutStream.Append ("\"" + BHAVStrings.BHAVString201Run [T] + "\"");  	else  		P.OutStream.Append ("function " + (int)T);  	T = (short)P.Operand (6);  	if (T != 0)  		P.OutStream.Append (" with new icon");  	break;  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (9' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (9' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr153Len)  	P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  else  	P.OutStream.Append ("WHO=" + (int)(P [4]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr153Len)  	P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  else  	P.OutStream.Append ("WHO=" + (int)(P [4]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr153Len)  	P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  else  	P.OutStream.Append ("WHO=" + (int)(P [4]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (BHAVStrings.BHAVString153 [P [4]]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("WHO=" + (int)(P [4]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVStr212Len)  	P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  else  	P.OutStream.Append ("WHAT=" + (int)(P [6]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVStr212Len)  	P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  else  	P.OutStream.Append ("WHAT=" + (int)(P [6]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVStr212Len)  	P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  else  	P.OutStream.Append ("WHAT=" + (int)(P [6]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (BHAVStrings.BHAVString212 [P [6]]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("WHAT=" + (int)(P [6]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [10]' P.Operand (8));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [10]' P.Operand (8));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr231Len)  	P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  else  	P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr231Len)  	P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  else  	P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr231Len)  	P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  else  	P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (BHAVStrings.BHAVString231 [P [4]]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("WHAT [" + (int)(P [4]) + "]");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("10: tutorial " + ((P [4] == 0) ? "begin" : "end"));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (8' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (8' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (8);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (10);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [8] == 0)  	P.OutStream.Append ("me");  else if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [9] == 3 && U == 11)  	P.OutStream.Append ("me");  else  	DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [9]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ((int)(P.OutStream [4]) + " of ");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (((P [7] & 2) != 0) ? 25 : 9' P [5]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVString224Len) {  	if (P [6] > 0) {  		//cout << " pri=" << BhavStr224[p[6]];  	}  } else  	P.OutStream.Append (" PRI=" + (int)(P [6]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVString224Len) {  	if (P [6] > 0) {  		//cout << " pri=" << BhavStr224[p[6]];  	}  } else  	P.OutStream.Append (" PRI=" + (int)(P [6]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] < BHAVString224Len) {  	if (P [6] > 0) {  		//cout << " pri=" << BhavStr224[p[6]];  	}  } else  	P.OutStream.Append (" PRI=" + (int)(P [6]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] > 0) {  	//cout << " pri=" << BhavStr224[p[6]];  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (" PRI=" + (int)(P [6]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 1) != 0) {  	P.OutStream.Append (" icon=");  	DoExpressionOperation (25' P.Operand (8));  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 1) != 0) {  	P.OutStream.Append (" icon=");  	DoExpressionOperation (25' P.Operand (8));  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 1) != 0) {  	P.OutStream.Append (" icon=");  	DoExpressionOperation (25' P.Operand (8));  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P.Operand (8));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P.Operand (8));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 0x04) != 0)  	P.OutStream.Append ("' continue as current ");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [7] & 0x08) != 0)  	P.OutStream.Append ("' use name ");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (4);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (4);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] != 7 || U == 0) {  	P.OutStream.Append (" if ");  	DoExpressionOperation (P [6]' U);  	P.OutStream.Append (" != 0");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] != 7 || U == 0) {  	P.OutStream.Append (" if ");  	DoExpressionOperation (P [6]' U);  	P.OutStream.Append (" != 0");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [6] != 7 || U == 0) {  	P.OutStream.Append (" if ");  	DoExpressionOperation (P [6]' U);  	P.OutStream.Append (" != 0");  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (P [6]' U);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 2) != 0)  	P.OutStream.Append ("empty ");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 2) != 0)  	P.OutStream.Append ("empty ");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr239Len)  	P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  else  	P.OutStream.Append ("LOC=" + (int)(P [4]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr239Len)  	P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  else  	P.OutStream.Append ("LOC=" + (int)(P [4]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if (P [4] < BHAVStr239Len)  	P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  else  	P.OutStream.Append ("LOC=" + (int)(P [4]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append (BHAVStrings.BHAVString239 [P [4]]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: P.OutStream.Append ("LOC=" + (int)(P [4]));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 1) != 0) {  	P.OutStream.Append (" start at ");  	DoExpressionOperation (25' P [5]);  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 1) != 0) {  	P.OutStream.Append (" start at ");  	DoExpressionOperation (25' P [5]);  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 1) != 0) {  	P.OutStream.Append (" start at ");  	DoExpressionOperation (25' P [5]);  }  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [5]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [5]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 4) != 0)  	P.OutStream.Append (" user-editable");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 4) != 0)  	P.OutStream.Append (" user-editable");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (9' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (9' P.Operand (4));  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: U = P.Operand (6);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 1) != 0)  	P.OutStream.Append ("' return immediately");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 2) != 0)  	P.OutStream.Append ("' clean up all");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: if ((P [6] & 2) != 0)  	P.OutStream.Append ("' clean up all");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [4]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [4]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [5]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [5]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [6]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: DoExpressionOperation (25' P [6]);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: T = P.Operand (4);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: T = (short)P.Operand (6);  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append ("(" + P.Operand (4) + "' " + P.Operand (6) + "' " + P.Operand (8) + "' " + P.Operand (10) + ")");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append ("(" + P.Operand (4) + "' " + P.Operand (6) + "' " + P.Operand (8) + "' " + P.Operand (10) + ")");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append ("(" + P.Operand (4) + "' " + P.Operand (6) + "' " + P.Operand (8) + "' " + P.Operand (10) + ")");  
Magic Number,Iffinator.Flash,BHAVAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append ("(" + P.Operand (4) + "' " + P.Operand (6) + "' " + P.Operand (8) + "' " + P.Operand (10) + ")");  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: m_Version = Reader.ReadUInt16 () - 20000;  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	if (m_Version < 3) {  		SpriteCount = Reader.ReadUInt16 ();  		DirectionFlag = Reader.ReadByte ();  		Zoom = Reader.ReadByte ();  	} else {  		DirectionFlag = Reader.ReadUInt32 ();  		Zoom = Reader.ReadUInt32 ();  		SpriteCount = Reader.ReadUInt32 ();  	}  	DrawGroupImg Image = new DrawGroupImg (SpriteCount' DirectionFlag' Zoom);  	for (int j = 0; j < SpriteCount; j++) {  		ushort Tag = 0;  		int PixelX = 0' PixelY = 0;  		uint SprID = 0' SprFrameID = 0' Flags = 0;  		float ZOffset = 0' XOffset = 0' YOffset = 0;  		if (m_Version < 3) {  			Tag = Reader.ReadUInt16 ();  			SprID = Reader.ReadUInt16 ();  			SprFrameID = Reader.ReadUInt16 ();  			Flags = Reader.ReadUInt16 ();  			PixelX = Reader.ReadInt16 ();  			PixelY = Reader.ReadInt16 ();  			if (m_Version == 1)  				ZOffset = Reader.ReadUInt32 ();  		} else {  			SprID = Reader.ReadUInt32 ();  			SprFrameID = Reader.ReadUInt32 ();  			PixelX = Reader.ReadInt32 ();  			PixelY = Reader.ReadInt32 ();  			ZOffset = Reader.ReadUInt32 ();  			Flags = Reader.ReadUInt32 ();  			if (m_Version == 4) {  				XOffset = Reader.ReadUInt32 ();  				YOffset = Reader.ReadUInt32 ();  			}  		}  		SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  		if (Frame != null) {  			DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  			Image.Sprites.Insert (0' Sprite);  		}  	}  	//Image.CompileSprites();  	m_Images.Add (Image);  }  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	if (m_Version < 3) {  		SpriteCount = Reader.ReadUInt16 ();  		DirectionFlag = Reader.ReadByte ();  		Zoom = Reader.ReadByte ();  	} else {  		DirectionFlag = Reader.ReadUInt32 ();  		Zoom = Reader.ReadUInt32 ();  		SpriteCount = Reader.ReadUInt32 ();  	}  	DrawGroupImg Image = new DrawGroupImg (SpriteCount' DirectionFlag' Zoom);  	for (int j = 0; j < SpriteCount; j++) {  		ushort Tag = 0;  		int PixelX = 0' PixelY = 0;  		uint SprID = 0' SprFrameID = 0' Flags = 0;  		float ZOffset = 0' XOffset = 0' YOffset = 0;  		if (m_Version < 3) {  			Tag = Reader.ReadUInt16 ();  			SprID = Reader.ReadUInt16 ();  			SprFrameID = Reader.ReadUInt16 ();  			Flags = Reader.ReadUInt16 ();  			PixelX = Reader.ReadInt16 ();  			PixelY = Reader.ReadInt16 ();  			if (m_Version == 1)  				ZOffset = Reader.ReadUInt32 ();  		} else {  			SprID = Reader.ReadUInt32 ();  			SprFrameID = Reader.ReadUInt32 ();  			PixelX = Reader.ReadInt32 ();  			PixelY = Reader.ReadInt32 ();  			ZOffset = Reader.ReadUInt32 ();  			Flags = Reader.ReadUInt32 ();  			if (m_Version == 4) {  				XOffset = Reader.ReadUInt32 ();  				YOffset = Reader.ReadUInt32 ();  			}  		}  		SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  		if (Frame != null) {  			DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  			Image.Sprites.Insert (0' Sprite);  		}  	}  	//Image.CompileSprites();  	m_Images.Add (Image);  }  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	if (m_Version < 3) {  		SpriteCount = Reader.ReadUInt16 ();  		DirectionFlag = Reader.ReadByte ();  		Zoom = Reader.ReadByte ();  	} else {  		DirectionFlag = Reader.ReadUInt32 ();  		Zoom = Reader.ReadUInt32 ();  		SpriteCount = Reader.ReadUInt32 ();  	}  	DrawGroupImg Image = new DrawGroupImg (SpriteCount' DirectionFlag' Zoom);  	for (int j = 0; j < SpriteCount; j++) {  		ushort Tag = 0;  		int PixelX = 0' PixelY = 0;  		uint SprID = 0' SprFrameID = 0' Flags = 0;  		float ZOffset = 0' XOffset = 0' YOffset = 0;  		if (m_Version < 3) {  			Tag = Reader.ReadUInt16 ();  			SprID = Reader.ReadUInt16 ();  			SprFrameID = Reader.ReadUInt16 ();  			Flags = Reader.ReadUInt16 ();  			PixelX = Reader.ReadInt16 ();  			PixelY = Reader.ReadInt16 ();  			if (m_Version == 1)  				ZOffset = Reader.ReadUInt32 ();  		} else {  			SprID = Reader.ReadUInt32 ();  			SprFrameID = Reader.ReadUInt32 ();  			PixelX = Reader.ReadInt32 ();  			PixelY = Reader.ReadInt32 ();  			ZOffset = Reader.ReadUInt32 ();  			Flags = Reader.ReadUInt32 ();  			if (m_Version == 4) {  				XOffset = Reader.ReadUInt32 ();  				YOffset = Reader.ReadUInt32 ();  			}  		}  		SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  		if (Frame != null) {  			DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  			Image.Sprites.Insert (0' Sprite);  		}  	}  	//Image.CompileSprites();  	m_Images.Add (Image);  }  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: if (m_Version < 3) {  	SpriteCount = Reader.ReadUInt16 ();  	DirectionFlag = Reader.ReadByte ();  	Zoom = Reader.ReadByte ();  } else {  	DirectionFlag = Reader.ReadUInt32 ();  	Zoom = Reader.ReadUInt32 ();  	SpriteCount = Reader.ReadUInt32 ();  }  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int j = 0; j < SpriteCount; j++) {  	ushort Tag = 0;  	int PixelX = 0' PixelY = 0;  	uint SprID = 0' SprFrameID = 0' Flags = 0;  	float ZOffset = 0' XOffset = 0' YOffset = 0;  	if (m_Version < 3) {  		Tag = Reader.ReadUInt16 ();  		SprID = Reader.ReadUInt16 ();  		SprFrameID = Reader.ReadUInt16 ();  		Flags = Reader.ReadUInt16 ();  		PixelX = Reader.ReadInt16 ();  		PixelY = Reader.ReadInt16 ();  		if (m_Version == 1)  			ZOffset = Reader.ReadUInt32 ();  	} else {  		SprID = Reader.ReadUInt32 ();  		SprFrameID = Reader.ReadUInt32 ();  		PixelX = Reader.ReadInt32 ();  		PixelY = Reader.ReadInt32 ();  		ZOffset = Reader.ReadUInt32 ();  		Flags = Reader.ReadUInt32 ();  		if (m_Version == 4) {  			XOffset = Reader.ReadUInt32 ();  			YOffset = Reader.ReadUInt32 ();  		}  	}  	SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  	if (Frame != null) {  		DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  		Image.Sprites.Insert (0' Sprite);  	}  }  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: for (int j = 0; j < SpriteCount; j++) {  	ushort Tag = 0;  	int PixelX = 0' PixelY = 0;  	uint SprID = 0' SprFrameID = 0' Flags = 0;  	float ZOffset = 0' XOffset = 0' YOffset = 0;  	if (m_Version < 3) {  		Tag = Reader.ReadUInt16 ();  		SprID = Reader.ReadUInt16 ();  		SprFrameID = Reader.ReadUInt16 ();  		Flags = Reader.ReadUInt16 ();  		PixelX = Reader.ReadInt16 ();  		PixelY = Reader.ReadInt16 ();  		if (m_Version == 1)  			ZOffset = Reader.ReadUInt32 ();  	} else {  		SprID = Reader.ReadUInt32 ();  		SprFrameID = Reader.ReadUInt32 ();  		PixelX = Reader.ReadInt32 ();  		PixelY = Reader.ReadInt32 ();  		ZOffset = Reader.ReadUInt32 ();  		Flags = Reader.ReadUInt32 ();  		if (m_Version == 4) {  			XOffset = Reader.ReadUInt32 ();  			YOffset = Reader.ReadUInt32 ();  		}  	}  	SpriteFrame Frame = FindSpriteFrame (SprID' SprFrameID);  	if (Frame != null) {  		DrawGroupSprite Sprite = new DrawGroupSprite (Tag' Flags' new PixelOffset (PixelX' PixelY)' new WorldOffset (XOffset' YOffset' ZOffset)' Frame);  		Image.Sprites.Insert (0' Sprite);  	}  }  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: if (m_Version < 3) {  	Tag = Reader.ReadUInt16 ();  	SprID = Reader.ReadUInt16 ();  	SprFrameID = Reader.ReadUInt16 ();  	Flags = Reader.ReadUInt16 ();  	PixelX = Reader.ReadInt16 ();  	PixelY = Reader.ReadInt16 ();  	if (m_Version == 1)  		ZOffset = Reader.ReadUInt32 ();  } else {  	SprID = Reader.ReadUInt32 ();  	SprFrameID = Reader.ReadUInt32 ();  	PixelX = Reader.ReadInt32 ();  	PixelY = Reader.ReadInt32 ();  	ZOffset = Reader.ReadUInt32 ();  	Flags = Reader.ReadUInt32 ();  	if (m_Version == 4) {  		XOffset = Reader.ReadUInt32 ();  		YOffset = Reader.ReadUInt32 ();  	}  }  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: if (m_Version < 3) {  	Tag = Reader.ReadUInt16 ();  	SprID = Reader.ReadUInt16 ();  	SprFrameID = Reader.ReadUInt16 ();  	Flags = Reader.ReadUInt16 ();  	PixelX = Reader.ReadInt16 ();  	PixelY = Reader.ReadInt16 ();  	if (m_Version == 1)  		ZOffset = Reader.ReadUInt32 ();  } else {  	SprID = Reader.ReadUInt32 ();  	SprFrameID = Reader.ReadUInt32 ();  	PixelX = Reader.ReadInt32 ();  	PixelY = Reader.ReadInt32 ();  	ZOffset = Reader.ReadUInt32 ();  	Flags = Reader.ReadUInt32 ();  	if (m_Version == 4) {  		XOffset = Reader.ReadUInt32 ();  		YOffset = Reader.ReadUInt32 ();  	}  }  
Magic Number,Iffinator.Flash,DrawGroup,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: if (m_Version == 4) {  	XOffset = Reader.ReadUInt32 ();  	YOffset = Reader.ReadUInt32 ();  }  
Magic Number,Iffinator.Flash,DrawGroupImg,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: m_CompiledBitmap = new Bitmap (136' 384);  
Magic Number,Iffinator.Flash,DrawGroupImg,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: m_CompiledBitmap = new Bitmap (136' 384);  
Magic Number,Iffinator.Flash,DrawGroupImg,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: foreach (DrawGroupSprite Sprite in Sprites) {  	int xOffset = m_CompiledBitmap.Width / 2 + Sprite.SpriteOffset.X;  	int yOffset = m_CompiledBitmap.Height / 2 + Sprite.SpriteOffset.Y;  	gfx.DrawImageUnscaled (Sprite.Bitmap' Sprite.Sprite.XLocation' Sprite.Sprite.YLocation);  }  
Magic Number,Iffinator.Flash,DrawGroupImg,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: foreach (DrawGroupSprite Sprite in Sprites) {  	int xOffset = m_CompiledBitmap.Width / 2 + Sprite.SpriteOffset.X;  	int yOffset = m_CompiledBitmap.Height / 2 + Sprite.SpriteOffset.Y;  	gfx.DrawImageUnscaled (Sprite.Bitmap' Sprite.Sprite.XLocation' Sprite.Sprite.YLocation);  }  
Magic Number,Iffinator.Flash,FCNS,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,Iffinator.Flash,FCNS,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,Iffinator.Flash,FCNS,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: for (int i = 0; i < m_ConstantCount; i++) {  	TuningConstant TConstant = new TuningConstant ();  	if (m_Version == 1) {  		TConstant.Name = ReadZeroPaddedString (Reader);  		byte[] Value = Reader.ReadBytes (4);  		//This should totally not be neccessary' but once again  		//Maxis has introduced the concept of 'half-empty-entries'!  		if (Value.Length == 0) {  			m_TuningConstants.Add (TConstant);  			break;  		}  		TConstant.Value = BitConverter.ToSingle (Value' 0);  		TConstant.Description = ReadZeroPaddedString (Reader);  	} else if (m_Version == 2) {  		TConstant.Name = Reader.ReadString ();  		TConstant.Value = Reader.ReadSingle ();  		TConstant.Description = Reader.ReadString ();  	}  	m_TuningConstants.Add (TConstant);  }  
Magic Number,Iffinator.Flash,FCNS,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: for (int i = 0; i < m_ConstantCount; i++) {  	TuningConstant TConstant = new TuningConstant ();  	if (m_Version == 1) {  		TConstant.Name = ReadZeroPaddedString (Reader);  		byte[] Value = Reader.ReadBytes (4);  		//This should totally not be neccessary' but once again  		//Maxis has introduced the concept of 'half-empty-entries'!  		if (Value.Length == 0) {  			m_TuningConstants.Add (TConstant);  			break;  		}  		TConstant.Value = BitConverter.ToSingle (Value' 0);  		TConstant.Description = ReadZeroPaddedString (Reader);  	} else if (m_Version == 2) {  		TConstant.Name = Reader.ReadString ();  		TConstant.Value = Reader.ReadSingle ();  		TConstant.Description = Reader.ReadString ();  	}  	m_TuningConstants.Add (TConstant);  }  
Magic Number,Iffinator.Flash,FCNS,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: if (m_Version == 1) {  	TConstant.Name = ReadZeroPaddedString (Reader);  	byte[] Value = Reader.ReadBytes (4);  	//This should totally not be neccessary' but once again  	//Maxis has introduced the concept of 'half-empty-entries'!  	if (Value.Length == 0) {  		m_TuningConstants.Add (TConstant);  		break;  	}  	TConstant.Value = BitConverter.ToSingle (Value' 0);  	TConstant.Description = ReadZeroPaddedString (Reader);  } else if (m_Version == 2) {  	TConstant.Name = Reader.ReadString ();  	TConstant.Value = Reader.ReadSingle ();  	TConstant.Description = Reader.ReadString ();  }  
Magic Number,Iffinator.Flash,FCNS,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: if (m_Version == 1) {  	TConstant.Name = ReadZeroPaddedString (Reader);  	byte[] Value = Reader.ReadBytes (4);  	//This should totally not be neccessary' but once again  	//Maxis has introduced the concept of 'half-empty-entries'!  	if (Value.Length == 0) {  		m_TuningConstants.Add (TConstant);  		break;  	}  	TConstant.Value = BitConverter.ToSingle (Value' 0);  	TConstant.Description = ReadZeroPaddedString (Reader);  } else if (m_Version == 2) {  	TConstant.Name = Reader.ReadString ();  	TConstant.Value = Reader.ReadSingle ();  	TConstant.Description = Reader.ReadString ();  }  
Magic Number,Iffinator.Flash,FCNS,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: if (m_Version == 2) {  	TConstant.Name = Reader.ReadString ();  	TConstant.Value = Reader.ReadSingle ();  	TConstant.Description = Reader.ReadString ();  }  
Magic Number,Iffinator.Flash,FieldReader,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,ReadBits,The following statement contains a magic number: while (FieldData.BitBufferCount < Width) {  	if (FieldData.ReadDataLength >= FieldData.EncodedDataLength)  		return 0;  	FieldData.BitBuffer <<= 8;  	FieldData.BitBuffer |= FieldData.EncodedData [FieldData.FieldDataCounter++];  	FieldData.BitBufferCount += 8;  	FieldData.ReadDataLength++;  }  
Magic Number,Iffinator.Flash,FieldReader,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,ReadBits,The following statement contains a magic number: while (FieldData.BitBufferCount < Width) {  	if (FieldData.ReadDataLength >= FieldData.EncodedDataLength)  		return 0;  	FieldData.BitBuffer <<= 8;  	FieldData.BitBuffer |= FieldData.EncodedData [FieldData.FieldDataCounter++];  	FieldData.BitBufferCount += 8;  	FieldData.ReadDataLength++;  }  
Magic Number,Iffinator.Flash,FieldReader,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,ReadBits,The following statement contains a magic number: FieldData.BitBuffer <<= 8;  
Magic Number,Iffinator.Flash,FieldReader,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,ReadBits,The following statement contains a magic number: FieldData.BitBufferCount += 8;  
Magic Number,Iffinator.Flash,FieldReader,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,DecodeField,The following statement contains a magic number: if (ReadBits (ref Data' 2' ref Prefix) == 0)  	return 0;  
Magic Number,Iffinator.Flash,FieldReader,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,DecodeField,The following statement contains a magic number: Width = Data.FieldWidths [FieldType * 4 + Prefix];  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,Iff,The following statement contains a magic number: foreach (KeyValuePair<string' List<uint>> KVP in Files) {  	foreach (uint Offset in KVP.Value) {  		m_Reader.BaseStream.Seek (Offset' SeekOrigin.Begin);  		IffChunk Chunk = new IffChunk (KVP.Key);  		Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  		Chunk.ID = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  		ushort Flags = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  		Chunk.NameString = GetNameString ();  		m_Chunks.Add (Chunk);  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,Iff,The following statement contains a magic number: foreach (uint Offset in KVP.Value) {  	m_Reader.BaseStream.Seek (Offset' SeekOrigin.Begin);  	IffChunk Chunk = new IffChunk (KVP.Key);  	Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  	Chunk.ID = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	ushort Flags = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	Chunk.NameString = GetNameString ();  	m_Chunks.Add (Chunk);  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,Iff,The following statement contains a magic number: Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (resMapOffset != 0) {  	long pos = m_Reader.BaseStream.Position;  	m_Reader.BaseStream.Position = resMapOffset;  	m_Reader.BaseStream.Position += 76;  	//Skip the header.  	m_Reader.ReadInt32 ();  	//Reserved  	uint version = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt32 ();  	//pmsr  	m_Reader.ReadInt32 ();  	//Size  	uint typeCount = m_Reader.ReadUInt32 ();  	//How many types are present in this *.iff...  	for (uint i = 0; i < typeCount; i++) {  		//NOTE: For some types in some files this is empty...  		string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  		if (version == 0) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 13 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//numEntries + 1 entry without label = 16 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		//How many entries there are...  		uint numEntries = m_Reader.ReadUInt32 ();  		List<uint> offsets = new List<uint> ();  		for (uint j = 0; j < numEntries; j++) {  			if (version == 0) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 9 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			} else if (version == 1) {  				//Empty RSMP...  				//Minimum size for an entry without a label is 12 bytes.  				if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  					files.Clear ();  					FuckThisShit (ref files);  					break;  				}  			}  			uint offset = m_Reader.ReadUInt32 ();  			m_Reader.ReadInt16 ();  			//ChunkID  			if (version == 1) {  				m_Reader.ReadInt16 ();  			}  			//ChunkID  			m_Reader.ReadInt16 ();  			//Flags  			if (version == 1) {  				byte Length = m_Reader.ReadByte ();  				if (Length > 0)  					m_Reader.ReadBytes (Length);  			} else {  				GetNameString ();  			}  			offsets.Add (offset);  		}  		if (!files.ContainsKey (typeCode))  			files.Add (typeCode' offsets);  	}  } else//There was no offset to the resourcemap' meaning that an RSMP probably doesn't exist.   {  	List<KeyValuePair<string' uint>> offsets = new List<KeyValuePair<string' uint>> ();  	while (true) {  		uint offset = (uint)m_Reader.BaseStream.Position;  		byte[] TagBytes = m_Reader.ReadBytes (4);  		Array.Reverse (TagBytes);  		string tag = new ASCIIEncoding ().GetString (TagBytes);  		byte[] bytes = m_Reader.ReadBytes (4);  		if (bytes.Length == 0)  			break;  		uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  		m_Reader.BaseStream.Position += (size - 8);  		if (!tag.Equals ("XXXX"))  			offsets.Add (new KeyValuePair<string' uint> (tag' offset));  		//76 bytes is the size of a chunkheader' so don't bother reading the next one  		//the stream has less than 76 bytes left.  		if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  			break;  	}  	List<string> typesFound = new List<string> ();  	foreach (KeyValuePair<string' uint> kvp in offsets) {  		if (!typesFound.Exists (delegate (string s) {  			return s.CompareTo (kvp.Key) == 0;  		})) {  			List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll (delegate (KeyValuePair<string' uint> pair) {  				return pair.Key.CompareTo (kvp.Key) == 0;  			});  			List<uint> offsetValues = new List<uint> ();  			foreach (KeyValuePair<string' uint> kvp2 in theseChunks) {  				offsetValues.Add (kvp2.Value);  			}  			if (!files.ContainsKey (kvp.Key))  				files.Add (kvp.Key' offsetValues);  			typesFound.Add (kvp.Key);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: m_Reader.BaseStream.Position += 76;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	} else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		} else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	} else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		} else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	} else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		} else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	} else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		} else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint i = 0; i < typeCount; i++) {  	//NOTE: For some types in some files this is empty...  	string typeCode = new ASCIIEncoding ().GetString (m_Reader.ReadBytes (4));  	if (version == 0) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 13 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	} else if (version == 1) {  		//Empty RSMP...  		//numEntries + 1 entry without label = 16 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	//How many entries there are...  	uint numEntries = m_Reader.ReadUInt32 ();  	List<uint> offsets = new List<uint> ();  	for (uint j = 0; j < numEntries; j++) {  		if (version == 0) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 9 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		} else if (version == 1) {  			//Empty RSMP...  			//Minimum size for an entry without a label is 12 bytes.  			if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  				files.Clear ();  				FuckThisShit (ref files);  				break;  			}  		}  		uint offset = m_Reader.ReadUInt32 ();  		m_Reader.ReadInt16 ();  		//ChunkID  		if (version == 1) {  			m_Reader.ReadInt16 ();  		}  		//ChunkID  		m_Reader.ReadInt16 ();  		//Flags  		if (version == 1) {  			byte Length = m_Reader.ReadByte ();  			if (Length > 0)  				m_Reader.ReadBytes (Length);  		} else {  			GetNameString ();  		}  		offsets.Add (offset);  	}  	if (!files.ContainsKey (typeCode))  		files.Add (typeCode' offsets);  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 0) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 13 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  } else if (version == 1) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 16 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 0) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 13 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  } else if (version == 1) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 16 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13) {  	files.Clear ();  	FuckThisShit (ref files);  	break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 1) {  	//Empty RSMP...  	//numEntries + 1 entry without label = 16 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 16) {  	files.Clear ();  	FuckThisShit (ref files);  	break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint j = 0; j < numEntries; j++) {  	if (version == 0) {  		//Empty RSMP...  		//Minimum size for an entry without a label is 9 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	} else if (version == 1) {  		//Empty RSMP...  		//Minimum size for an entry without a label is 12 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	uint offset = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt16 ();  	//ChunkID  	if (version == 1) {  		m_Reader.ReadInt16 ();  	}  	//ChunkID  	m_Reader.ReadInt16 ();  	//Flags  	if (version == 1) {  		byte Length = m_Reader.ReadByte ();  		if (Length > 0)  			m_Reader.ReadBytes (Length);  	} else {  		GetNameString ();  	}  	offsets.Add (offset);  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: for (uint j = 0; j < numEntries; j++) {  	if (version == 0) {  		//Empty RSMP...  		//Minimum size for an entry without a label is 9 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	} else if (version == 1) {  		//Empty RSMP...  		//Minimum size for an entry without a label is 12 bytes.  		if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  			files.Clear ();  			FuckThisShit (ref files);  			break;  		}  	}  	uint offset = m_Reader.ReadUInt32 ();  	m_Reader.ReadInt16 ();  	//ChunkID  	if (version == 1) {  		m_Reader.ReadInt16 ();  	}  	//ChunkID  	m_Reader.ReadInt16 ();  	//Flags  	if (version == 1) {  		byte Length = m_Reader.ReadByte ();  		if (Length > 0)  			m_Reader.ReadBytes (Length);  	} else {  		GetNameString ();  	}  	offsets.Add (offset);  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 0) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 9 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  } else if (version == 1) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 12 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 0) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 9 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  } else if (version == 1) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 12 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)) {  	files.Clear ();  	FuckThisShit (ref files);  	break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (version == 1) {  	//Empty RSMP...  	//Minimum size for an entry without a label is 12 bytes.  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  		files.Clear ();  		FuckThisShit (ref files);  		break;  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 12)) {  	files.Clear ();  	FuckThisShit (ref files);  	break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: m_Reader.BaseStream.Position += (size - 8);  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  	break;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: foreach (KeyValuePair<string' List<uint>> file in files) {  	foreach (int offset in file.Value) {  		if (offset > 0) {  			m_Reader.BaseStream.Position = offset;  			byte[] Buf = m_Reader.ReadBytes (4);  			string StrResource = Encoding.ASCII.GetString (Buf);  			if (StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS") {  				//MessageBox.Show(StrResource);  				IffChunk Chunk = ToChunk (StrResource' offset);  				//i += (int)Chunk.Length;  				m_Chunks.Add (Chunk);  			}  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: foreach (int offset in file.Value) {  	if (offset > 0) {  		m_Reader.BaseStream.Position = offset;  		byte[] Buf = m_Reader.ReadBytes (4);  		string StrResource = Encoding.ASCII.GetString (Buf);  		if (StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS") {  			//MessageBox.Show(StrResource);  			IffChunk Chunk = ToChunk (StrResource' offset);  			//i += (int)Chunk.Length;  			m_Chunks.Add (Chunk);  		}  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: if (offset > 0) {  	m_Reader.BaseStream.Position = offset;  	byte[] Buf = m_Reader.ReadBytes (4);  	string StrResource = Encoding.ASCII.GetString (Buf);  	if (StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" || StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" || StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" || StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" || StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" || StrResource == "BMP_" || StrResource == "FCNS") {  		//MessageBox.Show(StrResource);  		IffChunk Chunk = ToChunk (StrResource' offset);  		//i += (int)Chunk.Length;  		m_Chunks.Add (Chunk);  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: m_Reader.BaseStream.Position = 64;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (!tag.Equals ("XXXX"))  		offsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: m_Reader.BaseStream.Position += (size - 8);  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  	break;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ToChunk,The following statement contains a magic number: Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ToChunk,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) >= Chunk.Length) {  	m_Reader.BaseStream.Position = offset + 76;  	Chunk.Data = m_Reader.ReadBytes ((int)Chunk.Length);  } else  	Chunk.Data = new byte[Chunk.Length];  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ToChunk,The following statement contains a magic number: m_Reader.BaseStream.Position = offset + 76;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,GetNameString,The following statement contains a magic number: for (i = 0; i < 63; i++) {  	Chr = (char)m_Reader.PeekChar ();  	if (Chr == '\0') {  		IsZeroTerminated = true;  		break;  	}  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,GetNameString,The following statement contains a magic number: if (IsZeroTerminated)  	return new string (m_Reader.ReadChars (i));  else  	return Encoding.ASCII.GetString (m_Reader.ReadBytes (64));  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,GetNameString,The following statement contains a magic number: return Encoding.ASCII.GetString (m_Reader.ReadBytes (64));  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position = 64;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (tag.Equals ("PALT"))  		PALTOffsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (tag.Equals ("PALT"))  		PALTOffsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (tag.Equals ("PALT"))  		PALTOffsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: while (true) {  	uint offset = (uint)m_Reader.BaseStream.Position;  	byte[] TagBytes = m_Reader.ReadBytes (4);  	Array.Reverse (TagBytes);  	string tag = new ASCIIEncoding ().GetString (TagBytes);  	byte[] bytes = m_Reader.ReadBytes (4);  	if (bytes.Length == 0)  		break;  	uint size = Endian.SwapUInt32 (BitConverter.ToUInt32 (bytes' 0));  	m_Reader.BaseStream.Position += (size - 8);  	if (tag.Equals ("PALT"))  		PALTOffsets.Add (new KeyValuePair<string' uint> (tag' offset));  	//76 bytes is the size of a chunkheader' so don't bother reading the next one  	//the stream has less than 76 bytes left.  	if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  		break;  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position += (size - 8);  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: if (m_Reader.BaseStream.Position == m_Reader.BaseStream.Length || (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76)  	break;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: foreach (KeyValuePair<string' uint> KVP in PALTOffsets) {  	m_Reader.BaseStream.Position = KVP.Value;  	IffChunk Chunk = new IffChunk (KVP.Key);  	Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  	Chunk.ID = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	ushort Flags = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	Chunk.NameString = GetNameString ();  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) >= Chunk.Length) {  		m_Reader.BaseStream.Position = KVP.Value + 76;  		Chunk.Data = m_Reader.ReadBytes ((int)Chunk.Length);  	} else  		Chunk.Data = new byte[Chunk.Length];  	m_PMaps.Add (new PaletteMap (Chunk));  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: foreach (KeyValuePair<string' uint> KVP in PALTOffsets) {  	m_Reader.BaseStream.Position = KVP.Value;  	IffChunk Chunk = new IffChunk (KVP.Key);  	Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  	Chunk.ID = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	ushort Flags = Endian.SwapUInt16 (m_Reader.ReadUInt16 ());  	Chunk.NameString = GetNameString ();  	if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) >= Chunk.Length) {  		m_Reader.BaseStream.Position = KVP.Value + 76;  		Chunk.Data = m_Reader.ReadBytes ((int)Chunk.Length);  	} else  		Chunk.Data = new byte[Chunk.Length];  	m_PMaps.Add (new PaletteMap (Chunk));  }  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: Chunk.Length = Endian.SwapUInt32 (m_Reader.ReadUInt32 ()) - 76;  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: if ((m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) >= Chunk.Length) {  	m_Reader.BaseStream.Position = KVP.Value + 76;  	Chunk.Data = m_Reader.ReadBytes ((int)Chunk.Length);  } else  	Chunk.Data = new byte[Chunk.Length];  
Magic Number,Iffinator.Flash,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position = KVP.Value + 76;  
Magic Number,Iffinator.Flash,IffChunkID,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\IffChunkID.cs,ToChunkID,The following statement contains a magic number: return ((A << 24) | (B << 16) | (C << 8) | D);  
Magic Number,Iffinator.Flash,IffChunkID,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\IffChunkID.cs,ToChunkID,The following statement contains a magic number: return ((A << 24) | (B << 16) | (C << 8) | D);  
Magic Number,Iffinator.Flash,IffChunkID,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\IffChunkID.cs,ToChunkID,The following statement contains a magic number: return ((A << 24) | (B << 16) | (C << 8) | D);  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: if ((Reader.BaseStream.Length - Reader.BaseStream.Position) == 0 || (Reader.BaseStream.Length - Reader.BaseStream.Position) < 2)  	return;  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	if (m_CompressionCode != 1)  		return;  	//Compressioncode should always be 1.  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	if (m_CompressionCode != 1)  		return;  	//Compressioncode should always be 1.  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: for (int i = 0; i < m_NumInteractions; i++) {  	TTABCore Interaction = new TTABCore ();  	BitArray BArray = new BitArray (Reader.ReadBytes (2));  	Interaction.ActionFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.GuardFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.MotiveEntries = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Flags = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.StrTableIndex = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationCode = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationValue = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Autonomy = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.JoinIndex = (int)GetLongBits (BArray);  	m_Interactions.Add (Interaction);  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: for (int i = 0; i < m_NumInteractions; i++) {  	TTABCore Interaction = new TTABCore ();  	BitArray BArray = new BitArray (Reader.ReadBytes (2));  	Interaction.ActionFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.GuardFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.MotiveEntries = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Flags = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.StrTableIndex = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationCode = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationValue = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Autonomy = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.JoinIndex = (int)GetLongBits (BArray);  	m_Interactions.Add (Interaction);  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: for (int i = 0; i < m_NumInteractions; i++) {  	TTABCore Interaction = new TTABCore ();  	BitArray BArray = new BitArray (Reader.ReadBytes (2));  	Interaction.ActionFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.GuardFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.MotiveEntries = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Flags = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.StrTableIndex = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationCode = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationValue = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Autonomy = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.JoinIndex = (int)GetLongBits (BArray);  	m_Interactions.Add (Interaction);  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: for (int i = 0; i < m_NumInteractions; i++) {  	TTABCore Interaction = new TTABCore ();  	BitArray BArray = new BitArray (Reader.ReadBytes (2));  	Interaction.ActionFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.GuardFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.MotiveEntries = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Flags = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.StrTableIndex = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationCode = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationValue = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Autonomy = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.JoinIndex = (int)GetLongBits (BArray);  	m_Interactions.Add (Interaction);  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: for (int i = 0; i < m_NumInteractions; i++) {  	TTABCore Interaction = new TTABCore ();  	BitArray BArray = new BitArray (Reader.ReadBytes (2));  	Interaction.ActionFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.GuardFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.MotiveEntries = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Flags = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.StrTableIndex = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationCode = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationValue = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Autonomy = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.JoinIndex = (int)GetLongBits (BArray);  	m_Interactions.Add (Interaction);  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: for (int i = 0; i < m_NumInteractions; i++) {  	TTABCore Interaction = new TTABCore ();  	BitArray BArray = new BitArray (Reader.ReadBytes (2));  	Interaction.ActionFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.GuardFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.MotiveEntries = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Flags = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.StrTableIndex = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationCode = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationValue = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Autonomy = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.JoinIndex = (int)GetLongBits (BArray);  	m_Interactions.Add (Interaction);  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: for (int i = 0; i < m_NumInteractions; i++) {  	TTABCore Interaction = new TTABCore ();  	BitArray BArray = new BitArray (Reader.ReadBytes (2));  	Interaction.ActionFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.GuardFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.MotiveEntries = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Flags = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.StrTableIndex = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationCode = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationValue = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Autonomy = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.JoinIndex = (int)GetLongBits (BArray);  	m_Interactions.Add (Interaction);  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: for (int i = 0; i < m_NumInteractions; i++) {  	TTABCore Interaction = new TTABCore ();  	BitArray BArray = new BitArray (Reader.ReadBytes (2));  	Interaction.ActionFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.GuardFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.MotiveEntries = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Flags = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.StrTableIndex = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationCode = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationValue = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Autonomy = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.JoinIndex = (int)GetLongBits (BArray);  	m_Interactions.Add (Interaction);  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: for (int i = 0; i < m_NumInteractions; i++) {  	TTABCore Interaction = new TTABCore ();  	BitArray BArray = new BitArray (Reader.ReadBytes (2));  	Interaction.ActionFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.GuardFunction = (short)GetShortBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.MotiveEntries = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Flags = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.StrTableIndex = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationCode = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.AttenuationValue = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.Autonomy = (int)GetLongBits (BArray);  	BArray = new BitArray (Reader.ReadBytes (4));  	Interaction.JoinIndex = (int)GetLongBits (BArray);  	m_Interactions.Add (Interaction);  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: BArray = new BitArray (Reader.ReadBytes (4));  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: BArray = new BitArray (Reader.ReadBytes (4));  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: BArray = new BitArray (Reader.ReadBytes (4));  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: BArray = new BitArray (Reader.ReadBytes (4));  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: BArray = new BitArray (Reader.ReadBytes (4));  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: BArray = new BitArray (Reader.ReadBytes (4));  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: BArray = new BitArray (Reader.ReadBytes (4));  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: BArray = new BitArray (Reader.ReadBytes (4));  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: for (int i = 3; i < Width; i++) {  	Bits.Add ((byte)((BArray.Get (i) == true) ? 1 : 0));  	Counter++;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: if (Bytes.Length < 8) {  	List<byte> bytes = new List<byte> (Bytes);  	while (bytes.Count != 8)  		bytes.Add (0);  	Value = BitConverter.ToInt64 (bytes.ToArray ()' 0);  } else  	Value = BitConverter.ToInt64 (Bytes' 0);  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: if (Bytes.Length < 8) {  	List<byte> bytes = new List<byte> (Bytes);  	while (bytes.Count != 8)  		bytes.Add (0);  	Value = BitConverter.ToInt64 (bytes.ToArray ()' 0);  } else  	Value = BitConverter.ToInt64 (Bytes' 0);  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: while (bytes.Count != 8)  	bytes.Add (0);  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: for (int i = 3; i < Width; i++) {  	Bits.Add ((byte)((BArray.Get (i) == true) ? 1 : 0));  	Counter++;  }  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: if (Bytes.Length < 8) {  	List<byte> bytes = new List<byte> (Bytes);  	while (bytes.Count != 8)  		bytes.Add (0);  	Value = BitConverter.ToInt64 (bytes.ToArray ()' 0);  } else  	Value = BitConverter.ToInt64 (Bytes' 0);  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: if (Bytes.Length < 8) {  	List<byte> bytes = new List<byte> (Bytes);  	while (bytes.Count != 8)  		bytes.Add (0);  	Value = BitConverter.ToInt64 (bytes.ToArray ()' 0);  } else  	Value = BitConverter.ToInt64 (Bytes' 0);  
Magic Number,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: while (bytes.Count != 8)  	bytes.Add (0);  
Magic Number,Iffinator.Flash,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\OBJD.cs,OBJD,The following statement contains a magic number: if (m_Version != 138) {  	//Assume log statements will be stored in the client's log...  	Log.LogThis ("Tried loading OBJD chunk version: " + m_Version + " (SimsLib.dll)"' eloglevel.error);  	return;  }  
Magic Number,Iffinator.Flash,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\OBJD.cs,OBJD,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,Iffinator.Flash,OBJf,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\OBJf.cs,OBJf,The following statement contains a magic number: Reader.ReadBytes (8);  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors = new Color[256];  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: Reader.BaseStream.Position = 16;  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	//Reader.BaseStream.Position += 3;  	byte[] colors = new byte[] {    	};  	if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  		m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  	else  		m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  }  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	//Reader.BaseStream.Position += 3;  	byte[] colors = new byte[] {    	};  	if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  		m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  	else  		m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  }  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++) {  	//Reader.BaseStream.Position += 3;  	byte[] colors = new byte[] {    	};  	if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  		m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  	else  		m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  }  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  	m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  else  	m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: if ((Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3)  	m_Colors [i] = Color.FromArgb (Reader.ReadByte ()' Reader.ReadByte ()' Reader.ReadByte ());  else  	m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors [i] = Color.FromArgb (255' 0x80' 0x80' 0x80);  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors = new Color[256];  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	m_Colors [i] = Color.FromArgb (255' 0' 0' 0);  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: for (int i = 0; i < 256; i++)  	m_Colors [i] = Color.FromArgb (255' 0' 0' 0);  
Magic Number,Iffinator.Flash,PaletteMap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors [i] = Color.FromArgb (255' 0' 0' 0);  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,GetFrame,The following statement contains a magic number: if (m_Version != 1001) {  	foreach (SpriteFrame Frame in m_Frames) {  		if (Frame.FrameIndex == Index)  			return Frame;  	}  	return ReadFrame (Index);  } else  	return m_Frames [Index];  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version != 1001)  	m_ChunkData = Chunk.Data;  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_IsBigEndian) {  	if (m_Version != 1001) {  		m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		for (uint i = 0; i < m_FrameCount; i++)  			m_OffsetTable.Add (Endian.SwapUInt32 (Reader.ReadUInt32 ()));  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		} else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	} else {  		m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		} else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  } else {  	if (m_Version != 1001) {  		m_FrameCount = Reader.ReadUInt32 ();  		m_PaletteID = Reader.ReadUInt32 ();  		for (uint i = 0; i < m_FrameCount; i++)  			m_OffsetTable.Add (Reader.ReadUInt32 ());  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		} else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	} else {  		m_FrameCount = Reader.ReadUInt32 ();  		m_PaletteID = Reader.ReadUInt32 ();  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		} else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_IsBigEndian) {  	if (m_Version != 1001) {  		m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		for (uint i = 0; i < m_FrameCount; i++)  			m_OffsetTable.Add (Endian.SwapUInt32 (Reader.ReadUInt32 ()));  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		} else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	} else {  		m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		} else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  } else {  	if (m_Version != 1001) {  		m_FrameCount = Reader.ReadUInt32 ();  		m_PaletteID = Reader.ReadUInt32 ();  		for (uint i = 0; i < m_FrameCount; i++)  			m_OffsetTable.Add (Reader.ReadUInt32 ());  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		} else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	} else {  		m_FrameCount = Reader.ReadUInt32 ();  		m_PaletteID = Reader.ReadUInt32 ();  		//Find and set the correct palettemap...  		if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  			m_PMap = PaletteMaps [0];  		} else  			m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  				if (PMap.ID == m_PaletteID) {  					return true;  				}  				return false;  			});  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version != 1001) {  	m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  	m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  	for (uint i = 0; i < m_FrameCount; i++)  		m_OffsetTable.Add (Endian.SwapUInt32 (Reader.ReadUInt32 ()));  	//Find and set the correct palettemap...  	if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  		m_PMap = PaletteMaps [0];  	} else  		m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  			if (PMap.ID == m_PaletteID) {  				return true;  			}  			return false;  		});  } else {  	m_FrameCount = Endian.SwapUInt32 (Reader.ReadUInt32 ());  	m_PaletteID = Endian.SwapUInt32 (Reader.ReadUInt32 ());  	//Find and set the correct palettemap...  	if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  		m_PMap = PaletteMaps [0];  	} else  		m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  			if (PMap.ID == m_PaletteID) {  				return true;  			}  			return false;  		});  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version != 1001) {  	m_FrameCount = Reader.ReadUInt32 ();  	m_PaletteID = Reader.ReadUInt32 ();  	for (uint i = 0; i < m_FrameCount; i++)  		m_OffsetTable.Add (Reader.ReadUInt32 ());  	//Find and set the correct palettemap...  	if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  		m_PMap = PaletteMaps [0];  	} else  		m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  			if (PMap.ID == m_PaletteID) {  				return true;  			}  			return false;  		});  } else {  	m_FrameCount = Reader.ReadUInt32 ();  	m_PaletteID = Reader.ReadUInt32 ();  	//Find and set the correct palettemap...  	if (PaletteMaps.Count == 1 && m_PaletteID == 1) {  		m_PMap = PaletteMaps [0];  	} else  		m_PMap = PaletteMaps.Find (delegate (PaletteMap PMap) {  			if (PMap.ID == m_PaletteID) {  				return true;  			}  			return false;  		});  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version == 1001) {  	//Framecount may be set to -1 and should be ignored...  	while (true) {  		SpriteFrame Frame = new SpriteFrame ();  		Frame.Version = Reader.ReadUInt32 ();  		Frame.Size = Reader.ReadUInt32 ();  		Reader.ReadBytes (4);  		//Reserved.  		Frame.Height = Reader.ReadUInt16 ();  		Frame.Width = Reader.ReadUInt16 ();  		Frame.Init (true' false);  		//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  		DecompressFrame2 (ref Frame' ref Reader);  		Frame.BitmapData.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		m_Frames.Add (Frame);  		if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  			break;  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version == 1001) {  	//Framecount may be set to -1 and should be ignored...  	while (true) {  		SpriteFrame Frame = new SpriteFrame ();  		Frame.Version = Reader.ReadUInt32 ();  		Frame.Size = Reader.ReadUInt32 ();  		Reader.ReadBytes (4);  		//Reserved.  		Frame.Height = Reader.ReadUInt16 ();  		Frame.Width = Reader.ReadUInt16 ();  		Frame.Init (true' false);  		//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  		DecompressFrame2 (ref Frame' ref Reader);  		Frame.BitmapData.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		m_Frames.Add (Frame);  		if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  			break;  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: if (m_Version == 1001) {  	//Framecount may be set to -1 and should be ignored...  	while (true) {  		SpriteFrame Frame = new SpriteFrame ();  		Frame.Version = Reader.ReadUInt32 ();  		Frame.Size = Reader.ReadUInt32 ();  		Reader.ReadBytes (4);  		//Reserved.  		Frame.Height = Reader.ReadUInt16 ();  		Frame.Width = Reader.ReadUInt16 ();  		Frame.Init (true' false);  		//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  		DecompressFrame2 (ref Frame' ref Reader);  		Frame.BitmapData.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		m_Frames.Add (Frame);  		if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  			break;  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: while (true) {  	SpriteFrame Frame = new SpriteFrame ();  	Frame.Version = Reader.ReadUInt32 ();  	Frame.Size = Reader.ReadUInt32 ();  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Reader.ReadUInt16 ();  	Frame.Width = Reader.ReadUInt16 ();  	Frame.Init (true' false);  	//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  	DecompressFrame2 (ref Frame' ref Reader);  	Frame.BitmapData.Unlock (true);  	//The bitmapdata is locked when the frame is created.  	m_Frames.Add (Frame);  	if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  		break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: while (true) {  	SpriteFrame Frame = new SpriteFrame ();  	Frame.Version = Reader.ReadUInt32 ();  	Frame.Size = Reader.ReadUInt32 ();  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Reader.ReadUInt16 ();  	Frame.Width = Reader.ReadUInt16 ();  	Frame.Init (true' false);  	//SPR#s don't have alpha channels' but alpha is used to plot transparent pixels.  	DecompressFrame2 (ref Frame' ref Reader);  	Frame.BitmapData.Unlock (true);  	//The bitmapdata is locked when the frame is created.  	m_Frames.Add (Frame);  	if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  		break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: if ((Reader.BaseStream.Position == Reader.BaseStream.Length) || (Reader.BaseStream.Position - Reader.BaseStream.Length < 14))  	break;  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,ReadFrame,The following statement contains a magic number: if (!m_IsBigEndian) {  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Reader.ReadUInt16 ();  	Frame.Width = Reader.ReadUInt16 ();  	Frame.PaletteID = (ushort)m_PaletteID;  } else {  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Endian.SwapUInt16 (Reader.ReadUInt16 ());  	Frame.Width = Endian.SwapUInt16 (Reader.ReadUInt16 ());  	Frame.PaletteID = (ushort)m_PaletteID;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,ReadFrame,The following statement contains a magic number: if (!m_IsBigEndian) {  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Reader.ReadUInt16 ();  	Frame.Width = Reader.ReadUInt16 ();  	Frame.PaletteID = (ushort)m_PaletteID;  } else {  	Reader.ReadBytes (4);  	//Reserved.  	Frame.Height = Endian.SwapUInt16 (Reader.ReadUInt16 ());  	Frame.Width = Endian.SwapUInt16 (Reader.ReadUInt16 ());  	Frame.PaletteID = (ushort)m_PaletteID;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,ReadFrame,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,ReadFrame,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (quit == false) {  	byte RowCommand = Reader.ReadByte ();  	byte RowCount = Reader.ReadByte ();  	switch (RowCommand) {  	case 0x00:  		//Start marker; the count byte is ignored.  		break;  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes the   	//size in bytes of the row and pixel data.  	case 0x04:  		RowCount -= 2;  		CurrentColumn = 0;  		while (RowCount > 0) {  			PixCommand = Reader.ReadByte ();  			PixCount = Reader.ReadByte ();  			RowCount -= 2;  			switch (PixCommand) {  			case 1:  				//Leave the next pixel count pixels as transparent.  				Transparent = Color.FromArgb (0' 0' 0' 0);  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  				}  				CurrentColumn += PixCount;  				break;  			case 2:  				//Fill the next pixel count pixels with a palette color.  				//The pixel data is two bytes: the first byte denotes the palette color index' and the   				//second byte is padding (which is always equal to the first byte but is ignored).  				Clr = Reader.ReadByte ();  				Reader.ReadByte ();  				//Padding  				RowCount -= 2;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				break;  			case 3:  				//Set the next pixel count pixels to the palette color indices defined by the   				//pixel data provided directly after this command.  				byte Padding = (byte)(PixCount % 2);  				if (Padding != 0)  					RowCount -= (byte)(PixCount + Padding);  				else  					RowCount -= PixCount;  				for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  					Clr = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  				}  				CurrentColumn += PixCount;  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  		}  		CurrentRow++;  		break;  	case 0x05:  		//End marker. The count byte is always 0' but may be ignored.  		//Some sprites don't have these' so read them using ReadBytes()' which  		//simply returns an empty array if the stream couldn't be read.  		Reader.ReadBytes (2);  		//PixCommand and PixCount.  		quit = true;  		break;  	case 0x09:  		//Leave the next count rows as transparent.  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int i = 0; i < RowCount; i++) {  			for (int j = CurrentColumn; j < Frame.Width; j++)  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			CurrentRow++;  		}  		break;  	case 0x10:  		//Start marker' equivalent to 0x00; the count byte is ignored.  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	RowCount -= 2;  	switch (PixCommand) {  	case 1:  		//Leave the next pixel count pixels as transparent.  		Transparent = Color.FromArgb (0' 0' 0' 0);  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		}  		CurrentColumn += PixCount;  		break;  	case 2:  		//Fill the next pixel count pixels with a palette color.  		//The pixel data is two bytes: the first byte denotes the palette color index' and the   		//second byte is padding (which is always equal to the first byte but is ignored).  		Clr = Reader.ReadByte ();  		Reader.ReadByte ();  		//Padding  		RowCount -= 2;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		break;  	case 3:  		//Set the next pixel count pixels to the palette color indices defined by the   		//pixel data provided directly after this command.  		byte Padding = (byte)(PixCount % 2);  		if (Padding != 0)  			RowCount -= (byte)(PixCount + Padding);  		else  			RowCount -= PixCount;  		for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  			Clr = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  		}  		CurrentColumn += PixCount;  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: Reader.ReadBytes (2);  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,GetFrame,The following statement contains a magic number: if (m_Version == 1000) {  	foreach (SpriteFrame Frame in m_Frames) {  		if (Frame.FrameIndex == Index) {  			return Frame;  		}  	}  	return ReadFrame (Index);  } else  	return m_Frames [Index];  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: if (m_Version == 1000)  	m_ChunkData = Chunk.Data;  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: if (m_Version == 1001) {  	m_PaletteID = Reader.ReadUInt32 ();  	m_FrameCount = Reader.ReadUInt32 ();  } else {  	m_FrameCount = Reader.ReadUInt32 ();  	m_PaletteID = Reader.ReadUInt32 ();  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: if (m_Version == 1000) {  	for (int i = 0; i < m_FrameCount; i++) {  		offsets [i] = Reader.ReadInt32 ();  		m_FrameOffsets.Add (offsets [i]);  	}  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: if (m_Version == 1001) {  	for (int l = 0; l < m_FrameCount; l++) {  		SpriteFrame Frame = new SpriteFrame ();  		Frame.Version = Reader.ReadUInt32 ();  		Frame.Size = Reader.ReadUInt32 ();  		Frame.Width = Reader.ReadUInt16 ();  		Frame.Height = Reader.ReadUInt16 ();  		Frame.Flag = Reader.ReadUInt32 ();  		Frame.PaletteID = Reader.ReadUInt16 ();  		Frame.TransparentPixel = m_PMap.GetColorAtIndex (Reader.ReadUInt16 ());  		Frame.YLocation = Reader.ReadUInt16 ();  		Frame.XLocation = Reader.ReadUInt16 ();  		if ((SPR2Flags)Frame.Flag == SPR2Flags.HasAlphaChannel)  			Frame.Init (true' true);  		else {  			if ((SPR2Flags)Frame.Flag == SPR2Flags.HasZBufferChannel)  				Frame.Init (false' true);  			else  				Frame.Init (false' false);  		}  		DecompressFrame2 (ref Frame' ref Reader);  		Frame.BitmapData.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		if (Frame.HasZBuffer)  			Frame.ZBuffer.Unlock (true);  		//The bitmapdata is locked when the frame is created.  		m_Frames.Add (Frame);  	}  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	while (quit == false) {  		int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		switch (rowHeader [0]) {  		case 0:  			column = 0;  			numCodesTillNewline = rowHeader [1];  			for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  				int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  				try {  					switch (rowHeader2 [0]) {  					case 1:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead += 2;  						}  						break;  					case 2:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							int Z = Reader.ReadByte ();  							byte b = Reader.ReadByte ();  							Color clr = m_PMap.GetColorAtIndex (b);  							Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  							bytesRead += 3;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					case 3:  						column += rowHeader2 [1];  						break;  					case 6:  						for (int i = 0; i < rowHeader2 [1]; i++) {  							byte b = Reader.ReadByte ();  							Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  							bytesRead++;  						}  						if (Reader.BaseStream.Position % 2 == 1) {  							Reader.ReadByte ();  							bytesRead++;  						}  						break;  					default:  						break;  					}  				} catch (Exception e) {  					Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  				}  				lastType = rowHeader2 [0];  			}  			row++;  			break;  		case 4:  			for (int i = 0; i < rowHeader [1]; i++) {  				row++;  				column = 0;  			}  			break;  		case 5:  			quit = true;  			break;  		default:  			Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  		lastType = rowHeader [0];  	}  } catch (Exception E) {  	Log.LogThis ("Unable to parse SPR2! \r\n" + "Version: " + m_Version + "\r\n" + "PaletteID: " + m_PaletteID + "\r\n" + "FrameCount: " + m_FrameCount + "\r\n" + E.ToString () + "\r\n"' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: while (quit == false) {  	int[] rowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (rowHeader [0]) {  	case 0:  		column = 0;  		numCodesTillNewline = rowHeader [1];  		for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  			int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  			try {  				switch (rowHeader2 [0]) {  				case 1:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead += 2;  					}  					break;  				case 2:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						int Z = Reader.ReadByte ();  						byte b = Reader.ReadByte ();  						Color clr = m_PMap.GetColorAtIndex (b);  						Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  						bytesRead += 3;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				case 3:  					column += rowHeader2 [1];  					break;  				case 6:  					for (int i = 0; i < rowHeader2 [1]; i++) {  						byte b = Reader.ReadByte ();  						Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  						bytesRead++;  					}  					if (Reader.BaseStream.Position % 2 == 1) {  						Reader.ReadByte ();  						bytesRead++;  					}  					break;  				default:  					break;  				}  			} catch (Exception e) {  				Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  			}  			lastType = rowHeader2 [0];  		}  		row++;  		break;  	case 4:  		for (int i = 0; i < rowHeader [1]; i++) {  			row++;  			column = 0;  		}  		break;  	case 5:  		quit = true;  		break;  	default:  		Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  	lastType = rowHeader [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader [0]) {  case 0:  	column = 0;  	numCodesTillNewline = rowHeader [1];  	for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  		int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  		try {  			switch (rowHeader2 [0]) {  			case 1:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead += 2;  				}  				break;  			case 2:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					int Z = Reader.ReadByte ();  					byte b = Reader.ReadByte ();  					Color clr = m_PMap.GetColorAtIndex (b);  					Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  					bytesRead += 3;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			case 3:  				column += rowHeader2 [1];  				break;  			case 6:  				for (int i = 0; i < rowHeader2 [1]; i++) {  					byte b = Reader.ReadByte ();  					Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  					bytesRead++;  				}  				if (Reader.BaseStream.Position % 2 == 1) {  					Reader.ReadByte ();  					bytesRead++;  				}  				break;  			default:  				break;  			}  		} catch (Exception e) {  			Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  		}  		lastType = rowHeader2 [0];  	}  	row++;  	break;  case 4:  	for (int i = 0; i < rowHeader [1]; i++) {  		row++;  		column = 0;  	}  	break;  case 5:  	quit = true;  	break;  default:  	Log.LogThis ("Error reading code " + lastType + '!'' eloglevel.error);  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  	int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  	try {  		switch (rowHeader2 [0]) {  		case 1:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead += 2;  			}  			break;  		case 2:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Color clr = m_PMap.GetColorAtIndex (b);  				Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  				bytesRead += 3;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		case 3:  			column += rowHeader2 [1];  			break;  		case 6:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead++;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		default:  			break;  		}  	} catch (Exception e) {  		Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  	}  	lastType = rowHeader2 [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  	int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  	try {  		switch (rowHeader2 [0]) {  		case 1:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead += 2;  			}  			break;  		case 2:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Color clr = m_PMap.GetColorAtIndex (b);  				Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  				bytesRead += 3;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		case 3:  			column += rowHeader2 [1];  			break;  		case 6:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead++;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		default:  			break;  		}  	} catch (Exception e) {  		Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  	}  	lastType = rowHeader2 [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  	int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  	try {  		switch (rowHeader2 [0]) {  		case 1:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead += 2;  			}  			break;  		case 2:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Color clr = m_PMap.GetColorAtIndex (b);  				Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  				bytesRead += 3;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		case 3:  			column += rowHeader2 [1];  			break;  		case 6:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead++;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		default:  			break;  		}  	} catch (Exception e) {  		Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  	}  	lastType = rowHeader2 [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  	int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  	try {  		switch (rowHeader2 [0]) {  		case 1:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead += 2;  			}  			break;  		case 2:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Color clr = m_PMap.GetColorAtIndex (b);  				Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  				bytesRead += 3;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		case 3:  			column += rowHeader2 [1];  			break;  		case 6:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead++;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		default:  			break;  		}  	} catch (Exception e) {  		Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  	}  	lastType = rowHeader2 [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  	int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  	try {  		switch (rowHeader2 [0]) {  		case 1:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead += 2;  			}  			break;  		case 2:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Color clr = m_PMap.GetColorAtIndex (b);  				Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  				bytesRead += 3;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		case 3:  			column += rowHeader2 [1];  			break;  		case 6:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead++;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		default:  			break;  		}  	} catch (Exception e) {  		Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  	}  	lastType = rowHeader2 [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  	int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  	try {  		switch (rowHeader2 [0]) {  		case 1:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead += 2;  			}  			break;  		case 2:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Color clr = m_PMap.GetColorAtIndex (b);  				Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  				bytesRead += 3;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		case 3:  			column += rowHeader2 [1];  			break;  		case 6:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead++;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		default:  			break;  		}  	} catch (Exception e) {  		Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  	}  	lastType = rowHeader2 [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  	int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  	try {  		switch (rowHeader2 [0]) {  		case 1:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead += 2;  			}  			break;  		case 2:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Color clr = m_PMap.GetColorAtIndex (b);  				Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  				bytesRead += 3;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		case 3:  			column += rowHeader2 [1];  			break;  		case 6:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead++;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		default:  			break;  		}  	} catch (Exception e) {  		Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  	}  	lastType = rowHeader2 [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  	int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  	try {  		switch (rowHeader2 [0]) {  		case 1:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead += 2;  			}  			break;  		case 2:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Color clr = m_PMap.GetColorAtIndex (b);  				Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  				bytesRead += 3;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		case 3:  			column += rowHeader2 [1];  			break;  		case 6:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead++;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		default:  			break;  		}  	} catch (Exception e) {  		Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  	}  	lastType = rowHeader2 [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2) {  	int[] rowHeader2 = GetDecryptedValues (Reader.ReadUInt16 ());  	try {  		switch (rowHeader2 [0]) {  		case 1:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead += 2;  			}  			break;  		case 2:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				int Z = Reader.ReadByte ();  				byte b = Reader.ReadByte ();  				Color clr = m_PMap.GetColorAtIndex (b);  				Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  				bytesRead += 3;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		case 3:  			column += rowHeader2 [1];  			break;  		case 6:  			for (int i = 0; i < rowHeader2 [1]; i++) {  				byte b = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  				bytesRead++;  			}  			if (Reader.BaseStream.Position % 2 == 1) {  				Reader.ReadByte ();  				bytesRead++;  			}  			break;  		default:  			break;  		}  	} catch (Exception e) {  		Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  	}  	lastType = rowHeader2 [0];  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: bytesRead += 2
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	switch (rowHeader2 [0]) {  	case 1:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead += 2;  		}  		break;  	case 2:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Color clr = m_PMap.GetColorAtIndex (b);  			Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  			bytesRead += 3;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	case 3:  		column += rowHeader2 [1];  		break;  	case 6:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead++;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	default:  		break;  	}  } catch (Exception e) {  	Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	switch (rowHeader2 [0]) {  	case 1:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead += 2;  		}  		break;  	case 2:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Color clr = m_PMap.GetColorAtIndex (b);  			Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  			bytesRead += 3;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	case 3:  		column += rowHeader2 [1];  		break;  	case 6:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead++;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	default:  		break;  	}  } catch (Exception e) {  	Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	switch (rowHeader2 [0]) {  	case 1:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead += 2;  		}  		break;  	case 2:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Color clr = m_PMap.GetColorAtIndex (b);  			Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  			bytesRead += 3;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	case 3:  		column += rowHeader2 [1];  		break;  	case 6:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead++;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	default:  		break;  	}  } catch (Exception e) {  	Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	switch (rowHeader2 [0]) {  	case 1:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead += 2;  		}  		break;  	case 2:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Color clr = m_PMap.GetColorAtIndex (b);  			Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  			bytesRead += 3;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	case 3:  		column += rowHeader2 [1];  		break;  	case 6:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead++;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	default:  		break;  	}  } catch (Exception e) {  	Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	switch (rowHeader2 [0]) {  	case 1:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead += 2;  		}  		break;  	case 2:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Color clr = m_PMap.GetColorAtIndex (b);  			Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  			bytesRead += 3;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	case 3:  		column += rowHeader2 [1];  		break;  	case 6:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead++;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	default:  		break;  	}  } catch (Exception e) {  	Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	switch (rowHeader2 [0]) {  	case 1:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead += 2;  		}  		break;  	case 2:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Color clr = m_PMap.GetColorAtIndex (b);  			Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  			bytesRead += 3;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	case 3:  		column += rowHeader2 [1];  		break;  	case 6:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead++;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	default:  		break;  	}  } catch (Exception e) {  	Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: try {  	switch (rowHeader2 [0]) {  	case 1:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead += 2;  		}  		break;  	case 2:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			int Z = Reader.ReadByte ();  			byte b = Reader.ReadByte ();  			Color clr = m_PMap.GetColorAtIndex (b);  			Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  			bytesRead += 3;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	case 3:  		column += rowHeader2 [1];  		break;  	case 6:  		for (int i = 0; i < rowHeader2 [1]; i++) {  			byte b = Reader.ReadByte ();  			Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  			bytesRead++;  		}  		if (Reader.BaseStream.Position % 2 == 1) {  			Reader.ReadByte ();  			bytesRead++;  		}  		break;  	default:  		break;  	}  } catch (Exception e) {  	Log.LogThis (String.Format ("Error reading code {0} ({1}). Last code read was {2}."' rowHeader2 [0]' e.Message' lastType)' eloglevel.error);  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader2 [0]) {  case 1:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead += 2;  	}  	break;  case 2:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Color clr = m_PMap.GetColorAtIndex (b);  		Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  		bytesRead += 3;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  case 3:  	column += rowHeader2 [1];  	break;  case 6:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead++;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  default:  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader2 [0]) {  case 1:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead += 2;  	}  	break;  case 2:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Color clr = m_PMap.GetColorAtIndex (b);  		Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  		bytesRead += 3;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  case 3:  	column += rowHeader2 [1];  	break;  case 6:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead++;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  default:  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader2 [0]) {  case 1:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead += 2;  	}  	break;  case 2:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Color clr = m_PMap.GetColorAtIndex (b);  		Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  		bytesRead += 3;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  case 3:  	column += rowHeader2 [1];  	break;  case 6:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead++;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  default:  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader2 [0]) {  case 1:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead += 2;  	}  	break;  case 2:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Color clr = m_PMap.GetColorAtIndex (b);  		Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  		bytesRead += 3;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  case 3:  	column += rowHeader2 [1];  	break;  case 6:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead++;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  default:  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader2 [0]) {  case 1:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead += 2;  	}  	break;  case 2:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Color clr = m_PMap.GetColorAtIndex (b);  		Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  		bytesRead += 3;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  case 3:  	column += rowHeader2 [1];  	break;  case 6:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead++;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  default:  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader2 [0]) {  case 1:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead += 2;  	}  	break;  case 2:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Color clr = m_PMap.GetColorAtIndex (b);  		Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  		bytesRead += 3;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  case 3:  	column += rowHeader2 [1];  	break;  case 6:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead++;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  default:  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader2 [0]) {  case 1:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead += 2;  	}  	break;  case 2:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		int Z = Reader.ReadByte ();  		byte b = Reader.ReadByte ();  		Color clr = m_PMap.GetColorAtIndex (b);  		Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  		bytesRead += 3;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  case 3:  	column += rowHeader2 [1];  	break;  case 6:  	for (int i = 0; i < rowHeader2 [1]; i++) {  		byte b = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  		bytesRead++;  	}  	if (Reader.BaseStream.Position % 2 == 1) {  		Reader.ReadByte ();  		bytesRead++;  	}  	break;  default:  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int i = 0; i < rowHeader2 [1]; i++) {  	int Z = Reader.ReadByte ();  	byte b = Reader.ReadByte ();  	Frame.BitmapData.SetPixel (new Point (column++' row)' m_PMap.GetColorAtIndex (b));  	bytesRead += 2;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: bytesRead += 2;  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: for (int i = 0; i < rowHeader2 [1]; i++) {  	int Z = Reader.ReadByte ();  	byte b = Reader.ReadByte ();  	Color clr = m_PMap.GetColorAtIndex (b);  	Frame.BitmapData.SetPixel (new Point (column++' row)' Color.FromArgb (Reader.ReadByte ()' clr));  	bytesRead += 3;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: bytesRead += 3;  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: if (Reader.BaseStream.Position % 2 == 1) {  	Reader.ReadByte ();  	bytesRead++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: if (Reader.BaseStream.Position % 2 == 1) {  	Reader.ReadByte ();  	bytesRead++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (Quit == false) {  	int[] RowHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	switch (RowHeader [0]) {  	case 0:  		//Fill this row with pixel data that directly follows; the count byte of the row   		//command denotes the size in bytes of the row's command/count bytes together   		//with the supplied pixel data.  		int RowCount = RowHeader [1];  		RowCount -= 2;  		//Row command + count bytes.  		while (RowCount > 0) {  			int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  			RowCount -= 2;  			int PixelCount = PixelHeader [1];  			switch (PixelHeader [0]) {  			case 1:  				//Set the next pixel count pixels in the z-buffer and color sprites to the   				//values defined by the pixel data provided directly after this command.  				RowCount -= PixelCount * 2;  				while (PixelCount > 0) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 2:  				//Set the next pixel count pixels in the z-buffer' color' and alpha   				//sprites to the values defined by the pixel data provided directly after   				//this command.  				Padding = PixelCount % 2;  				RowCount -= (PixelCount * 3) + Padding;  				while (PixelCount > 0) {  					ZClr = Color.FromArgb (Reader.ReadByte ());  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					//Read the alpha.  					Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  					ZClr = Color.FromArgb (Clr.A' ZClr);  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			case 3:  				//Leave the next pixel count pixels in the color sprite filled with the   				//transparent color' in the z-buffer sprite filled with 255' and in the   				//alpha sprite filled with 0. This pixel command has no pixel data.  				while (PixelCount > 0) {  					//This is completely transparent regardless of whether the frame  					//supports alpha.  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					PixelCount--;  					CurrentColumn++;  				}  				break;  			case 6:  				//Set the next pixel count pixels in the color sprite to the palette color   				//indices defined by the pixel data provided directly after this command.  				Padding = PixelCount % 2;  				RowCount -= PixelCount + Padding;  				while (PixelCount > 0) {  					Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  					if (Clr != Frame.TransparentPixel)  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  					if (Frame.HasZBuffer) {  						if (Clr != Frame.TransparentPixel)  							Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  						else  							Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  					}  					PixelCount--;  					CurrentColumn++;  				}  				if (Padding != 0)  					Reader.ReadByte ();  				break;  			}  			if (Reader.BaseStream.Position == Reader.BaseStream.Length)  				break;  		}  		CurrentRow++;  		CurrentColumn = 0;  		break;  	case 4:  		//Leave the next count rows in the color sprite filled with the transparent color'   		//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  		for (int i = 0; i < RowHeader [1]; i++) {  			for (int j = 0; j < Frame.Width; j++) {  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				CurrentColumn++;  			}  			CurrentColumn = 0;  			CurrentRow++;  		}  		CurrentColumn = 0;  		break;  	case 5:  		//Sprite end marker; the count byte is always 0' but may be ignored.  		Quit = true;  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (RowCount > 0) {  	int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  	RowCount -= 2;  	int PixelCount = PixelHeader [1];  	switch (PixelHeader [0]) {  	case 1:  		//Set the next pixel count pixels in the z-buffer and color sprites to the   		//values defined by the pixel data provided directly after this command.  		RowCount -= PixelCount * 2;  		while (PixelCount > 0) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 2:  		//Set the next pixel count pixels in the z-buffer' color' and alpha   		//sprites to the values defined by the pixel data provided directly after   		//this command.  		Padding = PixelCount % 2;  		RowCount -= (PixelCount * 3) + Padding;  		while (PixelCount > 0) {  			ZClr = Color.FromArgb (Reader.ReadByte ());  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			//Read the alpha.  			Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  			ZClr = Color.FromArgb (Clr.A' ZClr);  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	case 3:  		//Leave the next pixel count pixels in the color sprite filled with the   		//transparent color' in the z-buffer sprite filled with 255' and in the   		//alpha sprite filled with 0. This pixel command has no pixel data.  		while (PixelCount > 0) {  			//This is completely transparent regardless of whether the frame  			//supports alpha.  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			PixelCount--;  			CurrentColumn++;  		}  		break;  	case 6:  		//Set the next pixel count pixels in the color sprite to the palette color   		//indices defined by the pixel data provided directly after this command.  		Padding = PixelCount % 2;  		RowCount -= PixelCount + Padding;  		while (PixelCount > 0) {  			Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  			if (Clr != Frame.TransparentPixel)  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				if (Clr != Frame.TransparentPixel)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			PixelCount--;  			CurrentColumn++;  		}  		if (Padding != 0)  			Reader.ReadByte ();  		break;  	}  	if (Reader.BaseStream.Position == Reader.BaseStream.Length)  		break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= 2;  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= PixelCount * 2;  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Padding = PixelCount % 2;  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: RowCount -= (PixelCount * 3) + Padding;  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	//This is completely transparent regardless of whether the frame  	//supports alpha.  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	//This is completely transparent regardless of whether the frame  	//supports alpha.  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	//This is completely transparent regardless of whether the frame  	//supports alpha.  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	//This is completely transparent regardless of whether the frame  	//supports alpha.  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Padding = PixelCount % 2;  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: while (PixelCount > 0) {  	Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  	if (Clr != Frame.TransparentPixel)  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		if (Clr != Frame.TransparentPixel)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	PixelCount--;  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	if (Clr != Frame.TransparentPixel)  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  	else  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Clr != Frame.TransparentPixel)  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  else  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int i = 0; i < RowHeader [1]; i++) {  	for (int j = 0; j < Frame.Width; j++) {  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		CurrentColumn++;  	}  	CurrentColumn = 0;  	CurrentRow++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int i = 0; i < RowHeader [1]; i++) {  	for (int j = 0; j < Frame.Width; j++) {  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		CurrentColumn++;  	}  	CurrentColumn = 0;  	CurrentRow++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int i = 0; i < RowHeader [1]; i++) {  	for (int j = 0; j < Frame.Width; j++) {  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		CurrentColumn++;  	}  	CurrentColumn = 0;  	CurrentRow++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int i = 0; i < RowHeader [1]; i++) {  	for (int j = 0; j < Frame.Width; j++) {  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		CurrentColumn++;  	}  	CurrentColumn = 0;  	CurrentRow++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int j = 0; j < Frame.Width; j++) {  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int j = 0; j < Frame.Width; j++) {  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int j = 0; j < Frame.Width; j++) {  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: for (int j = 0; j < Frame.Width; j++) {  	Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  	if (Frame.HasZBuffer) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  	}  	CurrentColumn++;  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: if (Frame.HasZBuffer) {  	Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,ExportToBitmaps,The following statement contains a magic number: if (m_Version == 1001) {  	foreach (SpriteFrame Frame in m_Frames) {  		string fileLocation = directory + '\\' + m_ID + '_' + Frame.Width + 'x' + Frame.Height + ".bmp";  		if (File.Exists (fileLocation))  			File.Delete (fileLocation);  		Frame.BitmapData.BitMap.Save (fileLocation);  		//This calls FastPixel.Unlock()  		Frame.BitmapData.Lock ();  		//The bitmap should always be locked!  	}  }  
Magic Number,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,GetDecryptedValues,The following statement contains a magic number: return new int[] {  	(P >> 13)'  	// Code  	((P & 0x1FFF))  };  
Magic Number,Iffinator.Flash,StringTable,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,ReadZeroString,The following statement contains a magic number: while (true) {  	Chrs = Reader.ReadChars (2);  	SB.Append (Chrs);  	if (new string (Chrs) == "\0\0")  		break;  }  
Magic Number,Iffinator.Flash,StringTable,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,ReadZeroString,The following statement contains a magic number: Chrs = Reader.ReadChars (2);  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_InteractionCount > 0) {  	m_Version = Reader.ReadUInt16 ();  	try {  		long FieldValue = 0;  		if (m_Version == 9 || m_Version == 10) {  			m_CompressionCode = Reader.ReadByte ();  			m_FEncodingData.CompressionCode = m_CompressionCode;  			m_FEncodingData.FieldWidths = new byte[] {  				5'  				8'  				13'  				16'  				6'  				11'  				21'  				32  			};  			m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  			m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  		}  		for (ushort i = 0; i < m_InteractionCount; i++) {  			if (m_Version == 9 || m_Version == 10) {  				Interaction Action = new Interaction ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.ActionFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				Action.GuardFuncID = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.MotiveEntryCount = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.Flags = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.TTAID = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationCode = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AttenuationValue = (float)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.AutonomyThreshold = (uint)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				Action.JoiningIndex = (int)FieldValue;  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMinimum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.EffectRangeMaximum = (short)FieldValue;  					m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  					MotiveEntry.PersonalityModifier = (ushort)FieldValue;  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 10)  					m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  				//Unknown...  			} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  				Interaction Action = new Interaction ();  				Action.ActionFuncID = Reader.ReadInt16 ();  				Action.GuardFuncID = Reader.ReadInt16 ();  				Action.MotiveEntryCount = Reader.ReadUInt32 ();  				Action.Flags = Reader.ReadUInt32 ();  				Action.TTAID = Reader.ReadUInt32 ();  				if (m_Version >= 7)  					Action.AttenuationCode = Reader.ReadUInt32 ();  				Action.AttenuationValue = Reader.ReadUInt32 ();  				Action.AutonomyThreshold = Reader.ReadUInt32 ();  				Action.JoiningIndex = Reader.ReadInt32 ();  				for (uint j = 0; j < Action.MotiveEntryCount; j++) {  					Motive MotiveEntry = new Motive ();  					if (m_Version >= 7)  						MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  					MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  					if (m_Version >= 7)  						MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  					Action.Motives.Add (MotiveEntry);  				}  				m_Interactions.Add (Action);  				if (m_Version == 11)  					Reader.ReadBytes (4);  				//Unknown.  			}  		}  	} catch (Exception E) {  		Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: try {  	long FieldValue = 0;  	if (m_Version == 9 || m_Version == 10) {  		m_CompressionCode = Reader.ReadByte ();  		m_FEncodingData.CompressionCode = m_CompressionCode;  		m_FEncodingData.FieldWidths = new byte[] {  			5'  			8'  			13'  			16'  			6'  			11'  			21'  			32  		};  		m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  		m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  	}  	for (ushort i = 0; i < m_InteractionCount; i++) {  		if (m_Version == 9 || m_Version == 10) {  			Interaction Action = new Interaction ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.ActionFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			Action.GuardFuncID = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.MotiveEntryCount = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.Flags = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.TTAID = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationCode = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AttenuationValue = (float)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.AutonomyThreshold = (uint)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			Action.JoiningIndex = (int)FieldValue;  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMinimum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.EffectRangeMaximum = (short)FieldValue;  				m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  				MotiveEntry.PersonalityModifier = (ushort)FieldValue;  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 10)  				m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  			//Unknown...  		} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  			Interaction Action = new Interaction ();  			Action.ActionFuncID = Reader.ReadInt16 ();  			Action.GuardFuncID = Reader.ReadInt16 ();  			Action.MotiveEntryCount = Reader.ReadUInt32 ();  			Action.Flags = Reader.ReadUInt32 ();  			Action.TTAID = Reader.ReadUInt32 ();  			if (m_Version >= 7)  				Action.AttenuationCode = Reader.ReadUInt32 ();  			Action.AttenuationValue = Reader.ReadUInt32 ();  			Action.AutonomyThreshold = Reader.ReadUInt32 ();  			Action.JoiningIndex = Reader.ReadInt32 ();  			for (uint j = 0; j < Action.MotiveEntryCount; j++) {  				Motive MotiveEntry = new Motive ();  				if (m_Version >= 7)  					MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  				MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  				if (m_Version >= 7)  					MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  				Action.Motives.Add (MotiveEntry);  			}  			m_Interactions.Add (Action);  			if (m_Version == 11)  				Reader.ReadBytes (4);  			//Unknown.  		}  	}  } catch (Exception E) {  	Log.LogThis ("Failed parsing a TTAB chunk!\r\n" + "Version: " + m_Version + "\r\n" + "InteractionCount: " + m_InteractionCount + "\r\n" + E.ToString ()' eloglevel.error);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	m_CompressionCode = Reader.ReadByte ();  	m_FEncodingData.CompressionCode = m_CompressionCode;  	m_FEncodingData.FieldWidths = new byte[] {  		5'  		8'  		13'  		16'  		6'  		11'  		21'  		32  	};  	m_FEncodingData.EncodedDataLength = (uint)(Reader.BaseStream.Length - Reader.BaseStream.Position);  	m_FEncodingData.EncodedData = Reader.ReadBytes ((int)m_FEncodingData.EncodedDataLength);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] {  	5'  	8'  	13'  	16'  	6'  	11'  	21'  	32  };  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (ushort i = 0; i < m_InteractionCount; i++) {  	if (m_Version == 9 || m_Version == 10) {  		Interaction Action = new Interaction ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.ActionFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		Action.GuardFuncID = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.MotiveEntryCount = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.Flags = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.TTAID = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationCode = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AttenuationValue = (float)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.AutonomyThreshold = (uint)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		Action.JoiningIndex = (int)FieldValue;  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMinimum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.EffectRangeMaximum = (short)FieldValue;  			m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  			MotiveEntry.PersonalityModifier = (ushort)FieldValue;  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 10)  			m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  		//Unknown...  	} else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  		Interaction Action = new Interaction ();  		Action.ActionFuncID = Reader.ReadInt16 ();  		Action.GuardFuncID = Reader.ReadInt16 ();  		Action.MotiveEntryCount = Reader.ReadUInt32 ();  		Action.Flags = Reader.ReadUInt32 ();  		Action.TTAID = Reader.ReadUInt32 ();  		if (m_Version >= 7)  			Action.AttenuationCode = Reader.ReadUInt32 ();  		Action.AttenuationValue = Reader.ReadUInt32 ();  		Action.AutonomyThreshold = Reader.ReadUInt32 ();  		Action.JoiningIndex = Reader.ReadInt32 ();  		for (uint j = 0; j < Action.MotiveEntryCount; j++) {  			Motive MotiveEntry = new Motive ();  			if (m_Version >= 7)  				MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  			MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  			if (m_Version >= 7)  				MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  			Action.Motives.Add (MotiveEntry);  		}  		m_Interactions.Add (Action);  		if (m_Version == 11)  			Reader.ReadBytes (4);  		//Unknown.  	}  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 9 || m_Version == 10) {  	Interaction Action = new Interaction ();  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.ActionFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  	Action.GuardFuncID = (short)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.MotiveEntryCount = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.Flags = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.TTAID = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationCode = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AttenuationValue = (float)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.AutonomyThreshold = (uint)FieldValue;  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	Action.JoiningIndex = (int)FieldValue;  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMinimum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.EffectRangeMaximum = (short)FieldValue;  		m_FReader.DecodeField (ref m_FEncodingData' 0' ref FieldValue);  		MotiveEntry.PersonalityModifier = (ushort)FieldValue;  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 10)  		m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  	//Unknown...  } else if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 10)  	m_FReader.DecodeField (ref m_FEncodingData' 1' ref FieldValue);  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11) {  	Interaction Action = new Interaction ();  	Action.ActionFuncID = Reader.ReadInt16 ();  	Action.GuardFuncID = Reader.ReadInt16 ();  	Action.MotiveEntryCount = Reader.ReadUInt32 ();  	Action.Flags = Reader.ReadUInt32 ();  	Action.TTAID = Reader.ReadUInt32 ();  	if (m_Version >= 7)  		Action.AttenuationCode = Reader.ReadUInt32 ();  	Action.AttenuationValue = Reader.ReadUInt32 ();  	Action.AutonomyThreshold = Reader.ReadUInt32 ();  	Action.JoiningIndex = Reader.ReadInt32 ();  	for (uint j = 0; j < Action.MotiveEntryCount; j++) {  		Motive MotiveEntry = new Motive ();  		if (m_Version >= 7)  			MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  		MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  		if (m_Version >= 7)  			MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  		Action.Motives.Add (MotiveEntry);  	}  	m_Interactions.Add (Action);  	if (m_Version == 11)  		Reader.ReadBytes (4);  	//Unknown.  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version >= 7)  	Action.AttenuationCode = Reader.ReadUInt32 ();  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (uint j = 0; j < Action.MotiveEntryCount; j++) {  	Motive MotiveEntry = new Motive ();  	if (m_Version >= 7)  		MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  	MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  	if (m_Version >= 7)  		MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  	Action.Motives.Add (MotiveEntry);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: for (uint j = 0; j < Action.MotiveEntryCount; j++) {  	Motive MotiveEntry = new Motive ();  	if (m_Version >= 7)  		MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  	MotiveEntry.EffectRangeMaximum = Reader.ReadInt16 ();  	if (m_Version >= 7)  		MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  	Action.Motives.Add (MotiveEntry);  }  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version >= 7)  	MotiveEntry.EffectRangeMinimum = Reader.ReadInt16 ();  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version >= 7)  	MotiveEntry.PersonalityModifier = Reader.ReadUInt16 ();  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 11)  	Reader.ReadBytes (4);  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: if (m_Version == 11)  	Reader.ReadBytes (4);  
Magic Number,Iffinator.Flash,TTAB,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: Reader.ReadBytes (4);  
Duplicate Code,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method contains a code clone-set at the following line numbers (starting from the method definition): ((38' 57)' (70' 89)' (179' 198)' (147' 166))
Duplicate Code,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method contains a code clone-set at the following line numbers (starting from the method definition): ((38' 58)' (147' 167))
Duplicate Code,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method contains a code clone-set at the following line numbers (starting from the method definition): ((70' 91)' (179' 200))
Duplicate Code,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method contains a code clone-set at the following line numbers (starting from the method definition): ((62' 88)' (139' 165)' (171' 197))
Duplicate Code,Iffinator,ChunkAnalyzer,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method contains a code clone-set at the following line numbers (starting from the method definition): ((137' 157)' (169' 189))
Missing Default,Iffinator.Flash,BHAV,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following switch statement is missing a default case: switch (m_Signature) {  case 0x8000:  case 0x8001:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Locals = 0;  	//No locals in code; added in 8002?  	m_Params = 4;  	//I can't find this in header; always 4?  	break;  case 0x8002:  	m_HeaderLength = 12;  	Count = (Header [3] << 8) | Header [4];  	m_Type = Header [5];  	m_Params = Header [6];  	m_Locals = (ushort)((Header [7] << 8) | Header [8]);  	m_Flags = (ushort)((Header [9] << 8) | Header [10]);  	//Byte 11 and 12 are set to 0 in this version' we have no use for them.  	break;  case 0x8003:  	m_HeaderLength = 13;  	byte LastHeaderByte = Reader.ReadByte ();  	Count = (((((LastHeaderByte << 8) | Header [11]) << 8) | Header [10]) << 8) | Header [9];  	m_Type = Header [3];  	m_Params = Header [4];  	m_Locals = Header [5];  	//Byte number 6 and 7 are unknown in this version' we have no use for them.  	m_Flags = (ushort)((Header [8] << 8) | Header [9]);  	break;  }  
Missing Default,Iffinator.Flash,InteractionList,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following switch statement is missing a default case: switch (m_Version) {  case 2:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Reader.ReadInt16 ();  		//0xA3A3 (skip)  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 3:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt16 ();  		Interaction.Flags = Reader.ReadInt16 ();  		Reader.ReadInt32 ();  		//4-byte float' no idea what it is used for.  		m_Interactions.Add (Interaction);  	}  	break;  case 5:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 7:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 8:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		Interaction.ActionFunction = Reader.ReadInt16 ();  		Interaction.GuardFunction = Reader.ReadInt16 ();  		Interaction.MotiveEntries = Reader.ReadInt32 ();  		Interaction.Flags = Reader.ReadInt32 ();  		Interaction.StrTableIndex = Reader.ReadInt32 ();  		Interaction.AttenuationCode = Reader.ReadInt32 ();  		Interaction.AttenuationValue = Reader.ReadInt32 ();  		Interaction.Autonomy = Reader.ReadInt32 ();  		Interaction.JoinIndex = Reader.ReadInt32 ();  		m_Interactions.Add (Interaction);  	}  	break;  case 9:  	for (int i = 0; i < m_NumInteractions; i++) {  		TTABCore Interaction = new TTABCore ();  		BitArray BArray = new BitArray (Reader.ReadBytes (2));  		Interaction.ActionFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.GuardFunction = (short)GetShortBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.MotiveEntries = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Flags = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.StrTableIndex = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationCode = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.AttenuationValue = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.Autonomy = (int)GetLongBits (BArray);  		BArray = new BitArray (Reader.ReadBytes (4));  		Interaction.JoinIndex = (int)GetLongBits (BArray);  		m_Interactions.Add (Interaction);  	}  	break;  }  
Missing Default,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (RowCommand) {  case 0x00:  	//Start marker; the count byte is ignored.  	break;  //Fill this row with pixel data that directly follows; the count byte of the row command denotes the   //size in bytes of the row and pixel data.  case 0x04:  	RowCount -= 2;  	CurrentColumn = 0;  	while (RowCount > 0) {  		PixCommand = Reader.ReadByte ();  		PixCount = Reader.ReadByte ();  		RowCount -= 2;  		switch (PixCommand) {  		case 1:  			//Leave the next pixel count pixels as transparent.  			Transparent = Color.FromArgb (0' 0' 0' 0);  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  			}  			CurrentColumn += PixCount;  			break;  		case 2:  			//Fill the next pixel count pixels with a palette color.  			//The pixel data is two bytes: the first byte denotes the palette color index' and the   			//second byte is padding (which is always equal to the first byte but is ignored).  			Clr = Reader.ReadByte ();  			Reader.ReadByte ();  			//Padding  			RowCount -= 2;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			break;  		case 3:  			//Set the next pixel count pixels to the palette color indices defined by the   			//pixel data provided directly after this command.  			byte Padding = (byte)(PixCount % 2);  			if (Padding != 0)  				RowCount -= (byte)(PixCount + Padding);  			else  				RowCount -= PixCount;  			for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  				Clr = Reader.ReadByte ();  				Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  			}  			CurrentColumn += PixCount;  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  	}  	CurrentRow++;  	break;  case 0x05:  	//End marker. The count byte is always 0' but may be ignored.  	//Some sprites don't have these' so read them using ReadBytes()' which  	//simply returns an empty array if the stream couldn't be read.  	Reader.ReadBytes (2);  	//PixCommand and PixCount.  	quit = true;  	break;  case 0x09:  	//Leave the next count rows as transparent.  	PixCommand = Reader.ReadByte ();  	PixCount = Reader.ReadByte ();  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int i = 0; i < RowCount; i++) {  		for (int j = CurrentColumn; j < Frame.Width; j++)  			Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  		CurrentRow++;  	}  	break;  case 0x10:  	//Start marker' equivalent to 0x00; the count byte is ignored.  	break;  }  
Missing Default,Iffinator.Flash,SPRParser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (PixCommand) {  case 1:  	//Leave the next pixel count pixels as transparent.  	Transparent = Color.FromArgb (0' 0' 0' 0);  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' Transparent);  	}  	CurrentColumn += PixCount;  	break;  case 2:  	//Fill the next pixel count pixels with a palette color.  	//The pixel data is two bytes: the first byte denotes the palette color index' and the   	//second byte is padding (which is always equal to the first byte but is ignored).  	Clr = Reader.ReadByte ();  	Reader.ReadByte ();  	//Padding  	RowCount -= 2;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	break;  case 3:  	//Set the next pixel count pixels to the palette color indices defined by the   	//pixel data provided directly after this command.  	byte Padding = (byte)(PixCount % 2);  	if (Padding != 0)  		RowCount -= (byte)(PixCount + Padding);  	else  		RowCount -= PixCount;  	for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++) {  		Clr = Reader.ReadByte ();  		Frame.BitmapData.SetPixel (new Point (j' CurrentRow)' m_PMap.GetColorAtIndex (Clr));  	}  	CurrentColumn += PixCount;  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Missing Default,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (RowHeader [0]) {  case 0:  	//Fill this row with pixel data that directly follows; the count byte of the row   	//command denotes the size in bytes of the row's command/count bytes together   	//with the supplied pixel data.  	int RowCount = RowHeader [1];  	RowCount -= 2;  	//Row command + count bytes.  	while (RowCount > 0) {  		int[] PixelHeader = GetDecryptedValues (Reader.ReadUInt16 ());  		RowCount -= 2;  		int PixelCount = PixelHeader [1];  		switch (PixelHeader [0]) {  		case 1:  			//Set the next pixel count pixels in the z-buffer and color sprites to the   			//values defined by the pixel data provided directly after this command.  			RowCount -= PixelCount * 2;  			while (PixelCount > 0) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 2:  			//Set the next pixel count pixels in the z-buffer' color' and alpha   			//sprites to the values defined by the pixel data provided directly after   			//this command.  			Padding = PixelCount % 2;  			RowCount -= (PixelCount * 3) + Padding;  			while (PixelCount > 0) {  				ZClr = Color.FromArgb (Reader.ReadByte ());  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				//Read the alpha.  				Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  				ZClr = Color.FromArgb (Clr.A' ZClr);  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		case 3:  			//Leave the next pixel count pixels in the color sprite filled with the   			//transparent color' in the z-buffer sprite filled with 255' and in the   			//alpha sprite filled with 0. This pixel command has no pixel data.  			while (PixelCount > 0) {  				//This is completely transparent regardless of whether the frame  				//supports alpha.  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer)  					Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				PixelCount--;  				CurrentColumn++;  			}  			break;  		case 6:  			//Set the next pixel count pixels in the color sprite to the palette color   			//indices defined by the pixel data provided directly after this command.  			Padding = PixelCount % 2;  			RowCount -= PixelCount + Padding;  			while (PixelCount > 0) {  				Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  				if (Clr != Frame.TransparentPixel)  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  				else  					Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  				if (Frame.HasZBuffer) {  					if (Clr != Frame.TransparentPixel)  						Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  					else  						Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  				}  				PixelCount--;  				CurrentColumn++;  			}  			if (Padding != 0)  				Reader.ReadByte ();  			break;  		}  		if (Reader.BaseStream.Position == Reader.BaseStream.Length)  			break;  	}  	CurrentRow++;  	CurrentColumn = 0;  	break;  case 4:  	//Leave the next count rows in the color sprite filled with the transparent color'   	//in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.  	for (int i = 0; i < RowHeader [1]; i++) {  		for (int j = 0; j < Frame.Width; j++) {  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  			if (Frame.HasZBuffer) {  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  			}  			CurrentColumn++;  		}  		CurrentColumn = 0;  		CurrentRow++;  	}  	CurrentColumn = 0;  	break;  case 5:  	//Sprite end marker; the count byte is always 0' but may be ignored.  	Quit = true;  	break;  }  
Missing Default,Iffinator.Flash,SPR2Parser,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (PixelHeader [0]) {  case 1:  	//Set the next pixel count pixels in the z-buffer and color sprites to the   	//values defined by the pixel data provided directly after this command.  	RowCount -= PixelCount * 2;  	while (PixelCount > 0) {  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (Reader.ReadByte ()' 0' 0' 0));  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 2:  	//Set the next pixel count pixels in the z-buffer' color' and alpha   	//sprites to the values defined by the pixel data provided directly after   	//this command.  	Padding = PixelCount % 2;  	RowCount -= (PixelCount * 3) + Padding;  	while (PixelCount > 0) {  		ZClr = Color.FromArgb (Reader.ReadByte ());  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		//Read the alpha.  		Clr = Color.FromArgb (Reader.ReadByte ()' Clr);  		ZClr = Color.FromArgb (Clr.A' ZClr);  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' ZClr);  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  case 3:  	//Leave the next pixel count pixels in the color sprite filled with the   	//transparent color' in the z-buffer sprite filled with 255' and in the   	//alpha sprite filled with 0. This pixel command has no pixel data.  	while (PixelCount > 0) {  		//This is completely transparent regardless of whether the frame  		//supports alpha.  		Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer)  			Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		PixelCount--;  		CurrentColumn++;  	}  	break;  case 6:  	//Set the next pixel count pixels in the color sprite to the palette color   	//indices defined by the pixel data provided directly after this command.  	Padding = PixelCount % 2;  	RowCount -= PixelCount + Padding;  	while (PixelCount > 0) {  		Clr = m_PMap.GetColorAtIndex (Reader.ReadByte ());  		if (Clr != Frame.TransparentPixel)  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Clr);  		else  			Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (0' 0' 0' 0));  		if (Frame.HasZBuffer) {  			if (Clr != Frame.TransparentPixel)  				Frame.ZBuffer.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 1' 1' 1));  			else  				Frame.BitmapData.SetPixel (new Point (CurrentColumn' CurrentRow)' Color.FromArgb (255' 255' 255' 255));  		}  		PixelCount--;  		CurrentColumn++;  	}  	if (Padding != 0)  		Reader.ReadByte ();  	break;  }  
Missing Default,Iffinator.Flash,StringTable,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,StringTable,The following switch statement is missing a default case: switch (m_FormatCode) {  case 0:  	//Some tables are empty... LITERALLY!  	if (Reader.BaseStream.Position < Reader.BaseStream.Length) {  		m_NumEntries = Reader.ReadUInt16 ();  		for (int i = 0; i < m_NumEntries; i++) {  			StringTableString Str = new StringTableString ();  			Str.Str = ReadPascalString (Reader);  			m_Strings.Add (Str);  		}  	}  	break;  case 0xFFFF:  	m_NumEntries = Reader.ReadUInt16 ();  	for (int i = 0; i < m_NumEntries; i++) {  		StringTableString Str = new StringTableString ();  		char C;  		StringBuilder SB = new StringBuilder ();  		while (true) {  			C = Reader.ReadChar ();  			SB.Append (C);  			if (C == '\0')  				break;  		}  		Str.Str = SB.ToString ();  		m_Strings.Add (Str);  	}  	break;  case 0xFEFF:  	m_NumEntries = Reader.ReadUInt16 ();  	for (int i = 0; i < m_NumEntries; i++) {  		StringTableString Str = new StringTableString ();  		char C;  		StringBuilder SB = new StringBuilder ();  		//String  		while (true) {  			C = Reader.ReadChar ();  			SB.Append (C);  			if (C == '\0')  				break;  		}  		Str.Str = SB.ToString ();  		m_Strings.Add (Str);  		SB = new StringBuilder ();  		//Comment  		while (true) {  			C = Reader.ReadChar ();  			SB.Append (C);  			if (C == '\0')  				break;  		}  	}  	break;  case 0xFDFF:  	m_NumEntries = Reader.ReadUInt16 ();  	for (int i = 0; i < m_NumEntries; i++) {  		StringTableString Str = new StringTableString ();  		Str.LanguageCode = Reader.ReadByte ();  		char C;  		StringBuilder SB = new StringBuilder ();  		while (true) {  			C = (char)Reader.ReadByte ();  			if (C == '\0')  				break;  			SB.Append (C);  		}  		Str.Str = SB.ToString ();  		C = new char ();  		SB = new StringBuilder ();  		while (true) {  			C = (char)Reader.ReadByte ();  			if (C == '\0')  				break;  			SB.Append (C);  		}  		Str.Str2 = SB.ToString ();  		m_Strings.Add (Str);  	}  	break;  case 0xFCFF:  	//Only found in TSO-files!  	m_NumSets = Reader.ReadByte ();  	//if (!m_IsCTSS)  	//{  	if (m_NumSets >= 1) {  		for (int i = 0; i < m_NumSets; i++) {  			StringSet Set = new StringSet ();  			Set.NumEntries = Reader.ReadInt16 ();  			for (int j = 0; j < Set.NumEntries; j++) {  				// string code' then two specially-counted strings  				// for some reason' the language code is one below the  				// documented values.  we adjust this here' which  				// unfortunately makes non-translated strings strange.  				StringTableString Str = new StringTableString ();  				Str.LanguageCode = (byte)(Reader.ReadByte () + 1);  				Str.Str = ReadPascalString1 (Reader);  				Str.Str2 = ReadPascalString1 (Reader);  				Set.Strings.Add (Str);  			}  			m_StringSets.Add (Set);  		}  	}  	/*}                     else                     {                         StringSet Set = new StringSet();                          for (int i = 0; i < 2; i++)                         {                             StringTableString Str = new StringTableString();                             Str.LanguageCode = (byte)(Reader.ReadByte() + 1);                              Str.Str = ReadZeroString(Reader);                             Reader.ReadByte();                             Str.Str2 = ReadZeroString(Reader);                              Set.Strings.Add(Str);                         }                     }*/break;  }  
