Implementation smell,Namespace,Class,File,Method,Description
Long Method,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method has 234 lines of code.
Long Method,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The method has 145 lines of code.
Long Method,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,LstSPR2s_Click,The method has 128 lines of code.
Long Method,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The method has 257 lines of code.
Long Method,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The method has 193 lines of code.
Long Method,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The method has 155 lines of code.
Long Method,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The method has 118 lines of code.
Long Method,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The method has 138 lines of code.
Long Method,Iffinator.Flash,StringTable,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,StringTable,The method has 141 lines of code.
Complex Method,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,Cyclomatic complexity of the method is 47
Complex Method,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,LstChunkTypes_SelectedIndexChanged,Cyclomatic complexity of the method is 17
Complex Method,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,LstSPR2s_Click,Cyclomatic complexity of the method is 26
Complex Method,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,BtnPrevFrame_Click,Cyclomatic complexity of the method is 27
Complex Method,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,BtnNextFrame_Click,Cyclomatic complexity of the method is 31
Complex Method,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,Cyclomatic complexity of the method is 8
Complex Method,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,Cyclomatic complexity of the method is 47
Complex Method,Iffinator.Flash,DrawGroup,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,Cyclomatic complexity of the method is 8
Complex Method,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,Cyclomatic complexity of the method is 29
Complex Method,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,Cyclomatic complexity of the method is 8
Complex Method,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,Cyclomatic complexity of the method is 17
Complex Method,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,Cyclomatic complexity of the method is 15
Complex Method,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,Cyclomatic complexity of the method is 18
Complex Method,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,Cyclomatic complexity of the method is 12
Complex Method,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,Cyclomatic complexity of the method is 17
Complex Method,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,Cyclomatic complexity of the method is 24
Complex Method,Iffinator.Flash,StringTable,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,StringTable,Cyclomatic complexity of the method is 23
Complex Method,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,Cyclomatic complexity of the method is 13
Long Parameter List,Iffinator.Flash,DrawGroupSprite,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupSprite.cs,DrawGroupSprite,The method has 5 parameters. Parameters: type' flags' spriteOffset' objectOffset' frame
Long Identifier,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,,The length of the parameter extractImageSpritesToolStripMenuItem is 36.
Long Identifier,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,,The length of the parameter chunkAnalyzerToolStripMenuItem is 30.
Long Statement,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The length of the statement  "            this.extractImageSpritesToolStripMenuItem.Click += new System.EventHandler(this.extractImageSpritesToolStripMenuItem_Click); " is 124.
Long Statement,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The length of the statement  "                        List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll(delegate(KeyValuePair<string' uint> pair) { return pair.Key.CompareTo(kvp.Key) == 0; }); " is 151.
Long Statement,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The length of the statement  "                    List<KeyValuePair<string' uint>> theseChunks = offsets.FindAll(delegate(KeyValuePair<string' uint> pair) { return pair.Key.CompareTo(kvp.Key) == 0; }); " is 151.
Complex Conditional,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The conditional expression  "P.Operand(4) == 0xFFFF && P.Operand(6) == 0xFFFF && P.Operand(8) == 0xFFFF && P.Operand(10) == 0xFFFF"  is complex.
Complex Conditional,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The conditional expression  "StrResource == "SPR#" || StrResource == "SPR2" || StrResource == "rsmp" || StrResource == "PALT" ||                              StrResource == "DGRP" || StrResource == "STR#" || StrResource == "BHAV" || StrResource == "FWAV" ||                              StrResource == "CTSS" || StrResource == "TTAB" || StrResource == "TTAs" || StrResource == "OBJf" ||                              StrResource == "BCON" || StrResource == "TPRP" || StrResource == "TMPL" || StrResource == "TRCN" ||                              StrResource == "Optn" || StrResource == "SLOT" || StrResource == "GLOB" || StrResource == "FBMP" ||                              StrResource == "BMP_" || StrResource == "FCNS""  is complex.
Complex Conditional,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ParseStrings,The conditional expression  "Chunk.Resource == "STR#" || Chunk.Resource == "TTAs" ||                       Chunk.Resource == "CTSS" || Chunk.Resource == "CST""  is complex.
Complex Conditional,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The conditional expression  "m_Version == 5 || m_Version == 7 || m_Version == 8 || m_Version == 11"  is complex.
Magic Number,Iffinator,BHAVEdit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.LstInstructions.Location = new System.Drawing.Point(12' 12);
Magic Number,Iffinator,BHAVEdit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.LstInstructions.Location = new System.Drawing.Point(12' 12);
Magic Number,Iffinator,BHAVEdit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.LstInstructions.Size = new System.Drawing.Size(205' 381);
Magic Number,Iffinator,BHAVEdit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.LstInstructions.Size = new System.Drawing.Size(205' 381);
Magic Number,Iffinator,BHAVEdit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Iffinator,BHAVEdit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Iffinator,BHAVEdit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(468' 402);
Magic Number,Iffinator,BHAVEdit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\BHAVEdit.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(468' 402);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblTSOPath.Location = new System.Drawing.Point(13' 50);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblTSOPath.Location = new System.Drawing.Point(13' 50);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblTSOPath.Size = new System.Drawing.Size(56' 13);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblTSOPath.Size = new System.Drawing.Size(56' 13);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtChunkType.Location = new System.Drawing.Point(16' 179);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtChunkType.Location = new System.Drawing.Point(16' 179);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtChunkType.Size = new System.Drawing.Size(100' 20);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtChunkType.Size = new System.Drawing.Size(100' 20);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.Location = new System.Drawing.Point(13' 163);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.Location = new System.Drawing.Point(13' 163);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.Size = new System.Drawing.Size(91' 13);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.Size = new System.Drawing.Size(91' 13);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblChunkType.TabIndex = 2;
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtTSOPath.Location = new System.Drawing.Point(12' 66);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtTSOPath.Location = new System.Drawing.Point(12' 66);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtTSOPath.Size = new System.Drawing.Size(145' 20);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.TxtTSOPath.Size = new System.Drawing.Size(145' 20);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.Location = new System.Drawing.Point(320' 29);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.Location = new System.Drawing.Point(320' 29);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.Size = new System.Drawing.Size(205' 316);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.Size = new System.Drawing.Size(205' 316);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkTypes.TabIndex = 3;
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.Location = new System.Drawing.Point(541' 29);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.Location = new System.Drawing.Point(541' 29);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.Size = new System.Drawing.Size(220' 199);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.Size = new System.Drawing.Size(220' 199);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LstChunkInfo.TabIndex = 4;
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.Location = new System.Drawing.Point(19' 320);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.Location = new System.Drawing.Point(19' 320);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.Size = new System.Drawing.Size(75' 23);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.Size = new System.Drawing.Size(75' 23);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAnalyze.TabIndex = 5;
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(773' 24);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(773' 24);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.TabIndex = 6;
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.whatIsThisToolStripMenuItem.Size = new System.Drawing.Size(140' 22);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.whatIsThisToolStripMenuItem.Size = new System.Drawing.Size(140' 22);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.Location = new System.Drawing.Point(16' 105);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.Location = new System.Drawing.Point(16' 105);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.Size = new System.Drawing.Size(55' 13);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.Size = new System.Drawing.Size(55' 13);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.LblScanning.TabIndex = 7;
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.Location = new System.Drawing.Point(100' 320);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.Location = new System.Drawing.Point(100' 320);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.Size = new System.Drawing.Size(75' 23);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.Size = new System.Drawing.Size(75' 23);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.BtnAbort.TabIndex = 5;
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(773' 355);
Magic Number,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(773' 355);
Magic Number,Iffinator,Endian,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,Iffinator,Endian,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,Iffinator,Endian,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,Iffinator,Endian,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,Iffinator,FastPixel,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Lock,The following statement contains a magic number: byte[] Bytes = new byte[(m_Width * m_Height) * 4];
Magic Number,Iffinator,FastPixel,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: m_RGBValues[i + 2] = Clr.R;
Magic Number,Iffinator,FastPixel,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,Clear,The following statement contains a magic number: m_RGBValues[i + 3] = Clr.A;
Magic Number,Iffinator,FastPixel,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: int Index = ((Y * m_Width + X) * 4);
Magic Number,Iffinator,FastPixel,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: m_RGBValues[Index + 2] = Clr.R;
Magic Number,Iffinator,FastPixel,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,SetPixel,The following statement contains a magic number: m_RGBValues[Index + 3] = Clr.A;
Magic Number,Iffinator,FastPixel,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,GetPixel,The following statement contains a magic number: int Index = ((Y * m_Width + X) * 4);
Magic Number,Iffinator,FastPixel,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,GetPixel,The following statement contains a magic number: int R = m_RGBValues[Index + 2];
Magic Number,Iffinator,FastPixel,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\FastPixel.cs,GetPixel,The following statement contains a magic number: int A = m_RGBValues[Index + 3];
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(624' 24);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(624' 24);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.openiffToolStripMenuItem.Size = new System.Drawing.Size(192' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.openiffToolStripMenuItem.Size = new System.Drawing.Size(192' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractiffToolStripMenuItem.Size = new System.Drawing.Size(192' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractiffToolStripMenuItem.Size = new System.Drawing.Size(192' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractImageSpritesToolStripMenuItem.Size = new System.Drawing.Size(192' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractImageSpritesToolStripMenuItem.Size = new System.Drawing.Size(192' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size(192' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.exitToolStripMenuItem.Size = new System.Drawing.Size(192' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.analyzeToolStripMenuItem.Size = new System.Drawing.Size(60' 20);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.analyzeToolStripMenuItem.Size = new System.Drawing.Size(60' 20);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.chunkAnalyzerToolStripMenuItem.Size = new System.Drawing.Size(155' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.chunkAnalyzerToolStripMenuItem.Size = new System.Drawing.Size(155' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.helpToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size(116' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size(116' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblNumChunks.Location = new System.Drawing.Point(13' 44);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblNumChunks.Location = new System.Drawing.Point(13' 44);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblNumChunks.Size = new System.Drawing.Size(97' 13);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblNumChunks.Size = new System.Drawing.Size(97' 13);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.Location = new System.Drawing.Point(12' 168);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.Location = new System.Drawing.Point(12' 168);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.Size = new System.Drawing.Size(216' 218);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.Size = new System.Drawing.Size(216' 218);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.PictCurrentFrame.TabIndex = 2;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.Location = new System.Drawing.Point(12' 392);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.Location = new System.Drawing.Point(12' 392);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.Size = new System.Drawing.Size(30' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.Size = new System.Drawing.Size(30' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnPrevFrame.TabIndex = 3;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.Location = new System.Drawing.Point(119' 392);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.Location = new System.Drawing.Point(119' 392);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.Size = new System.Drawing.Size(30' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.Size = new System.Drawing.Size(30' 22);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.BtnNextFrame.TabIndex = 3;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.Location = new System.Drawing.Point(238' 46);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.Location = new System.Drawing.Point(238' 46);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.Size = new System.Drawing.Size(374' 368);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.Size = new System.Drawing.Size(374' 368);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstSPR2s.TabIndex = 4;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.Location = new System.Drawing.Point(174' 76);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.Location = new System.Drawing.Point(174' 76);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.Size = new System.Drawing.Size(58' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.Size = new System.Drawing.Size(58' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSpr2.TabIndex = 6;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.Location = new System.Drawing.Point(173' 122);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.Location = new System.Drawing.Point(173' 122);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.Size = new System.Drawing.Size(59' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.Size = new System.Drawing.Size(59' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiStr.TabIndex = 7;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.Location = new System.Drawing.Point(174' 99);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.Location = new System.Drawing.Point(174' 99);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.Size = new System.Drawing.Size(61' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.Size = new System.Drawing.Size(61' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiDgrp.TabIndex = 8;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.Location = new System.Drawing.Point(173' 145);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.Location = new System.Drawing.Point(173' 145);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.Size = new System.Drawing.Size(59' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.Size = new System.Drawing.Size(59' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiBhavs.TabIndex = 7;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.Location = new System.Drawing.Point(173' 53);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.Location = new System.Drawing.Point(173' 53);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.Size = new System.Drawing.Size(52' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.Size = new System.Drawing.Size(52' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.RdiSPR.TabIndex = 9;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip1.Size = new System.Drawing.Size(61' 4);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.contextMenuStrip1.Size = new System.Drawing.Size(61' 4);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.Location = new System.Drawing.Point(12' 145);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.Location = new System.Drawing.Point(12' 145);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.Size = new System.Drawing.Size(87' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.Size = new System.Drawing.Size(87' 17);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ChkZBuffer.TabIndex = 10;
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(624' 427);
Magic Number,Iffinator,Form1,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(624' 427);
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: byte[] Header = Reader.ReadBytes(12);
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Signature = (ushort)((Header[1] << 8) | Header[0]);
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: Count <= 0 || Count > 253
Magic Number,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following statement contains a magic number: m_Instructions.Add(Reader.ReadBytes(12));
Magic Number,Iffinator.Flash,IFFDecode,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,Operand,The following statement contains a magic number: return (Instruction[i + 1] << 8) | Instruction[i];
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: K < 256
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.Operand(4) == 0xFFFF && P.Operand(6) == 0xFFFF && P.Operand(8) == 0xFFFF && P.Operand(10) == 0xFFFF
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.Operand(4) == 0xFFFF && P.Operand(6) == 0xFFFF && P.Operand(8) == 0xFFFF && P.Operand(10) == 0xFFFF
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.Operand(4) == 0xFFFF && P.Operand(6) == 0xFFFF && P.Operand(8) == 0xFFFF && P.Operand(10) == 0xFFFF
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodeInstruction,The following statement contains a magic number: P.Operand(4) == 0xFFFF && P.Operand(6) == 0xFFFF && P.Operand(8) == 0xFFFF && P.Operand(10) == 0xFFFF
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DecodePrimitive,The following statement contains a magic number: switch (Op)              {                  default:                      DefaultPrimitive(P);                      break;                  case 0:                      P.OutStream.Append("0: sleep ");                      DoExpressionOperation(9' P.Operand(4));                      P.OutStream.Append(" ticks");                      break;                  case 1: //Generic sim call                      int BHAVStr220Len = (BHAVStrings.BHAVString220.Length / BHAVStrings.BHAVString220[0].Length) - 1;                      int T = P.Operand(4);                        if (T < BHAVStr220Len)                          P.OutStream.Append(BHAVStrings.BHAVString220[T]);                      else                          P.OutStream.Append("1: generic sim call " + T);                      break;                  case 2:                      ExpressionPrimitive(P.Instruction);                      break;                  case 3:                      P.OutStream.Append("3: find best interaction");                      break;                  case 4:                      P.OutStream.Append("4: grab stack object");                      break;                  case 5:                      P.OutStream.Append("5: drop stack object");                      break;                  case 6:                      ChangeSuitOrAccessoryPrimitive(P.Instruction);                      break;                  case 7: //Update                      P.OutStream.Append("7: refresh ");                        int BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (P[4] < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[P[4]]);                      else                          P.OutStream.Append("WHO=" + (int)(P[4]));                        P.OutStream.Append(" ");                        int BHAVStr212Len = (BHAVStrings.BHAVString212.Length / BHAVStrings.BHAVString212[0].Length) - 1;                        if (P[6] < BHAVStr212Len)                          P.OutStream.Append(BHAVStrings.BHAVString212[P[6]]);                      else                          P.OutStream.Append("WHAT=" + (int)(P[6]));                      break;                  case 8: //Random                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := random ");                      DoExpressionOperation(P[10]' P.Operand(8));                      break;                  case 9: //Burn                      P.OutStream.Append("9: burn ");                        int BHAVStr231Len = (BHAVStrings.BHAVString231.Length / BHAVStrings.BHAVString231[0].Length) - 1;                        if (P[4] < BHAVStr231Len)                          P.OutStream.Append(BHAVStrings.BHAVString231[P[4]]);                      else                          P.OutStream.Append("WHAT [" + (int)(P[4]) + "]");                      break;                  case 10: //Tutorial                      // STR#238 - situation action descriptions                      P.OutStream.Append("10: tutorial " + ((P[4] == 0) ? "begin" : "end"));                      break;                  case 11: //Distance                      DoExpressionOperation(8' P.Operand(4));                      P.OutStream.Append(" := distance from stack object to ");                        U = P.Operand(8);                        if (P[6] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 12: //Direction to                      DoExpressionOperation(P[6]' P.Operand(4));                      P.OutStream.Append(" := direction from stack object to ");                        U = P.Operand(10);                        if (P[8] == 0)                          P.OutStream.Append("me");                      else if (P[9] == 3 && U == 11)                          P.OutStream.Append("me");                      else                          DoExpressionOperation(P[9]' U);                      break;                  case 13: //Push interaction                      P.OutStream.Append("13: queue ");                      P.OutStream.Append((int)(P.OutStream[4]) + " of ");                      DoExpressionOperation(((P[7] & 2) != 0) ? 25 : 9' P[5]);                        int BHAVString224Len = (BHAVStrings.BHAVString224.Length / BHAVStrings.BHAVString224[0].Length) - 1;                        if (P[6] < BHAVString224Len)                      {                          if (P[6] > 0)                          {                              //cout << " pri=" << BhavStr224[p[6]];                          }                      }                      else                          P.OutStream.Append(" PRI=" + (int)(P[6]));                        if ((P[7] & 1) != 0)                      {                          P.OutStream.Append(" icon=");                          DoExpressionOperation(25' P.Operand(8));                      }                        if ((P[7] & 0x04) != 0) P.OutStream.Append("' continue as current ");                      if ((P[7] & 0x08) != 0) P.OutStream.Append("' use name ");                                            break;                  case 14: //Find the best object for...                      U = P.Operand(4);                      P.OutStream.Append("14: find best object for ");                        int BHAVString201Len = (BHAVStrings.BHAVString201Obj.Length / BHAVStrings.BHAVString201Obj[0].Length) - 1;                        if (U < BHAVString201Len)                          P.OutStream.Append(BHAVStrings.BHAVString201Obj[U]);                      else                          P.OutStream.Append("function " + (int)(U));                        int X = P.Operand(6)'                          Y = P.Operand(8)'                          Z = P.Operand(10);                        if (X == 0 && Y == 0 && Z == 0)                          break;                        P.OutStream.Append("(" + (int)(X) + "' " + (int)(Y) + "' " + (int)(Z) + ")");                        break;                  case 15: //Tree breakpoint                      P.OutStream.Append("15: tree breakpoint");                      U = P.Operand(4);                        if (P[6] != 7 || U == 0)                      {                          P.OutStream.Append(" if ");                          DoExpressionOperation(P[6]' U);                          P.OutStream.Append(" != 0");                      }                      break;                  case 16: //Find location for                      P.OutStream.Append("16: find: ");                        if((P[6] & 2) != 0) P.OutStream.Append("empty ");                        int BHAVStr239Len = (BHAVStrings.BHAVString239.Length / BHAVStrings.BHAVString239[0].Length) - 1;                        if (P[4] < BHAVStr239Len)                          P.OutStream.Append(BHAVStrings.BHAVString239[P[4]]);                      else                          P.OutStream.Append("LOC=" + (int)(P[4]));                        P.OutStream.Append(" loc");                        if ((P[6] & 1) != 0)                      {                          P.OutStream.Append(" start at ");                          DoExpressionOperation(25' P[5]);                      }                        if ((P[6] & 4) != 0) P.OutStream.Append(" user-editable");                      break;                  case 17: //Idle for input                      P.OutStream.Append("17: idle for input ");                      DoExpressionOperation(9' P.Operand(4));                        U = P.Operand(6);                      P.OutStream.Append(" ticks' " + ((U == 0) ? "forbid" : "allow") + " push");                      break;                  case 18: //Remove object instance                      P.OutStream.Append("18: remove ");                      int Who = P.Operand(4);                      BHAVStr153Len = (BHAVStrings.BHAVString153.Length / BHAVStrings.BHAVString153[0].Length) - 1;                        if (Who < BHAVStr153Len)                          P.OutStream.Append(BHAVStrings.BHAVString153[Who]);                      else                          P.OutStream.Append("object[" + Who + "]'s");                        P.OutStream.Append(" instance");                        if ((P[6] & 1) != 0) P.OutStream.Append("' return immediately");                      if ((P[6] & 2) != 0) P.OutStream.Append("' clean up all");                      break;                  case 19: //Make new character                      P.OutStream.Append("19: make new character(");                      DoExpressionOperation(25' P[4]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[5]);                      P.OutStream.Append("'");                      DoExpressionOperation(25' P[6]);                      P.OutStream.Append(")");                      break;                  case 20: //Run functional tree                      T = P.Operand(4);                      P.OutStream.Append("20: run ");                      BHAVString201Len = (BHAVStrings.BHAVString201Run.Length / BHAVStrings.BHAVString201Run[0].Length) - 1;                        if (T < BHAVString201Len)                          P.OutStream.Append("\"" + BHAVStrings.BHAVString201Run[T] + "\"");                      else                          P.OutStream.Append("function " + (int)T);                        T = (short)P.Operand(6);                      if (T != 0) P.OutStream.Append(" with new icon");                      break;              }
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append("(" + P.Operand(4) + "' " + P.Operand(6) + "' " +                  P.Operand(8) + "' " + P.Operand(10) + ")");
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append("(" + P.Operand(4) + "' " + P.Operand(6) + "' " +                  P.Operand(8) + "' " + P.Operand(10) + ")");
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append("(" + P.Operand(4) + "' " + P.Operand(6) + "' " +                  P.Operand(8) + "' " + P.Operand(10) + ")");
Magic Number,Iffinator.Flash,BHAVAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,DefaultPrimitive,The following statement contains a magic number: P.OutStream.Append("(" + P.Operand(4) + "' " + P.Operand(6) + "' " +                  P.Operand(8) + "' " + P.Operand(10) + ")");
Magic Number,Iffinator.Flash,DrawGroup,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: m_Version = Reader.ReadUInt16() - 20000;
Magic Number,Iffinator.Flash,DrawGroup,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: uint Count = (m_Version < 3) ? Reader.ReadUInt16() : Reader.ReadUInt32();
Magic Number,Iffinator.Flash,DrawGroup,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: m_Version < 3
Magic Number,Iffinator.Flash,DrawGroup,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroup.cs,DrawGroup,The following statement contains a magic number: m_Version < 3
Magic Number,Iffinator.Flash,DrawGroupImg,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: m_CompiledBitmap = new Bitmap(136' 384);
Magic Number,Iffinator.Flash,DrawGroupImg,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: m_CompiledBitmap = new Bitmap(136' 384);
Magic Number,Iffinator.Flash,DrawGroupImg,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: int xOffset = m_CompiledBitmap.Width / 2 + Sprite.SpriteOffset.X;
Magic Number,Iffinator.Flash,DrawGroupImg,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\DrawGroupImg.cs,CompileSprites,The following statement contains a magic number: int yOffset = m_CompiledBitmap.Height / 2 + Sprite.SpriteOffset.Y;
Magic Number,Iffinator.Flash,FCNS,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,FCNS,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,FCNS,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FCNS.cs,FCNS,The following statement contains a magic number: byte[] Value = Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,FieldReader,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,ReadBits,The following statement contains a magic number: FieldData.BitBuffer <<= 8;
Magic Number,Iffinator.Flash,FieldReader,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,ReadBits,The following statement contains a magic number: FieldData.BitBufferCount += 8;
Magic Number,Iffinator.Flash,FieldReader,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,DecodeField,The following statement contains a magic number: ReadBits(ref Data' 2' ref Prefix) == 0
Magic Number,Iffinator.Flash,FieldReader,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\FieldReader.cs,DecodeField,The following statement contains a magic number: Width = Data.FieldWidths[FieldType * 4 + Prefix];
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,Iff,The following statement contains a magic number: Chunk.Length = Endian.SwapUInt32(m_Reader.ReadUInt32()) - 76;
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: string Identifier = new string(m_Reader.ReadChars(60)).Replace("\0"' "");
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: m_Reader.BaseStream.Position += 76;
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: string typeCode = new ASCIIEncoding().GetString(m_Reader.ReadBytes(4));
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 13
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < ((numEntries - j) * 9)
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ReadChunks,The following statement contains a magic number: byte[] Buf = m_Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: m_Reader.BaseStream.Position = 64;
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: byte[] TagBytes = m_Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: byte[] bytes = m_Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: m_Reader.BaseStream.Position += (size - 8);
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FuckThisShit,The following statement contains a magic number: m_Reader.BaseStream.Position == m_Reader.BaseStream.Length ||                      (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ToChunk,The following statement contains a magic number: Chunk.Length = Endian.SwapUInt32(m_Reader.ReadUInt32()) - 76;
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,ToChunk,The following statement contains a magic number: m_Reader.BaseStream.Position = offset + 76;
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,GetNameString,The following statement contains a magic number: i < 63
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position = 64;
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: byte[] TagBytes = m_Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: byte[] bytes = m_Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position += (size - 8);
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position == m_Reader.BaseStream.Length ||                      (m_Reader.BaseStream.Length - m_Reader.BaseStream.Position) < 76
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: Chunk.Length = Endian.SwapUInt32(m_Reader.ReadUInt32()) - 76;
Magic Number,Iffinator.Flash,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\Iff.cs,FindPALT,The following statement contains a magic number: m_Reader.BaseStream.Position = KVP.Value + 76;
Magic Number,Iffinator.Flash,IffChunkID,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\IffChunkID.cs,ToChunkID,The following statement contains a magic number: uint C = StrID[2];
Magic Number,Iffinator.Flash,IffChunkID,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\IffChunkID.cs,ToChunkID,The following statement contains a magic number: uint D = StrID[3];
Magic Number,Iffinator.Flash,IffChunkID,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\IffChunkID.cs,ToChunkID,The following statement contains a magic number: return ((A << 24) | (B << 16) | (C << 8) | D);
Magic Number,Iffinator.Flash,IffChunkID,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\IffChunkID.cs,ToChunkID,The following statement contains a magic number: return ((A << 24) | (B << 16) | (C << 8) | D);
Magic Number,Iffinator.Flash,IffChunkID,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\IffChunkID.cs,ToChunkID,The following statement contains a magic number: return ((A << 24) | (B << 16) | (C << 8) | D);
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: (Reader.BaseStream.Length - Reader.BaseStream.Position) == 0 ||                   (Reader.BaseStream.Length - Reader.BaseStream.Position) < 2
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: m_Version == 9 || m_Version == 10
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: m_Version == 9 || m_Version == 10
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following statement contains a magic number: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: byte[] Widths = { 5' 8' 13' 16 };
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: byte[] Widths = { 5' 8' 13' 16 };
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: byte[] Widths = { 5' 8' 13' 16 };
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: byte[] Widths = { 5' 8' 13' 16 };
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: byte Code2 = BArray.Get(2) ? (byte)1 : (byte)0;
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: ArrayList Bits = new ArrayList(BArray.Length - 3);
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: bytes.Count != 8
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetShortBits,The following statement contains a magic number: Bytes.Length < 8
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: byte[] Widths = { 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: byte[] Widths = { 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: byte[] Widths = { 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: byte[] Widths = { 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: byte Code2 = BArray.Get(2) ? (byte)1 : (byte)0;
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: ArrayList Bits = new ArrayList(BArray.Length - 3);
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: bytes.Count != 8
Magic Number,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,GetLongBits,The following statement contains a magic number: Bytes.Length < 8
Magic Number,Iffinator.Flash,OBJD,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\OBJD.cs,OBJD,The following statement contains a magic number: m_Version != 138
Magic Number,Iffinator.Flash,OBJD,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\OBJD.cs,OBJD,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,OBJf,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\OBJf.cs,OBJf,The following statement contains a magic number: Reader.ReadBytes(8);
Magic Number,Iffinator.Flash,OBJf,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\OBJf.cs,OBJf,The following statement contains a magic number: string Header = Encoding.ASCII.GetString(Reader.ReadBytes(4));
Magic Number,Iffinator.Flash,PaletteMap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors = new Color[256];
Magic Number,Iffinator.Flash,PaletteMap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: Reader.BaseStream.Position = 16;
Magic Number,Iffinator.Flash,PaletteMap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: (Reader.BaseStream.Length - Reader.BaseStream.Position) >= 3
Magic Number,Iffinator.Flash,PaletteMap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: i < 256
Magic Number,Iffinator.Flash,PaletteMap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors = new Color[256];
Magic Number,Iffinator.Flash,PaletteMap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: m_Colors[i] = Color.FromArgb(255' 0' 0' 0);
Magic Number,Iffinator.Flash,PaletteMap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\PaletteMap.cs,PaletteMap,The following statement contains a magic number: i < 256
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,GetFrame,The following statement contains a magic number: m_Version != 1001
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: m_Version != 1001
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: m_Version != 1001
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: (Reader.BaseStream.Position == Reader.BaseStream.Length) ||                           (Reader.BaseStream.Position - Reader.BaseStream.Length < 14)
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,SPRParser,The following statement contains a magic number: m_Version == 1001
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,ReadFrame,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand)                  {                      case 0x00: //Start marker; the count byte is ignored.                          break;                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes the                       //size in bytes of the row and pixel data.                      case 0x04:                          RowCount -= 2;                          CurrentColumn = 0;                            while (RowCount > 0)                          {                              PixCommand = Reader.ReadByte();                              PixCount = Reader.ReadByte();                              RowCount -= 2;                                switch (PixCommand)                              {                                  case 1: //Leave the next pixel count pixels as transparent.                                      Transparent = Color.FromArgb(0' 0' 0' 0);                                      for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 2: //Fill the next pixel count pixels with a palette color.                                      //The pixel data is two bytes: the first byte denotes the palette color index' and the                                       //second byte is padding (which is always equal to the first byte but is ignored).                                      Clr = Reader.ReadByte();                                      Reader.ReadByte(); //Padding                                      RowCount -= 2;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 3: //Set the next pixel count pixels to the palette color indices defined by the                                       //pixel data provided directly after this command.                                        byte Padding = (byte)(PixCount % 2);                                        if (Padding != 0)                                          RowCount -= (byte)(PixCount + Padding);                                      else                                          RowCount -= PixCount;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Clr = Reader.ReadByte();                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                          }                            CurrentRow++;                            break;                      case 0x05: //End marker. The count byte is always 0' but may be ignored.                            //Some sprites don't have these' so read them using ReadBytes()' which                          //simply returns an empty array if the stream couldn't be read.                          Reader.ReadBytes(2); //PixCommand and PixCount.                            quit = true;                          break;                      case 0x09: //Leave the next count rows as transparent.                          PixCommand = Reader.ReadByte();                          PixCount = Reader.ReadByte();                            Transparent = Color.FromArgb(0' 0' 0' 0);                            for (int i = 0; i < RowCount; i++)                          {                              for (int j = CurrentColumn; j < Frame.Width; j++)                                  Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                CurrentRow++;                          }                            break;                      case 0x10: //Start marker' equivalent to 0x00; the count byte is ignored.                          break;                  }
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand)                  {                      case 0x00: //Start marker; the count byte is ignored.                          break;                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes the                       //size in bytes of the row and pixel data.                      case 0x04:                          RowCount -= 2;                          CurrentColumn = 0;                            while (RowCount > 0)                          {                              PixCommand = Reader.ReadByte();                              PixCount = Reader.ReadByte();                              RowCount -= 2;                                switch (PixCommand)                              {                                  case 1: //Leave the next pixel count pixels as transparent.                                      Transparent = Color.FromArgb(0' 0' 0' 0);                                      for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 2: //Fill the next pixel count pixels with a palette color.                                      //The pixel data is two bytes: the first byte denotes the palette color index' and the                                       //second byte is padding (which is always equal to the first byte but is ignored).                                      Clr = Reader.ReadByte();                                      Reader.ReadByte(); //Padding                                      RowCount -= 2;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 3: //Set the next pixel count pixels to the palette color indices defined by the                                       //pixel data provided directly after this command.                                        byte Padding = (byte)(PixCount % 2);                                        if (Padding != 0)                                          RowCount -= (byte)(PixCount + Padding);                                      else                                          RowCount -= PixCount;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Clr = Reader.ReadByte();                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                          }                            CurrentRow++;                            break;                      case 0x05: //End marker. The count byte is always 0' but may be ignored.                            //Some sprites don't have these' so read them using ReadBytes()' which                          //simply returns an empty array if the stream couldn't be read.                          Reader.ReadBytes(2); //PixCommand and PixCount.                            quit = true;                          break;                      case 0x09: //Leave the next count rows as transparent.                          PixCommand = Reader.ReadByte();                          PixCount = Reader.ReadByte();                            Transparent = Color.FromArgb(0' 0' 0' 0);                            for (int i = 0; i < RowCount; i++)                          {                              for (int j = CurrentColumn; j < Frame.Width; j++)                                  Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                CurrentRow++;                          }                            break;                      case 0x10: //Start marker' equivalent to 0x00; the count byte is ignored.                          break;                  }
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand)                  {                      case 0x00: //Start marker; the count byte is ignored.                          break;                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes the                       //size in bytes of the row and pixel data.                      case 0x04:                          RowCount -= 2;                          CurrentColumn = 0;                            while (RowCount > 0)                          {                              PixCommand = Reader.ReadByte();                              PixCount = Reader.ReadByte();                              RowCount -= 2;                                switch (PixCommand)                              {                                  case 1: //Leave the next pixel count pixels as transparent.                                      Transparent = Color.FromArgb(0' 0' 0' 0);                                      for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 2: //Fill the next pixel count pixels with a palette color.                                      //The pixel data is two bytes: the first byte denotes the palette color index' and the                                       //second byte is padding (which is always equal to the first byte but is ignored).                                      Clr = Reader.ReadByte();                                      Reader.ReadByte(); //Padding                                      RowCount -= 2;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 3: //Set the next pixel count pixels to the palette color indices defined by the                                       //pixel data provided directly after this command.                                        byte Padding = (byte)(PixCount % 2);                                        if (Padding != 0)                                          RowCount -= (byte)(PixCount + Padding);                                      else                                          RowCount -= PixCount;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Clr = Reader.ReadByte();                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                          }                            CurrentRow++;                            break;                      case 0x05: //End marker. The count byte is always 0' but may be ignored.                            //Some sprites don't have these' so read them using ReadBytes()' which                          //simply returns an empty array if the stream couldn't be read.                          Reader.ReadBytes(2); //PixCommand and PixCount.                            quit = true;                          break;                      case 0x09: //Leave the next count rows as transparent.                          PixCommand = Reader.ReadByte();                          PixCount = Reader.ReadByte();                            Transparent = Color.FromArgb(0' 0' 0' 0);                            for (int i = 0; i < RowCount; i++)                          {                              for (int j = CurrentColumn; j < Frame.Width; j++)                                  Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                CurrentRow++;                          }                            break;                      case 0x10: //Start marker' equivalent to 0x00; the count byte is ignored.                          break;                  }
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand)                  {                      case 0x00: //Start marker; the count byte is ignored.                          break;                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes the                       //size in bytes of the row and pixel data.                      case 0x04:                          RowCount -= 2;                          CurrentColumn = 0;                            while (RowCount > 0)                          {                              PixCommand = Reader.ReadByte();                              PixCount = Reader.ReadByte();                              RowCount -= 2;                                switch (PixCommand)                              {                                  case 1: //Leave the next pixel count pixels as transparent.                                      Transparent = Color.FromArgb(0' 0' 0' 0);                                      for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 2: //Fill the next pixel count pixels with a palette color.                                      //The pixel data is two bytes: the first byte denotes the palette color index' and the                                       //second byte is padding (which is always equal to the first byte but is ignored).                                      Clr = Reader.ReadByte();                                      Reader.ReadByte(); //Padding                                      RowCount -= 2;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 3: //Set the next pixel count pixels to the palette color indices defined by the                                       //pixel data provided directly after this command.                                        byte Padding = (byte)(PixCount % 2);                                        if (Padding != 0)                                          RowCount -= (byte)(PixCount + Padding);                                      else                                          RowCount -= PixCount;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Clr = Reader.ReadByte();                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                          }                            CurrentRow++;                            break;                      case 0x05: //End marker. The count byte is always 0' but may be ignored.                            //Some sprites don't have these' so read them using ReadBytes()' which                          //simply returns an empty array if the stream couldn't be read.                          Reader.ReadBytes(2); //PixCommand and PixCount.                            quit = true;                          break;                      case 0x09: //Leave the next count rows as transparent.                          PixCommand = Reader.ReadByte();                          PixCount = Reader.ReadByte();                            Transparent = Color.FromArgb(0' 0' 0' 0);                            for (int i = 0; i < RowCount; i++)                          {                              for (int j = CurrentColumn; j < Frame.Width; j++)                                  Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                CurrentRow++;                          }                            break;                      case 0x10: //Start marker' equivalent to 0x00; the count byte is ignored.                          break;                  }
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand)                  {                      case 0x00: //Start marker; the count byte is ignored.                          break;                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes the                       //size in bytes of the row and pixel data.                      case 0x04:                          RowCount -= 2;                          CurrentColumn = 0;                            while (RowCount > 0)                          {                              PixCommand = Reader.ReadByte();                              PixCount = Reader.ReadByte();                              RowCount -= 2;                                switch (PixCommand)                              {                                  case 1: //Leave the next pixel count pixels as transparent.                                      Transparent = Color.FromArgb(0' 0' 0' 0);                                      for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 2: //Fill the next pixel count pixels with a palette color.                                      //The pixel data is two bytes: the first byte denotes the palette color index' and the                                       //second byte is padding (which is always equal to the first byte but is ignored).                                      Clr = Reader.ReadByte();                                      Reader.ReadByte(); //Padding                                      RowCount -= 2;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 3: //Set the next pixel count pixels to the palette color indices defined by the                                       //pixel data provided directly after this command.                                        byte Padding = (byte)(PixCount % 2);                                        if (Padding != 0)                                          RowCount -= (byte)(PixCount + Padding);                                      else                                          RowCount -= PixCount;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Clr = Reader.ReadByte();                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                          }                            CurrentRow++;                            break;                      case 0x05: //End marker. The count byte is always 0' but may be ignored.                            //Some sprites don't have these' so read them using ReadBytes()' which                          //simply returns an empty array if the stream couldn't be read.                          Reader.ReadBytes(2); //PixCommand and PixCount.                            quit = true;                          break;                      case 0x09: //Leave the next count rows as transparent.                          PixCommand = Reader.ReadByte();                          PixCount = Reader.ReadByte();                            Transparent = Color.FromArgb(0' 0' 0' 0);                            for (int i = 0; i < RowCount; i++)                          {                              for (int j = CurrentColumn; j < Frame.Width; j++)                                  Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                CurrentRow++;                          }                            break;                      case 0x10: //Start marker' equivalent to 0x00; the count byte is ignored.                          break;                  }
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand)                  {                      case 0x00: //Start marker; the count byte is ignored.                          break;                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes the                       //size in bytes of the row and pixel data.                      case 0x04:                          RowCount -= 2;                          CurrentColumn = 0;                            while (RowCount > 0)                          {                              PixCommand = Reader.ReadByte();                              PixCount = Reader.ReadByte();                              RowCount -= 2;                                switch (PixCommand)                              {                                  case 1: //Leave the next pixel count pixels as transparent.                                      Transparent = Color.FromArgb(0' 0' 0' 0);                                      for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 2: //Fill the next pixel count pixels with a palette color.                                      //The pixel data is two bytes: the first byte denotes the palette color index' and the                                       //second byte is padding (which is always equal to the first byte but is ignored).                                      Clr = Reader.ReadByte();                                      Reader.ReadByte(); //Padding                                      RowCount -= 2;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 3: //Set the next pixel count pixels to the palette color indices defined by the                                       //pixel data provided directly after this command.                                        byte Padding = (byte)(PixCount % 2);                                        if (Padding != 0)                                          RowCount -= (byte)(PixCount + Padding);                                      else                                          RowCount -= PixCount;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Clr = Reader.ReadByte();                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                          }                            CurrentRow++;                            break;                      case 0x05: //End marker. The count byte is always 0' but may be ignored.                            //Some sprites don't have these' so read them using ReadBytes()' which                          //simply returns an empty array if the stream couldn't be read.                          Reader.ReadBytes(2); //PixCommand and PixCount.                            quit = true;                          break;                      case 0x09: //Leave the next count rows as transparent.                          PixCommand = Reader.ReadByte();                          PixCount = Reader.ReadByte();                            Transparent = Color.FromArgb(0' 0' 0' 0);                            for (int i = 0; i < RowCount; i++)                          {                              for (int j = CurrentColumn; j < Frame.Width; j++)                                  Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                CurrentRow++;                          }                            break;                      case 0x10: //Start marker' equivalent to 0x00; the count byte is ignored.                          break;                  }
Magic Number,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowCommand)                  {                      case 0x00: //Start marker; the count byte is ignored.                          break;                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes the                       //size in bytes of the row and pixel data.                      case 0x04:                          RowCount -= 2;                          CurrentColumn = 0;                            while (RowCount > 0)                          {                              PixCommand = Reader.ReadByte();                              PixCount = Reader.ReadByte();                              RowCount -= 2;                                switch (PixCommand)                              {                                  case 1: //Leave the next pixel count pixels as transparent.                                      Transparent = Color.FromArgb(0' 0' 0' 0);                                      for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 2: //Fill the next pixel count pixels with a palette color.                                      //The pixel data is two bytes: the first byte denotes the palette color index' and the                                       //second byte is padding (which is always equal to the first byte but is ignored).                                      Clr = Reader.ReadByte();                                      Reader.ReadByte(); //Padding                                      RowCount -= 2;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 3: //Set the next pixel count pixels to the palette color indices defined by the                                       //pixel data provided directly after this command.                                        byte Padding = (byte)(PixCount % 2);                                        if (Padding != 0)                                          RowCount -= (byte)(PixCount + Padding);                                      else                                          RowCount -= PixCount;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Clr = Reader.ReadByte();                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                          }                            CurrentRow++;                            break;                      case 0x05: //End marker. The count byte is always 0' but may be ignored.                            //Some sprites don't have these' so read them using ReadBytes()' which                          //simply returns an empty array if the stream couldn't be read.                          Reader.ReadBytes(2); //PixCommand and PixCount.                            quit = true;                          break;                      case 0x09: //Leave the next count rows as transparent.                          PixCommand = Reader.ReadByte();                          PixCount = Reader.ReadByte();                            Transparent = Color.FromArgb(0' 0' 0' 0);                            for (int i = 0; i < RowCount; i++)                          {                              for (int j = CurrentColumn; j < Frame.Width; j++)                                  Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                CurrentRow++;                          }                            break;                      case 0x10: //Start marker' equivalent to 0x00; the count byte is ignored.                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,GetFrame,The following statement contains a magic number: m_Version == 1000
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: m_Version == 1000
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: m_Version == 1001
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: m_Version == 1000
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,SPR2Parser,The following statement contains a magic number: m_Version == 1001
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame,The following statement contains a magic number: switch (rowHeader[0])                      {                          case 0:                              column = 0;                              numCodesTillNewline = rowHeader[1];                              for (int bytesRead = 0; bytesRead < numCodesTillNewline - 2; bytesRead += 2)                              {                                  int[] rowHeader2 = GetDecryptedValues(Reader.ReadUInt16());                                  try                                  {                                      switch (rowHeader2[0])                                      {                                          case 1:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead += 2;                                              }                                              break;                                          case 2:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  int Z = Reader.ReadByte();                                                    byte b = Reader.ReadByte();                                                  Color clr = m_PMap.GetColorAtIndex(b);                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' Color.FromArgb(Reader.ReadByte()' clr));                                                  bytesRead += 3;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          case 3:                                              column += rowHeader2[1];                                              break;                                          case 6:                                              for (int i = 0; i < rowHeader2[1]; i++)                                              {                                                  byte b = Reader.ReadByte();                                                  Frame.BitmapData.SetPixel(new Point(column++' row)' m_PMap.GetColorAtIndex(b));                                                  bytesRead++;                                              }                                              if (Reader.BaseStream.Position % 2 == 1) { Reader.ReadByte(); bytesRead++; }                                              break;                                          default:                                              break;                                      }                                  }                                  catch (Exception e)                                  {                                      Log.LogThis(String.Format("Error reading code {0} ({1}). Last code read was {2}."'                                          rowHeader2[0]' e.Message' lastType)' eloglevel.error);                                  }                                  lastType = rowHeader2[0];                              }                              row++;                              break;                          case 4:                              for (int i = 0; i < rowHeader[1]; i++)                              {                                  row++;                                  column = 0;                              }                              break;                          case 5:                              quit = true;                              break;                          default:                              Log.LogThis("Error reading code " + lastType + '!'' eloglevel.error);                              break;                      }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following statement contains a magic number: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,ExportToBitmaps,The following statement contains a magic number: m_Version == 1001
Magic Number,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,GetDecryptedValues,The following statement contains a magic number: return new int[] {(P>>13)'    // Code                                ((P&0x1FFF))};
Magic Number,Iffinator.Flash,StringTable,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,StringTable,The following statement contains a magic number: byte[] FormatCodeBuf = Reader.ReadBytes(2);
Magic Number,Iffinator.Flash,StringTable,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,ReadZeroString,The following statement contains a magic number: char[] Chrs = new char[2];
Magic Number,Iffinator.Flash,StringTable,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,ReadZeroString,The following statement contains a magic number: Chrs = Reader.ReadChars(2);
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] { 5' 8' 13' 16' 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] { 5' 8' 13' 16' 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] { 5' 8' 13' 16' 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] { 5' 8' 13' 16' 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] { 5' 8' 13' 16' 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] { 5' 8' 13' 16' 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] { 5' 8' 13' 16' 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_FEncodingData.FieldWidths = new byte[] { 5' 8' 13' 16' 6' 11' 21' 32 };
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_Version == 9 || m_Version == 10
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_Version == 9 || m_Version == 10
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_Version == 10
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_Version == 9 || m_Version == 10
Magic Number,Iffinator.Flash,TTAB,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\TTAB.cs,TTAB,The following statement contains a magic number: m_Version == 9 || m_Version == 10
Duplicate Code,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 83)' (99' 125)' (243' 269)' (201' 227))
Duplicate Code,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 85)' (201' 229)' (99' 127)' (243' 271))
Duplicate Code,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method contains a code clone-set at the following line numbers (starting from the method definition): ((91' 117)' (193' 219)' (235' 261))
Duplicate Code,Iffinator,ChunkAnalyzer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\ChunkAnalyzer.cs,ScanIFFs,The method contains a code clone-set at the following line numbers (starting from the method definition): ((189' 211)' (231' 253))
Missing Default,Iffinator.Flash,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\BHAV.cs,BHAV,The following switch statement is missing a default case: switch (m_Signature)              {                  case 0x8000: case 0x8001:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Locals = 0; //No locals in code; added in 8002?                      m_Params = 4; //I can't find this in header; always 4?                      break;                  case 0x8002:                      m_HeaderLength = 12;                        Count = (Header[3] << 8) | Header[4];                      m_Type = Header[5];                      m_Params = Header[6];                      m_Locals = (ushort)((Header[7] << 8) | Header[8]);                      m_Flags = (ushort)((Header[9] << 8) | Header[10]);                      //Byte 11 and 12 are set to 0 in this version' we have no use for them.                      break;                  case 0x8003:                      m_HeaderLength = 13;                        byte LastHeaderByte = Reader.ReadByte();                      Count = (((((LastHeaderByte << 8) | Header[11]) << 8) | Header[10]) << 8) | Header[9];                        m_Type = Header[3];                      m_Params = Header[4];                      m_Locals = Header[5];                      //Byte number 6 and 7 are unknown in this version' we have no use for them.                      m_Flags = (ushort)((Header[8] << 8) | Header[9]);                      break;              }
Missing Default,Iffinator.Flash,InteractionList,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\InteractionList.cs,InteractionList,The following switch statement is missing a default case: switch (m_Version)              {                  case 2:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Reader.ReadInt16(); //0xA3A3 (skip)                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 3:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt16();                          Interaction.Flags = Reader.ReadInt16();                          Reader.ReadInt32(); //4-byte float' no idea what it is used for.                            m_Interactions.Add(Interaction);                      }                        break;                  case 5:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 7:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 8:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            Interaction.ActionFunction = Reader.ReadInt16();                          Interaction.GuardFunction = Reader.ReadInt16();                          Interaction.MotiveEntries = Reader.ReadInt32();                          Interaction.Flags = Reader.ReadInt32();                          Interaction.StrTableIndex = Reader.ReadInt32();                          Interaction.AttenuationCode = Reader.ReadInt32();                          Interaction.AttenuationValue = Reader.ReadInt32();                          Interaction.Autonomy = Reader.ReadInt32();                          Interaction.JoinIndex = Reader.ReadInt32();                            m_Interactions.Add(Interaction);                      }                        break;                  case 9:                      for (int i = 0; i < m_NumInteractions; i++)                      {                          TTABCore Interaction = new TTABCore();                            BitArray BArray = new BitArray(Reader.ReadBytes(2));                          Interaction.ActionFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.GuardFunction = (short)GetShortBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.MotiveEntries = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Flags = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.StrTableIndex = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationCode = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.AttenuationValue = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.Autonomy = (int)GetLongBits(BArray);                            BArray = new BitArray(Reader.ReadBytes(4));                          Interaction.JoinIndex = (int)GetLongBits(BArray);                            m_Interactions.Add(Interaction);                      }                        break;              }
Missing Default,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (RowCommand)                  {                      case 0x00: //Start marker; the count byte is ignored.                          break;                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes the                       //size in bytes of the row and pixel data.                      case 0x04:                          RowCount -= 2;                          CurrentColumn = 0;                            while (RowCount > 0)                          {                              PixCommand = Reader.ReadByte();                              PixCount = Reader.ReadByte();                              RowCount -= 2;                                switch (PixCommand)                              {                                  case 1: //Leave the next pixel count pixels as transparent.                                      Transparent = Color.FromArgb(0' 0' 0' 0);                                      for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 2: //Fill the next pixel count pixels with a palette color.                                      //The pixel data is two bytes: the first byte denotes the palette color index' and the                                       //second byte is padding (which is always equal to the first byte but is ignored).                                      Clr = Reader.ReadByte();                                      Reader.ReadByte(); //Padding                                      RowCount -= 2;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 3: //Set the next pixel count pixels to the palette color indices defined by the                                       //pixel data provided directly after this command.                                        byte Padding = (byte)(PixCount % 2);                                        if (Padding != 0)                                          RowCount -= (byte)(PixCount + Padding);                                      else                                          RowCount -= PixCount;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Clr = Reader.ReadByte();                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                          }                            CurrentRow++;                            break;                      case 0x05: //End marker. The count byte is always 0' but may be ignored.                            //Some sprites don't have these' so read them using ReadBytes()' which                          //simply returns an empty array if the stream couldn't be read.                          Reader.ReadBytes(2); //PixCommand and PixCount.                            quit = true;                          break;                      case 0x09: //Leave the next count rows as transparent.                          PixCommand = Reader.ReadByte();                          PixCount = Reader.ReadByte();                            Transparent = Color.FromArgb(0' 0' 0' 0);                            for (int i = 0; i < RowCount; i++)                          {                              for (int j = CurrentColumn; j < Frame.Width; j++)                                  Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                CurrentRow++;                          }                            break;                      case 0x10: //Start marker' equivalent to 0x00; the count byte is ignored.                          break;                  }
Missing Default,Iffinator.Flash,SPRParser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPRParser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (PixCommand)                              {                                  case 1: //Leave the next pixel count pixels as transparent.                                      Transparent = Color.FromArgb(0' 0' 0' 0);                                      for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)' Transparent);                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 2: //Fill the next pixel count pixels with a palette color.                                      //The pixel data is two bytes: the first byte denotes the palette color index' and the                                       //second byte is padding (which is always equal to the first byte but is ignored).                                      Clr = Reader.ReadByte();                                      Reader.ReadByte(); //Padding                                      RowCount -= 2;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        break;                                  case 3: //Set the next pixel count pixels to the palette color indices defined by the                                       //pixel data provided directly after this command.                                        byte Padding = (byte)(PixCount % 2);                                        if (Padding != 0)                                          RowCount -= (byte)(PixCount + Padding);                                      else                                          RowCount -= PixCount;                                        for (int j = CurrentColumn; j < (CurrentColumn + PixCount); j++)                                      {                                          Clr = Reader.ReadByte();                                          Frame.BitmapData.SetPixel(new Point(j' CurrentRow)'                                              m_PMap.GetColorAtIndex(Clr));                                      }                                        CurrentColumn += PixCount;                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }
Missing Default,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (RowHeader[0])                  {                      case 0: //Fill this row with pixel data that directly follows; the count byte of the row                               //command denotes the size in bytes of the row's command/count bytes together                               //with the supplied pixel data.                          int RowCount = RowHeader[1];                          RowCount -= 2; //Row command + count bytes.                            while (RowCount > 0)                          {                              int[] PixelHeader = GetDecryptedValues(Reader.ReadUInt16());                              RowCount -= 2;                                int PixelCount = PixelHeader[1];                                switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }                                if (Reader.BaseStream.Position == Reader.BaseStream.Length)                                  break;                          }                            CurrentRow++;                          CurrentColumn = 0;                             break;                      case 4: //Leave the next count rows in the color sprite filled with the transparent color'                               //in the z-buffer sprite filled with 255' and in the alpha sprite filled with 0.                          for (int i = 0; i < RowHeader[1]; i++)                          {                              for (int j = 0; j < Frame.Width; j++)                              {                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                       Color.FromArgb(0' 0' 0' 0));                                    if (Frame.HasZBuffer)                                  {                                      Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                          Color.FromArgb(255' 255' 255' 255));                                  }                                    CurrentColumn++;                              }                                CurrentColumn = 0;                              CurrentRow++;                          }                            CurrentColumn = 0;                            break;                      case 5: //Sprite end marker; the count byte is always 0' but may be ignored.                          Quit = true;                          break;                  }
Missing Default,Iffinator.Flash,SPR2Parser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\SPR2Parser.cs,DecompressFrame2,The following switch statement is missing a default case: switch (PixelHeader[0])                              {                                  case 1: //Set the next pixel count pixels in the z-buffer and color sprites to the                                           //values defined by the pixel data provided directly after this command.                                      RowCount -= PixelCount * 2;                                        while (PixelCount > 0)                                      {                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(Reader.ReadByte()' 0' 0' 0));                                            Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 2: //Set the next pixel count pixels in the z-buffer' color' and alpha                                           //sprites to the values defined by the pixel data provided directly after                                           //this command.                                      Padding = PixelCount % 2;                                      RowCount -= (PixelCount * 3) + Padding;                                        while (PixelCount > 0)                                      {                                          ZClr = Color.FromArgb(Reader.ReadByte());                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                            //Read the alpha.                                          Clr = Color.FromArgb(Reader.ReadByte()' Clr);                                          ZClr = Color.FromArgb(Clr.A' ZClr);                                            Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)' ZClr);                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                                  case 3: //Leave the next pixel count pixels in the color sprite filled with the                                           //transparent color' in the z-buffer sprite filled with 255' and in the                                           //alpha sprite filled with 0. This pixel command has no pixel data.                                      while (PixelCount > 0)                                      {                                          //This is completely transparent regardless of whether the frame                                          //supports alpha.                                          Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                               Color.FromArgb(0' 0' 0' 0));                                            if(Frame.HasZBuffer)                                              Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                  Color.FromArgb(255' 255' 255' 255));                                            PixelCount--;                                          CurrentColumn++;                                      }                                        break;                                  case 6: //Set the next pixel count pixels in the color sprite to the palette color                                           //indices defined by the pixel data provided directly after this command.                                      Padding = PixelCount % 2;                                      RowCount -= PixelCount + Padding;                                        while (PixelCount > 0)                                      {                                          Clr = m_PMap.GetColorAtIndex(Reader.ReadByte());                                          if (Clr != Frame.TransparentPixel)                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)' Clr);                                          else                                              Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                   Color.FromArgb(0' 0' 0' 0));                                            if (Frame.HasZBuffer)                                          {                                              if (Clr != Frame.TransparentPixel)                                                  Frame.ZBuffer.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 1' 1' 1));                                              else                                                  Frame.BitmapData.SetPixel(new Point(CurrentColumn' CurrentRow)'                                                       Color.FromArgb(255' 255' 255' 255));                                          }                                            PixelCount--;                                          CurrentColumn++;                                      }                                        if (Padding != 0)                                          Reader.ReadByte();                                        break;                              }
Missing Default,Iffinator.Flash,StringTable,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Iffinator\Iffinator\Flash\StringTable.cs,StringTable,The following switch statement is missing a default case: switch (m_FormatCode)              {                  case 0:                      //Some tables are empty... LITERALLY!                      if (Reader.BaseStream.Position < Reader.BaseStream.Length)                      {                          m_NumEntries = Reader.ReadUInt16();                            for (int i = 0; i < m_NumEntries; i++)                          {                              StringTableString Str = new StringTableString();                                Str.Str = ReadPascalString(Reader);                                m_Strings.Add(Str);                          }                      }                        break;                  case 0xFFFF:                      m_NumEntries = Reader.ReadUInt16();                        for (int i = 0; i < m_NumEntries; i++)                      {                          StringTableString Str = new StringTableString();                            char C;                          StringBuilder SB = new StringBuilder();                            while (true)                          {                              C = Reader.ReadChar();                              SB.Append(C);                                if (C == '\0')                                  break;                          }                            Str.Str = SB.ToString();                          m_Strings.Add(Str);                      }                        break;                  case 0xFEFF:                      m_NumEntries = Reader.ReadUInt16();                        for (int i = 0; i < m_NumEntries; i++)                      {                          StringTableString Str = new StringTableString();                            char C;                          StringBuilder SB = new StringBuilder();                            //String                          while (true)                          {                              C = Reader.ReadChar();                              SB.Append(C);                                if (C == '\0')                                  break;                          }                            Str.Str = SB.ToString();                          m_Strings.Add(Str);                          SB = new StringBuilder();                            //Comment                          while (true)                          {                              C = Reader.ReadChar();                              SB.Append(C);                                if (C == '\0')                                  break;                          }                      }                        break;                  case 0xFDFF:                      m_NumEntries = Reader.ReadUInt16();                        for (int i = 0; i < m_NumEntries; i++)                      {                          StringTableString Str = new StringTableString();                          Str.LanguageCode = Reader.ReadByte();                            char C;                          StringBuilder SB = new StringBuilder();                            while (true)                          {                              C = (char)Reader.ReadByte();                                if (C == '\0')                                  break;                                SB.Append(C);                          }                            Str.Str = SB.ToString();                            C = new char();                          SB = new StringBuilder();                            while (true)                          {                              C = (char)Reader.ReadByte();                                if (C == '\0')                                  break;                                SB.Append(C);                          }                            Str.Str2 = SB.ToString();                              m_Strings.Add(Str);                      }                        break;                    case 0xFCFF: //Only found in TSO-files!                      m_NumSets = Reader.ReadByte();                        //if (!m_IsCTSS)                      //{                      if (m_NumSets >= 1)                      {                          for (int i = 0; i < m_NumSets; i++)                          {                              StringSet Set = new StringSet();                                Set.NumEntries = Reader.ReadInt16();                                for (int j = 0; j < Set.NumEntries; j++)                              {                                  // string code' then two specially-counted strings                                  // for some reason' the language code is one below the                                  // documented values.  we adjust this here' which                                  // unfortunately makes non-translated strings strange.                                  StringTableString Str = new StringTableString();                                  Str.LanguageCode = (byte)(Reader.ReadByte() + 1);                                    Str.Str = ReadPascalString1(Reader);                                  Str.Str2 = ReadPascalString1(Reader);                                    Set.Strings.Add(Str);                              }                                m_StringSets.Add(Set);                          }                      }                      /*}                      else                      {                          StringSet Set = new StringSet();                            for (int i = 0; i < 2; i++)                          {                              StringTableString Str = new StringTableString();                              Str.LanguageCode = (byte)(Reader.ReadByte() + 1);                                Str.Str = ReadZeroString(Reader);                              Reader.ReadByte();                              Str.Str2 = ReadZeroString(Reader);                                Set.Strings.Add(Str);                          }                      }*/                        break;              }
