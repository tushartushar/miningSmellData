Implementation smell,Namespace,Class,File,Method,Description
Long Method,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleChallengeResponse,The method has 100 lines of code.
Complex Method,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Logger_OnMessageLogged,Cyclomatic complexity of the method is 9
Complex Method,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Logger_OnMessageLogged,Cyclomatic complexity of the method is 9
Complex Method,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Logger_OnMessageLogged,Cyclomatic complexity of the method is 9
Complex Method,TSO_LoginServer.Network,CityServerPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\CityServerPacketHandlers.cs,HandlePlayerOnlineResponse,Cyclomatic complexity of the method is 14
Complex Method,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleChallengeResponse,Cyclomatic complexity of the method is 12
Complex Method,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,Cyclomatic complexity of the method is 24
Long Statement,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The length of the statement  "	ProtocolAbstractionLibraryD.Logger.OnMessageLogged += new ProtocolAbstractionLibraryD.MessageLoggedDelegate (Logger_OnMessageLogged); " is 133.
Long Statement,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The length of the statement  "	PacketHandlers.Register ((byte)PacketType.LOGIN_REQUEST' false' 0' new OnPacketReceive (LoginPacketHandlers.HandleLoginRequest)); " is 129.
Long Statement,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The length of the statement  "	PacketHandlers.Register ((byte)PacketType.CHALLENGE_RESPONSE' true' 0' new OnPacketReceive (LoginPacketHandlers.HandleChallengeResponse)); " is 138.
Long Statement,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The length of the statement  "	PacketHandlers.Register ((byte)PacketType.CHARACTER_LIST' true' 0' new OnPacketReceive (LoginPacketHandlers.HandleCharacterInfoRequest)); " is 137.
Long Statement,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The length of the statement  "	PacketHandlers.Register ((byte)PacketType.CITY_LIST' true' 0' new OnPacketReceive (LoginPacketHandlers.HandleCityInfoRequest)); " is 127.
Long Statement,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The length of the statement  "	PacketHandlers.Register ((byte)PacketType.CHARACTER_CREATE' true' 0' new OnPacketReceive (LoginPacketHandlers.HandleCharacterCreate)); " is 134.
Long Statement,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The length of the statement  "	PacketHandlers.Register ((byte)PacketType.REQUEST_CITY_TOKEN' true' 0' new OnPacketReceive (LoginPacketHandlers.HandleCityTokenRequest)); " is 137.
Long Statement,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The length of the statement  "	PacketHandlers.Register ((byte)PacketType.RETIRE_CHARACTER' true' 0' new OnPacketReceive (LoginPacketHandlers.HandleCharacterRetirement)); " is 138.
Long Statement,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleLoginRequest,The length of the statement  "		string ClientVersion = Version1.ToString () + "." + Version2.ToString () + "." + Version3.ToString () + "." + Version4.ToString (); " is 131.
Long Statement,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleLoginRequest,The length of the statement  "		byte[] EncryptedData = StaticStaticDiffieHellman.Encrypt (NetworkFacade.ServerKey' System.Security.Cryptography.ECDiffieHellmanCngPublicKey.FromByteArray (Enc.PublicKey' System.Security.Cryptography.CngKeyBlobFormat.EccPublicBlob)' Enc.NOnce' StreamToEncrypt.ToArray ()); " is 271.
Long Statement,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleLoginRequest,The length of the statement  "		EncryptedPacket.WriteUInt16 ((ushort)(PacketHeaders.UNENCRYPTED + (1 + NetworkFacade.ServerPublicKey.Length) + (1 + EncryptedData.Length))); " is 140.
Long Statement,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleChallengeResponse,The length of the statement  "		if (AccountName == string.Empty || AccountName.ToLower ().Equals ("username") || AccountName.ToLower ().Contains ("username")) { " is 128.
Long Statement,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The length of the statement  "				ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (Char.GUID.ToString ().Length + 1) + (Token.ToString ().Length + 1)); " is 171.
Long Statement,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityTokenRequest,The length of the statement  "		ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (CharGUID.ToString ().Length + 1) + (Token.ToString ().Length + 1)); " is 170.
Magic Number,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The following statement contains a magic number: NetworkFacade.CServerListener.Initialize (new IPEndPoint (IPAddress.Parse ("127.0.0.1")' 2108));  
Magic Number,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The following statement contains a magic number: while (true) {  	Thread.Sleep (1000);  }  
Magic Number,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Main,The following statement contains a magic number: Thread.Sleep (1000);  
Magic Number,TSO_LoginServer.Network,CityServerListener,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\CityServerListener.cs,Initialize,The following statement contains a magic number: try {  	m_ListenerSock.Bind (LocalEP);  	m_ListenerSock.Listen (10000);  	Logger.LogDebug ("Started listening on: " + LocalEP.Address.ToString () + ":" + LocalEP.Port + "\r\n");  } catch (SocketException E) {  	Logger.LogWarning ("Winsock error caused by call to Socket.Bind(): \n" + E.ToString () + "\r\n");  }  
Magic Number,TSO_LoginServer.Network,CityServerListener,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\CityServerListener.cs,Initialize,The following statement contains a magic number: m_ListenerSock.Listen (10000);  
Magic Number,TSO_LoginServer.Network,CityServerListener,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\CityServerListener.cs,OnAccept,The following statement contains a magic number: if (AcceptedSocket != null) {  	Logger.LogDebug ("\nNew cityserver connected!\r\n");  	//Let sockets linger for 5 seconds after they're closed' in an attempt to make sure all  	//pending data is sent!  	AcceptedSocket.LingerState = new LingerOption (true' 5);  	NetworkClient Client = new NetworkClient (AcceptedSocket' this' EncryptionMode.NoEncryption);  	PotentialLogins.Add (Client);  }  
Magic Number,TSO_LoginServer.Network,CityServerListener,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\CityServerListener.cs,OnAccept,The following statement contains a magic number: AcceptedSocket.LingerState = new LingerOption (true' 5);  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleLoginRequest,The following statement contains a magic number: try {  	Logger.LogInfo ("Received LoginRequest!\r\n");  	byte Version1 = (byte)P.ReadByte ();  	byte Version2 = (byte)P.ReadByte ();  	byte Version3 = (byte)P.ReadByte ();  	byte Version4 = (byte)P.ReadByte ();  	string ClientVersion = Version1.ToString () + "." + Version2.ToString () + "." + Version3.ToString () + "." + Version4.ToString ();  	if (ClientVersion != GlobalSettings.Default.ClientVersion) {  		PacketStream OutPacket = new PacketStream ((byte)PacketType.INVALID_VERSION' 2);  		OutPacket.WriteHeader ();  		OutPacket.WriteByte (0x01);  		Client.Send (OutPacket.ToArray ());  		Logger.LogInfo ("Bad version - sent SInvalidVersion!\r\n");  		Client.Disconnect ();  		return;  	}  	PacketStream EncryptedPacket = new PacketStream ((byte)PacketType.LOGIN_NOTIFY' 0);  	EncryptedPacket.WriteHeader ();  	AESEncryptor Enc = (AESEncryptor)Client.ClientEncryptor;  	if (Enc == null)  		Enc = new AESEncryptor ("");  	Enc.PublicKey = P.ReadBytes ((P.ReadByte ()));  	Enc.NOnce = P.ReadBytes ((P.ReadByte ()));  	Enc.PrivateKey = NetworkFacade.ServerKey;  	Client.ClientEncryptor = Enc;  	MemoryStream StreamToEncrypt = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (StreamToEncrypt);  	Writer.Write (Enc.Challenge' 0' Enc.Challenge.Length);  	Writer.Flush ();  	byte[] EncryptedData = StaticStaticDiffieHellman.Encrypt (NetworkFacade.ServerKey' System.Security.Cryptography.ECDiffieHellmanCngPublicKey.FromByteArray (Enc.PublicKey' System.Security.Cryptography.CngKeyBlobFormat.EccPublicBlob)' Enc.NOnce' StreamToEncrypt.ToArray ());  	EncryptedPacket.WriteUInt16 ((ushort)(PacketHeaders.UNENCRYPTED + (1 + NetworkFacade.ServerPublicKey.Length) + (1 + EncryptedData.Length)));  	EncryptedPacket.WriteByte ((byte)NetworkFacade.ServerPublicKey.Length);  	EncryptedPacket.WriteBytes (NetworkFacade.ServerPublicKey);  	EncryptedPacket.WriteByte ((byte)EncryptedData.Length);  	EncryptedPacket.WriteBytes (EncryptedData);  	Client.Send (EncryptedPacket.ToArray ());  } //This should HOPEFULLY wade off clients sending unreadable (I.E old protocol) packets...  catch (Exception E) {  	Logger.LogDebug ("Error while handling login request' disconnecting client: " + E.ToString ());  	Client.Disconnect ();  	return;  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleLoginRequest,The following statement contains a magic number: if (ClientVersion != GlobalSettings.Default.ClientVersion) {  	PacketStream OutPacket = new PacketStream ((byte)PacketType.INVALID_VERSION' 2);  	OutPacket.WriteHeader ();  	OutPacket.WriteByte (0x01);  	Client.Send (OutPacket.ToArray ());  	Logger.LogInfo ("Bad version - sent SInvalidVersion!\r\n");  	Client.Disconnect ();  	return;  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterInfoRequest,The following statement contains a magic number: if (DateTimeStr != string.Empty)  	Timestamp = DateTime.Parse (DateTimeStr);  else {  	//Unix epoch  	Timestamp = new DateTime (1970' 1' 1' 0' 0' 1);  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterInfoRequest,The following statement contains a magic number: Timestamp = new DateTime (1970' 1' 1' 0' 0' 1);  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: if (NetworkFacade.CServerListener.CityServers.Count > 0) {  	lock (NetworkFacade.CServerListener.CityServers) {  		foreach (CityInfo CInfo in NetworkFacade.CServerListener.CityServers) {  			Packet.WriteString (CInfo.Name);  			Packet.WriteString (CInfo.Description);  			Packet.WriteString (CInfo.IP);  			Packet.WriteInt32 (CInfo.Port);  			//Hack (?) to ensure status is written correctly.  			switch (CInfo.Status) {  			case CityInfoStatus.Ok:  				Packet.WriteByte (1);  				break;  			case CityInfoStatus.Busy:  				Packet.WriteByte (2);  				break;  			case CityInfoStatus.Full:  				Packet.WriteByte (3);  				break;  			case CityInfoStatus.Reserved:  				Packet.WriteByte (4);  				break;  			}  			Packet.WriteUInt64 (CInfo.Thumbnail);  			Packet.WriteString (CInfo.UUID);  			Packet.WriteUInt64 (CInfo.Map);  		}  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: if (NetworkFacade.CServerListener.CityServers.Count > 0) {  	lock (NetworkFacade.CServerListener.CityServers) {  		foreach (CityInfo CInfo in NetworkFacade.CServerListener.CityServers) {  			Packet.WriteString (CInfo.Name);  			Packet.WriteString (CInfo.Description);  			Packet.WriteString (CInfo.IP);  			Packet.WriteInt32 (CInfo.Port);  			//Hack (?) to ensure status is written correctly.  			switch (CInfo.Status) {  			case CityInfoStatus.Ok:  				Packet.WriteByte (1);  				break;  			case CityInfoStatus.Busy:  				Packet.WriteByte (2);  				break;  			case CityInfoStatus.Full:  				Packet.WriteByte (3);  				break;  			case CityInfoStatus.Reserved:  				Packet.WriteByte (4);  				break;  			}  			Packet.WriteUInt64 (CInfo.Thumbnail);  			Packet.WriteString (CInfo.UUID);  			Packet.WriteUInt64 (CInfo.Map);  		}  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: if (NetworkFacade.CServerListener.CityServers.Count > 0) {  	lock (NetworkFacade.CServerListener.CityServers) {  		foreach (CityInfo CInfo in NetworkFacade.CServerListener.CityServers) {  			Packet.WriteString (CInfo.Name);  			Packet.WriteString (CInfo.Description);  			Packet.WriteString (CInfo.IP);  			Packet.WriteInt32 (CInfo.Port);  			//Hack (?) to ensure status is written correctly.  			switch (CInfo.Status) {  			case CityInfoStatus.Ok:  				Packet.WriteByte (1);  				break;  			case CityInfoStatus.Busy:  				Packet.WriteByte (2);  				break;  			case CityInfoStatus.Full:  				Packet.WriteByte (3);  				break;  			case CityInfoStatus.Reserved:  				Packet.WriteByte (4);  				break;  			}  			Packet.WriteUInt64 (CInfo.Thumbnail);  			Packet.WriteString (CInfo.UUID);  			Packet.WriteUInt64 (CInfo.Map);  		}  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: lock (NetworkFacade.CServerListener.CityServers) {  	foreach (CityInfo CInfo in NetworkFacade.CServerListener.CityServers) {  		Packet.WriteString (CInfo.Name);  		Packet.WriteString (CInfo.Description);  		Packet.WriteString (CInfo.IP);  		Packet.WriteInt32 (CInfo.Port);  		//Hack (?) to ensure status is written correctly.  		switch (CInfo.Status) {  		case CityInfoStatus.Ok:  			Packet.WriteByte (1);  			break;  		case CityInfoStatus.Busy:  			Packet.WriteByte (2);  			break;  		case CityInfoStatus.Full:  			Packet.WriteByte (3);  			break;  		case CityInfoStatus.Reserved:  			Packet.WriteByte (4);  			break;  		}  		Packet.WriteUInt64 (CInfo.Thumbnail);  		Packet.WriteString (CInfo.UUID);  		Packet.WriteUInt64 (CInfo.Map);  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: lock (NetworkFacade.CServerListener.CityServers) {  	foreach (CityInfo CInfo in NetworkFacade.CServerListener.CityServers) {  		Packet.WriteString (CInfo.Name);  		Packet.WriteString (CInfo.Description);  		Packet.WriteString (CInfo.IP);  		Packet.WriteInt32 (CInfo.Port);  		//Hack (?) to ensure status is written correctly.  		switch (CInfo.Status) {  		case CityInfoStatus.Ok:  			Packet.WriteByte (1);  			break;  		case CityInfoStatus.Busy:  			Packet.WriteByte (2);  			break;  		case CityInfoStatus.Full:  			Packet.WriteByte (3);  			break;  		case CityInfoStatus.Reserved:  			Packet.WriteByte (4);  			break;  		}  		Packet.WriteUInt64 (CInfo.Thumbnail);  		Packet.WriteString (CInfo.UUID);  		Packet.WriteUInt64 (CInfo.Map);  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: lock (NetworkFacade.CServerListener.CityServers) {  	foreach (CityInfo CInfo in NetworkFacade.CServerListener.CityServers) {  		Packet.WriteString (CInfo.Name);  		Packet.WriteString (CInfo.Description);  		Packet.WriteString (CInfo.IP);  		Packet.WriteInt32 (CInfo.Port);  		//Hack (?) to ensure status is written correctly.  		switch (CInfo.Status) {  		case CityInfoStatus.Ok:  			Packet.WriteByte (1);  			break;  		case CityInfoStatus.Busy:  			Packet.WriteByte (2);  			break;  		case CityInfoStatus.Full:  			Packet.WriteByte (3);  			break;  		case CityInfoStatus.Reserved:  			Packet.WriteByte (4);  			break;  		}  		Packet.WriteUInt64 (CInfo.Thumbnail);  		Packet.WriteString (CInfo.UUID);  		Packet.WriteUInt64 (CInfo.Map);  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: foreach (CityInfo CInfo in NetworkFacade.CServerListener.CityServers) {  	Packet.WriteString (CInfo.Name);  	Packet.WriteString (CInfo.Description);  	Packet.WriteString (CInfo.IP);  	Packet.WriteInt32 (CInfo.Port);  	//Hack (?) to ensure status is written correctly.  	switch (CInfo.Status) {  	case CityInfoStatus.Ok:  		Packet.WriteByte (1);  		break;  	case CityInfoStatus.Busy:  		Packet.WriteByte (2);  		break;  	case CityInfoStatus.Full:  		Packet.WriteByte (3);  		break;  	case CityInfoStatus.Reserved:  		Packet.WriteByte (4);  		break;  	}  	Packet.WriteUInt64 (CInfo.Thumbnail);  	Packet.WriteString (CInfo.UUID);  	Packet.WriteUInt64 (CInfo.Map);  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: foreach (CityInfo CInfo in NetworkFacade.CServerListener.CityServers) {  	Packet.WriteString (CInfo.Name);  	Packet.WriteString (CInfo.Description);  	Packet.WriteString (CInfo.IP);  	Packet.WriteInt32 (CInfo.Port);  	//Hack (?) to ensure status is written correctly.  	switch (CInfo.Status) {  	case CityInfoStatus.Ok:  		Packet.WriteByte (1);  		break;  	case CityInfoStatus.Busy:  		Packet.WriteByte (2);  		break;  	case CityInfoStatus.Full:  		Packet.WriteByte (3);  		break;  	case CityInfoStatus.Reserved:  		Packet.WriteByte (4);  		break;  	}  	Packet.WriteUInt64 (CInfo.Thumbnail);  	Packet.WriteString (CInfo.UUID);  	Packet.WriteUInt64 (CInfo.Map);  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: foreach (CityInfo CInfo in NetworkFacade.CServerListener.CityServers) {  	Packet.WriteString (CInfo.Name);  	Packet.WriteString (CInfo.Description);  	Packet.WriteString (CInfo.IP);  	Packet.WriteInt32 (CInfo.Port);  	//Hack (?) to ensure status is written correctly.  	switch (CInfo.Status) {  	case CityInfoStatus.Ok:  		Packet.WriteByte (1);  		break;  	case CityInfoStatus.Busy:  		Packet.WriteByte (2);  		break;  	case CityInfoStatus.Full:  		Packet.WriteByte (3);  		break;  	case CityInfoStatus.Reserved:  		Packet.WriteByte (4);  		break;  	}  	Packet.WriteUInt64 (CInfo.Thumbnail);  	Packet.WriteString (CInfo.UUID);  	Packet.WriteUInt64 (CInfo.Map);  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: switch (CInfo.Status) {  case CityInfoStatus.Ok:  	Packet.WriteByte (1);  	break;  case CityInfoStatus.Busy:  	Packet.WriteByte (2);  	break;  case CityInfoStatus.Full:  	Packet.WriteByte (3);  	break;  case CityInfoStatus.Reserved:  	Packet.WriteByte (4);  	break;  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: switch (CInfo.Status) {  case CityInfoStatus.Ok:  	Packet.WriteByte (1);  	break;  case CityInfoStatus.Busy:  	Packet.WriteByte (2);  	break;  case CityInfoStatus.Full:  	Packet.WriteByte (3);  	break;  case CityInfoStatus.Reserved:  	Packet.WriteByte (4);  	break;  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: switch (CInfo.Status) {  case CityInfoStatus.Ok:  	Packet.WriteByte (1);  	break;  case CityInfoStatus.Busy:  	Packet.WriteByte (2);  	break;  case CityInfoStatus.Full:  	Packet.WriteByte (3);  	break;  case CityInfoStatus.Reserved:  	Packet.WriteByte (4);  	break;  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: Packet.WriteByte (2);  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: Packet.WriteByte (3);  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following statement contains a magic number: Packet.WriteByte (4);  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The following statement contains a magic number: using (var db = DataAccess.Get ()) {  	Account Acc = db.Accounts.GetByUsername (AccountName);  	if (Acc.NumCharacters >= 3) {  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.ExceededCharacterLimit);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		return;  	}  	//TODO: Send GUID to client...  	var Char = new Character ();  	string LastCached = P.ReadString ();  	if (LastCached == string.Empty) {  		//TODO: Proper error...  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		return;  	}  	Char.LastCached = ProtoHelpers.ParseDateTime (LastCached);  	Char.Name = P.ReadString ();  	Char.Sex = P.ReadString ();  	Char.Description = P.ReadString ();  	Char.GUID = Guid.NewGuid ();  	Char.HeadOutfitID = (long)P.ReadUInt64 ();  	Char.BodyOutfitID = (long)P.ReadUInt64 ();  	Char.AccountID = Acc.AccountID;  	Char.AppearanceType = P.ReadByte ();  	Char.CityName = P.ReadString ();  	Char.CityThumb = (long)P.ReadUInt64 ();  	Char.City = P.ReadString ();  	Char.CityMap = (long)P.ReadUInt64 ();  	Char.CityIp = P.ReadString ();  	Char.CityPort = P.ReadInt32 ();  	Char.Money = NetworkFacade.INITIAL_MONEY;  	//These are going into DB' so be nazi. Sieg heil!  	if (Char.Name == string.Empty || Char.Sex == string.Empty || Char.Description == string.Empty) {  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		return;  	}  	var status = db.Characters.CreateCharacter (Char);  	switch (status) {  	case LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted:  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		break;  	case LoginDataModel.Entities.CharacterCreationStatus.NameTooLong:  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameTooLong);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		break;  	case LoginDataModel.Entities.CharacterCreationStatus.Success:  		Guid Token = Guid.NewGuid ();  		//This actually updates the record' not sure how.  		Acc.NumCharacters++;  		//THIS NEEDS TO HAPPEN FIRST FOR CITY SERVER AUTHENTICATION TO WORK!  		CityInfo CServer = NetworkFacade.CServerListener.GetCityServer (Char.City);  		//Just in case...  		if (CServer != null) {  			PacketStream CServerPacket = new PacketStream (0x01' 0);  			CServerPacket.WriteHeader ();  			ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (Char.GUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  			CServerPacket.WriteUInt16 (PacketLength);  			CServerPacket.WriteByte (1);  			//CharacterCreate = true  			CServerPacket.WriteInt32 (Acc.AccountID);  			CServerPacket.WriteString (Client.RemoteIP);  			CServerPacket.WriteInt32 (Client.RemotePort);  			CServerPacket.WriteString (Char.GUID.ToString ());  			CServerPacket.WriteString (Token.ToString (""));  			CServer.Client.Send (CServerPacket.ToArray ());  		}  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.Success);  		CCStatusPacket.WriteString (Char.GUID.ToString ());  		CCStatusPacket.WriteString (Token.ToString ());  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		break;  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The following statement contains a magic number: using (var db = DataAccess.Get ()) {  	Account Acc = db.Accounts.GetByUsername (AccountName);  	if (Acc.NumCharacters >= 3) {  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.ExceededCharacterLimit);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		return;  	}  	//TODO: Send GUID to client...  	var Char = new Character ();  	string LastCached = P.ReadString ();  	if (LastCached == string.Empty) {  		//TODO: Proper error...  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		return;  	}  	Char.LastCached = ProtoHelpers.ParseDateTime (LastCached);  	Char.Name = P.ReadString ();  	Char.Sex = P.ReadString ();  	Char.Description = P.ReadString ();  	Char.GUID = Guid.NewGuid ();  	Char.HeadOutfitID = (long)P.ReadUInt64 ();  	Char.BodyOutfitID = (long)P.ReadUInt64 ();  	Char.AccountID = Acc.AccountID;  	Char.AppearanceType = P.ReadByte ();  	Char.CityName = P.ReadString ();  	Char.CityThumb = (long)P.ReadUInt64 ();  	Char.City = P.ReadString ();  	Char.CityMap = (long)P.ReadUInt64 ();  	Char.CityIp = P.ReadString ();  	Char.CityPort = P.ReadInt32 ();  	Char.Money = NetworkFacade.INITIAL_MONEY;  	//These are going into DB' so be nazi. Sieg heil!  	if (Char.Name == string.Empty || Char.Sex == string.Empty || Char.Description == string.Empty) {  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		return;  	}  	var status = db.Characters.CreateCharacter (Char);  	switch (status) {  	case LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted:  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		break;  	case LoginDataModel.Entities.CharacterCreationStatus.NameTooLong:  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameTooLong);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		break;  	case LoginDataModel.Entities.CharacterCreationStatus.Success:  		Guid Token = Guid.NewGuid ();  		//This actually updates the record' not sure how.  		Acc.NumCharacters++;  		//THIS NEEDS TO HAPPEN FIRST FOR CITY SERVER AUTHENTICATION TO WORK!  		CityInfo CServer = NetworkFacade.CServerListener.GetCityServer (Char.City);  		//Just in case...  		if (CServer != null) {  			PacketStream CServerPacket = new PacketStream (0x01' 0);  			CServerPacket.WriteHeader ();  			ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (Char.GUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  			CServerPacket.WriteUInt16 (PacketLength);  			CServerPacket.WriteByte (1);  			//CharacterCreate = true  			CServerPacket.WriteInt32 (Acc.AccountID);  			CServerPacket.WriteString (Client.RemoteIP);  			CServerPacket.WriteInt32 (Client.RemotePort);  			CServerPacket.WriteString (Char.GUID.ToString ());  			CServerPacket.WriteString (Token.ToString (""));  			CServer.Client.Send (CServerPacket.ToArray ());  		}  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.Success);  		CCStatusPacket.WriteString (Char.GUID.ToString ());  		CCStatusPacket.WriteString (Token.ToString ());  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		break;  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The following statement contains a magic number: using (var db = DataAccess.Get ()) {  	Account Acc = db.Accounts.GetByUsername (AccountName);  	if (Acc.NumCharacters >= 3) {  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.ExceededCharacterLimit);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		return;  	}  	//TODO: Send GUID to client...  	var Char = new Character ();  	string LastCached = P.ReadString ();  	if (LastCached == string.Empty) {  		//TODO: Proper error...  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		return;  	}  	Char.LastCached = ProtoHelpers.ParseDateTime (LastCached);  	Char.Name = P.ReadString ();  	Char.Sex = P.ReadString ();  	Char.Description = P.ReadString ();  	Char.GUID = Guid.NewGuid ();  	Char.HeadOutfitID = (long)P.ReadUInt64 ();  	Char.BodyOutfitID = (long)P.ReadUInt64 ();  	Char.AccountID = Acc.AccountID;  	Char.AppearanceType = P.ReadByte ();  	Char.CityName = P.ReadString ();  	Char.CityThumb = (long)P.ReadUInt64 ();  	Char.City = P.ReadString ();  	Char.CityMap = (long)P.ReadUInt64 ();  	Char.CityIp = P.ReadString ();  	Char.CityPort = P.ReadInt32 ();  	Char.Money = NetworkFacade.INITIAL_MONEY;  	//These are going into DB' so be nazi. Sieg heil!  	if (Char.Name == string.Empty || Char.Sex == string.Empty || Char.Description == string.Empty) {  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		return;  	}  	var status = db.Characters.CreateCharacter (Char);  	switch (status) {  	case LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted:  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		break;  	case LoginDataModel.Entities.CharacterCreationStatus.NameTooLong:  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameTooLong);  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		break;  	case LoginDataModel.Entities.CharacterCreationStatus.Success:  		Guid Token = Guid.NewGuid ();  		//This actually updates the record' not sure how.  		Acc.NumCharacters++;  		//THIS NEEDS TO HAPPEN FIRST FOR CITY SERVER AUTHENTICATION TO WORK!  		CityInfo CServer = NetworkFacade.CServerListener.GetCityServer (Char.City);  		//Just in case...  		if (CServer != null) {  			PacketStream CServerPacket = new PacketStream (0x01' 0);  			CServerPacket.WriteHeader ();  			ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (Char.GUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  			CServerPacket.WriteUInt16 (PacketLength);  			CServerPacket.WriteByte (1);  			//CharacterCreate = true  			CServerPacket.WriteInt32 (Acc.AccountID);  			CServerPacket.WriteString (Client.RemoteIP);  			CServerPacket.WriteInt32 (Client.RemotePort);  			CServerPacket.WriteString (Char.GUID.ToString ());  			CServerPacket.WriteString (Token.ToString (""));  			CServer.Client.Send (CServerPacket.ToArray ());  		}  		CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.Success);  		CCStatusPacket.WriteString (Char.GUID.ToString ());  		CCStatusPacket.WriteString (Token.ToString ());  		Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  		break;  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The following statement contains a magic number: if (Acc.NumCharacters >= 3) {  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.ExceededCharacterLimit);  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	return;  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The following statement contains a magic number: switch (status) {  case LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted:  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	break;  case LoginDataModel.Entities.CharacterCreationStatus.NameTooLong:  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameTooLong);  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	break;  case LoginDataModel.Entities.CharacterCreationStatus.Success:  	Guid Token = Guid.NewGuid ();  	//This actually updates the record' not sure how.  	Acc.NumCharacters++;  	//THIS NEEDS TO HAPPEN FIRST FOR CITY SERVER AUTHENTICATION TO WORK!  	CityInfo CServer = NetworkFacade.CServerListener.GetCityServer (Char.City);  	//Just in case...  	if (CServer != null) {  		PacketStream CServerPacket = new PacketStream (0x01' 0);  		CServerPacket.WriteHeader ();  		ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (Char.GUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  		CServerPacket.WriteUInt16 (PacketLength);  		CServerPacket.WriteByte (1);  		//CharacterCreate = true  		CServerPacket.WriteInt32 (Acc.AccountID);  		CServerPacket.WriteString (Client.RemoteIP);  		CServerPacket.WriteInt32 (Client.RemotePort);  		CServerPacket.WriteString (Char.GUID.ToString ());  		CServerPacket.WriteString (Token.ToString (""));  		CServer.Client.Send (CServerPacket.ToArray ());  	}  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.Success);  	CCStatusPacket.WriteString (Char.GUID.ToString ());  	CCStatusPacket.WriteString (Token.ToString ());  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	break;  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The following statement contains a magic number: switch (status) {  case LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted:  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	break;  case LoginDataModel.Entities.CharacterCreationStatus.NameTooLong:  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameTooLong);  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	break;  case LoginDataModel.Entities.CharacterCreationStatus.Success:  	Guid Token = Guid.NewGuid ();  	//This actually updates the record' not sure how.  	Acc.NumCharacters++;  	//THIS NEEDS TO HAPPEN FIRST FOR CITY SERVER AUTHENTICATION TO WORK!  	CityInfo CServer = NetworkFacade.CServerListener.GetCityServer (Char.City);  	//Just in case...  	if (CServer != null) {  		PacketStream CServerPacket = new PacketStream (0x01' 0);  		CServerPacket.WriteHeader ();  		ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (Char.GUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  		CServerPacket.WriteUInt16 (PacketLength);  		CServerPacket.WriteByte (1);  		//CharacterCreate = true  		CServerPacket.WriteInt32 (Acc.AccountID);  		CServerPacket.WriteString (Client.RemoteIP);  		CServerPacket.WriteInt32 (Client.RemotePort);  		CServerPacket.WriteString (Char.GUID.ToString ());  		CServerPacket.WriteString (Token.ToString (""));  		CServer.Client.Send (CServerPacket.ToArray ());  	}  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.Success);  	CCStatusPacket.WriteString (Char.GUID.ToString ());  	CCStatusPacket.WriteString (Token.ToString ());  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	break;  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The following statement contains a magic number: if (CServer != null) {  	PacketStream CServerPacket = new PacketStream (0x01' 0);  	CServerPacket.WriteHeader ();  	ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (Char.GUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  	CServerPacket.WriteUInt16 (PacketLength);  	CServerPacket.WriteByte (1);  	//CharacterCreate = true  	CServerPacket.WriteInt32 (Acc.AccountID);  	CServerPacket.WriteString (Client.RemoteIP);  	CServerPacket.WriteInt32 (Client.RemotePort);  	CServerPacket.WriteString (Char.GUID.ToString ());  	CServerPacket.WriteString (Token.ToString (""));  	CServer.Client.Send (CServerPacket.ToArray ());  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The following statement contains a magic number: if (CServer != null) {  	PacketStream CServerPacket = new PacketStream (0x01' 0);  	CServerPacket.WriteHeader ();  	ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (Char.GUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  	CServerPacket.WriteUInt16 (PacketLength);  	CServerPacket.WriteByte (1);  	//CharacterCreate = true  	CServerPacket.WriteInt32 (Acc.AccountID);  	CServerPacket.WriteString (Client.RemoteIP);  	CServerPacket.WriteInt32 (Client.RemotePort);  	CServerPacket.WriteString (Char.GUID.ToString ());  	CServerPacket.WriteString (Token.ToString (""));  	CServer.Client.Send (CServerPacket.ToArray ());  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityTokenRequest,The following statement contains a magic number: using (var db = DataAccess.Get ()) {  	Account Acc = db.Accounts.GetByUsername (AccountName);  	PacketStream CServerPacket = new PacketStream (0x01' 0);  	CServerPacket.WriteHeader ();  	ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (CharGUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  	CServerPacket.WriteUInt16 (PacketLength);  	CServerPacket.WriteByte (0);  	//CharacterCreate = false.  	CServerPacket.WriteInt32 (Acc.AccountID);  	CServerPacket.WriteString (Client.RemoteIP);  	CServerPacket.WriteInt32 (Client.RemotePort);  	CServerPacket.WriteString (CharGUID.ToString ());  	CServerPacket.WriteString (Token.ToString (""));  	CServer.Client.Send (CServerPacket.ToArray ());  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityTokenRequest,The following statement contains a magic number: using (var db = DataAccess.Get ()) {  	Account Acc = db.Accounts.GetByUsername (AccountName);  	PacketStream CServerPacket = new PacketStream (0x01' 0);  	CServerPacket.WriteHeader ();  	ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (CharGUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  	CServerPacket.WriteUInt16 (PacketLength);  	CServerPacket.WriteByte (0);  	//CharacterCreate = false.  	CServerPacket.WriteInt32 (Acc.AccountID);  	CServerPacket.WriteString (Client.RemoteIP);  	CServerPacket.WriteInt32 (Client.RemotePort);  	CServerPacket.WriteString (CharGUID.ToString ());  	CServerPacket.WriteString (Token.ToString (""));  	CServer.Client.Send (CServerPacket.ToArray ());  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterRetirement,The following statement contains a magic number: using (var db = DataAccess.Get ()) {  	Account Acc = db.Accounts.GetByUsername (AccountName);  	IQueryable<Character> Query = db.Characters.GetForAccount (Acc.AccountID);  	//FUCK' I hate LINQ.  	Guid CharGUID = new Guid (GUID);  	Character Char = Query.Where (x => x.GUID == CharGUID).SingleOrDefault ();  	if (Char != null)  		db.Characters.RetireCharacter (Char);  	else  		return;  	//This actually updates the record' not sure how.  	Acc.NumCharacters--;  	if (Char != null) {  		CityInfo CInfo = NetworkFacade.CServerListener.GetCityServer (Char.City);  		//Just in case...  		if (CInfo != null) {  			Packet = new PacketStream (0x02' 0);  			Packet.WriteHeader ();  			ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 4 + GUID.Length + 1);  			Packet.WriteUInt16 (PacketLength);  			Packet.WriteInt32 (Acc.AccountID);  			Packet.WriteString (GUID);  			CInfo.Client.Send (Packet.ToArray ());  		}  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterRetirement,The following statement contains a magic number: if (Char != null) {  	CityInfo CInfo = NetworkFacade.CServerListener.GetCityServer (Char.City);  	//Just in case...  	if (CInfo != null) {  		Packet = new PacketStream (0x02' 0);  		Packet.WriteHeader ();  		ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 4 + GUID.Length + 1);  		Packet.WriteUInt16 (PacketLength);  		Packet.WriteInt32 (Acc.AccountID);  		Packet.WriteString (GUID);  		CInfo.Client.Send (Packet.ToArray ());  	}  }  
Magic Number,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterRetirement,The following statement contains a magic number: if (CInfo != null) {  	Packet = new PacketStream (0x02' 0);  	Packet.WriteHeader ();  	ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 4 + GUID.Length + 1);  	Packet.WriteUInt16 (PacketLength);  	Packet.WriteInt32 (Acc.AccountID);  	Packet.WriteString (GUID);  	CInfo.Client.Send (Packet.ToArray ());  }  
Missing Default,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Logger_OnMessageLogged,The following switch statement is missing a default case: switch (Msg.Level) {  case ProtocolAbstractionLibraryD.LogLevel.info:  	Logger.LogInfo (Msg.Message);  	break;  case ProtocolAbstractionLibraryD.LogLevel.error:  	Logger.LogDebug (Msg.Message);  	break;  case ProtocolAbstractionLibraryD.LogLevel.warn:  	Logger.LogWarning (Msg.Message);  	break;  }  
Missing Default,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Logger_OnMessageLogged,The following switch statement is missing a default case: switch (Msg.Level) {  case LoginDataModel.LogLevel.info:  	Logger.LogInfo (Msg.Message);  	break;  case LoginDataModel.LogLevel.error:  	Logger.LogDebug (Msg.Message);  	break;  case LoginDataModel.LogLevel.warn:  	Logger.LogWarning (Msg.Message);  	break;  }  
Missing Default,TSO_LoginServer,Program,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Program.cs,Logger_OnMessageLogged,The following switch statement is missing a default case: switch (Msg.Level) {  case GonzoNet.LogLevel.info:  	Logger.LogInfo (Msg.Message);  	break;  case GonzoNet.LogLevel.error:  	Logger.LogDebug (Msg.Message);  	break;  case GonzoNet.LogLevel.warn:  	Logger.LogWarning (Msg.Message);  	break;  }  
Missing Default,TSO_LoginServer.Network,CityServerPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\CityServerPacketHandlers.cs,HandlePlayerOnlineResponse,The following switch statement is missing a default case: switch (Result) {  case 0x01:  	Packet = new PacketStream ((byte)PacketType.REQUEST_CITY_TOKEN' 0);  	Packet.WriteString (Token);  	FoundClient = NetworkFacade.ClientListener.GetClient (RemoteIP' RemotePort);  	if (FoundClient != null)  		FoundClient.SendEncrypted ((byte)PacketType.REQUEST_CITY_TOKEN' Packet.ToArray ());  	break;  case 0x02:  	//Write player was already online packet!  	Packet = new PacketStream ((byte)PacketType.PLAYER_ALREADY_ONLINE' 0);  	Packet.WriteByte (0x00);  	//Dummy  	FoundClient = NetworkFacade.ClientListener.GetClient (RemoteIP' RemotePort);  	if (FoundClient != null)  		FoundClient.SendEncrypted ((byte)PacketType.PLAYER_ALREADY_ONLINE' Packet.ToArray ());  	break;  }  
Missing Default,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCityInfoRequest,The following switch statement is missing a default case: switch (CInfo.Status) {  case CityInfoStatus.Ok:  	Packet.WriteByte (1);  	break;  case CityInfoStatus.Busy:  	Packet.WriteByte (2);  	break;  case CityInfoStatus.Full:  	Packet.WriteByte (3);  	break;  case CityInfoStatus.Reserved:  	Packet.WriteByte (4);  	break;  }  
Missing Default,TSO_LoginServer.Network,LoginPacketHandlers,F:\newReposMay17\Afr0_Project-Dollhouse\TSO LoginServer\TSO LoginServer\Network\LoginPacketHandlers.cs,HandleCharacterCreate,The following switch statement is missing a default case: switch (status) {  case LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted:  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameAlreadyExisted);  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	break;  case LoginDataModel.Entities.CharacterCreationStatus.NameTooLong:  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.NameTooLong);  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	break;  case LoginDataModel.Entities.CharacterCreationStatus.Success:  	Guid Token = Guid.NewGuid ();  	//This actually updates the record' not sure how.  	Acc.NumCharacters++;  	//THIS NEEDS TO HAPPEN FIRST FOR CITY SERVER AUTHENTICATION TO WORK!  	CityInfo CServer = NetworkFacade.CServerListener.GetCityServer (Char.City);  	//Just in case...  	if (CServer != null) {  		PacketStream CServerPacket = new PacketStream (0x01' 0);  		CServerPacket.WriteHeader ();  		ushort PacketLength = (ushort)(PacketHeaders.UNENCRYPTED + 1 + 4 + (Client.RemoteIP.Length + 1) + 4 + (Char.GUID.ToString ().Length + 1) + (Token.ToString ().Length + 1));  		CServerPacket.WriteUInt16 (PacketLength);  		CServerPacket.WriteByte (1);  		//CharacterCreate = true  		CServerPacket.WriteInt32 (Acc.AccountID);  		CServerPacket.WriteString (Client.RemoteIP);  		CServerPacket.WriteInt32 (Client.RemotePort);  		CServerPacket.WriteString (Char.GUID.ToString ());  		CServerPacket.WriteString (Token.ToString (""));  		CServer.Client.Send (CServerPacket.ToArray ());  	}  	CCStatusPacket.WriteByte ((int)LoginDataModel.Entities.CharacterCreationStatus.Success);  	CCStatusPacket.WriteString (Char.GUID.ToString ());  	CCStatusPacket.WriteString (Token.ToString ());  	Client.SendEncrypted (CCStatusPacket.PacketID' CCStatusPacket.ToArray ());  	break;  }  
