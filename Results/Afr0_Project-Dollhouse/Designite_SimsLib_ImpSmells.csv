Implementation smell,Namespace,Class,File,Method,Description
Long Method,SimsLib.IFF,OBJD,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The method has 109 lines of code.
Long Method,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The method has 158 lines of code.
Long Method,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The method has 181 lines of code.
Long Method,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The method has 102 lines of code.
Complex Method,SimsLib.ThreeD,Animation,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Animation.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,SimsLib.IFF,OBJD,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,SimsLib.IFF,SPRFrame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,Cyclomatic complexity of the method is 12
Complex Method,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,Cyclomatic complexity of the method is 28
Complex Method,SimsLib.IFF,STR,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\STR.cs,Read,Cyclomatic complexity of the method is 13
Complex Method,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,Cyclomatic complexity of the method is 21
Complex Method,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,Cyclomatic complexity of the method is 16
Complex Method,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,Cyclomatic complexity of the method is 14
Complex Method,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,Cyclomatic complexity of the method is 12
Complex Method,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,Cyclomatic complexity of the method is 12
Long Parameter List,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,ArrayCopy2,The method has 5 parameters. Parameters: Src' SrcPos' Dest' DestPos' Length
Long Statement,SimsLib.ThreeD,Mesh,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,StoreOnGPU,The length of the statement  "            GPUBlendVertexBuffer = new DynamicVertexBuffer(device' MeshVertex.SizeInBytes * BlendVertexBuffer.Length' BufferUsage.None); " is 124.
Long Statement,SimsLib.ThreeD,Mesh,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,StoreOnGPU,The length of the statement  "            GPUIndexBuffer = new IndexBuffer(device' sizeof(short) * IndexBuffer.Length' BufferUsage.None' IndexElementSize.SixteenBits); " is 125.
Long Statement,SimsLib.ThreeD,Mesh,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,DrawGeometry,The length of the statement  "                gd.DrawUserIndexedPrimitives(PrimitiveType.TriangleList' BlendVertexBuffer' 0' BlendVertexBuffer.Length' IndexBuffer' 0' NumPrimitives); " is 136.
Long Statement,SimsLib.ThreeD,Mesh,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,Draw,The length of the statement  "            gd.DrawUserIndexedPrimitives(PrimitiveType.TriangleList' BlendVertexBuffer' 0' BlendVertexBuffer.Length' IndexBuffer' 0' NumPrimitives); " is 136.
Long Statement,SimsLib.IFF,SLOT,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The length of the statement  "                /** The span for version 4 is 34.  The span for version 6 is 54.  The span for version 7 is 58.  The span for version 8 is 62.  The span for version 9 is 66.  The span for version 10 is 70.  **/ " is 194.
Long Statement,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The length of the statement  "                    /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/ " is 171.
Long Statement,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The length of the statement  "			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) " is 133.
Long Statement,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetItemByID,The length of the statement  "            //Far3Entry Entry = Array.Find(entries' delegate(Far3Entry entry) { return entry.FileID == FileID && entry.TypeID == TypeID; }); " is 128.
Long Statement,LogThis,Log,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,LogHeader,The length of the statement  "					sHeader = "======(" + System.AppDomain.CurrentDomain.FriendlyName + ") ====  " + sText + "============ Date:" + dt.ToString("yyyyMMdd") + " Time:" + dt.ToString("hh:mm:ss") ; " is 174.
Long Statement,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetWeek,The length of the statement  "			//Console.WriteLine( "There are {0} weeks in the current year ({1})."' myCal.GetWeekOfYear( LastDay' myCWR' myFirstDOW )' LastDay.Year ); " is 137.
Long Statement,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The length of the statement  "                    m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)]; " is 139.
Empty Catch Block,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,AppendToFile,The method has an empty catch block.
Magic Number,SimsLib.ThreeD,Binding,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Binding.cs,Read,The following statement contains a magic number: meshType == 8
Magic Number,SimsLib.ThreeD,Binding,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Binding.cs,Read,The following statement contains a magic number: textureType == 8
Magic Number,SimsLib.ThreeD,Lightmaps,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,Lightmaps,The following statement contains a magic number: Data.Length != 2271104
Magic Number,SimsLib.ThreeD,Lightmaps,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: Writer.Write((uint)(m_Lights[Index].Width * m_Lights[Index].Height * 3 + 54));
Magic Number,SimsLib.ThreeD,Lightmaps,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: Writer.Write((uint)(m_Lights[Index].Width * m_Lights[Index].Height * 3 + 54));
Magic Number,SimsLib.ThreeD,Lightmaps,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: Writer.Write((uint)(m_Lights[Index].Width * m_Lights[Index].Height * 3));
Magic Number,SimsLib.ThreeD,Lightmaps,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: j < 3
Magic Number,SimsLib.ThreeD,Mesh,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,Read,The following statement contains a magic number: IndexBuffer = new short[faceCount * 3];
Magic Number,SimsLib.ThreeD,Outfit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Outfit.cs,GetAppearance,The following statement contains a magic number: switch (type)              {                  case AppearanceType.Light:                      return (ulong)LightAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Medium:                      return (ulong)MediumAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Dark:                      return (ulong)DarkAppearanceFileID << 32 | LightAppearanceTypeID;              }
Magic Number,SimsLib.ThreeD,Outfit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Outfit.cs,GetAppearance,The following statement contains a magic number: switch (type)              {                  case AppearanceType.Light:                      return (ulong)LightAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Medium:                      return (ulong)MediumAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Dark:                      return (ulong)DarkAppearanceFileID << 32 | LightAppearanceTypeID;              }
Magic Number,SimsLib.ThreeD,Outfit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Outfit.cs,GetAppearance,The following statement contains a magic number: switch (type)              {                  case AppearanceType.Light:                      return (ulong)LightAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Medium:                      return (ulong)MediumAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Dark:                      return (ulong)DarkAppearanceFileID << 32 | LightAppearanceTypeID;              }
Magic Number,SimsLib.ThreeD,Skeleton,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Skeleton.cs,FindQuaternionMatrix,The following statement contains a magic number: mtxIn.M11 = 1.0f - 2.0f * (y2 + z2);
Magic Number,SimsLib.ThreeD,Skeleton,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Skeleton.cs,FindQuaternionMatrix,The following statement contains a magic number: mtxIn.M12 = 2.0f * (xy - wz);
Magic Number,SimsLib.ThreeD,Skeleton,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Skeleton.cs,FindQuaternionMatrix,The following statement contains a magic number: mtxIn.M13 = 2.0f * (xz + wy);
Magic Number,SimsLib.ThreeD,Skeleton,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Skeleton.cs,FindQuaternionMatrix,The following statement contains a magic number: mtxIn.M21 = 2.0f * (xy + wz);
Magic Number,SimsLib.ThreeD,Skeleton,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Skeleton.cs,FindQuaternionMatrix,The following statement contains a magic number: mtxIn.M22 = 1.0f - 2.0f * (x2 + z2);
Magic Number,SimsLib.ThreeD,Skeleton,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Skeleton.cs,FindQuaternionMatrix,The following statement contains a magic number: mtxIn.M23 = 2.0f * (yz - wx);
Magic Number,SimsLib.ThreeD,Skeleton,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Skeleton.cs,FindQuaternionMatrix,The following statement contains a magic number: mtxIn.M31 = 2.0f * (xz - wy);
Magic Number,SimsLib.ThreeD,Skeleton,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Skeleton.cs,FindQuaternionMatrix,The following statement contains a magic number: mtxIn.M32 = 2.0f * (yz + wx);
Magic Number,SimsLib.ThreeD,Skeleton,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Skeleton.cs,FindQuaternionMatrix,The following statement contains a magic number: mtxIn.M33 = 1.0f - 2.0f * (x2 + y2);
Magic Number,SimsLib,Endian,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,SimsLib,Endian,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,SimsLib,Endian,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,SimsLib,Endian,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,SimsLib,IoBuffer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: var m_buffer = Reader.ReadBytes(4);
Magic Number,SimsLib,IoBuffer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib,IoBuffer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib,IoBuffer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib,IoBuffer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib,IoBuffer,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib.HIT,TLO,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\HIT\TLO.cs,TLO,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,SimsLib.HIT,TLO,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\HIT\TLO.cs,TLO,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,SimsLib.HIT,Track,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\HIT\Track.cs,Track,The following statement contains a magic number: m_Label = Values[2];
Magic Number,SimsLib.HIT,Track,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\HIT\Track.cs,Track,The following statement contains a magic number: m_TrackID = Values[4];
Magic Number,SimsLib.IFF,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\BHAV.cs,Read,The following statement contains a magic number: io.Skip(8);
Magic Number,SimsLib.IFF,BHAV,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\BHAV.cs,Read,The following statement contains a magic number: instruction.Operand = io.ReadBytes(8);
Magic Number,SimsLib.IFF,DGRP,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,Read,The following statement contains a magic number: uint imageCount = version < 20003 ? io.ReadUInt16() : io.ReadUInt32();
Magic Number,SimsLib.IFF,DGRPImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,Read,The following statement contains a magic number: version < 20003
Magic Number,SimsLib.IFF,DGRPSprite,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,Read,The following statement contains a magic number: version == 20001
Magic Number,SimsLib.IFF,DGRPSprite,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,Read,The following statement contains a magic number: version < 20003
Magic Number,SimsLib.IFF,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\IFF.cs,Read,The following statement contains a magic number: var identifier = io.ReadChars(60' false).Replace("\0"' "");
Magic Number,SimsLib.IFF,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\IFF.cs,Read,The following statement contains a magic number: var chunkType = io.ReadChars(4);
Magic Number,SimsLib.IFF,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\IFF.cs,Read,The following statement contains a magic number: var chunkLabel = io.ReadChars(64);
Magic Number,SimsLib.IFF,Iff,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\IFF.cs,Read,The following statement contains a magic number: var chunkDataSize = chunkSize - 76;
Magic Number,SimsLib.IFF,OBJD,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: var numFields = 80;
Magic Number,SimsLib.IFF,OBJD,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: numFields = 95;
Magic Number,SimsLib.IFF,OBJD,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: Version == 138
Magic Number,SimsLib.IFF,OBJD,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: numFields -= 2;
Magic Number,SimsLib.IFF,PALT,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\PALT.cs,PALT,The following statement contains a magic number: Colors = new Color[256];
Magic Number,SimsLib.IFF,PALT,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\PALT.cs,PALT,The following statement contains a magic number: i < 256
Magic Number,SimsLib.IFF,PALT,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\PALT.cs,Read,The following statement contains a magic number: var reserved = io.ReadBytes(8);
Magic Number,SimsLib.IFF,SLOT,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The following statement contains a magic number: var slotMagic = io.ReadBytes(4);
Magic Number,SimsLib.IFF,SLOT,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The following statement contains a magic number: version >= 6
Magic Number,SimsLib.IFF,SLOT,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The following statement contains a magic number: version >= 7
Magic Number,SimsLib.IFF,SLOT,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The following statement contains a magic number: version >= 8
Magic Number,SimsLib.IFF,SPR,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Read,The following statement contains a magic number: version != 1001
Magic Number,SimsLib.IFF,SPRFrame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Read,The following statement contains a magic number: version == 1001
Magic Number,SimsLib.IFF,SPRFrame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }
Magic Number,SimsLib.IFF,SPRFrame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }
Magic Number,SimsLib.IFF,SPRFrame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }
Magic Number,SimsLib.IFF,SPRFrame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }
Magic Number,SimsLib.IFF,SPR2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Read,The following statement contains a magic number: version == 1000
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Read,The following statement contains a magic number: version == 1001
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: var command = marker >> 13;
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Magic Number,SimsLib.FAR1,FARArchive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR1\FARArchive.cs,FARArchive,The following statement contains a magic number: string Header = Encoding.ASCII.GetString(m_Reader.ReadBytes(8));
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: int writeIndex = 9;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: index >= Data.Length - 2
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 3;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: offsetCopyCount <= 2
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = (index - lastReadIndex) / 4 - 1;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: index - lastReadIndex >= 4
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: index < Data.Length - 3
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = (index - lastReadIndex) / 4 - 1;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: index - lastReadIndex >= 4
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Data.Length > 6
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: Control1 >= 0 && Control1 <= 127
Magic Number,SimsLib.FAR3,Decompresser,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: Data.Length > 6
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: string Header = Encoding.ASCII.GetString(m_Reader.ReadBytes(8));
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: (Header != "FAR!byAZ") || (Version != 3)
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: byte[] Dummy = m_Reader.ReadBytes(3);
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: m_Reader.ReadBytes(9);
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: byte[] Dummy = m_Reader.ReadBytes(3);
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);
Magic Number,SimsLib.FAR3,FAR3Archive,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetItemByID,The following statement contains a magic number: uint FileID = BitConverter.ToUInt32(Bytes' 4);
Magic Number,LogThis,Log,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,UseSensibleDefaults,The following statement contains a magic number: Log.LogSizeMax = 100;
Magic Number,LogThis,Log,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: string[] baseInfo = new string[3];
Magic Number,LogThis,Log,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: baseInfo[2] = a[a.Length-1];
Magic Number,LogThis,Log,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: baseInfo[1] = baseInfo[1].Remove(baseInfo[1].Length-baseInfo[2].Length-1'baseInfo[2].Length+1);
Magic Number,LogThis,Log,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: baseInfo[1] = baseInfo[1].Remove(baseInfo[1].Length-baseInfo[2].Length-1'baseInfo[2].Length+1);
Magic Number,LogThis,Log,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: i<filePath.Length - ((baseInfo[1].Length) + (baseInfo[2].Length+1))-1
Magic Number,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat)  			{  				case elogquotaformat.kbytes:  					try  					{  						FileInfo info = new FileInfo(sLogPath);  						nfileSize = info.Length;  					}  					catch (Exception x)  					{  						System.Console.WriteLine("Error:" + x.Message);  						nfileSize = 0;  					}  					if (nfileSize < (m_logsizemax*1024))  					{ return; }  					break;  				case elogquotaformat.rows:  					using (StreamReader sr = new StreamReader(sLogPath))   					{  						String line;  						while ((line = sr.ReadLine()) != null)   						{  							i++;  						}	  						if (i < m_logsizemax) {return;}  					}  					break;  			}
Magic Number,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}
Magic Number,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}
Magic Number,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}
Magic Number,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}
Magic Number,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}
Magic Number,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}
Magic Number,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetWeek,The following statement contains a magic number: DateTime LastDay = new System.DateTime( DateTime.Now.Year' 12' 31 );
Magic Number,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetWeek,The following statement contains a magic number: DateTime LastDay = new System.DateTime( DateTime.Now.Year' 12' 31 );
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_ID = new string(m_Reader.ReadChars(4));
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: uint dwFMTSize = 16;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: uint dwRIFFSize = 36 + dwDataSize;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_UnreadBitsCount = 8;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits(4));
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits(4));
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower[0] = (ReadBits(4) + 1) * 8;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower[0] = (ReadBits(4) + 1) * 8;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: float Base = 1.04f + (float)(ReadBits(6)) / 1000.0f;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: float Base = 1.04f + (float)(ReadBits(6)) / 1000.0f;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: float Base = 1.04f + (float)(ReadBits(6)) / 1000.0f;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: i < 64
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: byte Value = (byte)(m_UnreadBitsValue & (255 >> (8 - Bits)));
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: byte Value = (byte)(m_UnreadBitsValue & (255 >> (8 - Bits)));
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: m_UnreadBitsCount += 8;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: (m_UnreadBitsCount < 8) && (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length)
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: int BlockSize = Lesser((int)Frames' 432);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: int Value = (int)Math.Round(m_DecompressedFrame[324 + i]);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: Value = Clamp<int>(Value' -32768' 32767);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: Value = Clamp<int>(Value' -32768' 32767);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: float[] Excitation = new float[118];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: float[] RCDelta = new float[12];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: byte index = ReadBits((byte)((i < 4) ? 6 : 5));
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: byte index = ReadBits((byte)((i < 4) ? 6 : 5));
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: byte index = ReadBits((byte)((i < 4) ? 6 : 5));
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: i < 12
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: int Phase = ReadBits(8);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Phase = 216;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: i == 0 && Phase > 216
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: float PitchGain = (float)(ReadBits(4)) / 15.0f;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: float PitchGain = (float)(ReadBits(4)) / 15.0f;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: float InnovationGain = m_InnovationPower[ReadBits(6)];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: GenerateExcitation(5' ref Excitation' Voiced' 1);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: j < 108
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: i < 4
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy(m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy(m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy(m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: j < 12
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize(i * 12' (i != 3) ? 12 : 396);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize(i * 12' (i != 3) ? 12 : 396);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize(i * 12' (i != 3) ? 12 : 396);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize(i * 12' (i != 3) ? 12 : 396);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: i < 4
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: Table = (code < 2 || code > 8) ? 1 : 0;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: Table = (code < 2 || code > 8) ? 1 : 0;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: Excitation[i] = (code - 1) / 4;
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: code >= 4
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: i < Offset + 108
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: float[] LPC = new float[12];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: ++offset == 12
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: m_DecompressedFrame[324 + Sample] += LPC[i] * m_History[offset];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: i < 12
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: m_History[offset--] = m_DecompressedFrame[324 + Sample++];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: float[] RCTemp = new float[12]' LPCTemp = new float[12];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: float[] RCTemp = new float[12]' LPCTemp = new float[12];
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: Array.Copy(RC' 0' RCTemp' 1' 11);
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: j != 11
Magic Number,SimsLib.UTK,UTKFile2,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: i < 12
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = new string(m_Reader.ReadChars(4));
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = new string(m_Reader.ReadChars(4));
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwFMTSize = 16;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2left = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: dleft = (byte)(LONIBBLE(bInput) + 8);
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2right = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: dright = (byte)(LONIBBLE(bInput) + 8);
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: int c2 = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: d = (byte)(LONIBBLE(bInput) + 8);
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: c2left = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: dleft = (byte)(LONIBBLE(bInput) + 8);
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: return 32767;
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: sample > 32767
Magic Number,SimsLib.XA,XAFile,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,HINIBBLE,The following statement contains a magic number: return (byte)(((B) >> 4) & 0x0F);
Missing Default,SimsLib.ThreeD,Outfit,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Outfit.cs,GetAppearance,The following switch statement is missing a default case: switch (type)              {                  case AppearanceType.Light:                      return (ulong)LightAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Medium:                      return (ulong)MediumAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Dark:                      return (ulong)DarkAppearanceFileID << 32 | LightAppearanceTypeID;              }
Missing Default,SimsLib.IFF,DGRP,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,GetImage,The following switch statement is missing a default case: switch (worldRotation)              {                  case 0:                      rotatedDirection = direction;                      break;                  case 1:                      switch (direction)                      {                          case 0x01:                              rotatedDirection = 0x04;                              break;                          case 0x10:                              rotatedDirection = 0x40;                              break;                          case 0x40:                              rotatedDirection = 0x01;                              break;                          case 0x04:                              rotatedDirection = 0x10;                              break;                      }                      break;              }
Missing Default,SimsLib.IFF,DGRP,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,GetImage,The following switch statement is missing a default case: switch (direction)                      {                          case 0x01:                              rotatedDirection = 0x04;                              break;                          case 0x10:                              rotatedDirection = 0x40;                              break;                          case 0x40:                              rotatedDirection = 0x01;                              break;                          case 0x04:                              rotatedDirection = 0x10;                              break;                      }
Missing Default,SimsLib.IFF,SPRFrame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following switch statement is missing a default case: switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }
Missing Default,SimsLib.IFF,SPRFrame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following switch statement is missing a default case: switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }
Missing Default,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following switch statement is missing a default case: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Missing Default,SimsLib.IFF,SPR2Frame,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following switch statement is missing a default case: switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }
Missing Default,LogThis,Log,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,LogHeader,The following switch statement is missing a default case: switch(logheaderlevel)  			{  				case elogheaderlevel.Level_1:  					sHeader = "======(" + System.AppDomain.CurrentDomain.FriendlyName + ") ====  " + sText + "============ Date:" + dt.ToString("yyyyMMdd") + " Time:" + dt.ToString("hh:mm:ss") ;  					break;  				case elogheaderlevel.Level_2:  					sHeader = "------" + sText + " ============ Time:" + dt.ToString("hh:mm:ss") ;  					break;  				case elogheaderlevel.Level_3:  					sHeader = "---" + sText + " --- Time:" + dt.ToString("hh:mm:ss") ;  					break;  			}
Missing Default,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following switch statement is missing a default case: switch (m_logquotaformat)  			{  				case elogquotaformat.kbytes:  					try  					{  						FileInfo info = new FileInfo(sLogPath);  						nfileSize = info.Length;  					}  					catch (Exception x)  					{  						System.Console.WriteLine("Error:" + x.Message);  						nfileSize = 0;  					}  					if (nfileSize < (m_logsizemax*1024))  					{ return; }  					break;  				case elogquotaformat.rows:  					using (StreamReader sr = new StreamReader(sLogPath))   					{  						String line;  						while ((line = sr.ReadLine()) != null)   						{  							i++;  						}	  						if (i < m_logsizemax) {return;}  					}  					break;  			}
Missing Default,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following switch statement is missing a default case: switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}
Missing Default,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,SetLogPath,The following switch statement is missing a default case: switch (m_logperiod)  				{  					case elogperiod.day:  						sPeriod = dt.ToString("yyyyMMdd");  						break;  					case elogperiod.week:  						string week = GetWeek();  						sPeriod = dt.ToString("yyyyweek" + week);  						break;  					case elogperiod.month:  						sPeriod = dt.ToString("yyyyMM");  						break;  				}
Missing Default,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,SetLogPath,The following switch statement is missing a default case: switch (m_lognameformat)  				{  					case elognameformat.date_name:  						sLogName = sPeriod + "_" + m_logfilename;  						break;  					case elognameformat.name_date:  						sLogName = m_logfilename + "_" + sPeriod;  						break;  				}
Missing Default,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,LogThis,The following switch statement is missing a default case: switch (logprefix)  				{  					case elogprefix.dt:  						logtext = dt.ToString("yyyy.MM.dd") + "-" + dt.ToString("hh.mm.ss") + ": " + logtext;  						break;  					case elogprefix.loglevel:  						logtext = loglevel.ToString() + ": " + logtext;  						break;  					case elogprefix.dt_loglevel:  						logtext = dt.ToString("yyyy.MM.dd") + "-" + dt.ToString("hh.mm.ss") + ":" + loglevel + ": " + logtext;  						break;  				}
Missing Default,LogThis,LogMethods,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,LogThis,The following switch statement is missing a default case: switch (m_logwhere)  				{  					case elogwhere.file:  						AppendToFile(sFilePath'logtext);  						break;  					case elogwhere.eventlog:  						LogEvent(logtext'loglevel);  						break;  					case elogwhere.eventlog_and_file:  						AppendToFile(sFilePath'logtext);  						LogEvent(logtext'loglevel);  						break;  				}
