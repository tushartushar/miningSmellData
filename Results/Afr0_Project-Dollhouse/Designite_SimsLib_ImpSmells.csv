Implementation smell,Namespace,Class,File,Method,Description
Long Method,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The method has 109 lines of code.
Long Method,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The method has 158 lines of code.
Long Method,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The method has 181 lines of code.
Long Method,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The method has 102 lines of code.
Complex Method,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,Cyclomatic complexity of the method is 17
Complex Method,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,Cyclomatic complexity of the method is 9
Long Parameter List,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,ArrayCopy2,The method has 5 parameters. Parameters: Src' SrcPos' Dest' DestPos' Length
Long Statement,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,StoreOnGPU,The length of the statement  "            GPUBlendVertexBuffer = new DynamicVertexBuffer(device' MeshVertex.SizeInBytes * BlendVertexBuffer.Length' BufferUsage.None); " is 124.
Long Statement,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,StoreOnGPU,The length of the statement  "            GPUIndexBuffer = new IndexBuffer(device' sizeof(short) * IndexBuffer.Length' BufferUsage.None' IndexElementSize.SixteenBits); " is 125.
Long Statement,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,DrawGeometry,The length of the statement  "                gd.DrawUserIndexedPrimitives(PrimitiveType.TriangleList' BlendVertexBuffer' 0' BlendVertexBuffer.Length' IndexBuffer' 0' NumPrimitives); " is 136.
Long Statement,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,Draw,The length of the statement  "            gd.DrawUserIndexedPrimitives(PrimitiveType.TriangleList' BlendVertexBuffer' 0' BlendVertexBuffer.Length' IndexBuffer' 0' NumPrimitives); " is 136.
Long Statement,SimsLib.IFF,SLOT,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The length of the statement  "                /** The span for version 4 is 34.  The span for version 6 is 54.  The span for version 7 is 58.  The span for version 8 is 62.  The span for version 9 is 66.  The span for version 10 is 70.  **/ " is 194.
Long Statement,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The length of the statement  "                    /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/ " is 171.
Long Statement,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The length of the statement  "			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) " is 133.
Long Statement,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetItemByID,The length of the statement  "            //Far3Entry Entry = Array.Find(entries' delegate(Far3Entry entry) { return entry.FileID == FileID && entry.TypeID == TypeID; }); " is 128.
Long Statement,LogThis,Log,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,LogHeader,The length of the statement  "					sHeader = "======(" + System.AppDomain.CurrentDomain.FriendlyName + ") ====  " + sText + "============ Date:" + dt.ToString("yyyyMMdd") + " Time:" + dt.ToString("hh:mm:ss") ; " is 174.
Long Statement,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetWeek,The length of the statement  "			//Console.WriteLine( "There are {0} weeks in the current year ({1})."' myCal.GetWeekOfYear( LastDay' myCWR' myFirstDOW )' LastDay.Year ); " is 137.
Long Statement,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The length of the statement  "                    m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)]; " is 139.
Empty Catch Block,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,AppendToFile,The method has an empty catch block.
Magic Number,SimsLib.ThreeD,Binding,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Binding.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream))              {                  var version = io.ReadUInt32();                  if (version != 1)                  {                      throw new Exception("Unknown binding version");                  }                    Bone = io.ReadPascalString();                  var meshType = io.ReadUInt32();                  if (meshType == 8)                  {                      this.MeshGroupID = io.ReadUInt32();                      this.MeshFileID = io.ReadUInt32();                      this.MeshTypeID = io.ReadUInt32();                  }                    var textureType = io.ReadUInt32();                  if (textureType == 8)                  {                      this.TextureGroupID = io.ReadUInt32();                      this.TextureFileID = io.ReadUInt32();                      this.TextureTypeID = io.ReadUInt32();                  }              }
Magic Number,SimsLib.ThreeD,Binding,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Binding.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream))              {                  var version = io.ReadUInt32();                  if (version != 1)                  {                      throw new Exception("Unknown binding version");                  }                    Bone = io.ReadPascalString();                  var meshType = io.ReadUInt32();                  if (meshType == 8)                  {                      this.MeshGroupID = io.ReadUInt32();                      this.MeshFileID = io.ReadUInt32();                      this.MeshTypeID = io.ReadUInt32();                  }                    var textureType = io.ReadUInt32();                  if (textureType == 8)                  {                      this.TextureGroupID = io.ReadUInt32();                      this.TextureFileID = io.ReadUInt32();                      this.TextureTypeID = io.ReadUInt32();                  }              }
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,Lightmaps,The following statement contains a magic number: if (Data.Length != 2271104)                  throw new Exception("Invalid 'lightmap.dat' - Lightmap.cs!");
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: Writer.Write((uint)(m_Lights[Index].Width * m_Lights[Index].Height * 3 + 54));
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: Writer.Write((uint)(m_Lights[Index].Width * m_Lights[Index].Height * 3 + 54));
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: Writer.Write((uint)(m_Lights[Index].Width * m_Lights[Index].Height * 3));
Magic Number,SimsLib.ThreeD,Lightmaps,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Lightmaps.cs,GetLightmap,The following statement contains a magic number: for (int i = 0; i < m_Lights[Index].Width * m_Lights[Index].Height; i++)              {                  for (int j = 0; j < 3; j++)                      Writer.Write(Reader.ReadByte());              }
Magic Number,SimsLib.ThreeD,Mesh,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Mesh.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream))              {                  var version = io.ReadInt32();                  var boneCount = io.ReadInt32();                  var boneNames = new string[boneCount];                  for (var i = 0; i < boneCount; i++)                  {                      boneNames[i] = io.ReadPascalString();                  }                    var faceCount = io.ReadInt32();                  NumPrimitives = faceCount;                    IndexBuffer = new short[faceCount * 3];                  int offset = 0;                  for (var i = 0; i < faceCount; i++)                  {                      IndexBuffer[offset++] = (short)io.ReadInt32();                      IndexBuffer[offset++] = (short)io.ReadInt32();                      IndexBuffer[offset++] = (short)io.ReadInt32();                  }                    /** Bone bindings **/                  var bindingCount = io.ReadInt32();                  BoneBindings = new BoneBinding[bindingCount];                  for (var i = 0; i < bindingCount; i++)                  {                      BoneBindings[i] = new BoneBinding                      {                          BoneIndex = io.ReadInt32()'                          FirstRealVertex = io.ReadInt32()'                          RealVertexCount = io.ReadInt32()'                          FirstBlendVertex = io.ReadInt32()'                          BlendVertexCount = io.ReadInt32()                      };                        BoneBindings[i].BoneName = boneNames[BoneBindings[i].BoneIndex];                  }                    var realVertexCount = io.ReadInt32();                  RealVertexBuffer = new MeshVertex[realVertexCount];                    for (var i = 0; i < realVertexCount; i++)                  {                      RealVertexBuffer[i].UV.X = io.ReadFloat();                      RealVertexBuffer[i].UV.Y = io.ReadFloat();                  }                    /** Blend data **/                  var blendVertexCount = io.ReadInt32();                  BlendData = new BlendData[blendVertexCount];                  for (var i = 0; i < blendVertexCount; i++)                  {                      BlendData[i] = new BlendData                      {                          Weight = (float)io.ReadInt32() / 0x8000'                          OtherVertex = io.ReadInt32()                      };                  }                    var realVertexCount2 = io.ReadInt32();                  BlendVertexBuffer = new MeshVertex[realVertexCount];                    for (int i = 0; i < realVertexCount; i++)                  {                      RealVertexBuffer[i].Position = new Microsoft.Xna.Framework.Vector3(                          -io.ReadFloat()'                          io.ReadFloat()'                          io.ReadFloat()                      );                        BlendVertexBuffer[i].Position = RealVertexBuffer[i].Position;                      BlendVertexBuffer[i].Normal = new Microsoft.Xna.Framework.Vector3(                          -io.ReadFloat()'                          io.ReadFloat()'                          io.ReadFloat()                      );                      BlendVertexBuffer[i].UV = RealVertexBuffer[i].UV;                  }              }
Magic Number,SimsLib.ThreeD,Outfit,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Outfit.cs,GetAppearance,The following statement contains a magic number: switch (type)              {                  case AppearanceType.Light:                      return (ulong)LightAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Medium:                      return (ulong)MediumAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Dark:                      return (ulong)DarkAppearanceFileID << 32 | LightAppearanceTypeID;              }
Magic Number,SimsLib.ThreeD,Outfit,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Outfit.cs,GetAppearance,The following statement contains a magic number: switch (type)              {                  case AppearanceType.Light:                      return (ulong)LightAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Medium:                      return (ulong)MediumAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Dark:                      return (ulong)DarkAppearanceFileID << 32 | LightAppearanceTypeID;              }
Magic Number,SimsLib.ThreeD,Outfit,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Outfit.cs,GetAppearance,The following statement contains a magic number: switch (type)              {                  case AppearanceType.Light:                      return (ulong)LightAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Medium:                      return (ulong)MediumAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Dark:                      return (ulong)DarkAppearanceFileID << 32 | LightAppearanceTypeID;              }
Magic Number,SimsLib,Endian,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,SimsLib,Endian,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,SimsLib,Endian,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,SimsLib,Endian,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,SimsLib,IoBuffer,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: var m_buffer = Reader.ReadBytes(4);
Magic Number,SimsLib,IoBuffer,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib,IoBuffer,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib,IoBuffer,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib,IoBuffer,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib,IoBuffer,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IOBuffer.cs,ReadFloat,The following statement contains a magic number: uint tmpBuffer = (uint)(m_buffer[0] | m_buffer[1] << 8 | m_buffer[2] << 16 | m_buffer[3] << 24);
Magic Number,SimsLib.HIT,TLO,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\HIT\TLO.cs,TLO,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,SimsLib.HIT,TLO,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\HIT\TLO.cs,TLO,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,SimsLib.HIT,Track,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\HIT\Track.cs,Track,The following statement contains a magic number: m_Label = Values[2];
Magic Number,SimsLib.HIT,Track,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\HIT\Track.cs,Track,The following statement contains a magic number: m_TrackID = Values[4];
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\BHAV.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version = io.ReadUInt16();                  uint count = 0;                    if (version == 0x8000)                  {                      count = io.ReadUInt16();                      io.Skip(8);                  }                  else if (version == 0x8001)                  {                      count = io.ReadUInt16();                      var unknown = io.ReadBytes(8);                  }                  else if (version == 0x8002)                  {                      count = io.ReadUInt16();                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadUInt16();                      this.Flags = io.ReadUInt16();                      io.Skip(2);                  }                  else if (version == 0x8003)                  {                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadByte();                      io.Skip(2);                      this.Flags = io.ReadUInt16();                      count = io.ReadUInt32();                  }                    Instructions = new BHAVInstruction[count];                  for (var i = 0; i < count; i++)                  {                      var instruction = new BHAVInstruction();                      instruction.Opcode = io.ReadUInt16();                      instruction.TruePointer = io.ReadByte();                      instruction.FalsePointer = io.ReadByte();                      instruction.Operand = io.ReadBytes(8);                      Instructions[i] = instruction;                  }              }
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\BHAV.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version = io.ReadUInt16();                  uint count = 0;                    if (version == 0x8000)                  {                      count = io.ReadUInt16();                      io.Skip(8);                  }                  else if (version == 0x8001)                  {                      count = io.ReadUInt16();                      var unknown = io.ReadBytes(8);                  }                  else if (version == 0x8002)                  {                      count = io.ReadUInt16();                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadUInt16();                      this.Flags = io.ReadUInt16();                      io.Skip(2);                  }                  else if (version == 0x8003)                  {                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadByte();                      io.Skip(2);                      this.Flags = io.ReadUInt16();                      count = io.ReadUInt32();                  }                    Instructions = new BHAVInstruction[count];                  for (var i = 0; i < count; i++)                  {                      var instruction = new BHAVInstruction();                      instruction.Opcode = io.ReadUInt16();                      instruction.TruePointer = io.ReadByte();                      instruction.FalsePointer = io.ReadByte();                      instruction.Operand = io.ReadBytes(8);                      Instructions[i] = instruction;                  }              }
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\BHAV.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version = io.ReadUInt16();                  uint count = 0;                    if (version == 0x8000)                  {                      count = io.ReadUInt16();                      io.Skip(8);                  }                  else if (version == 0x8001)                  {                      count = io.ReadUInt16();                      var unknown = io.ReadBytes(8);                  }                  else if (version == 0x8002)                  {                      count = io.ReadUInt16();                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadUInt16();                      this.Flags = io.ReadUInt16();                      io.Skip(2);                  }                  else if (version == 0x8003)                  {                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadByte();                      io.Skip(2);                      this.Flags = io.ReadUInt16();                      count = io.ReadUInt32();                  }                    Instructions = new BHAVInstruction[count];                  for (var i = 0; i < count; i++)                  {                      var instruction = new BHAVInstruction();                      instruction.Opcode = io.ReadUInt16();                      instruction.TruePointer = io.ReadByte();                      instruction.FalsePointer = io.ReadByte();                      instruction.Operand = io.ReadBytes(8);                      Instructions[i] = instruction;                  }              }
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\BHAV.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version = io.ReadUInt16();                  uint count = 0;                    if (version == 0x8000)                  {                      count = io.ReadUInt16();                      io.Skip(8);                  }                  else if (version == 0x8001)                  {                      count = io.ReadUInt16();                      var unknown = io.ReadBytes(8);                  }                  else if (version == 0x8002)                  {                      count = io.ReadUInt16();                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadUInt16();                      this.Flags = io.ReadUInt16();                      io.Skip(2);                  }                  else if (version == 0x8003)                  {                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadByte();                      io.Skip(2);                      this.Flags = io.ReadUInt16();                      count = io.ReadUInt32();                  }                    Instructions = new BHAVInstruction[count];                  for (var i = 0; i < count; i++)                  {                      var instruction = new BHAVInstruction();                      instruction.Opcode = io.ReadUInt16();                      instruction.TruePointer = io.ReadByte();                      instruction.FalsePointer = io.ReadByte();                      instruction.Operand = io.ReadBytes(8);                      Instructions[i] = instruction;                  }              }
Magic Number,SimsLib.IFF,BHAV,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\BHAV.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version = io.ReadUInt16();                  uint count = 0;                    if (version == 0x8000)                  {                      count = io.ReadUInt16();                      io.Skip(8);                  }                  else if (version == 0x8001)                  {                      count = io.ReadUInt16();                      var unknown = io.ReadBytes(8);                  }                  else if (version == 0x8002)                  {                      count = io.ReadUInt16();                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadUInt16();                      this.Flags = io.ReadUInt16();                      io.Skip(2);                  }                  else if (version == 0x8003)                  {                      this.Type = io.ReadByte();                      this.Args = io.ReadByte();                      this.Locals = io.ReadByte();                      io.Skip(2);                      this.Flags = io.ReadUInt16();                      count = io.ReadUInt32();                  }                    Instructions = new BHAVInstruction[count];                  for (var i = 0; i < count; i++)                  {                      var instruction = new BHAVInstruction();                      instruction.Opcode = io.ReadUInt16();                      instruction.TruePointer = io.ReadByte();                      instruction.FalsePointer = io.ReadByte();                      instruction.Operand = io.ReadBytes(8);                      Instructions[i] = instruction;                  }              }
Magic Number,SimsLib.IFF,DGRP,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version = io.ReadUInt16();                  uint imageCount = version < 20003 ? io.ReadUInt16() : io.ReadUInt32();                  Images = new DGRPImage[imageCount];                    for (var i = 0; i < imageCount; i++)                  {                      var image = new DGRPImage(this);                      image.Read(version' io);                      Images[i] = image;                  }              }
Magic Number,SimsLib.IFF,DGRPImage,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,Read,The following statement contains a magic number: if (version < 20003)              {                  spriteCount = io.ReadUInt16();                  Direction = io.ReadByte();                  Zoom = io.ReadByte();              }              else              {                  Direction = io.ReadUInt32();                  Zoom = io.ReadUInt32();                  spriteCount = io.ReadUInt32();              }
Magic Number,SimsLib.IFF,DGRPSprite,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,Read,The following statement contains a magic number: if (version < 20003)              {                  //Unknown ignored "Type" field                  var type = io.ReadUInt16();                  SpriteID = io.ReadUInt16();                  SpriteFrameIndex = io.ReadUInt16();                    var flagsRaw = io.ReadUInt16();                  Flags = (DGRPSpriteFlags)flagsRaw;                    SpriteOffset.X = io.ReadInt16();                  SpriteOffset.Y = io.ReadInt16();                    if (version == 20001)                  {                      ObjectOffset.Z = io.ReadFloat();                  }              }              else              {                  SpriteID = io.ReadUInt32();                  SpriteFrameIndex = io.ReadUInt32();                  SpriteOffset.X = io.ReadInt32();                  SpriteOffset.Y = io.ReadInt32();                  ObjectOffset.Z = io.ReadFloat();                  Flags = (DGRPSpriteFlags)io.ReadUInt32();                  if (version == 20004)                  {                      ObjectOffset.X = io.ReadFloat();                      ObjectOffset.Y = io.ReadFloat();                  }              }
Magic Number,SimsLib.IFF,DGRPSprite,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,Read,The following statement contains a magic number: if (version < 20003)              {                  //Unknown ignored "Type" field                  var type = io.ReadUInt16();                  SpriteID = io.ReadUInt16();                  SpriteFrameIndex = io.ReadUInt16();                    var flagsRaw = io.ReadUInt16();                  Flags = (DGRPSpriteFlags)flagsRaw;                    SpriteOffset.X = io.ReadInt16();                  SpriteOffset.Y = io.ReadInt16();                    if (version == 20001)                  {                      ObjectOffset.Z = io.ReadFloat();                  }              }              else              {                  SpriteID = io.ReadUInt32();                  SpriteFrameIndex = io.ReadUInt32();                  SpriteOffset.X = io.ReadInt32();                  SpriteOffset.Y = io.ReadInt32();                  ObjectOffset.Z = io.ReadFloat();                  Flags = (DGRPSpriteFlags)io.ReadUInt32();                  if (version == 20004)                  {                      ObjectOffset.X = io.ReadFloat();                      ObjectOffset.Y = io.ReadFloat();                  }              }
Magic Number,SimsLib.IFF,DGRPSprite,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,Read,The following statement contains a magic number: if (version < 20003)              {                  //Unknown ignored "Type" field                  var type = io.ReadUInt16();                  SpriteID = io.ReadUInt16();                  SpriteFrameIndex = io.ReadUInt16();                    var flagsRaw = io.ReadUInt16();                  Flags = (DGRPSpriteFlags)flagsRaw;                    SpriteOffset.X = io.ReadInt16();                  SpriteOffset.Y = io.ReadInt16();                    if (version == 20001)                  {                      ObjectOffset.Z = io.ReadFloat();                  }              }              else              {                  SpriteID = io.ReadUInt32();                  SpriteFrameIndex = io.ReadUInt32();                  SpriteOffset.X = io.ReadInt32();                  SpriteOffset.Y = io.ReadInt32();                  ObjectOffset.Z = io.ReadFloat();                  Flags = (DGRPSpriteFlags)io.ReadUInt32();                  if (version == 20004)                  {                      ObjectOffset.X = io.ReadFloat();                      ObjectOffset.Y = io.ReadFloat();                  }              }
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\IFF.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.BIG_ENDIAN))              {                  var identifier = io.ReadChars(60' false).Replace("\0"' "");                  if (identifier != "IFF FILE 2.5:TYPE FOLLOWED BY SIZE JAMIE DOORNBOS & MAXIS 1")                  {                      throw new Exception("Invalid iff file!");                  }                    var rsmpOffset = io.ReadUInt32();                    while (io.HasMore)                  {                      var chunkType = io.ReadChars(4);                      var chunkSize = io.ReadUInt32();                      var chunkID = io.ReadUInt16();                      var chunkFlags = io.ReadUInt16();                      var chunkLabel = io.ReadChars(64);                      var chunkDataSize = chunkSize - 76;                        /** Do we understand this chunk type? **/                      if (!CHUNK_TYPES.ContainsKey(chunkType))                      {                          /** Skip it! **/                          io.Skip(chunkDataSize);                      }                      else                      {                          Type chunkClass = CHUNK_TYPES[chunkType];                          AbstractIffChunk newChunk = (AbstractIffChunk)Activator.CreateInstance(chunkClass);                          newChunk.ChunkID = chunkID;                          newChunk.ChunkFlags = chunkFlags;                          newChunk.ChunkLabel = chunkLabel;                          newChunk.ChunkData = io.ReadBytes(chunkDataSize);                          newChunk.ChunkParent = this;                            if (!ByChunkType.ContainsKey(chunkClass))                          {                              ByChunkType.Add(chunkClass' new List<object>());                          }                          if (!ByChunkId.ContainsKey(chunkClass))                          {                              ByChunkId.Add(chunkClass' new Dictionary<ushort' object>());                          }                            ByChunkType[chunkClass].Add(newChunk);                          //if (chunkID != 0){                          ByChunkId[chunkClass].Add(chunkID' newChunk);                          //}                      }                  }              }
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\IFF.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.BIG_ENDIAN))              {                  var identifier = io.ReadChars(60' false).Replace("\0"' "");                  if (identifier != "IFF FILE 2.5:TYPE FOLLOWED BY SIZE JAMIE DOORNBOS & MAXIS 1")                  {                      throw new Exception("Invalid iff file!");                  }                    var rsmpOffset = io.ReadUInt32();                    while (io.HasMore)                  {                      var chunkType = io.ReadChars(4);                      var chunkSize = io.ReadUInt32();                      var chunkID = io.ReadUInt16();                      var chunkFlags = io.ReadUInt16();                      var chunkLabel = io.ReadChars(64);                      var chunkDataSize = chunkSize - 76;                        /** Do we understand this chunk type? **/                      if (!CHUNK_TYPES.ContainsKey(chunkType))                      {                          /** Skip it! **/                          io.Skip(chunkDataSize);                      }                      else                      {                          Type chunkClass = CHUNK_TYPES[chunkType];                          AbstractIffChunk newChunk = (AbstractIffChunk)Activator.CreateInstance(chunkClass);                          newChunk.ChunkID = chunkID;                          newChunk.ChunkFlags = chunkFlags;                          newChunk.ChunkLabel = chunkLabel;                          newChunk.ChunkData = io.ReadBytes(chunkDataSize);                          newChunk.ChunkParent = this;                            if (!ByChunkType.ContainsKey(chunkClass))                          {                              ByChunkType.Add(chunkClass' new List<object>());                          }                          if (!ByChunkId.ContainsKey(chunkClass))                          {                              ByChunkId.Add(chunkClass' new Dictionary<ushort' object>());                          }                            ByChunkType[chunkClass].Add(newChunk);                          //if (chunkID != 0){                          ByChunkId[chunkClass].Add(chunkID' newChunk);                          //}                      }                  }              }
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\IFF.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.BIG_ENDIAN))              {                  var identifier = io.ReadChars(60' false).Replace("\0"' "");                  if (identifier != "IFF FILE 2.5:TYPE FOLLOWED BY SIZE JAMIE DOORNBOS & MAXIS 1")                  {                      throw new Exception("Invalid iff file!");                  }                    var rsmpOffset = io.ReadUInt32();                    while (io.HasMore)                  {                      var chunkType = io.ReadChars(4);                      var chunkSize = io.ReadUInt32();                      var chunkID = io.ReadUInt16();                      var chunkFlags = io.ReadUInt16();                      var chunkLabel = io.ReadChars(64);                      var chunkDataSize = chunkSize - 76;                        /** Do we understand this chunk type? **/                      if (!CHUNK_TYPES.ContainsKey(chunkType))                      {                          /** Skip it! **/                          io.Skip(chunkDataSize);                      }                      else                      {                          Type chunkClass = CHUNK_TYPES[chunkType];                          AbstractIffChunk newChunk = (AbstractIffChunk)Activator.CreateInstance(chunkClass);                          newChunk.ChunkID = chunkID;                          newChunk.ChunkFlags = chunkFlags;                          newChunk.ChunkLabel = chunkLabel;                          newChunk.ChunkData = io.ReadBytes(chunkDataSize);                          newChunk.ChunkParent = this;                            if (!ByChunkType.ContainsKey(chunkClass))                          {                              ByChunkType.Add(chunkClass' new List<object>());                          }                          if (!ByChunkId.ContainsKey(chunkClass))                          {                              ByChunkId.Add(chunkClass' new Dictionary<ushort' object>());                          }                            ByChunkType[chunkClass].Add(newChunk);                          //if (chunkID != 0){                          ByChunkId[chunkClass].Add(chunkID' newChunk);                          //}                      }                  }              }
Magic Number,SimsLib.IFF,Iff,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\IFF.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.BIG_ENDIAN))              {                  var identifier = io.ReadChars(60' false).Replace("\0"' "");                  if (identifier != "IFF FILE 2.5:TYPE FOLLOWED BY SIZE JAMIE DOORNBOS & MAXIS 1")                  {                      throw new Exception("Invalid iff file!");                  }                    var rsmpOffset = io.ReadUInt32();                    while (io.HasMore)                  {                      var chunkType = io.ReadChars(4);                      var chunkSize = io.ReadUInt32();                      var chunkID = io.ReadUInt16();                      var chunkFlags = io.ReadUInt16();                      var chunkLabel = io.ReadChars(64);                      var chunkDataSize = chunkSize - 76;                        /** Do we understand this chunk type? **/                      if (!CHUNK_TYPES.ContainsKey(chunkType))                      {                          /** Skip it! **/                          io.Skip(chunkDataSize);                      }                      else                      {                          Type chunkClass = CHUNK_TYPES[chunkType];                          AbstractIffChunk newChunk = (AbstractIffChunk)Activator.CreateInstance(chunkClass);                          newChunk.ChunkID = chunkID;                          newChunk.ChunkFlags = chunkFlags;                          newChunk.ChunkLabel = chunkLabel;                          newChunk.ChunkData = io.ReadBytes(chunkDataSize);                          newChunk.ChunkParent = this;                            if (!ByChunkType.ContainsKey(chunkClass))                          {                              ByChunkType.Add(chunkClass' new List<object>());                          }                          if (!ByChunkId.ContainsKey(chunkClass))                          {                              ByChunkId.Add(chunkClass' new Dictionary<ushort' object>());                          }                            ByChunkType[chunkClass].Add(newChunk);                          //if (chunkID != 0){                          ByChunkId[chunkClass].Add(chunkID' newChunk);                          //}                      }                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\OBJD.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  this.Version = io.ReadUInt32();                    /**136 (80 fields)                      138a (95 fields) - Used for The Sims 1 base game objects?                      138b (108 fields) - Used for The Sims 1 expansion objects?                      139 (96 fields)                      140 (97 fields)                      141 (97 fields)                      142 (105 fields)**/                  var numFields = 80;                  if (Version == 138)                  {                      numFields = 95;                  }                  else if (Version == 139)                  {                      numFields = 96;                  }                  else if (Version == 140)                  {                      numFields = 97;                  }                  else if (Version == 141)                  {                      numFields = 97;                  }                  else if (Version == 142)                  {                      numFields = 105;                  }                    numFields -= 2;                  RawData = new ushort[numFields];                  io.Mark();                    for (var i = 0; i < numFields; i++)                  {                      RawData[i] = io.ReadUInt16();                  }                    io.SeekFromMark(0);                    this.StackSize = io.ReadUInt16();                  this.BaseGraphicID = io.ReadUInt16();                  this.NumGraphics = io.ReadUInt16();                  this.BHAV_MainID = io.ReadUInt16();                  this.BHAV_GardeningID = io.ReadUInt16();                  this.TreeTableID = io.ReadUInt16();                  this.InteractionGroupID = io.ReadUInt16();                  this.ObjectType = (OBJDType)io.ReadUInt16();                  this.MasterID = io.ReadUInt16();                  this.SubIndex = io.ReadUInt16();                  this.BHAV_WashHandsID = io.ReadUInt16();                  this.AnimationTableID = io.ReadUInt16();                  this.GUID = io.ReadUInt32();                  this.Disabled = io.ReadUInt16();                  this.OldTreeID = io.ReadUInt16();                  this.Price = io.ReadUInt16();                  this.BodyStringID = io.ReadUInt16();                  this.SlotID = io.ReadUInt16();                  this.BHAV_AllowIntersectionID = io.ReadUInt16();                  this.UsesInTable = io.ReadUInt16();                  this.BitField1 = io.ReadUInt16();                  this.BHAV_PrepareFoodID = io.ReadUInt16();                  this.BHAV_CookFoodID = io.ReadUInt16();                  this.BHAV_PlaceSurfaceID = io.ReadUInt16();                  this.BHAV_DisposeID = io.ReadUInt16();                  this.BHAV_EatID = io.ReadUInt16();                  this.BHAV_PickupID = io.ReadUInt16();                  this.BHAV_WashDishID = io.ReadUInt16();                  this.BHAV_EatSurfaceID = io.ReadUInt16();                  this.BHAV_SitID = io.ReadUInt16();                  this.BHAV_StandID = io.ReadUInt16();                    this.SalePrice = io.ReadUInt16();                  this.InitialDepreciation = io.ReadUInt16();                  this.DailyDepreciation = io.ReadUInt16();                  this.SelfDepreciating = io.ReadUInt16();                  this.DepreciationLimit = io.ReadUInt16();                  this.RoomFlags = io.ReadUInt16();                  this.FunctionFlags = io.ReadUInt16();                  this.CatalogStringsID = io.ReadUInt16();                    this.Global = io.ReadUInt16();                  this.BHAV_Init = io.ReadUInt16();                  this.BHAV_Place = io.ReadUInt16();                  this.BHAV_UserPickup = io.ReadUInt16();                  this.WallStyle = io.ReadUInt16();                  this.BHAV_Load = io.ReadUInt16();                  this.BHAV_UserPlace = io.ReadUInt16();                  this.ObjectVersion = io.ReadUInt16();                  this.BHAV_RoomChange = io.ReadUInt16();                  this.MotiveEffectsID = io.ReadUInt16();                  this.BHAV_Cleanup = io.ReadUInt16();                  this.BHAV_LevelInfo = io.ReadUInt16();                  this.CatalogID = io.ReadUInt16();                  this.BHAV_ServingSurface = io.ReadUInt16();                  this.LevelOffset = io.ReadUInt16();                  this.Shadow = io.ReadUInt16();                  this.NumAttributes = io.ReadUInt16();                    this.BHAV_Clean = io.ReadUInt16();                  this.BHAV_QueueSkipped = io.ReadUInt16();                  this.FrontDirection = io.ReadUInt16();                  this.BHAV_WallAdjacencyChanged = io.ReadUInt16();                  this.MyLeadObject = io.ReadUInt16();                  this.DynamicSpriteBaseId = io.ReadUInt16();                  this.NumDynamicSprites = io.ReadUInt16();                    if (this.NumAttributes == 0 && ObjectType != OBJDType.Portal)                  {                      System.Diagnostics.Debug.WriteLine(GUID.ToString("x"));                  }              }
Magic Number,SimsLib.IFF,PALT,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\PALT.cs,PALT,The following statement contains a magic number: Colors = new Color[256];
Magic Number,SimsLib.IFF,PALT,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\PALT.cs,PALT,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  Colors[i] = color;              }
Magic Number,SimsLib.IFF,PALT,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\PALT.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version = io.ReadUInt32();                  var numEntries = io.ReadUInt32();                  var reserved = io.ReadBytes(8);                    Colors = new Color[numEntries];                  for (var i = 0; i < numEntries; i++)                  {                      var r = io.ReadByte();                      var g = io.ReadByte();                      var b = io.ReadByte();                      Colors[i] = new Color(r' g' b);                  }              }
Magic Number,SimsLib.IFF,SLOT,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var zero = io.ReadUInt32();                  var version = io.ReadUInt32();                  var slotMagic = io.ReadBytes(4);                  var numSlots = io.ReadUInt32();                    Slots = new SLOTItem[numSlots];                    /** The span for version 4 is 34.  The span for version 6 is 54.  The span for version 7 is 58.  The span for version 8 is 62.  The span for version 9 is 66.  The span for version 10 is 70.  **/                  for (var i = 0; i < numSlots; i++)                  {                      io.Mark();                        var item = new SLOTItem();                      item.Type = io.ReadUInt16();                      item.Offset = new Vector3(                          io.ReadFloat()'                          io.ReadFloat()'                          io.ReadFloat()                      );                        var standing = io.ReadInt32();                      var sitting = io.ReadInt32();                      var ground = io.ReadInt32();                      var rsflags = io.ReadInt32();                      var snaptargetslot = io.ReadInt32();                      var minproximity = io.ReadInt32();                        item.Standing = standing;                      item.Sitting = sitting;                      item.Ground = ground;                      item.Rsflags = (SLOTFlags)rsflags;                      item.SnapTargetSlot = snaptargetslot;                      item.MinProximity = minproximity;                        if (version >= 6)                      {                          var maxproximity = io.ReadInt32();                          var optimalproximity = io.ReadInt32();                          var i9 = io.ReadInt32();                          var i10 = io.ReadInt32();                          var gradient = io.ReadFloat();                            item.MaxProximity = maxproximity;                          item.OptimalProximity = optimalproximity;                          item.Gradient = gradient;                      }                        if (version >= 7)                      {                          var i11 = io.ReadInt32();                      }                        if (version >= 8)                      {                          var facing = io.ReadInt32();                          var resolution = io.ReadInt32();                      }                        Slots[i] = item;                  }              }
Magic Number,SimsLib.IFF,SLOT,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var zero = io.ReadUInt32();                  var version = io.ReadUInt32();                  var slotMagic = io.ReadBytes(4);                  var numSlots = io.ReadUInt32();                    Slots = new SLOTItem[numSlots];                    /** The span for version 4 is 34.  The span for version 6 is 54.  The span for version 7 is 58.  The span for version 8 is 62.  The span for version 9 is 66.  The span for version 10 is 70.  **/                  for (var i = 0; i < numSlots; i++)                  {                      io.Mark();                        var item = new SLOTItem();                      item.Type = io.ReadUInt16();                      item.Offset = new Vector3(                          io.ReadFloat()'                          io.ReadFloat()'                          io.ReadFloat()                      );                        var standing = io.ReadInt32();                      var sitting = io.ReadInt32();                      var ground = io.ReadInt32();                      var rsflags = io.ReadInt32();                      var snaptargetslot = io.ReadInt32();                      var minproximity = io.ReadInt32();                        item.Standing = standing;                      item.Sitting = sitting;                      item.Ground = ground;                      item.Rsflags = (SLOTFlags)rsflags;                      item.SnapTargetSlot = snaptargetslot;                      item.MinProximity = minproximity;                        if (version >= 6)                      {                          var maxproximity = io.ReadInt32();                          var optimalproximity = io.ReadInt32();                          var i9 = io.ReadInt32();                          var i10 = io.ReadInt32();                          var gradient = io.ReadFloat();                            item.MaxProximity = maxproximity;                          item.OptimalProximity = optimalproximity;                          item.Gradient = gradient;                      }                        if (version >= 7)                      {                          var i11 = io.ReadInt32();                      }                        if (version >= 8)                      {                          var facing = io.ReadInt32();                          var resolution = io.ReadInt32();                      }                        Slots[i] = item;                  }              }
Magic Number,SimsLib.IFF,SLOT,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var zero = io.ReadUInt32();                  var version = io.ReadUInt32();                  var slotMagic = io.ReadBytes(4);                  var numSlots = io.ReadUInt32();                    Slots = new SLOTItem[numSlots];                    /** The span for version 4 is 34.  The span for version 6 is 54.  The span for version 7 is 58.  The span for version 8 is 62.  The span for version 9 is 66.  The span for version 10 is 70.  **/                  for (var i = 0; i < numSlots; i++)                  {                      io.Mark();                        var item = new SLOTItem();                      item.Type = io.ReadUInt16();                      item.Offset = new Vector3(                          io.ReadFloat()'                          io.ReadFloat()'                          io.ReadFloat()                      );                        var standing = io.ReadInt32();                      var sitting = io.ReadInt32();                      var ground = io.ReadInt32();                      var rsflags = io.ReadInt32();                      var snaptargetslot = io.ReadInt32();                      var minproximity = io.ReadInt32();                        item.Standing = standing;                      item.Sitting = sitting;                      item.Ground = ground;                      item.Rsflags = (SLOTFlags)rsflags;                      item.SnapTargetSlot = snaptargetslot;                      item.MinProximity = minproximity;                        if (version >= 6)                      {                          var maxproximity = io.ReadInt32();                          var optimalproximity = io.ReadInt32();                          var i9 = io.ReadInt32();                          var i10 = io.ReadInt32();                          var gradient = io.ReadFloat();                            item.MaxProximity = maxproximity;                          item.OptimalProximity = optimalproximity;                          item.Gradient = gradient;                      }                        if (version >= 7)                      {                          var i11 = io.ReadInt32();                      }                        if (version >= 8)                      {                          var facing = io.ReadInt32();                          var resolution = io.ReadInt32();                      }                        Slots[i] = item;                  }              }
Magic Number,SimsLib.IFF,SLOT,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SLOT.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var zero = io.ReadUInt32();                  var version = io.ReadUInt32();                  var slotMagic = io.ReadBytes(4);                  var numSlots = io.ReadUInt32();                    Slots = new SLOTItem[numSlots];                    /** The span for version 4 is 34.  The span for version 6 is 54.  The span for version 7 is 58.  The span for version 8 is 62.  The span for version 9 is 66.  The span for version 10 is 70.  **/                  for (var i = 0; i < numSlots; i++)                  {                      io.Mark();                        var item = new SLOTItem();                      item.Type = io.ReadUInt16();                      item.Offset = new Vector3(                          io.ReadFloat()'                          io.ReadFloat()'                          io.ReadFloat()                      );                        var standing = io.ReadInt32();                      var sitting = io.ReadInt32();                      var ground = io.ReadInt32();                      var rsflags = io.ReadInt32();                      var snaptargetslot = io.ReadInt32();                      var minproximity = io.ReadInt32();                        item.Standing = standing;                      item.Sitting = sitting;                      item.Ground = ground;                      item.Rsflags = (SLOTFlags)rsflags;                      item.SnapTargetSlot = snaptargetslot;                      item.MinProximity = minproximity;                        if (version >= 6)                      {                          var maxproximity = io.ReadInt32();                          var optimalproximity = io.ReadInt32();                          var i9 = io.ReadInt32();                          var i10 = io.ReadInt32();                          var gradient = io.ReadFloat();                            item.MaxProximity = maxproximity;                          item.OptimalProximity = optimalproximity;                          item.Gradient = gradient;                      }                        if (version >= 7)                      {                          var i11 = io.ReadInt32();                      }                        if (version >= 8)                      {                          var facing = io.ReadInt32();                          var resolution = io.ReadInt32();                      }                        Slots[i] = item;                  }              }
Magic Number,SimsLib.IFF,SPR,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version1 = io.ReadUInt16();                  var version2 = io.ReadUInt16();                  uint version = 0;                    if (version1 == 0)                  {                      io.ByteOrder = ByteOrder.BIG_ENDIAN;                      version = version2;                  }                  else                  {                      version = version1;                  }                    var spriteCount = io.ReadUInt32();                  PaletteID = (ushort)io.ReadUInt32();                    Frames = new List<SPRFrame>();                  if (version != 1001)                  {                      var offsetTable = new List<uint>();                      for (var i = 0; i < spriteCount; i++)                      {                          offsetTable.Add(io.ReadUInt32());                      }                      for (var i = 0; i < spriteCount; i++)                      {                          var frame = new SPRFrame(this);                          frame.Read(version' io);                          Frames.Add(frame);                      }                  }                  else                  {                      while (io.HasMore)                      {                          var frame = new SPRFrame(this);                          frame.Read(version' io);                          Frames.Add(frame);                      }                  }              }
Magic Number,SimsLib.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Read,The following statement contains a magic number: if (version == 1001)              {                  var spriteFersion = io.ReadUInt32();                  var size = io.ReadUInt32();                  this.Version = spriteFersion;              }              else              {                  this.Version = version;              }
Magic Number,SimsLib.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var command = io.ReadByte();                  var count = io.ReadByte();                    switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }                }
Magic Number,SimsLib.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var command = io.ReadByte();                  var count = io.ReadByte();                    switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }                }
Magic Number,SimsLib.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var command = io.ReadByte();                  var count = io.ReadByte();                    switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }                }
Magic Number,SimsLib.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var command = io.ReadByte();                  var count = io.ReadByte();                    switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }                }
Magic Number,SimsLib.IFF,SPR2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version = io.ReadUInt32();                  uint spriteCount = 0;                  if (version == 1000)                  {                      spriteCount = io.ReadUInt32();                      DefaultPaletteID = io.ReadUInt32();                      var offsetTable = new uint[spriteCount];                      for (var i = 0; i < spriteCount; i++)                      {                          offsetTable[i] = io.ReadUInt32();                      }                        Frames = new SPR2Frame[spriteCount];                      for (var i = 0; i < spriteCount; i++)                      {                          var frame = new SPR2Frame(this);                          io.Seek(SeekOrigin.Begin' offsetTable[i]);                            frame.Read(version' io);                          Frames[i] = frame;                      }                  }                  else if (version == 1001)                  {                      DefaultPaletteID = io.ReadUInt32();                      spriteCount = io.ReadUInt32();                        Frames = new SPR2Frame[spriteCount];                      for (var i = 0; i < spriteCount; i++)                      {                          var frame = new SPR2Frame(this);                          frame.Read(version' io);                          Frames[i] = frame;                      }                  }                  }
Magic Number,SimsLib.IFF,SPR2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var version = io.ReadUInt32();                  uint spriteCount = 0;                  if (version == 1000)                  {                      spriteCount = io.ReadUInt32();                      DefaultPaletteID = io.ReadUInt32();                      var offsetTable = new uint[spriteCount];                      for (var i = 0; i < spriteCount; i++)                      {                          offsetTable[i] = io.ReadUInt32();                      }                        Frames = new SPR2Frame[spriteCount];                      for (var i = 0; i < spriteCount; i++)                      {                          var frame = new SPR2Frame(this);                          io.Seek(SeekOrigin.Begin' offsetTable[i]);                            frame.Read(version' io);                          Frames[i] = frame;                      }                  }                  else if (version == 1001)                  {                      DefaultPaletteID = io.ReadUInt32();                      spriteCount = io.ReadUInt32();                        Frames = new SPR2Frame[spriteCount];                      for (var i = 0; i < spriteCount; i++)                      {                          var frame = new SPR2Frame(this);                          frame.Read(version' io);                          Frames[i] = frame;                      }                  }                  }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Read,The following statement contains a magic number: if (version == 1001)              {                  var spriteVersion = io.ReadUInt32();                  var spriteSize = io.ReadUInt32();              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following statement contains a magic number: while (!endmarker)              {                  var marker = io.ReadUInt16();                  var command = marker >> 13;                  var count = marker & 0x1FFF;                    switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }                  y++;              }
Magic Number,SimsLib.IFF,STR,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\STR.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var formatCode = io.ReadInt16();                  if (!io.HasMore) { return; }                    if (formatCode == 0)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              Value = io.ReadPascalString()                          };                      }                  }                  else if (formatCode == -1)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              Value = io.ReadNullTerminatedString()                          };                      }                  }                  else if (formatCode == -2)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              Value = io.ReadNullTerminatedString()'                              Comment = io.ReadNullTerminatedString()                          };                      }                  }                  else if (formatCode == -3)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              LanguageCode = (byte)(io.ReadByte() + 1)'                              Value = io.ReadNullTerminatedString()'                              Comment = io.ReadNullTerminatedString()                          };                      }                  }                  else if (formatCode == -4)                  {                      var numLanguageSets = io.ReadByte();                      this.LanguageSets = new STRLanguageSet[numLanguageSets];                        for (var i = 0; i < numLanguageSets; i++)                      {                          var item = new STRLanguageSet();                          var numStringPairs = io.ReadUInt16();                          item.Strings = new STRItem[numStringPairs];                          for (var x = 0; x < numStringPairs; x++)                          {                              item.Strings[x] = new STRItem                              {                                  LanguageCode = (byte)(io.ReadByte() + 1)'                                  Value = io.ReadVariableLengthPascalString()'                                  Comment = io.ReadVariableLengthPascalString()                              };                          }                          this.LanguageSets[i] = item;                      }                  }              }
Magic Number,SimsLib.IFF,STR,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\STR.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var formatCode = io.ReadInt16();                  if (!io.HasMore) { return; }                    if (formatCode == 0)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              Value = io.ReadPascalString()                          };                      }                  }                  else if (formatCode == -1)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              Value = io.ReadNullTerminatedString()                          };                      }                  }                  else if (formatCode == -2)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              Value = io.ReadNullTerminatedString()'                              Comment = io.ReadNullTerminatedString()                          };                      }                  }                  else if (formatCode == -3)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              LanguageCode = (byte)(io.ReadByte() + 1)'                              Value = io.ReadNullTerminatedString()'                              Comment = io.ReadNullTerminatedString()                          };                      }                  }                  else if (formatCode == -4)                  {                      var numLanguageSets = io.ReadByte();                      this.LanguageSets = new STRLanguageSet[numLanguageSets];                        for (var i = 0; i < numLanguageSets; i++)                      {                          var item = new STRLanguageSet();                          var numStringPairs = io.ReadUInt16();                          item.Strings = new STRItem[numStringPairs];                          for (var x = 0; x < numStringPairs; x++)                          {                              item.Strings[x] = new STRItem                              {                                  LanguageCode = (byte)(io.ReadByte() + 1)'                                  Value = io.ReadVariableLengthPascalString()'                                  Comment = io.ReadVariableLengthPascalString()                              };                          }                          this.LanguageSets[i] = item;                      }                  }              }
Magic Number,SimsLib.IFF,STR,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\STR.cs,Read,The following statement contains a magic number: using (var io = IoBuffer.FromStream(stream' ByteOrder.LITTLE_ENDIAN))              {                  var formatCode = io.ReadInt16();                  if (!io.HasMore) { return; }                    if (formatCode == 0)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              Value = io.ReadPascalString()                          };                      }                  }                  else if (formatCode == -1)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              Value = io.ReadNullTerminatedString()                          };                      }                  }                  else if (formatCode == -2)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              Value = io.ReadNullTerminatedString()'                              Comment = io.ReadNullTerminatedString()                          };                      }                  }                  else if (formatCode == -3)                  {                      var numStrings = io.ReadUInt16();                      Strings = new STRItem[numStrings];                      for (var i = 0; i < numStrings; i++)                      {                          Strings[i] = new STRItem                          {                              LanguageCode = (byte)(io.ReadByte() + 1)'                              Value = io.ReadNullTerminatedString()'                              Comment = io.ReadNullTerminatedString()                          };                      }                  }                  else if (formatCode == -4)                  {                      var numLanguageSets = io.ReadByte();                      this.LanguageSets = new STRLanguageSet[numLanguageSets];                        for (var i = 0; i < numLanguageSets; i++)                      {                          var item = new STRLanguageSet();                          var numStringPairs = io.ReadUInt16();                          item.Strings = new STRItem[numStringPairs];                          for (var x = 0; x < numStringPairs; x++)                          {                              item.Strings[x] = new STRItem                              {                                  LanguageCode = (byte)(io.ReadByte() + 1)'                                  Value = io.ReadVariableLengthPascalString()'                                  Comment = io.ReadVariableLengthPascalString()                              };                          }                          this.LanguageSets[i] = item;                      }                  }              }
Magic Number,SimsLib.FAR1,FARArchive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR1\FARArchive.cs,FARArchive,The following statement contains a magic number: string Header = Encoding.ASCII.GetString(m_Reader.ReadBytes(8));
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;                  m_Compressed = false;    	            if (m_CompressedSize < m_DecompressedSize)                      m_Compressed = true;    	            return DataStream.ToArray();              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    m_Compressed = true;                  int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false)              {                  isReadingSomething = true;                    try                  {                      m_Reader = new BinaryReader(File.Open(Path' FileMode.Open' FileAccess.Read' FileShare.Read));                  }                  catch (Exception e)                  {                      throw new FAR3Exception("Could not open the specified archive - " + Path + "! (FAR3Archive())");                  }                    string Header = Encoding.ASCII.GetString(m_Reader.ReadBytes(8));                  uint Version = m_Reader.ReadUInt32();                    if ((Header != "FAR!byAZ") || (Version != 3))                  {                      throw new FAR3Exception("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");                  }                    uint ManifestOffset = m_Reader.ReadUInt32();                  m_ManifestOffset = ManifestOffset;                    m_Reader.BaseStream.Seek(ManifestOffset' SeekOrigin.Begin);                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      Far3Entry Entry = new Far3Entry();                      Entry.DecompressedFileSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      Entry.DataType = m_Reader.ReadByte();                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Compressed = m_Reader.ReadByte();                      Entry.AccessNumber = m_Reader.ReadByte();                      Entry.FilenameLength = m_Reader.ReadUInt16();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Encoding.ASCII.GetString(m_Reader.ReadBytes(Entry.FilenameLength));                        if (!m_Entries.ContainsKey(Entry.Filename))                          m_Entries.Add(Entry.Filename' Entry);                      m_EntriesList.Add(Entry);                        m_EntryByID.Add(Entry.FileID' Entry);                  }                    //Keep the stream open' it helps peformance.                  //m_Reader.Close();                  isReadingSomething = false;              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false)              {                  isReadingSomething = true;                    try                  {                      m_Reader = new BinaryReader(File.Open(Path' FileMode.Open' FileAccess.Read' FileShare.Read));                  }                  catch (Exception e)                  {                      throw new FAR3Exception("Could not open the specified archive - " + Path + "! (FAR3Archive())");                  }                    string Header = Encoding.ASCII.GetString(m_Reader.ReadBytes(8));                  uint Version = m_Reader.ReadUInt32();                    if ((Header != "FAR!byAZ") || (Version != 3))                  {                      throw new FAR3Exception("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");                  }                    uint ManifestOffset = m_Reader.ReadUInt32();                  m_ManifestOffset = ManifestOffset;                    m_Reader.BaseStream.Seek(ManifestOffset' SeekOrigin.Begin);                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      Far3Entry Entry = new Far3Entry();                      Entry.DecompressedFileSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      Entry.DataType = m_Reader.ReadByte();                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Compressed = m_Reader.ReadByte();                      Entry.AccessNumber = m_Reader.ReadByte();                      Entry.FilenameLength = m_Reader.ReadUInt16();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Encoding.ASCII.GetString(m_Reader.ReadBytes(Entry.FilenameLength));                        if (!m_Entries.ContainsKey(Entry.Filename))                          m_Entries.Add(Entry.Filename' Entry);                      m_EntriesList.Add(Entry);                        m_EntryByID.Add(Entry.FileID' Entry);                  }                    //Keep the stream open' it helps peformance.                  //m_Reader.Close();                  isReadingSomething = false;              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false)              {                  isReadingSomething = true;                    try                  {                      m_Reader = new BinaryReader(File.Open(Path' FileMode.Open' FileAccess.Read' FileShare.Read));                  }                  catch (Exception e)                  {                      throw new FAR3Exception("Could not open the specified archive - " + Path + "! (FAR3Archive())");                  }                    string Header = Encoding.ASCII.GetString(m_Reader.ReadBytes(8));                  uint Version = m_Reader.ReadUInt32();                    if ((Header != "FAR!byAZ") || (Version != 3))                  {                      throw new FAR3Exception("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");                  }                    uint ManifestOffset = m_Reader.ReadUInt32();                  m_ManifestOffset = ManifestOffset;                    m_Reader.BaseStream.Seek(ManifestOffset' SeekOrigin.Begin);                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      Far3Entry Entry = new Far3Entry();                      Entry.DecompressedFileSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      Entry.DataType = m_Reader.ReadByte();                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Compressed = m_Reader.ReadByte();                      Entry.AccessNumber = m_Reader.ReadByte();                      Entry.FilenameLength = m_Reader.ReadUInt16();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Encoding.ASCII.GetString(m_Reader.ReadBytes(Entry.FilenameLength));                        if (!m_Entries.ContainsKey(Entry.Filename))                          m_Entries.Add(Entry.Filename' Entry);                      m_EntriesList.Add(Entry);                        m_EntryByID.Add(Entry.FileID' Entry);                  }                    //Keep the stream open' it helps peformance.                  //m_Reader.Close();                  isReadingSomething = false;              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false)              {                  isReadingSomething = true;                    try                  {                      m_Reader = new BinaryReader(File.Open(Path' FileMode.Open' FileAccess.Read' FileShare.Read));                  }                  catch (Exception e)                  {                      throw new FAR3Exception("Could not open the specified archive - " + Path + "! (FAR3Archive())");                  }                    string Header = Encoding.ASCII.GetString(m_Reader.ReadBytes(8));                  uint Version = m_Reader.ReadUInt32();                    if ((Header != "FAR!byAZ") || (Version != 3))                  {                      throw new FAR3Exception("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");                  }                    uint ManifestOffset = m_Reader.ReadUInt32();                  m_ManifestOffset = ManifestOffset;                    m_Reader.BaseStream.Seek(ManifestOffset' SeekOrigin.Begin);                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      Far3Entry Entry = new Far3Entry();                      Entry.DecompressedFileSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      Entry.DataType = m_Reader.ReadByte();                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Compressed = m_Reader.ReadByte();                      Entry.AccessNumber = m_Reader.ReadByte();                      Entry.FilenameLength = m_Reader.ReadUInt16();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Encoding.ASCII.GetString(m_Reader.ReadBytes(Entry.FilenameLength));                        if (!m_Entries.ContainsKey(Entry.Filename))                          m_Entries.Add(Entry.Filename' Entry);                      m_EntriesList.Add(Entry);                        m_EntryByID.Add(Entry.FileID' Entry);                  }                    //Keep the stream open' it helps peformance.                  //m_Reader.Close();                  isReadingSomething = false;              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false)              {                  isReadingSomething = true;                    try                  {                      m_Reader = new BinaryReader(File.Open(Path' FileMode.Open' FileAccess.Read' FileShare.Read));                  }                  catch (Exception e)                  {                      throw new FAR3Exception("Could not open the specified archive - " + Path + "! (FAR3Archive())");                  }                    string Header = Encoding.ASCII.GetString(m_Reader.ReadBytes(8));                  uint Version = m_Reader.ReadUInt32();                    if ((Header != "FAR!byAZ") || (Version != 3))                  {                      throw new FAR3Exception("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");                  }                    uint ManifestOffset = m_Reader.ReadUInt32();                  m_ManifestOffset = ManifestOffset;                    m_Reader.BaseStream.Seek(ManifestOffset' SeekOrigin.Begin);                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      Far3Entry Entry = new Far3Entry();                      Entry.DecompressedFileSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      Entry.DataType = m_Reader.ReadByte();                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Compressed = m_Reader.ReadByte();                      Entry.AccessNumber = m_Reader.ReadByte();                      Entry.FilenameLength = m_Reader.ReadUInt16();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Encoding.ASCII.GetString(m_Reader.ReadBytes(Entry.FilenameLength));                        if (!m_Entries.ContainsKey(Entry.Filename))                          m_Entries.Add(Entry.Filename' Entry);                      m_EntriesList.Add(Entry);                        m_EntryByID.Add(Entry.FileID' Entry);                  }                    //Keep the stream open' it helps peformance.                  //m_Reader.Close();                  isReadingSomething = false;              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,FAR3Archive,The following statement contains a magic number: if (isReadingSomething == false)              {                  isReadingSomething = true;                    try                  {                      m_Reader = new BinaryReader(File.Open(Path' FileMode.Open' FileAccess.Read' FileShare.Read));                  }                  catch (Exception e)                  {                      throw new FAR3Exception("Could not open the specified archive - " + Path + "! (FAR3Archive())");                  }                    string Header = Encoding.ASCII.GetString(m_Reader.ReadBytes(8));                  uint Version = m_Reader.ReadUInt32();                    if ((Header != "FAR!byAZ") || (Version != 3))                  {                      throw new FAR3Exception("Archive wasn't a valid FAR V.3 archive! (FAR3Archive())");                  }                    uint ManifestOffset = m_Reader.ReadUInt32();                  m_ManifestOffset = ManifestOffset;                    m_Reader.BaseStream.Seek(ManifestOffset' SeekOrigin.Begin);                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      Far3Entry Entry = new Far3Entry();                      Entry.DecompressedFileSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      Entry.DataType = m_Reader.ReadByte();                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Compressed = m_Reader.ReadByte();                      Entry.AccessNumber = m_Reader.ReadByte();                      Entry.FilenameLength = m_Reader.ReadUInt16();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Encoding.ASCII.GetString(m_Reader.ReadBytes(Entry.FilenameLength));                        if (!m_Entries.ContainsKey(Entry.Filename))                          m_Entries.Add(Entry.Filename' Entry);                      m_EntriesList.Add(Entry);                        m_EntryByID.Add(Entry.FileID' Entry);                  }                    //Keep the stream open' it helps peformance.                  //m_Reader.Close();                  isReadingSomething = false;              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: lock (m_Reader)              {                  //m_Reader = new BinaryReader(File.Open(m_ArchivePath' FileMode.Open' FileAccess.Read));                  m_Reader.BaseStream.Seek((long)Entry.DataOffset' SeekOrigin.Begin);                    isReadingSomething = true;                    if (Entry.Compressed == 0x01)                  {                      m_Reader.ReadBytes(9);                      uint Filesize = m_Reader.ReadUInt32();                      ushort CompressionID = m_Reader.ReadUInt16();                        if (CompressionID == 0xFB10)                      {                          byte[] Dummy = m_Reader.ReadBytes(3);                          uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                            Decompresser Dec = new Decompresser();                          Dec.CompressedSize = Filesize;                          Dec.DecompressedSize = DecompressedSize;                            byte[] DecompressedData = Dec.Decompress(m_Reader.ReadBytes((int)Filesize));                          //m_Reader.Close();                            isReadingSomething = false;                            return DecompressedData;                      }                      else                      {                          m_Reader.BaseStream.Seek((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);                            byte[] Data = m_Reader.ReadBytes((int)Entry.DecompressedFileSize);                          //m_Reader.Close();                            isReadingSomething = false;                            return Data;                      }                  }                  else                  {                      byte[] Data = m_Reader.ReadBytes((int)Entry.DecompressedFileSize);                      //m_Reader.Close();                        isReadingSomething = false;                        return Data;                  }              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: lock (m_Reader)              {                  //m_Reader = new BinaryReader(File.Open(m_ArchivePath' FileMode.Open' FileAccess.Read));                  m_Reader.BaseStream.Seek((long)Entry.DataOffset' SeekOrigin.Begin);                    isReadingSomething = true;                    if (Entry.Compressed == 0x01)                  {                      m_Reader.ReadBytes(9);                      uint Filesize = m_Reader.ReadUInt32();                      ushort CompressionID = m_Reader.ReadUInt16();                        if (CompressionID == 0xFB10)                      {                          byte[] Dummy = m_Reader.ReadBytes(3);                          uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                            Decompresser Dec = new Decompresser();                          Dec.CompressedSize = Filesize;                          Dec.DecompressedSize = DecompressedSize;                            byte[] DecompressedData = Dec.Decompress(m_Reader.ReadBytes((int)Filesize));                          //m_Reader.Close();                            isReadingSomething = false;                            return DecompressedData;                      }                      else                      {                          m_Reader.BaseStream.Seek((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);                            byte[] Data = m_Reader.ReadBytes((int)Entry.DecompressedFileSize);                          //m_Reader.Close();                            isReadingSomething = false;                            return Data;                      }                  }                  else                  {                      byte[] Data = m_Reader.ReadBytes((int)Entry.DecompressedFileSize);                      //m_Reader.Close();                        isReadingSomething = false;                        return Data;                  }              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: lock (m_Reader)              {                  //m_Reader = new BinaryReader(File.Open(m_ArchivePath' FileMode.Open' FileAccess.Read));                  m_Reader.BaseStream.Seek((long)Entry.DataOffset' SeekOrigin.Begin);                    isReadingSomething = true;                    if (Entry.Compressed == 0x01)                  {                      m_Reader.ReadBytes(9);                      uint Filesize = m_Reader.ReadUInt32();                      ushort CompressionID = m_Reader.ReadUInt16();                        if (CompressionID == 0xFB10)                      {                          byte[] Dummy = m_Reader.ReadBytes(3);                          uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                            Decompresser Dec = new Decompresser();                          Dec.CompressedSize = Filesize;                          Dec.DecompressedSize = DecompressedSize;                            byte[] DecompressedData = Dec.Decompress(m_Reader.ReadBytes((int)Filesize));                          //m_Reader.Close();                            isReadingSomething = false;                            return DecompressedData;                      }                      else                      {                          m_Reader.BaseStream.Seek((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);                            byte[] Data = m_Reader.ReadBytes((int)Entry.DecompressedFileSize);                          //m_Reader.Close();                            isReadingSomething = false;                            return Data;                      }                  }                  else                  {                      byte[] Data = m_Reader.ReadBytes((int)Entry.DecompressedFileSize);                      //m_Reader.Close();                        isReadingSomething = false;                        return Data;                  }              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetEntry,The following statement contains a magic number: lock (m_Reader)              {                  //m_Reader = new BinaryReader(File.Open(m_ArchivePath' FileMode.Open' FileAccess.Read));                  m_Reader.BaseStream.Seek((long)Entry.DataOffset' SeekOrigin.Begin);                    isReadingSomething = true;                    if (Entry.Compressed == 0x01)                  {                      m_Reader.ReadBytes(9);                      uint Filesize = m_Reader.ReadUInt32();                      ushort CompressionID = m_Reader.ReadUInt16();                        if (CompressionID == 0xFB10)                      {                          byte[] Dummy = m_Reader.ReadBytes(3);                          uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                            Decompresser Dec = new Decompresser();                          Dec.CompressedSize = Filesize;                          Dec.DecompressedSize = DecompressedSize;                            byte[] DecompressedData = Dec.Decompress(m_Reader.ReadBytes((int)Filesize));                          //m_Reader.Close();                            isReadingSomething = false;                            return DecompressedData;                      }                      else                      {                          m_Reader.BaseStream.Seek((m_Reader.BaseStream.Position - 15)' SeekOrigin.Begin);                            byte[] Data = m_Reader.ReadBytes((int)Entry.DecompressedFileSize);                          //m_Reader.Close();                            isReadingSomething = false;                            return Data;                      }                  }                  else                  {                      byte[] Data = m_Reader.ReadBytes((int)Entry.DecompressedFileSize);                      //m_Reader.Close();                        isReadingSomething = false;                        return Data;                  }              }
Magic Number,SimsLib.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\FAR3\FAR3Archive.cs,GetItemByID,The following statement contains a magic number: uint FileID = BitConverter.ToUInt32(Bytes' 4);
Magic Number,LogThis,Log,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,UseSensibleDefaults,The following statement contains a magic number: Log.LogSizeMax = 100;
Magic Number,LogThis,Log,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: string[] baseInfo = new string[3];
Magic Number,LogThis,Log,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: if (a.Length > 1)  			{  				try  				{  					baseInfo[2] = a[a.Length-1];   					baseInfo[1] = baseInfo[1].Remove(baseInfo[1].Length-baseInfo[2].Length-1'baseInfo[2].Length+1);  				}  				catch(Exception ex)  				{  					Debug.Write(ex.Message);  				}  			}
Magic Number,LogThis,Log,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: if (a.Length > 1)  			{  				try  				{  					baseInfo[2] = a[a.Length-1];   					baseInfo[1] = baseInfo[1].Remove(baseInfo[1].Length-baseInfo[2].Length-1'baseInfo[2].Length+1);  				}  				catch(Exception ex)  				{  					Debug.Write(ex.Message);  				}  			}
Magic Number,LogThis,Log,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: if (a.Length > 1)  			{  				try  				{  					baseInfo[2] = a[a.Length-1];   					baseInfo[1] = baseInfo[1].Remove(baseInfo[1].Length-baseInfo[2].Length-1'baseInfo[2].Length+1);  				}  				catch(Exception ex)  				{  					Debug.Write(ex.Message);  				}  			}
Magic Number,LogThis,Log,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetBasename,The following statement contains a magic number: for (int i=0;i<filePath.Length - ((baseInfo[1].Length) + (baseInfo[2].Length+1))-1	;i++)   			{  				baseInfo[0]+= filePath[i];  			}
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: switch (m_logquotaformat)  			{  				case elogquotaformat.kbytes:  					try  					{  						FileInfo info = new FileInfo(sLogPath);  						nfileSize = info.Length;  					}  					catch (Exception x)  					{  						System.Console.WriteLine("Error:" + x.Message);  						nfileSize = 0;  					}  					if (nfileSize < (m_logsizemax*1024))  					{ return; }  					break;  				case elogquotaformat.rows:  					using (StreamReader sr = new StreamReader(sLogPath))   					{  						String line;  						while ((line = sr.ReadLine()) != null)   						{  							i++;  						}	  						if (i < m_logsizemax) {return;}  					}  					break;  			}
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader(sLogPath))   			{  				switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}  			}
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader(sLogPath))   			{  				switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}  			}
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader(sLogPath))   			{  				switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}  			}
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader(sLogPath))   			{  				switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}  			}
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader(sLogPath))   			{  				switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}  			}
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following statement contains a magic number: using (StreamReader sr = new StreamReader(sLogPath))   			{  				switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}  			}
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetWeek,The following statement contains a magic number: DateTime LastDay = new System.DateTime( DateTime.Now.Year' 12' 31 );
Magic Number,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,GetWeek,The following statement contains a magic number: DateTime LastDay = new System.DateTime( DateTime.Now.Year' 12' 31 );
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_ID = new string(m_Reader.ReadChars(4));
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: uint dwFMTSize = 16;
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: uint dwRIFFSize = 36 + dwDataSize;
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_UnreadBitsCount = 8;
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits(4));
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits(4));
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower[0] = (ReadBits(4) + 1) * 8;
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower[0] = (ReadBits(4) + 1) * 8;
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: float Base = 1.04f + (float)(ReadBits(6)) / 1000.0f;
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadHeader,The following statement contains a magic number: for (int i = 1; i < 64; i++)                  m_InnovationPower[i] = m_InnovationPower[i - 1] * Base;
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: byte Value = (byte)(m_UnreadBitsValue & (255 >> (8 - Bits)));
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: byte Value = (byte)(m_UnreadBitsValue & (255 >> (8 - Bits)));
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: if ((m_UnreadBitsCount < 8) && (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length))              {                  m_UnreadBitsValue |= m_Reader.ReadByte() << m_UnreadBitsCount;                  m_UnreadBitsCount += 8;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,ReadBits,The following statement contains a magic number: if ((m_UnreadBitsCount < 8) && (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length))              {                  m_UnreadBitsValue |= m_Reader.ReadByte() << m_UnreadBitsCount;                  m_UnreadBitsCount += 8;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0)              {                  int BlockSize = Lesser((int)Frames' 432);                  DecodeFrame();                    for (int i = 0; i < BlockSize; i++)                  {                      int Value = (int)Math.Round(m_DecompressedFrame[324 + i]);                      Value = Clamp<int>(Value' -32768' 32767);                      m_Writer.Write((ushort)Value);                  }                    Frames -= (uint)BlockSize;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0)              {                  int BlockSize = Lesser((int)Frames' 432);                  DecodeFrame();                    for (int i = 0; i < BlockSize; i++)                  {                      int Value = (int)Math.Round(m_DecompressedFrame[324 + i]);                      Value = Clamp<int>(Value' -32768' 32767);                      m_Writer.Write((ushort)Value);                  }                    Frames -= (uint)BlockSize;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0)              {                  int BlockSize = Lesser((int)Frames' 432);                  DecodeFrame();                    for (int i = 0; i < BlockSize; i++)                  {                      int Value = (int)Math.Round(m_DecompressedFrame[324 + i]);                      Value = Clamp<int>(Value' -32768' 32767);                      m_Writer.Write((ushort)Value);                  }                    Frames -= (uint)BlockSize;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0)              {                  int BlockSize = Lesser((int)Frames' 432);                  DecodeFrame();                    for (int i = 0; i < BlockSize; i++)                  {                      int Value = (int)Math.Round(m_DecompressedFrame[324 + i]);                      Value = Clamp<int>(Value' -32768' 32767);                      m_Writer.Write((ushort)Value);                  }                    Frames -= (uint)BlockSize;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: float[] Excitation = new float[118];
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: float[] RCDelta = new float[12];
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy(m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy(m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy(m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: float[] LPC = new float[12];
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0)              {                  for (int i = 0; i < 12; i++)                  {                      if (++offset == 12) offset = 0;                      m_DecompressedFrame[324 + Sample] += LPC[i] * m_History[offset];                  }                    m_History[offset--] = m_DecompressedFrame[324 + Sample++];                  Samples--;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0)              {                  for (int i = 0; i < 12; i++)                  {                      if (++offset == 12) offset = 0;                      m_DecompressedFrame[324 + Sample] += LPC[i] * m_History[offset];                  }                    m_History[offset--] = m_DecompressedFrame[324 + Sample++];                  Samples--;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0)              {                  for (int i = 0; i < 12; i++)                  {                      if (++offset == 12) offset = 0;                      m_DecompressedFrame[324 + Sample] += LPC[i] * m_History[offset];                  }                    m_History[offset--] = m_DecompressedFrame[324 + Sample++];                  Samples--;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0)              {                  for (int i = 0; i < 12; i++)                  {                      if (++offset == 12) offset = 0;                      m_DecompressedFrame[324 + Sample] += LPC[i] * m_History[offset];                  }                    m_History[offset--] = m_DecompressedFrame[324 + Sample++];                  Samples--;              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: float[] RCTemp = new float[12]' LPCTemp = new float[12];
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: float[] RCTemp = new float[12]' LPCTemp = new float[12];
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: Array.Copy(RC' 0' RCTemp' 1' 11);
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++)              {                  LPC[i] = 0.0f;                    for (j = 11; j >= 0; j--)                  {                      LPC[i] -= RC[j] * RCTemp[j];                      if (j != 11)                          RCTemp[j + 1] = RCTemp[j] + RC[j] * LPC[i];                  }                    RCTemp[0] = LPCTemp[i] = LPC[i];                    for (j = 0; j < i; j++)                      LPC[i] -= LPCTemp[i - j - 1] * LPC[j];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++)              {                  LPC[i] = 0.0f;                    for (j = 11; j >= 0; j--)                  {                      LPC[i] -= RC[j] * RCTemp[j];                      if (j != 11)                          RCTemp[j + 1] = RCTemp[j] + RC[j] * LPC[i];                  }                    RCTemp[0] = LPCTemp[i] = LPC[i];                    for (j = 0; j < i; j++)                      LPC[i] -= LPCTemp[i - j - 1] * LPC[j];              }
Magic Number,SimsLib.UTK,UTKFile2,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\UTK\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++)              {                  LPC[i] = 0.0f;                    for (j = 11; j >= 0; j--)                  {                      LPC[i] -= RC[j] * RCTemp[j];                      if (j != 11)                          RCTemp[j + 1] = RCTemp[j] + RC[j] * LPC[i];                  }                    RCTemp[0] = LPCTemp[i] = LPC[i];                    for (j = 0; j < i; j++)                      LPC[i] -= LPCTemp[i - j - 1] * LPC[j];              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = new string(m_Reader.ReadChars(4));
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = new string(m_Reader.ReadChars(4));
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwFMTSize = 16;
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressFile,The following statement contains a magic number: if (m_Channels == 1) //Mono              {                  while (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length)                  {                      DecompressMono(m_Reader.ReadBytes(0xF));                  }              }              else if (m_Channels == 2) //Stereo              {                  while (m_Reader.BaseStream.Position < m_Reader.BaseStream.Length)                  {                      DecompressStereo(m_Reader.ReadBytes(0x1E));                  }              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2left = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: dleft = (byte)(LONIBBLE(bInput) + 8);
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2right = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: dright = (byte)(LONIBBLE(bInput) + 8);
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleLeft;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleLeft;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleLeft;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleLeft;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleLeft;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleLeft;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: int c2 = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: d = (byte)(LONIBBLE(bInput) + 8);
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: c2left = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: dleft = (byte)(LONIBBLE(bInput) + 8);
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: for (i = 1; i < 0xF; i++)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    // Now we've got lCurSampleLeft which is one mono sample and all is set                  // for the next input nibble...                  //Output((SHORT)lCurSampleLeft); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    // Now we've got lCurSampleLeft which is one mono sample and all is set                  // for the next input byte...                  //Output((SHORT)lCurSampleLeft); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,DecompressMono,The following statement contains a magic number: for (i = 1; i < 0xF; i++)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    // Now we've got lCurSampleLeft which is one mono sample and all is set                  // for the next input nibble...                  //Output((SHORT)lCurSampleLeft); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    // Now we've got lCurSampleLeft which is one mono sample and all is set                  // for the next input byte...                  //Output((SHORT)lCurSampleLeft); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);              }
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)                  return 32767;              else if (sample < -32768)                  return (-32768);              else                  return sample;
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)                  return 32767;              else if (sample < -32768)                  return (-32768);              else                  return sample;
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)                  return 32767;              else if (sample < -32768)                  return (-32768);              else                  return sample;
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)                  return 32767;              else if (sample < -32768)                  return (-32768);              else                  return sample;
Magic Number,SimsLib.XA,XAFile,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\XA\XAFile.cs,HINIBBLE,The following statement contains a magic number: return (byte)(((B) >> 4) & 0x0F);
Missing Default,SimsLib.ThreeD,Outfit,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\3D\Outfit.cs,GetAppearance,The following switch statement is missing a default case: switch (type)              {                  case AppearanceType.Light:                      return (ulong)LightAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Medium:                      return (ulong)MediumAppearanceFileID << 32 | LightAppearanceTypeID;                  case AppearanceType.Dark:                      return (ulong)DarkAppearanceFileID << 32 | LightAppearanceTypeID;              }
Missing Default,SimsLib.IFF,DGRP,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,GetImage,The following switch statement is missing a default case: switch (worldRotation)              {                  case 0:                      rotatedDirection = direction;                      break;                  case 1:                      switch (direction)                      {                          case 0x01:                              rotatedDirection = 0x04;                              break;                          case 0x10:                              rotatedDirection = 0x40;                              break;                          case 0x40:                              rotatedDirection = 0x01;                              break;                          case 0x04:                              rotatedDirection = 0x10;                              break;                      }                      break;              }
Missing Default,SimsLib.IFF,DGRP,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\DGRP.cs,GetImage,The following switch statement is missing a default case: switch (direction)                      {                          case 0x01:                              rotatedDirection = 0x04;                              break;                          case 0x10:                              rotatedDirection = 0x40;                              break;                          case 0x40:                              rotatedDirection = 0x01;                              break;                          case 0x04:                              rotatedDirection = 0x10;                              break;                      }
Missing Default,SimsLib.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following switch statement is missing a default case: switch (command)                  {                      /** Start marker **/                      case 0x00:                      case 0x10:                          break;                      /** Fill row with pixel data **/                      case 0x04:                          var bytes = count - 2;                          var x = 0;                            while (bytes > 0)                          {                              var pxCommand = io.ReadByte();                              var pxCount = io.ReadByte();                              bytes -= 2;                                switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }                          }                            y++;                          break;                      /** End marker **/                      case 0x05:                          endmarker = true;                          break;                      /** Leave next rows transparent **/                      case 0x09:                          y += count;                          continue;                  }
Missing Default,SimsLib.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR.cs,Decode,The following switch statement is missing a default case: switch (pxCommand)                              {                                  /** Next {n} pixels are transparent **/                                  case 0x01:                                      x += pxCount;                                      break;                                  /** Next {n} pixels are the same palette color **/                                  case 0x02:                                      var index = io.ReadByte();                                      var padding = io.ReadByte();                                      bytes -= 2;                                        var color = palette.Colors[index];                                      for (var j = 0; j < pxCount; j++)                                      {                                          this.SetPixel(x' y' color);                                          x++;                                      }                                      break;                                  /** Next {n} pixels are specific palette colours **/                                  case 0x03:                                      for (var j = 0; j < pxCount; j++)                                      {                                          var index2 = io.ReadByte();                                          var color2 = palette.Colors[index2];                                          this.SetPixel(x' y' color2);                                          x++;                                      }                                      bytes -= pxCount;                                      if (pxCount % 2 != 0)                                      {                                          //Padding                                          io.ReadByte();                                          bytes--;                                      }                                      break;                              }
Missing Default,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following switch statement is missing a default case: switch (command)                  {                      /** Fill with pixel data **/                      case 0x00:                          var bytes = count;                          bytes -= 2;                            var x = 0;                            while (bytes > 0)                          {                              var pxMarker = io.ReadUInt16();                              var pxCommand = pxMarker >> 13;                              var pxCount = pxMarker & 0x1FFF;                              bytes -= 2;                                switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }                          }                            /** If row isnt filled in' the rest is transparent **/                          while (x < Width)                          {                              var offset = (y * Width) + x;                              if (hasZBuffer)                              {                                  this.ZBufferData[offset] = 255;                              }                              x++;                          }                          break;                      /**  Leave the next count rows in the color channel filled with the transparent color' in the z-buffer channel filled with 255' and in the alpha channel filled with 0. **/                      case 0x04:                          for (var row = 0; row < count; row++)                          {                              for (var col = 0; col < Width; col++)                              {                                  var offset = (row * Width) + col;                                  if (hasPixels)                                  {                                      this.PixelData[offset] = transparentPixel;                                  }                                  if (hasAlpha)                                  {                                      this.PixelData[offset].A = 0;                                  }                                  if (hasZBuffer)                                  {                                      ZBufferData[offset] = 255;                                  }                              }                          }                          break;                      case 0x05:                          endmarker = true;                          break;                  }
Missing Default,SimsLib.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\IFF\SPR2.cs,Decode,The following switch statement is missing a default case: switch (pxCommand)                              {                                  case 0x01:                                  case 0x02:                                      var pxWithAlpha = pxCommand == 0x02;                                      for (var col = 0; col < pxCount; col++)                                      {                                          var zValue = io.ReadByte();                                          var pxValue = io.ReadByte();                                          bytes -= 2;                                            var pxColor = palette.Colors[pxValue];                                          if (pxWithAlpha)                                          {                                              pxColor.A = io.ReadByte();                                              bytes--;                                          }                                          else                                          {                                              if (pxColor.PackedValue == transparentPixel.PackedValue)                                              {                                                  pxColor.A = 0;                                              }                                          }                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = pxColor;                                          this.ZBufferData[offset] = zValue;                                          x++;                                      }                                      if (pxWithAlpha)                                      {                                          /** Padding? **/                                          if ((pxCount * 3) % 2 != 0)                                          {                                              bytes--;                                              io.ReadByte();                                          }                                      }                                      break;                                  case 0x03:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var offset = (y * Width) + x;                                          this.PixelData[offset] = transparentPixel;                                          this.PixelData[offset].A = 0;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = 255;                                          }                                          x++;                                      }                                      break;                                  case 0x06:                                      for (var col = 0; col < pxCount; col++)                                      {                                          var pxIndex = io.ReadByte();                                          bytes--;                                          var offset = (y * Width) + x;                                          var pxColor = palette.Colors[pxIndex];                                          byte z = 0;                                          if (pxColor.PackedValue == transparentPixel.PackedValue)                                          {                                              pxColor.A = 0;                                              z = 255;                                          }                                          this.PixelData[offset] = pxColor;                                          if (hasZBuffer)                                          {                                              this.ZBufferData[offset] = z;                                          }                                          x++;                                      }                                      if (pxCount % 2 != 0)                                      {                                          bytes--;                                          io.ReadByte();                                      }                                      break;                              }
Missing Default,LogThis,Log,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,LogHeader,The following switch statement is missing a default case: switch(logheaderlevel)  			{  				case elogheaderlevel.Level_1:  					sHeader = "======(" + System.AppDomain.CurrentDomain.FriendlyName + ") ====  " + sText + "============ Date:" + dt.ToString("yyyyMMdd") + " Time:" + dt.ToString("hh:mm:ss") ;  					break;  				case elogheaderlevel.Level_2:  					sHeader = "------" + sText + " ============ Time:" + dt.ToString("hh:mm:ss") ;  					break;  				case elogheaderlevel.Level_3:  					sHeader = "---" + sText + " --- Time:" + dt.ToString("hh:mm:ss") ;  					break;  			}
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following switch statement is missing a default case: switch (m_logquotaformat)  			{  				case elogquotaformat.kbytes:  					try  					{  						FileInfo info = new FileInfo(sLogPath);  						nfileSize = info.Length;  					}  					catch (Exception x)  					{  						System.Console.WriteLine("Error:" + x.Message);  						nfileSize = 0;  					}  					if (nfileSize < (m_logsizemax*1024))  					{ return; }  					break;  				case elogquotaformat.rows:  					using (StreamReader sr = new StreamReader(sLogPath))   					{  						String line;  						while ((line = sr.ReadLine()) != null)   						{  							i++;  						}	  						if (i < m_logsizemax) {return;}  					}  					break;  			}
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,TruncateLogFile,The following switch statement is missing a default case: switch (m_logquotaformat)  				{  					case elogquotaformat.kbytes:  						char[] c = null;  						long bufsize = 1024; //should match streams natural buffer size.  						long kb = 1024;  						j = (long)((m_logsizemax*kb) * .9);  						while (sr.Peek() >= 0)   						{  							c = new char[bufsize];  							sr.Read(c' 0' c.Length);  							i++;  							if ((i*bufsize) > j)  							{  								for (i = 0;i<c.Length ; i++)  								{  									if (c[i] == '\r' && c[i+1] == '\n')  									{  										//write out the remaining part of the last line.  										char[] c2 = new char[i+2];  										Array.Copy(c'0'c2'0'i+2);  										SW.Write(c2);  										break;  									}  										  								}  								  								break;  							}  							else  							{  								SW.Write(c);  							}  						}  						break;  					case elogquotaformat.rows:  						String line;  						j = (long)(m_logsizemax * .9); //reduce by 10% below max.  						while ((line = sr.ReadLine()) != null)   						{  							SW.WriteLine(line);  							i++;  							if (i > j) { break;}  						}  						break;  				}
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,SetLogPath,The following switch statement is missing a default case: switch (m_logperiod)  				{  					case elogperiod.day:  						sPeriod = dt.ToString("yyyyMMdd");  						break;  					case elogperiod.week:  						string week = GetWeek();  						sPeriod = dt.ToString("yyyyweek" + week);  						break;  					case elogperiod.month:  						sPeriod = dt.ToString("yyyyMM");  						break;  				}
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,SetLogPath,The following switch statement is missing a default case: switch (m_lognameformat)  				{  					case elognameformat.date_name:  						sLogName = sPeriod + "_" + m_logfilename;  						break;  					case elognameformat.name_date:  						sLogName = m_logfilename + "_" + sPeriod;  						break;  				}
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,LogThis,The following switch statement is missing a default case: switch (logprefix)  				{  					case elogprefix.dt:  						logtext = dt.ToString("yyyy.MM.dd") + "-" + dt.ToString("hh.mm.ss") + ": " + logtext;  						break;  					case elogprefix.loglevel:  						logtext = loglevel.ToString() + ": " + logtext;  						break;  					case elogprefix.dt_loglevel:  						logtext = dt.ToString("yyyy.MM.dd") + "-" + dt.ToString("hh.mm.ss") + ":" + loglevel + ": " + logtext;  						break;  				}
Missing Default,LogThis,LogMethods,C:\repos\Afr0_Project-Dollhouse\Other\tools\SimsLib\SimsLib\Log.cs,LogThis,The following switch statement is missing a default case: switch (m_logwhere)  				{  					case elogwhere.file:  						AppendToFile(sFilePath'logtext);  						break;  					case elogwhere.eventlog:  						LogEvent(logtext'loglevel);  						break;  					case elogwhere.eventlog_and_file:  						AppendToFile(sFilePath'logtext);  						LogEvent(logtext'loglevel);  						break;  				}
