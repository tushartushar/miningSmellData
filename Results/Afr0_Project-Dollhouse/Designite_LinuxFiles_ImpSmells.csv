Implementation smell,Namespace,Class,File,Method,Description
Long Method,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The method has 178 lines of code.
Long Method,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The method has 100 lines of code.
Long Method,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The method has 153 lines of code.
Long Method,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The method has 238 lines of code.
Long Method,Files.IFF,CST,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The method has 105 lines of code.
Long Method,Files.IFF,CTSS,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The method has 105 lines of code.
Long Method,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The method has 116 lines of code.
Long Method,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The method has 128 lines of code.
Long Method,Files.IFF,STR,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The method has 105 lines of code.
Long Method,Files.IFF,TTAs,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The method has 105 lines of code.
Long Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The method has 133 lines of code.
Long Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The method has 180 lines of code.
Complex Method,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,Cyclomatic complexity of the method is 9
Complex Method,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,Cyclomatic complexity of the method is 10
Complex Method,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,Cyclomatic complexity of the method is 16
Complex Method,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GetTexture,Cyclomatic complexity of the method is 8
Complex Method,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GetSound,Cyclomatic complexity of the method is 8
Complex Method,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,Cyclomatic complexity of the method is 33
Complex Method,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,Cyclomatic complexity of the method is 10
Complex Method,Files.Vitaboy,Mesh,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Mesh.cs,Mesh,Cyclomatic complexity of the method is 8
Complex Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,Cyclomatic complexity of the method is 9
Complex Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,Cyclomatic complexity of the method is 8
Complex Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,Cyclomatic complexity of the method is 10
Complex Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,Dispose,Cyclomatic complexity of the method is 9
Long Parameter List,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,ArrayCopy2,The method has 5 parameters. Parameters: Src' SrcPos' Dest' DestPos' Length
Long Identifier,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,Dispose,The length of the parameter CleanupNativeAndManagedResources is 32.
Long Identifier,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,Dispose,The length of the parameter CleanupNativeAndManagedResources is 32.
Long Identifier,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files.AudioLogic,HLS,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files.DBPF,DBPFArchive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files.FAR1,FAR1Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR1\FAR1Archive.cs,Dispose,The length of the parameter CleanupNativeAndManagedResources is 32.
Long Identifier,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files.Manager,Asset,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\Asset.cs,Dispose,The length of the parameter CleanupNativeAndManagedResources is 32.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaAuthorNameByteLength is 33.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaAuthorCommentsByteLength is 37.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaJobNameByteLength is 30.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaSoftwareIDByteLength is 33.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaSoftwareVersionLetterByteLength is 44.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaColorCorrectionTableValueLength is 44.
Long Statement,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The length of the statement  "                    m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)]; " is 139.
Long Statement,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The length of the statement  "            if (InputBuffer.Length != 0x1E) return; //todo' deal with this correctly. Right now stereo audio is kind of totally fucked! " is 123.
Long Statement,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The length of the statement  "			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) " is 133.
Long Statement,Files.IFF,Iff,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\Iff.cs,Init,The length of the statement  "            if (!MagicNumber.Equals("IFF FILE 2.5:TYPE FOLLOWED BY SIZE\0 JAMIE DOORNBOS & MAXIS 1\0"' StringComparison.InvariantCultureIgnoreCase)) " is 136.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The length of the statement  "                if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The length of the statement  "                        string Signature = System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.FooterSignatureByteLength)).TrimEnd('\0'); " is 133.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The length of the statement  "                        if (string.Compare(Signature' TargaConstants.TargaFooterASCIISignature' StringComparison.InvariantCultureIgnoreCase) == 0) " is 122.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The length of the statement  "                            string ResChar = System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.FooterReservedCharByteLength)).TrimEnd('\0'); " is 134.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The length of the statement  "            if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "            if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetAuthorName(System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaAuthorNameByteLength)).TrimEnd('\0')); " is 164.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetAuthorComments(System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaAuthorCommentsByteLength)).TrimEnd('\0')); " is 172.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        string strStamp = iMonth.ToString(CultureInfo.CurrentCulture) + @"/" + iDay.ToString(CultureInfo.CurrentCulture) + @"/" + iYear.ToString(CultureInfo.CurrentCulture) + @" "; " is 172.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        strStamp += iHour.ToString(CultureInfo.CurrentCulture) + @":" + iMinute.ToString(CultureInfo.CurrentCulture) + @":" + iSecond.ToString(CultureInfo.CurrentCulture); " is 163.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetJobName(System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaJobNameByteLength)).TrimEnd('\0')); " is 158.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetSoftwareID(System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaSoftwareIDByteLength)).TrimEnd('\0')); " is 164.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        string strVersionLetter = System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaSoftwareVersionLetterByteLength)).TrimEnd('\0'); " is 159.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetSoftwareID(iVersionNumber.ToString(@"F2"' CultureInfo.CurrentCulture) + strVersionLetter); " is 120.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The length of the statement  "            if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The length of the statement  "            this.intStride = (((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes " is 124.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The length of the statement  "                        pal.Entries[i] = Color.FromArgb(255' this.objTargaHeader.ColorMap[i].R' this.objTargaHeader.ColorMap[i].G' this.objTargaHeader.ColorMap[i].B); " is 142.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The length of the statement  "            if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The length of the statement  "                    System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>(); " is 158.
Complex Conditional,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,ParseHexString,The conditional expression  "HexStr.Contains("a") || HexStr.Contains("b") || HexStr.Contains("b") ||                  HexStr.Contains("c") || HexStr.Contains("d") || HexStr.Contains("e") || HexStr.Contains("f")"  is complex.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Magic Number,Files,Endian,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,Files,Endian,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,Files,Endian,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,Files,Endian,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt16,The following statement contains a magic number: byte[] b = ReadBytes(2);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt16,The following statement contains a magic number: return (short)(b[1] + (b[0] << 8));
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: byte[] b = ReadBytes(4);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b[3] + (b[2] << 8) + (b[1] << 16) + (b[0] << 24);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b[3] + (b[2] << 8) + (b[1] << 16) + (b[0] << 24);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b[3] + (b[2] << 8) + (b[1] << 16) + (b[0] << 24);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b[3] + (b[2] << 8) + (b[1] << 16) + (b[0] << 24);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b[3] + (b[2] << 8) + (b[1] << 16) + (b[0] << 24);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: byte[] b = ReadBytes(8);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileReader,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b[7] + (b[6] << 8) + (b[5] << 16) + (b[4] << 24) + (b[3] << 32) + (b[2] << 40) + (b[1] << 48) + (b[0] << 56);
Magic Number,Files,FileUtilities,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileUtilities.cs,HashCode,The following statement contains a magic number: foreach (var item in Enumerable)              {                  int thisHash = item.GetHashCode();                  //mix up the bits.                  hash = thisHash ^ ((hash << 5) + hash);              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_ID = Convert.ToString(m_Reader.ReadBytes(4));
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: uint dwFMTSize = 16;
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: uint dwRIFFSize = 36 + dwDataSize;
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_UnreadBitsCount = 8;
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits(4));
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits(4));
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower[0] = (ReadBits(4) + 1) * 8;
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower[0] = (ReadBits(4) + 1) * 8;
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: float Base = 1.04f + (float)(ReadBits(6)) / 1000.0f;
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: for (int i = 1; i < 64; i++)                  m_InnovationPower[i] = m_InnovationPower[i - 1] * Base;
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadBits,The following statement contains a magic number: byte Value = (byte)(m_UnreadBitsValue & (255 >> (8 - Bits)));
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadBits,The following statement contains a magic number: byte Value = (byte)(m_UnreadBitsValue & (255 >> (8 - Bits)));
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadBits,The following statement contains a magic number: if ((m_UnreadBitsCount < 8) && (m_Reader.Position < m_Reader.StreamLength))              {                  m_UnreadBitsValue |= m_Reader.ReadByte() << m_UnreadBitsCount;                  m_UnreadBitsCount += 8;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,ReadBits,The following statement contains a magic number: if ((m_UnreadBitsCount < 8) && (m_Reader.Position < m_Reader.StreamLength))              {                  m_UnreadBitsValue |= m_Reader.ReadByte() << m_UnreadBitsCount;                  m_UnreadBitsCount += 8;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0)              {                  int BlockSize = Lesser((int)Frames' 432);                  DecodeFrame();                    for (int i = 0; i < BlockSize; i++)                  {                      int Value = (int)Math.Round(m_DecompressedFrame[324 + i]);                      Value = Clamp<int>(Value' -32768' 32767);                      m_Writer.Write((ushort)Value);                  }                    Frames -= (uint)BlockSize;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0)              {                  int BlockSize = Lesser((int)Frames' 432);                  DecodeFrame();                    for (int i = 0; i < BlockSize; i++)                  {                      int Value = (int)Math.Round(m_DecompressedFrame[324 + i]);                      Value = Clamp<int>(Value' -32768' 32767);                      m_Writer.Write((ushort)Value);                  }                    Frames -= (uint)BlockSize;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0)              {                  int BlockSize = Lesser((int)Frames' 432);                  DecodeFrame();                    for (int i = 0; i < BlockSize; i++)                  {                      int Value = (int)Math.Round(m_DecompressedFrame[324 + i]);                      Value = Clamp<int>(Value' -32768' 32767);                      m_Writer.Write((ushort)Value);                  }                    Frames -= (uint)BlockSize;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0)              {                  int BlockSize = Lesser((int)Frames' 432);                  DecodeFrame();                    for (int i = 0; i < BlockSize; i++)                  {                      int Value = (int)Math.Round(m_DecompressedFrame[324 + i]);                      Value = Clamp<int>(Value' -32768' 32767);                      m_Writer.Write((ushort)Value);                  }                    Frames -= (uint)BlockSize;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: float[] Excitation = new float[118];
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: float[] RCDelta = new float[12];
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++)              {                  byte index = ReadBits((byte)((i < 4) ? 6 : 5));                    if (i == 0 && index < m_VoicedThreshold)                      Voiced = true;                    RCDelta[i] = (UTKCosine[index + ((i < 4) ? 0 : 16)] - m_RC[i]) / 4.0f;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  int Phase = ReadBits(8);                    if (i == 0 && Phase > 216)                      Phase = 216;                    float PitchGain = (float)(ReadBits(4)) / 15.0f;                  float InnovationGain = m_InnovationPower[ReadBits(6)];                    if (m_HalvedExcitation == false)                  {                      GenerateExcitation(5' ref Excitation' Voiced' 1);                  }                  else                  {                      //Fill the excitation window with half as many samples and interpolate the rest.                      int Alignment = ReadBits(1); //whether to fill the even or odd samples.                      bool FillWithZero = (ReadBits(1) != 0);                      int Offset = 5 + (1 - Alignment);                        GenerateExcitation(5 + Alignment' ref Excitation' Voiced' 2);                        if (FillWithZero)                      {                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] = 0.0f;                      }                      else                      {                          //Use sinc interpolation with 6 neighboring samples.                          for (int j = Offset; j < Offset + 108; j += 2)                              Excitation[j] =                                (Excitation[j - 1] + Excitation[j + 1]) * .5973859429f                              - (Excitation[j - 3] + Excitation[j + 3]) * .1145915613f                              + (Excitation[j - 5] + Excitation[j + 5]) * .0180326793f;                            InnovationGain /= 2.0f;                      }                  }                    for (int j = 0; j < 108; j++)                      m_DecompressedFrame[324 + 108 * i + j] = InnovationGain * Excitation[5 + j] + PitchGain * m_DecompressedFrame[108 * i + j + (216 - Phase)];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy(m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy(m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy(m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++)              {                  //Linearly interpolate the reflection coefficients for the current subframe.                  for (int j = 0; j < 12; j++)                      m_RC[j] += RCDelta[j];                    Synthesize(i * 12' (i != 3) ? 12 : 396);              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced)              {                  int Table = 0;                  int i = Offset;                    while (i < Offset + 108)                  {                      byte code = UTKCodebook[(Table << 8) | (m_UnreadBitsValue & 0xFF)];                      //Table = (code < 2 || code > 8);                      Table = (code < 2 || code > 8) ? 1 : 0;                      ReadBits(m_UTKCodeSkips[code]);                        if (code >= 4)                      {                          //Fill a sample with a value specified by the code; magnitude is limited to 6.0                          Excitation[i] = (code - 1) / 4;                          if ((code & 1) != 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                      else if (code >= 2)                      {                          //Fill between 7 and 70 samples with 0s                          int x = ReadBits(6) + 7;                          x = Lesser(x' (Offset + 108 - i) / Interval);                            while (x > 0)                          {                              Excitation[i] = 0.0f;                                i += Interval;                              x--;                          }                      }                      else                      {                          //Fill a sample with a custom value with magnitude >= 7.0                          Excitation[i] = 7.0f;                          while (ReadBits(1) != 0)                              Excitation[i]++;                            if (ReadBits(1) == 0)                              Excitation[i] *= -1.0f;                            i += Interval;                      }                  }              }              else              {                  //Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook                  for (int i = Offset; i < Offset + 108; i += Interval)                  {                      if (ReadBits(1) == 0) Excitation[i] = 0.0f;                      else if (ReadBits(1) == 0) Excitation[i] = -2.0f;                      else Excitation[i] = 2.0f;                  }              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: float[] LPC = new float[12];
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0)              {                  for (int i = 0; i < 12; i++)                  {                      if (++offset == 12) offset = 0;                      m_DecompressedFrame[324 + Sample] += LPC[i] * m_History[offset];                  }                    m_History[offset--] = m_DecompressedFrame[324 + Sample++];                  Samples--;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0)              {                  for (int i = 0; i < 12; i++)                  {                      if (++offset == 12) offset = 0;                      m_DecompressedFrame[324 + Sample] += LPC[i] * m_History[offset];                  }                    m_History[offset--] = m_DecompressedFrame[324 + Sample++];                  Samples--;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0)              {                  for (int i = 0; i < 12; i++)                  {                      if (++offset == 12) offset = 0;                      m_DecompressedFrame[324 + Sample] += LPC[i] * m_History[offset];                  }                    m_History[offset--] = m_DecompressedFrame[324 + Sample++];                  Samples--;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0)              {                  for (int i = 0; i < 12; i++)                  {                      if (++offset == 12) offset = 0;                      m_DecompressedFrame[324 + Sample] += LPC[i] * m_History[offset];                  }                    m_History[offset--] = m_DecompressedFrame[324 + Sample++];                  Samples--;              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: float[] RCTemp = new float[12]' LPCTemp = new float[12];
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: float[] RCTemp = new float[12]' LPCTemp = new float[12];
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: Array.Copy(RC' 0' RCTemp' 1' 11);
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++)              {                  LPC[i] = 0.0f;                    for (j = 11; j >= 0; j--)                  {                      LPC[i] -= RC[j] * RCTemp[j];                      if (j != 11)                          RCTemp[j + 1] = RCTemp[j] + RC[j] * LPC[i];                  }                    RCTemp[0] = LPCTemp[i] = LPC[i];                    for (j = 0; j < i; j++)                      LPC[i] -= LPCTemp[i - j - 1] * LPC[j];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++)              {                  LPC[i] = 0.0f;                    for (j = 11; j >= 0; j--)                  {                      LPC[i] -= RC[j] * RCTemp[j];                      if (j != 11)                          RCTemp[j + 1] = RCTemp[j] + RC[j] * LPC[i];                  }                    RCTemp[0] = LPCTemp[i] = LPC[i];                    for (j = 0; j < i; j++)                      LPC[i] -= LPCTemp[i - j - 1] * LPC[j];              }
Magic Number,Files.AudioFiles,UTKFile2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++)              {                  LPC[i] = 0.0f;                    for (j = 11; j >= 0; j--)                  {                      LPC[i] -= RC[j] * RCTemp[j];                      if (j != 11)                          RCTemp[j + 1] = RCTemp[j] + RC[j] * LPC[i];                  }                    RCTemp[0] = LPCTemp[i] = LPC[i];                    for (j = 0; j < i; j++)                      LPC[i] -= LPCTemp[i - j - 1] * LPC[j];              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = Convert.ToString(m_Reader.ReadBytes(4));
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = Convert.ToString(m_Reader.ReadBytes(4));
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwFMTSize = 16;
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressFile,The following statement contains a magic number: uint dwRIFFSize = /*dwFMTSize + 8 + dwDataSize + 8 + 4;*/ dwDataSize + 4 + 4 + dwFMTSize + 4 + 9;
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressFile,The following statement contains a magic number: if (m_Channels == 1) //Mono              {                  while (m_Reader.Position < m_Reader.StreamLength)                  {                      DecompressMono(m_Reader.ReadBytes(0xF));                  }              }              else if (m_Channels == 2) //Stereo              {                  while (m_Reader.Position < m_Reader.StreamLength)                  {                      DecompressStereo(m_Reader.ReadBytes(0x1E));                  }              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2left = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: dleft = (byte)(LONIBBLE(bInput) + 8);
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2right = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: dright = (byte)(LONIBBLE(bInput) + 8);
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = HINIBBLE(InputBuffer[i + 1]); // HIGHER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  //Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);                    // now do just the same for LOWER nibbles...                  // note that nubbles for each channel are packed pairwise into one byte                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    right = LONIBBLE(InputBuffer[i + 1]); // LOWER nibble for right channel                  right = (right << 0x1c) >> dright;                  right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;                  right = Clip16BitSample(right);                  m_PrevSampleRight = m_CurSampleRight;                  m_CurSampleRight = right;                    // Now we've got lCurSampleLeft and lCurSampleRight which form one stereo                  // sample and all is set for the next step...                  m_Writer.Write((short)m_CurSampleLeft);                  m_Writer.Write((short)m_CurSampleRight);              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressMono,The following statement contains a magic number: int c2 = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressMono,The following statement contains a magic number: d = (byte)(LONIBBLE(bInput) + 8);
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressMono,The following statement contains a magic number: c2left = (int)EATable[HINIBBLE(bInput) + 4];
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressMono,The following statement contains a magic number: dleft = (byte)(LONIBBLE(bInput) + 8);
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressMono,The following statement contains a magic number: for (i = 1; i < 0xF; i++)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    // Now we've got lCurSampleLeft which is one mono sample and all is set                  // for the next input nibble...                  //Output((SHORT)lCurSampleLeft); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    // Now we've got lCurSampleLeft which is one mono sample and all is set                  // for the next input byte...                  //Output((SHORT)lCurSampleLeft); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,DecompressMono,The following statement contains a magic number: for (i = 1; i < 0xF; i++)              {                  left = HINIBBLE(InputBuffer[i]);  // HIGHER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    // Now we've got lCurSampleLeft which is one mono sample and all is set                  // for the next input nibble...                  //Output((SHORT)lCurSampleLeft); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);                    left = LONIBBLE(InputBuffer[i]);  // LOWER nibble for left channel                  left = (left << 0x1c) >> dleft;                  left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;                  left = Clip16BitSample(left);                  m_PrevSampleLeft = m_CurSampleLeft;                  m_CurSampleLeft = left;                    // Now we've got lCurSampleLeft which is one mono sample and all is set                  // for the next input byte...                  //Output((SHORT)lCurSampleLeft); // send the sample to output                  m_Writer.Write((short)m_CurSampleLeft);              }
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)                  return 32767;              else if (sample < -32768)                  return (-32768);              else                  return sample;
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)                  return 32767;              else if (sample < -32768)                  return (-32768);              else                  return sample;
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)                  return 32767;              else if (sample < -32768)                  return (-32768);              else                  return sample;
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)                  return 32767;              else if (sample < -32768)                  return (-32768);              else                  return sample;
Magic Number,Files.AudioFiles,XAFile,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Audiofiles\XAFile.cs,HINIBBLE,The following statement contains a magic number: return (byte)(((B) >> 4) & 0x0F);
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach(string TrckEvent in TrackEvents)              {                  string[] Elements = TrckEvent.Split(''');                  TrackEvent Event = new TrackEvent();                  Event.Name = Elements[0];                  Event.EventType = (HITEvents)Enum.ToObject(typeof(HITEvents)' ParseHexString(Elements[1]));                  if(!Event.Name.Contains("bkground")) //Sigh' Maxis...                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2].Replace("0x"' "")' NumberStyles.HexNumber);                  else                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2]);                  Event.Unknown = ParseHexString(Elements[3]);                  Event.Unknown2 = ParseHexString(Elements[4]);                  Event.Unknown3 = ParseHexString(Elements[5]);                  Event.Unknown4 = ParseHexString(Elements[6]);                  Events.Add(Event);              }
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach(string TrckEvent in TrackEvents)              {                  string[] Elements = TrckEvent.Split(''');                  TrackEvent Event = new TrackEvent();                  Event.Name = Elements[0];                  Event.EventType = (HITEvents)Enum.ToObject(typeof(HITEvents)' ParseHexString(Elements[1]));                  if(!Event.Name.Contains("bkground")) //Sigh' Maxis...                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2].Replace("0x"' "")' NumberStyles.HexNumber);                  else                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2]);                  Event.Unknown = ParseHexString(Elements[3]);                  Event.Unknown2 = ParseHexString(Elements[4]);                  Event.Unknown3 = ParseHexString(Elements[5]);                  Event.Unknown4 = ParseHexString(Elements[6]);                  Events.Add(Event);              }
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach(string TrckEvent in TrackEvents)              {                  string[] Elements = TrckEvent.Split(''');                  TrackEvent Event = new TrackEvent();                  Event.Name = Elements[0];                  Event.EventType = (HITEvents)Enum.ToObject(typeof(HITEvents)' ParseHexString(Elements[1]));                  if(!Event.Name.Contains("bkground")) //Sigh' Maxis...                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2].Replace("0x"' "")' NumberStyles.HexNumber);                  else                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2]);                  Event.Unknown = ParseHexString(Elements[3]);                  Event.Unknown2 = ParseHexString(Elements[4]);                  Event.Unknown3 = ParseHexString(Elements[5]);                  Event.Unknown4 = ParseHexString(Elements[6]);                  Events.Add(Event);              }
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach(string TrckEvent in TrackEvents)              {                  string[] Elements = TrckEvent.Split(''');                  TrackEvent Event = new TrackEvent();                  Event.Name = Elements[0];                  Event.EventType = (HITEvents)Enum.ToObject(typeof(HITEvents)' ParseHexString(Elements[1]));                  if(!Event.Name.Contains("bkground")) //Sigh' Maxis...                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2].Replace("0x"' "")' NumberStyles.HexNumber);                  else                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2]);                  Event.Unknown = ParseHexString(Elements[3]);                  Event.Unknown2 = ParseHexString(Elements[4]);                  Event.Unknown3 = ParseHexString(Elements[5]);                  Event.Unknown4 = ParseHexString(Elements[6]);                  Events.Add(Event);              }
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach(string TrckEvent in TrackEvents)              {                  string[] Elements = TrckEvent.Split(''');                  TrackEvent Event = new TrackEvent();                  Event.Name = Elements[0];                  Event.EventType = (HITEvents)Enum.ToObject(typeof(HITEvents)' ParseHexString(Elements[1]));                  if(!Event.Name.Contains("bkground")) //Sigh' Maxis...                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2].Replace("0x"' "")' NumberStyles.HexNumber);                  else                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2]);                  Event.Unknown = ParseHexString(Elements[3]);                  Event.Unknown2 = ParseHexString(Elements[4]);                  Event.Unknown3 = ParseHexString(Elements[5]);                  Event.Unknown4 = ParseHexString(Elements[6]);                  Events.Add(Event);              }
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach(string TrckEvent in TrackEvents)              {                  string[] Elements = TrckEvent.Split(''');                  TrackEvent Event = new TrackEvent();                  Event.Name = Elements[0];                  Event.EventType = (HITEvents)Enum.ToObject(typeof(HITEvents)' ParseHexString(Elements[1]));                  if(!Event.Name.Contains("bkground")) //Sigh' Maxis...                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2].Replace("0x"' "")' NumberStyles.HexNumber);                  else                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2]);                  Event.Unknown = ParseHexString(Elements[3]);                  Event.Unknown2 = ParseHexString(Elements[4]);                  Event.Unknown3 = ParseHexString(Elements[5]);                  Event.Unknown4 = ParseHexString(Elements[6]);                  Events.Add(Event);              }
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach(string TrckEvent in TrackEvents)              {                  string[] Elements = TrckEvent.Split(''');                  TrackEvent Event = new TrackEvent();                  Event.Name = Elements[0];                  Event.EventType = (HITEvents)Enum.ToObject(typeof(HITEvents)' ParseHexString(Elements[1]));                  if(!Event.Name.Contains("bkground")) //Sigh' Maxis...                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2].Replace("0x"' "")' NumberStyles.HexNumber);                  else                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2]);                  Event.Unknown = ParseHexString(Elements[3]);                  Event.Unknown2 = ParseHexString(Elements[4]);                  Event.Unknown3 = ParseHexString(Elements[5]);                  Event.Unknown4 = ParseHexString(Elements[6]);                  Events.Add(Event);              }
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach(string TrckEvent in TrackEvents)              {                  string[] Elements = TrckEvent.Split(''');                  TrackEvent Event = new TrackEvent();                  Event.Name = Elements[0];                  Event.EventType = (HITEvents)Enum.ToObject(typeof(HITEvents)' ParseHexString(Elements[1]));                  if(!Event.Name.Contains("bkground")) //Sigh' Maxis...                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2].Replace("0x"' "")' NumberStyles.HexNumber);                  else                      Event.TrackID = (Elements[2].Equals(""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse(Elements[2]);                  Event.Unknown = ParseHexString(Elements[3]);                  Event.Unknown2 = ParseHexString(Elements[4]);                  Event.Unknown3 = ParseHexString(Elements[5]);                  Event.Unknown4 = ParseHexString(Elements[6]);                  Events.Add(Event);              }
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,ParseHexString,The following statement contains a magic number: if (HexStr.StartsWith("0x"))              {                  HexStr = HexStr.Substring(2);                  IsHex = true;              }              //Sigh' Maxis...              else if (HexStr.Contains("a") || HexStr.Contains("b") || HexStr.Contains("b") ||                  HexStr.Contains("c") || HexStr.Contains("d") || HexStr.Contains("e") || HexStr.Contains("f"))              {                  IsHex = true;              }
Magic Number,Files.AudioLogic,EVT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,ParseHexString,The following statement contains a magic number: if (IsHex)              {                  return Convert.ToUInt32(HexStr' 16);              }              else              {                  return Convert.ToUInt32(HexStr);              }
Magic Number,Files.AudioLogic,HLS,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,HLS,The following statement contains a magic number: try              {                  if (Unknown == 1) //First format                  {                      if ((m_Reader.StreamLength - m_Reader.Position) > 4) //... because sometimes it will just end here D:                      {                          uint Count = m_Reader.ReadUInt32();                            for (int i = 0; i < Count; i++)                              SoundsAndHitlists.Add(m_Reader.ReadUInt32());                      }                  }                  else                  {                      string Str = m_Reader.ReadString((int)Unknown).Replace("\n"' "");                      string[] SplitByComma = Str.Split(''');                        for(int i = 0; i < SplitByComma.Length; i++)                      {                          string[] SplitByDash = SplitByComma[i].Split('-');                            if(SplitByDash.Length > 1)                          {                              uint Min = Convert.ToUInt32(SplitByDash[0]);                              uint Max = Convert.ToUInt32(SplitByDash[1]);                                for(uint j = Min; j <= Max; j++)                                  SoundsAndHitlists.Add(j);                          }                          else                              SoundsAndHitlists.Add(Convert.ToUInt32(SplitByComma[i]));                      }                  }              }              catch              {                  m_Reader.Seek(4);                  for (int i = 0; i < Unknown; i++)                      SoundsAndHitlists.Add(m_Reader.ReadUInt32());                    m_Reader.Close();              }
Magic Number,Files.AudioLogic,HLS,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,HLS,The following statement contains a magic number: try              {                  if (Unknown == 1) //First format                  {                      if ((m_Reader.StreamLength - m_Reader.Position) > 4) //... because sometimes it will just end here D:                      {                          uint Count = m_Reader.ReadUInt32();                            for (int i = 0; i < Count; i++)                              SoundsAndHitlists.Add(m_Reader.ReadUInt32());                      }                  }                  else                  {                      string Str = m_Reader.ReadString((int)Unknown).Replace("\n"' "");                      string[] SplitByComma = Str.Split(''');                        for(int i = 0; i < SplitByComma.Length; i++)                      {                          string[] SplitByDash = SplitByComma[i].Split('-');                            if(SplitByDash.Length > 1)                          {                              uint Min = Convert.ToUInt32(SplitByDash[0]);                              uint Max = Convert.ToUInt32(SplitByDash[1]);                                for(uint j = Min; j <= Max; j++)                                  SoundsAndHitlists.Add(j);                          }                          else                              SoundsAndHitlists.Add(Convert.ToUInt32(SplitByComma[i]));                      }                  }              }              catch              {                  m_Reader.Seek(4);                  for (int i = 0; i < Unknown; i++)                      SoundsAndHitlists.Add(m_Reader.ReadUInt32());                    m_Reader.Close();              }
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: string MagicNumber = Enc.GetString(m_Reader.ReadBytes(4));
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: TrackName = Elements[2];
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[3].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  SoundID = uint.Parse(Elements[3].Replace("0x"' "")' NumberStyles.HexNumber);              else                  SoundID = 0;
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[3].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  SoundID = uint.Parse(Elements[3].Replace("0x"' "")' NumberStyles.HexNumber);              else                  SoundID = 0;
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (Elements[5].Equals("\r\n"' StringComparison.InvariantCultureIgnoreCase))                  return;
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[5].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Argument = (HITTrackArguments)Enum.Parse(typeof(HITTrackArguments)' Elements[5]);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[5].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Argument = (HITTrackArguments)Enum.Parse(typeof(HITTrackArguments)' Elements[5]);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[7].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  ControlGroup = (HITControlGroup)Enum.Parse(typeof(HITControlGroup)' Elements[7]);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[7].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  ControlGroup = (HITControlGroup)Enum.Parse(typeof(HITControlGroup)' Elements[7]);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 11 : 12].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  DuckingPriority = int.Parse(Elements[(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 11 : 12].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  DuckingPriority = int.Parse(Elements[(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 11 : 12].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  DuckingPriority = int.Parse(Elements[(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 11 : 12].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  DuckingPriority = int.Parse(Elements[(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 11 : 12].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  DuckingPriority = int.Parse(Elements[(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 11 : 12].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  DuckingPriority = int.Parse(Elements[(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 12 : 13].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Looped = (int.Parse(Elements[(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 12 : 13].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Looped = (int.Parse(Elements[(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 12 : 13].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Looped = (int.Parse(Elements[(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 12 : 13].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Looped = (int.Parse(Elements[(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 12 : 13].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Looped = (int.Parse(Elements[(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 12 : 13].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Looped = (int.Parse(Elements[(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 13 : 14].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Volume = int.Parse(Elements[(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 13 : 14].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Volume = int.Parse(Elements[(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 13 : 14].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Volume = int.Parse(Elements[(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 13 : 14].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Volume = int.Parse(Elements[(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 13 : 14].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Volume = int.Parse(Elements[(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);
Magic Number,Files.AudioLogic,TRK,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements[(m_Version != 2) ? 13 : 14].Equals(""' StringComparison.InvariantCultureIgnoreCase))                  Volume = int.Parse(Elements[(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);
Magic Number,Files.DBPF,DBPFArchive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(4));                    if (!MagicNumber.Equals("DBPF"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new DBPFException("MagicNumber was wrong - DBPFArchive.cs!");                      else                      {                          m_Reader.Close();                          return false;                      }                  }                    m_Reader.ReadUInt32();  //MajorVersion                  m_Reader.ReadUInt32();  //MinorVersion                  m_Reader.ReadBytes(12); //Reserved.                  m_Reader.ReadBytes(4);  //Date created.                  m_Reader.ReadBytes(4);  //Date modified.                  m_Reader.ReadUInt32();  //Index major version.                  IndexEntryCount = m_Reader.ReadUInt32();                  IndexOffset = m_Reader.ReadUInt32();                  IndexSize = m_Reader.ReadUInt32();                    m_Reader.Seek(IndexOffset);                    for(int i = 0; i < IndexEntryCount; i++)                  {                      DBPFEntry Entry = new DBPFEntry();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.GroupID = m_Reader.ReadUInt32();                      Entry.InstanceID = m_Reader.ReadUInt32();                      Entry.FileOffset = m_Reader.ReadUInt32();                      Entry.FileSize = m_Reader.ReadUInt32();                        UniqueFileID ID = new UniqueFileID(Entry.TypeID' Entry.InstanceID' Entry.GroupID);                      Entry.EntryID = ID;                      m_Entries.Add(ID' Entry);                  }              }
Magic Number,Files.DBPF,DBPFArchive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(4));                    if (!MagicNumber.Equals("DBPF"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new DBPFException("MagicNumber was wrong - DBPFArchive.cs!");                      else                      {                          m_Reader.Close();                          return false;                      }                  }                    m_Reader.ReadUInt32();  //MajorVersion                  m_Reader.ReadUInt32();  //MinorVersion                  m_Reader.ReadBytes(12); //Reserved.                  m_Reader.ReadBytes(4);  //Date created.                  m_Reader.ReadBytes(4);  //Date modified.                  m_Reader.ReadUInt32();  //Index major version.                  IndexEntryCount = m_Reader.ReadUInt32();                  IndexOffset = m_Reader.ReadUInt32();                  IndexSize = m_Reader.ReadUInt32();                    m_Reader.Seek(IndexOffset);                    for(int i = 0; i < IndexEntryCount; i++)                  {                      DBPFEntry Entry = new DBPFEntry();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.GroupID = m_Reader.ReadUInt32();                      Entry.InstanceID = m_Reader.ReadUInt32();                      Entry.FileOffset = m_Reader.ReadUInt32();                      Entry.FileSize = m_Reader.ReadUInt32();                        UniqueFileID ID = new UniqueFileID(Entry.TypeID' Entry.InstanceID' Entry.GroupID);                      Entry.EntryID = ID;                      m_Entries.Add(ID' Entry);                  }              }
Magic Number,Files.DBPF,DBPFArchive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(4));                    if (!MagicNumber.Equals("DBPF"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new DBPFException("MagicNumber was wrong - DBPFArchive.cs!");                      else                      {                          m_Reader.Close();                          return false;                      }                  }                    m_Reader.ReadUInt32();  //MajorVersion                  m_Reader.ReadUInt32();  //MinorVersion                  m_Reader.ReadBytes(12); //Reserved.                  m_Reader.ReadBytes(4);  //Date created.                  m_Reader.ReadBytes(4);  //Date modified.                  m_Reader.ReadUInt32();  //Index major version.                  IndexEntryCount = m_Reader.ReadUInt32();                  IndexOffset = m_Reader.ReadUInt32();                  IndexSize = m_Reader.ReadUInt32();                    m_Reader.Seek(IndexOffset);                    for(int i = 0; i < IndexEntryCount; i++)                  {                      DBPFEntry Entry = new DBPFEntry();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.GroupID = m_Reader.ReadUInt32();                      Entry.InstanceID = m_Reader.ReadUInt32();                      Entry.FileOffset = m_Reader.ReadUInt32();                      Entry.FileSize = m_Reader.ReadUInt32();                        UniqueFileID ID = new UniqueFileID(Entry.TypeID' Entry.InstanceID' Entry.GroupID);                      Entry.EntryID = ID;                      m_Entries.Add(ID' Entry);                  }              }
Magic Number,Files.DBPF,DBPFArchive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(4));                    if (!MagicNumber.Equals("DBPF"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new DBPFException("MagicNumber was wrong - DBPFArchive.cs!");                      else                      {                          m_Reader.Close();                          return false;                      }                  }                    m_Reader.ReadUInt32();  //MajorVersion                  m_Reader.ReadUInt32();  //MinorVersion                  m_Reader.ReadBytes(12); //Reserved.                  m_Reader.ReadBytes(4);  //Date created.                  m_Reader.ReadBytes(4);  //Date modified.                  m_Reader.ReadUInt32();  //Index major version.                  IndexEntryCount = m_Reader.ReadUInt32();                  IndexOffset = m_Reader.ReadUInt32();                  IndexSize = m_Reader.ReadUInt32();                    m_Reader.Seek(IndexOffset);                    for(int i = 0; i < IndexEntryCount; i++)                  {                      DBPFEntry Entry = new DBPFEntry();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.GroupID = m_Reader.ReadUInt32();                      Entry.InstanceID = m_Reader.ReadUInt32();                      Entry.FileOffset = m_Reader.ReadUInt32();                      Entry.FileSize = m_Reader.ReadUInt32();                        UniqueFileID ID = new UniqueFileID(Entry.TypeID' Entry.InstanceID' Entry.GroupID);                      Entry.EntryID = ID;                      m_Entries.Add(ID' Entry);                  }              }
Magic Number,Files.FAR1,FAR1Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR1\FAR1Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(8));                    if (!MagicNumber.Equals("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new FAR1Exception("MagicNumber was wrong - FAR1Archive.cs!");                      else                      {                          m_Reader.Close();                          return;                      }                  }                    m_Reader.ReadUInt32(); //Version.                  m_Reader.Seek(m_Reader.ReadUInt32());                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      FAR1Entry Entry = new FAR1Entry();                      Entry.CompressedDataSize = m_Reader.ReadUInt32();                      Entry.DecompressedDataSize = m_Reader.ReadUInt32();                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.FilenameLength = m_Reader.ReadUShort();                      Entry.FilenameHash = FileUtilities.GenerateHash(Enc.GetString(m_Reader.ReadBytes(Entry.FilenameLength)));                        m_Entries.Add(Entry);                  }              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6)              {  	            // some Compression Data  	            const int MAX_OFFSET = 0x20000;  	            const int MAX_COPY_COUNT = 0x404;  	            // used to finetune the lookup (small values increase the  	            // compression for Big Files)  	            const int QFS_MAXITER = 0x80;    	            // contains the latest offset for a combination of two  	            // characters  	            Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList>();    	            // will contain the compressed data (maximal size =  	            // uncompressedSize+MAX_COPY_COUNT)  	            byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];    	            // init some vars  	            int writeIndex = 9; // leave 9 bytes for the header  	            int lastReadIndex = 0;  	            ArrayList indexList = null;  	            int copyOffset = 0;  	            int copyCount = 0;  	            int index = -1;  	            bool end = false;    	            // begin main compression loop  	            while (index < Data.Length - 3)                  {  		            // get all Compression Candidates (list of offsets for all  		            // occurances of the current 3 bytes)  		            do                       {  			            index++;  			            if (index >= Data.Length - 2)                          {  				            end = true;  				            break;  			            }  			            int mapindex = Data[index] + (Data[index + 1] << 8)  					            + (Data[index + 2] << 16);    			            indexList = cmpmap2[mapindex];  			            if (indexList == null)                          {  				            indexList = new ArrayList();  				            cmpmap2.Add(mapindex' indexList);  			            }  			            indexList.Add(index);  		            } while (index < lastReadIndex);  		            if (end)  			            break;    		            // find the longest repeating byte sequence in the index  		            // List (for offset copy)  		            int offsetCopyCount = 0;  		            int loopcount = 1;  		            while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER))                      {  			            int foundindex = (int) indexList[(indexList.Count - 1) - loopcount];  			            if ((index - foundindex) >= MAX_OFFSET)                          {  				            break;  			            }    			            loopcount++;  			            copyCount = 3;    			            while ((Data.Length > index + copyCount)&& (Data[index + copyCount] == Data[foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT))                          {  				            copyCount++;  			            }    			            if (copyCount > offsetCopyCount)                          {  				            offsetCopyCount = copyCount;  				            copyOffset = index - foundindex;  			            }  		            }    		            // check if we can compress this  		            // In FSH Tool stand additionally this:  		            if (offsetCopyCount > Data.Length - index)                      {  			            offsetCopyCount = index - Data.Length;  		            }  		            if (offsetCopyCount <= 2)                      {  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 3) && (copyOffset > 0x400))                       { // 1024  			            offsetCopyCount = 0;  		            }                       else if ((offsetCopyCount == 4) && (copyOffset > 0x4000))                       { // 16384  			            offsetCopyCount = 0;  		            }    		            // this is offset-compressable? so do the compression  		            if (offsetCopyCount > 0)                      {  			            // plaincopy    			            // In FSH Tool stand this (A):  			            while (index - lastReadIndex >= 4)                          {  				            copyCount = (index - lastReadIndex) / 4 - 1;  				            if (copyCount > 0x1B)                              {  					            copyCount = 0x1B;  				            }                              cData[writeIndex++] = (byte)(0xE0 + copyCount);  				            copyCount = 4 * copyCount + 4;    				            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  				            lastReadIndex += copyCount;  				            writeIndex += copyCount;  			            }    			            // offsetcopy  			            copyCount = index - lastReadIndex;  			            copyOffset--;  			            if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400))                          {  				            cData[writeIndex++] = (byte) (((copyOffset >> 8) << 5)  						            + ((offsetCopyCount - 3) << 2) + copyCount);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000))                          {                              cData[writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				            cData[writeIndex++] = (byte) ((copyCount << 6) + (copyOffset >> 8));  				            cData[writeIndex++] = (byte) (copyOffset & 0xff);  			            }                           else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET))                          {                              cData[writeIndex++] = (byte)(0xc0  						            + ((copyOffset >> 16) << 4)  						            + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);                              cData[writeIndex++] = (byte)((copyOffset >> 8) & 0xff);                              cData[writeIndex++] = (byte)(copyOffset & 0xff);                              cData[writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			            }    			            // do the offset copy  			            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  			            writeIndex += copyCount;  			            lastReadIndex += copyCount;  			            lastReadIndex += offsetCopyCount;  		            }  	            }    	            // add the End Record  	            index = Data.Length;  	            // in FSH Tool stand the same as above (A)  	            while (index - lastReadIndex >= 4)                  {  		            copyCount = (index - lastReadIndex) / 4 - 1;  		                                  if (copyCount > 0x1B)  			            copyCount = 0x1B;                        cData[writeIndex++] = (byte)(0xE0 + copyCount);  		            copyCount = 4 * copyCount + 4;    		            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  		            lastReadIndex += copyCount;  		            writeIndex += copyCount;  	            }    	            copyCount = index - lastReadIndex;  	            cData[writeIndex++] = (byte) (0xfc + copyCount);  	            ArrayCopy2(Data' lastReadIndex' ref cData' writeIndex' copyCount);  	            writeIndex += copyCount;  	            lastReadIndex += copyCount;                    MemoryStream DataStream = new MemoryStream();                  BinaryWriter Writer = new BinaryWriter(DataStream);    	            // write the header for the compressed data  	            // set the compressed size                  Writer.Write((uint)writeIndex);                  m_CompressedSize = writeIndex;  	            // set the MAGICNUMBER                  Writer.Write((ushort)0xFB10);  	            // set the decompressed size  	            byte[] revData = BitConverter.GetBytes(Data.Length);                  Writer.Write((revData[2] << 16) | (revData[1] << 8) | revData[0]);                  Writer.Write(cData);                    //Avoid nasty swearing here!                  Writer.Flush();                    m_DecompressedSize = Data.Length;    	            return DataStream.ToArray();              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,Decompresser,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  byte[] DecompressedData = new byte[(int)m_DecompressedSize];                  int DataPos = 0;                    int Pos = 0;                  long Control1 = 0;                    while (Control1 != 0xFC && Pos < Data.Length)                  {                      Control1 = Data[Pos];                      Pos++;                        if (Pos == Data.Length)                          break;                        if (Control1 >= 0 && Control1 <= 127)                      {                          // 0x00 - 0x7F                          long control2 = Data[Pos];                          Pos++;                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if ((Control1 >= 128 && Control1 <= 191))                      {                          // 0x80 - 0xBF                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                            long numberOfPlainText = (control2 >> 6) & 0x03;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                          long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 192 && Control1 <= 223)                      {                          // 0xC0 - 0xDF                          long numberOfPlainText = (Control1 & 0x03);                          long control2 = Data[Pos];                          Pos++;                          long control3 = Data[Pos];                          Pos++;                          long control4 = Data[Pos];                          Pos++;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                            int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);                          long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;                          OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                          DataPos += (int)numberToCopyFromOffset;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else if (Control1 >= 224 && Control1 <= 251)                      {                          // 0xE0 - 0xFB                          long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                          DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                      else                      {                          long numberOfPlainText = (Control1 & 0x03);                          ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                            DataPos += (int)numberOfPlainText;                          Pos += (int)numberOfPlainText;                            if (DataPos == (DecompressedData.Length))                              break;                      }                  }                    return DecompressedData;              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(8));                    if (!MagicNumber.Equals("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new FAR3Exception("MagicNumber was wrong - FAR3Archive.cs!");                      else                      {                          m_Reader.Close();                          return false;                      }                  }                    m_Reader.ReadUInt32(); //Version.                  m_Reader.Seek((long)m_Reader.ReadUInt32());                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      FAR3Entry Entry = new FAR3Entry();                      Entry.DecompressedDataSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedDataSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      m_Reader.ReadByte(); //Unknown.                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Flags = m_Reader.ReadUShort();                      Entry.FileNameLength = m_Reader.ReadUShort();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Enc.GetString(m_Reader.ReadBytes(Entry.FileNameLength));                        UniqueFileID ID = new UniqueFileID(Entry.TypeID' Entry.FileID);                        if (!m_Entries.ContainsKey(ID.UniqueID))                          m_Entries.AddOrUpdate(ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(8));                    if (!MagicNumber.Equals("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new FAR3Exception("MagicNumber was wrong - FAR3Archive.cs!");                      else                      {                          m_Reader.Close();                          return false;                      }                  }                    m_Reader.ReadUInt32(); //Version.                  m_Reader.Seek((long)m_Reader.ReadUInt32());                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      FAR3Entry Entry = new FAR3Entry();                      Entry.DecompressedDataSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedDataSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      m_Reader.ReadByte(); //Unknown.                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Flags = m_Reader.ReadUShort();                      Entry.FileNameLength = m_Reader.ReadUShort();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Enc.GetString(m_Reader.ReadBytes(Entry.FileNameLength));                        UniqueFileID ID = new UniqueFileID(Entry.TypeID' Entry.FileID);                        if (!m_Entries.ContainsKey(ID.UniqueID))                          m_Entries.AddOrUpdate(ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(8));                    if (!MagicNumber.Equals("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new FAR3Exception("MagicNumber was wrong - FAR3Archive.cs!");                      else                      {                          m_Reader.Close();                          return false;                      }                  }                    m_Reader.ReadUInt32(); //Version.                  m_Reader.Seek((long)m_Reader.ReadUInt32());                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      FAR3Entry Entry = new FAR3Entry();                      Entry.DecompressedDataSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedDataSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      m_Reader.ReadByte(); //Unknown.                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Flags = m_Reader.ReadUShort();                      Entry.FileNameLength = m_Reader.ReadUShort();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Enc.GetString(m_Reader.ReadBytes(Entry.FileNameLength));                        UniqueFileID ID = new UniqueFileID(Entry.TypeID' Entry.FileID);                        if (!m_Entries.ContainsKey(ID.UniqueID))                          m_Entries.AddOrUpdate(ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(8));                    if (!MagicNumber.Equals("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new FAR3Exception("MagicNumber was wrong - FAR3Archive.cs!");                      else                      {                          m_Reader.Close();                          return false;                      }                  }                    m_Reader.ReadUInt32(); //Version.                  m_Reader.Seek((long)m_Reader.ReadUInt32());                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      FAR3Entry Entry = new FAR3Entry();                      Entry.DecompressedDataSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedDataSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      m_Reader.ReadByte(); //Unknown.                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Flags = m_Reader.ReadUShort();                      Entry.FileNameLength = m_Reader.ReadUShort();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Enc.GetString(m_Reader.ReadBytes(Entry.FileNameLength));                        UniqueFileID ID = new UniqueFileID(Entry.TypeID' Entry.FileID);                        if (!m_Entries.ContainsKey(ID.UniqueID))                          m_Entries.AddOrUpdate(ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader)              {                  ASCIIEncoding Enc = new ASCIIEncoding();                  string MagicNumber = Enc.GetString(m_Reader.ReadBytes(8));                    if (!MagicNumber.Equals("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase))                  {                      if (ThrowException)                          throw new FAR3Exception("MagicNumber was wrong - FAR3Archive.cs!");                      else                      {                          m_Reader.Close();                          return false;                      }                  }                    m_Reader.ReadUInt32(); //Version.                  m_Reader.Seek((long)m_Reader.ReadUInt32());                    uint NumFiles = m_Reader.ReadUInt32();                    for (int i = 0; i < NumFiles; i++)                  {                      FAR3Entry Entry = new FAR3Entry();                      Entry.DecompressedDataSize = m_Reader.ReadUInt32();                      byte[] Dummy = m_Reader.ReadBytes(3);                      Entry.CompressedDataSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                      m_Reader.ReadByte(); //Unknown.                      Entry.DataOffset = m_Reader.ReadUInt32();                      Entry.Flags = m_Reader.ReadUShort();                      Entry.FileNameLength = m_Reader.ReadUShort();                      Entry.TypeID = m_Reader.ReadUInt32();                      Entry.FileID = m_Reader.ReadUInt32();                      Entry.Filename = Enc.GetString(m_Reader.ReadBytes(Entry.FileNameLength));                        UniqueFileID ID = new UniqueFileID(Entry.TypeID' Entry.FileID);                        if (!m_Entries.ContainsKey(ID.UniqueID))                          m_Entries.AddOrUpdate(ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader)              {                  m_Reader.Seek((long)Entry.DataOffset);                    switch (Entry.TypeID)                  {                      case 1: //BMP                      case 2: //TGA                      case 5: //SKEL                      case 7: //ANIM                      case 9: //MESH                      case 11: //BND                      case 12: //APR                      case 13: //OFT                      case 15: //PO                      case 16: //COL                      case 18: //HAG                      case 20: //JPG                      case 24: //PNG                          return Decompress(Entry);                      case 14: //PNG' uncompressed                      default:                          MemoryStream MemStream = new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));                          MemStream.Seek(0' SeekOrigin.Begin);                          return MemStream;                  }              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Decompress,The following statement contains a magic number: m_Reader.ReadBytes(9);
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Decompress,The following statement contains a magic number: if (CompressionID == 0xFB10)              {                  byte[] Dummy = m_Reader.ReadBytes(3);                  uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                    Decompresser Dec = new Decompresser();                  Dec.CompressedSize = CompressedSize;                  Dec.DecompressedSize = DecompressedSize;                    byte[] DecompressedData = Dec.Decompress(m_Reader.ReadBytes((int)CompressedSize));                    MemoryStream MemStream = new MemoryStream(DecompressedData);                  MemStream.Seek(0' SeekOrigin.Begin);                    return MemStream;              }              else              {                  m_Reader.Seek(m_Reader.Position - 15);                  return new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Decompress,The following statement contains a magic number: if (CompressionID == 0xFB10)              {                  byte[] Dummy = m_Reader.ReadBytes(3);                  uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                    Decompresser Dec = new Decompresser();                  Dec.CompressedSize = CompressedSize;                  Dec.DecompressedSize = DecompressedSize;                    byte[] DecompressedData = Dec.Decompress(m_Reader.ReadBytes((int)CompressedSize));                    MemoryStream MemStream = new MemoryStream(DecompressedData);                  MemStream.Seek(0' SeekOrigin.Begin);                    return MemStream;              }              else              {                  m_Reader.Seek(m_Reader.Position - 15);                  return new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));              }
Magic Number,Files.FAR3,FAR3Archive,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Decompress,The following statement contains a magic number: if (CompressionID == 0xFB10)              {                  byte[] Dummy = m_Reader.ReadBytes(3);                  uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                    Decompresser Dec = new Decompresser();                  Dec.CompressedSize = CompressedSize;                  Dec.DecompressedSize = DecompressedSize;                    byte[] DecompressedData = Dec.Decompress(m_Reader.ReadBytes((int)CompressedSize));                    MemoryStream MemStream = new MemoryStream(DecompressedData);                  MemStream.Seek(0' SeekOrigin.Begin);                    return MemStream;              }              else              {                  m_Reader.Seek(m_Reader.Position - 15);                  return new MemoryStream(m_Reader.ReadBytes((int)Entry.DecompressedDataSize));              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,IsBMP,The following statement contains a magic number: byte[] data = Reader.ReadBytes(2);
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,IsUTK,The following statement contains a magic number: byte[] data = Reader.ReadBytes(4);
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,IsXA,The following statement contains a magic number: byte[] data = Reader.ReadBytes(4);
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives)              {                  if (Archive.ContainsEntry(ID))                  {                      Stream Data = Archive.GrabEntry(ID);                        if (!m_Assets.ContainsKey(ID))                      {                          switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }                      }                        return Data;                  }              }
Magic Number,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Enum.IsDefined(typeof(FileIDs.TerrainFileIDs)' ID))              {                  if (Enum.GetName(typeof(FileIDs.TerrainFileIDs)' ID).Contains("road"))                  {                      using (FileStream FS = File.Open(m_BaseDir + (IsLinux ? "gamedata/terrain/" : "gamedata\\terrain\\") +                          Enum.GetName(typeof(FileIDs.TerrainFileIDs)' ID) + ".tga"' FileMode.Open' FileAccess.Read'                          FileShare.ReadWrite))                      {                          using (Paloma.TargaImage TGA = new Paloma.TargaImage(FS))                          {                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                              MemStream.Seek(0' SeekOrigin.Begin);                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                          }                      }                  }                  else                  {                      using (FileStream FS = File.Open(m_BaseDir + (IsLinux ? "gamedata/terrain/newformat/" :                           "gamedata\\terrain\\newformat\\") + Enum.GetName(typeof(FileIDs.TerrainFileIDs)' ID) + ".tga"'                           FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                      {                          using (Paloma.TargaImage TGA = new Paloma.TargaImage(FS))                          {                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                              MemStream.Seek(0' SeekOrigin.Begin);                              try                              {                                  AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                      Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                              }                              catch(Exception E)                              {                                  m_Logger.Error("FileManager.GrabItem():\n" +                                      "Failed to load TGA from 'gamedata\\terrain\\newformat\\':\n" +                                       E.ToString());                              }                          }                      }                  }                    return MemStream;              }              else if (Enum.IsDefined(typeof(FileIDs.CitiesFileIDs)' ID))              {                  string[] Split = Enum.GetName(typeof(FileIDs.CitiesFileIDs)' ID).Split("_".ToCharArray());                  using (FileStream FS = File.Open(m_BaseDir + (IsLinux ? "cities/" : "cities\\") +                      Split[0] + "_" + Split[1] + (IsLinux ? "/" : "\\") + Split[2] + ".bmp"'                      FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                  {                      using (BMap = new Bitmap(FS))                      {                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                          MemStream.Seek(0' SeekOrigin.Begin);                      }                        try                      {                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                      }                      catch (Exception E)                      {                          m_Logger.Error("FileManager.GrabItem():\n" +                              "Failed to load BMP from 'cities\\':\n" +                              E.ToString());                      }                        return MemStream;                  }              }              else if(Enum.IsDefined(typeof(FileIDs.UIFileIDs)' ID))              {                  using (FileStream FS = File.Open(m_BaseDir +                      (IsLinux ? "uigraphics/holiday/" : "uigraphics\\holiday\\") +                      Enum.GetName(typeof(FileIDs.UIFileIDs)' ID) +                       GetExtension(Enum.GetName(typeof(FileIDs.UIFileIDs)' ID))'                       FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                  {                      using (BMap = new Bitmap(FS))                      {                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                          MemStream.Seek(0' SeekOrigin.Begin);                      }                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                      return MemStream;                  }              }              else if (Enum.IsDefined(typeof(FileIDs.HintsFileIDs)' ID))              {                  using (FileStream FS = File.Open(m_BaseDir +                      (IsLinux ? "uigraphics/hints/" : "uigraphics\\hints\\") +                       Enum.GetName(typeof(FileIDs.HintsFileIDs)' ID) + ".bmp"'                       FileMode.Open' FileAccess.Read' FileShare.ReadWrite))                  {                      using (BMap = new Bitmap(FS))                      {                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                          MemStream.Seek(0' SeekOrigin.Begin);                      }                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                      return MemStream;                  }              }
Magic Number,Files.IFF,CST,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,CST,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,CST,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,CST,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,CTSS,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,CTSS,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,CTSS,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,CTSS,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,DGRP,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following statement contains a magic number: switch(m_Version)              {                  case 20000:                      ImageCount = Reader.ReadUShort();                      break;                  case 20001:                      ImageCount = Reader.ReadUShort();                      break;                  case 20003:                      ImageCount = Reader.ReadUInt32();                      break;                  case 20004:                      ImageCount = Reader.ReadUInt32();                      break;              }
Magic Number,Files.IFF,DGRP,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following statement contains a magic number: switch(m_Version)              {                  case 20000:                      ImageCount = Reader.ReadUShort();                      break;                  case 20001:                      ImageCount = Reader.ReadUShort();                      break;                  case 20003:                      ImageCount = Reader.ReadUInt32();                      break;                  case 20004:                      ImageCount = Reader.ReadUInt32();                      break;              }
Magic Number,Files.IFF,DGRP,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following statement contains a magic number: switch(m_Version)              {                  case 20000:                      ImageCount = Reader.ReadUShort();                      break;                  case 20001:                      ImageCount = Reader.ReadUShort();                      break;                  case 20003:                      ImageCount = Reader.ReadUInt32();                      break;                  case 20004:                      ImageCount = Reader.ReadUInt32();                      break;              }
Magic Number,Files.IFF,DGRP,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following statement contains a magic number: switch(m_Version)              {                  case 20000:                      ImageCount = Reader.ReadUShort();                      break;                  case 20001:                      ImageCount = Reader.ReadUShort();                      break;                  case 20003:                      ImageCount = Reader.ReadUInt32();                      break;                  case 20004:                      ImageCount = Reader.ReadUInt32();                      break;              }
Magic Number,Files.IFF,DGRPImg,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRPImg,The following statement contains a magic number: if (Version == 20000 || Version == 20001)              {                  SpriteCount = Reader.ReadUShort();                  DirectionFlags = Reader.ReadByte();                  ZoomLevel = Reader.ReadByte();                    for (int i = 0; i < SpriteCount; i++)                      Info.Add(new SpriteInfo(Reader' Version));              }              else              {                  DirectionFlags = Reader.ReadUInt32();                  ZoomLevel = Reader.ReadUInt32();                  SpriteCount = Reader.ReadUInt32();                    for (int i = 0; i < SpriteCount; i++)                      Info.Add(new SpriteInfo(Reader' Version));              }
Magic Number,Files.IFF,DGRPImg,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRPImg,The following statement contains a magic number: if (Version == 20000 || Version == 20001)              {                  SpriteCount = Reader.ReadUShort();                  DirectionFlags = Reader.ReadByte();                  ZoomLevel = Reader.ReadByte();                    for (int i = 0; i < SpriteCount; i++)                      Info.Add(new SpriteInfo(Reader' Version));              }              else              {                  DirectionFlags = Reader.ReadUInt32();                  ZoomLevel = Reader.ReadUInt32();                  SpriteCount = Reader.ReadUInt32();                    for (int i = 0; i < SpriteCount; i++)                      Info.Add(new SpriteInfo(Reader' Version));              }
Magic Number,Files.IFF,SpriteInfo,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,SpriteInfo,The following statement contains a magic number: if(Version == 20000 || Version == 20001)              {                  Type = Reader.ReadInt16();                  SPRChunkID = Reader.ReadInt16();                  SPRFrameNum = Reader.ReadInt16();                  Flags = Reader.ReadInt16();                  SpriteXOffset = Reader.ReadInt16();                  SpriteYOffset = Reader.ReadInt16();                  ObjectZOffset = Reader.ReadFloat();              }              else              {                  SPRChunkID = Reader.ReadInt32();                  SPRFrameNum = Reader.ReadInt32();                  SpriteXOffset = Reader.ReadInt32();                  SpriteYOffset = Reader.ReadInt32();                  ObjectZOffset = Reader.ReadFloat();                  Flags = Reader.ReadInt32();                    if (Version == 20004)                  {                      ObjectXOffset = Reader.ReadFloat();                      ObjectYOffset = Reader.ReadFloat();                  }              }
Magic Number,Files.IFF,SpriteInfo,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,SpriteInfo,The following statement contains a magic number: if(Version == 20000 || Version == 20001)              {                  Type = Reader.ReadInt16();                  SPRChunkID = Reader.ReadInt16();                  SPRFrameNum = Reader.ReadInt16();                  Flags = Reader.ReadInt16();                  SpriteXOffset = Reader.ReadInt16();                  SpriteYOffset = Reader.ReadInt16();                  ObjectZOffset = Reader.ReadFloat();              }              else              {                  SPRChunkID = Reader.ReadInt32();                  SPRFrameNum = Reader.ReadInt32();                  SpriteXOffset = Reader.ReadInt32();                  SpriteYOffset = Reader.ReadInt32();                  ObjectZOffset = Reader.ReadFloat();                  Flags = Reader.ReadInt32();                    if (Version == 20004)                  {                      ObjectXOffset = Reader.ReadFloat();                      ObjectYOffset = Reader.ReadFloat();                  }              }
Magic Number,Files.IFF,SpriteInfo,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,SpriteInfo,The following statement contains a magic number: if(Version == 20000 || Version == 20001)              {                  Type = Reader.ReadInt16();                  SPRChunkID = Reader.ReadInt16();                  SPRFrameNum = Reader.ReadInt16();                  Flags = Reader.ReadInt16();                  SpriteXOffset = Reader.ReadInt16();                  SpriteYOffset = Reader.ReadInt16();                  ObjectZOffset = Reader.ReadFloat();              }              else              {                  SPRChunkID = Reader.ReadInt32();                  SPRFrameNum = Reader.ReadInt32();                  SpriteXOffset = Reader.ReadInt32();                  SpriteYOffset = Reader.ReadInt32();                  ObjectZOffset = Reader.ReadFloat();                  Flags = Reader.ReadInt32();                    if (Version == 20004)                  {                      ObjectXOffset = Reader.ReadFloat();                      ObjectYOffset = Reader.ReadFloat();                  }              }
Magic Number,Files.IFF,IFFChunk,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\IFFChunk.cs,ReadHeader,The following statement contains a magic number: Type = (IFFChunkTypes)Enum.Parse(typeof(IFFChunkTypes)' Reader.ReadString(4).Replace("#"' "").Replace("\0"' ""));
Magic Number,Files.IFF,IFFChunk,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\IFFChunk.cs,ReadHeader,The following statement contains a magic number: Reader.ReadBytes(64);
Magic Number,Files.IFF,IFFChunk,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\IFFChunk.cs,ReadHeader,The following statement contains a magic number: m_Data = Reader.ReadBytes((int)(Size - 76));
Magic Number,Files.IFF,Iff,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\Iff.cs,Init,The following statement contains a magic number: string MagicNumber = m_Reader.ReadString(60);
Magic Number,Files.IFF,Iff,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\Iff.cs,Init,The following statement contains a magic number: while ((m_Reader.StreamLength - m_Reader.Position) > 76)              {                  IFFChunk Chunk;                    if (m_Device != null)                      Chunk = new IFFChunk(m_Reader' m_Device' this);                  else                      Chunk = new IFFChunk(m_Reader' this);                    switch (Chunk.Type)                  {                      case IFFChunkTypes.FBMP:                          FBMP FBMPChunk = new FBMP(Chunk);                          m_FBMPChunks.Add(Chunk.ID' FBMPChunk);                          break;                      case IFFChunkTypes.FWAV:                          FWAV FWAVChunk = new FWAV(Chunk);                          m_FWAVChunks.Add(Chunk.ID' FWAVChunk);                          break;                      case IFFChunkTypes.BMP_:                          BMP_ BMPChunk = new BMP_(Chunk);                          m_BMP_Chunks.Add(Chunk.ID' BMPChunk);                          break;                      case IFFChunkTypes.DGRP:                          DGRP DGRPChunk = new DGRP(Chunk);                          m_DGRPChunks.Add(Chunk.ID' DGRPChunk);                          break;                      case IFFChunkTypes.BCON:                          BCON BCONChunk = new BCON(Chunk);                          m_BCONChunks.Add(Chunk.ID' BCONChunk);                          break;                      case IFFChunkTypes.GLOB:                          GLOB GlobChunk = new GLOB(Chunk);                          m_GLOBChunks.Add(Chunk.ID' GlobChunk);                          break;                      case IFFChunkTypes.OBJD:                          OBJD OBJDChunk = new OBJD(Chunk);                          m_OBJDs.Add(OBJDChunk);                          break;                      case IFFChunkTypes.TTAs:                          TTAs TTAsChunk = new TTAs(Chunk);                          m_TTAsChunks.Add(Chunk.ID' TTAsChunk);                          break;                      case IFFChunkTypes.TTAB:                          TTAB TTABChunk = new TTAB(Chunk);                          TTABChunk.Type = Chunk.Type;                          TTABChunk.ID = Chunk.ID;                          m_TTABChunks.Add(Chunk.ID' TTABChunk);                          break;                      case IFFChunkTypes.TPRP:                          TPRP TPRPChunk = new TPRP(Chunk);                          m_TPRPChunks.Add(Chunk.ID' TPRPChunk);                          break;                      case IFFChunkTypes.STR:                          STR STRChunk = new STR(Chunk);                          m_STRChunks.Add(Chunk.ID' STRChunk);                          break;                      case IFFChunkTypes.BHAV:                          BHAV BHAVChunk = new BHAV(Chunk);                          m_BHAVChunks.Add(Chunk.ID' BHAVChunk);                          break;                      case IFFChunkTypes.OBJf:                          OBJf OBJfChunk = new OBJf(Chunk);                          m_OBJfChunks.Add(Chunk.ID' OBJfChunk);                          break;                      case IFFChunkTypes.FCNS:                          FCNS FCNSChunk = new FCNS(Chunk);                          m_FCNSChunks.Add(Chunk.ID' FCNSChunk);                          break;                      case IFFChunkTypes.SPR:                          SPR SPRChunk = new SPR(Chunk);                          m_SPRChunks.Add(Chunk.ID' SPRChunk);                          break;                      case IFFChunkTypes.SPR2:                          SPR2 SPR2Chunk = new SPR2(Chunk);                          m_SPR2Chunks.Add(Chunk.ID' SPR2Chunk);                          break;                      case IFFChunkTypes.PALT:                          PALT PALTChunk = new PALT(Chunk);                          m_PALTChunks.Add(Chunk.ID' PALTChunk);                          break;                      case IFFChunkTypes.CTSS:                          CTSS CTSSChunk = new CTSS(Chunk);                          m_CTSSChunks.Add(Chunk.ID' CTSSChunk);                          break;                      case IFFChunkTypes.CST:                          CST CSTChunk = new CST(Chunk);                          m_CSTChunks.Add(Chunk.ID' CSTChunk);                          break;                  }              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Magic Number,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: if (m_NumFields > 80)              {                  WallStyleSpriteID = Reader.ReadUShort();                  RatingHunger = Reader.ReadUShort();                  RatingComfort = Reader.ReadUShort();                  RatingHygiene = Reader.ReadUShort();                  RatingBladder = Reader.ReadUShort();                  RatingEnergy = Reader.ReadUShort();                  RatingFun = Reader.ReadUShort();                  RatingRoom = Reader.ReadUShort();                  RatingSkillFlags = Reader.ReadUShort();              }
Magic Number,Files.IFF,OBJf,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJf.cs,OBJf,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,Files.IFF,OBJf,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJf.cs,OBJf,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,Files.IFF,OBJf,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJf.cs,OBJf,The following statement contains a magic number: Reader.ReadBytes(4);
Magic Number,Files.IFF,PALT,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\PALT.cs,PALT,The following statement contains a magic number: Reader.ReadBytes(8);
Magic Number,Files.IFF,SPR,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPR,The following statement contains a magic number: if (Version >= 502 && Version <= 505)              {                  //TODO: Should this be stored?                  for (int i = 0; i < SpriteCount; i++)                      m_OffsetTable.Add(Reader.ReadUInt32());              }              else                  m_OffsetTable.Add((uint)Reader.Position);
Magic Number,Files.IFF,SPR,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPR,The following statement contains a magic number: if (Version >= 502 && Version <= 505)              {                  //TODO: Should this be stored?                  for (int i = 0; i < SpriteCount; i++)                      m_OffsetTable.Add(Reader.ReadUInt32());              }              else                  m_OffsetTable.Add((uint)Reader.Position);
Magic Number,Files.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPRFrame,The following statement contains a magic number: if (Version == 1001)              {                  Version = Reader.ReadUInt32();                  Size = Reader.ReadUInt32();              }
Magic Number,Files.IFF,SPR2,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2,The following statement contains a magic number: if(Version == 1000)              {                  SpriteCount = Reader.ReadUInt32();                  m_PaletteID = Reader.ReadUInt32();                    for (int i = 0; i < SpriteCount; i++)                      m_OffsetTable.Add(Reader.ReadUInt32());              }              else              {                  m_PaletteID = Reader.ReadUInt32();                  SpriteCount = Reader.ReadUInt32();                    m_OffsetTable.Add((uint)Reader.Position);              }
Magic Number,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: if(SpriteVersion == 1001)              {                  Reader.ReadUInt32(); //Version                  Reader.ReadUInt32(); //Size              }
Magic Number,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while(!EndMarker)              {                  ushort Marker = Reader.ReadUShort();                  var Command = Marker >> 13;                  var Count = Marker & 0x1FFF;                    switch(Command)                  {                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes                       //the size in bytes of the row's command/count bytes together with the supplied pixel data. In                       //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a                       //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the                       //remainder is transparent. The pixel commands are:                      case 0x00:                          for(int i = 0; i < Count; i++)                          {                              ushort PxMarker = Reader.ReadUShort();                              var PxCommand = PxMarker >> 13;                              var PxCount = PxMarker & 0x1FFF;                                Color[] Colors;                                switch(PxCommand)                              {                                  //Set the next pixel count pixels in the z-buffer and color channels to the values defined                                   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel                                   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row                                   //for the z-buffer channel and color channel' respectively' in that order' using the full                                   //opacity value of 255 for each pixel that is not the transparent color.                                  case 0x01:                                      Colors = new Color[PxCount];                                        for(int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                      //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values                                       //defined by the pixel data provided directly after this command. Every group of 3 bytes in                                       //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity                                       //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'                                       //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale                                       //in the range 0-31' and the z buffer is in range 0-255.                                  case 0x02:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          byte Alpha = (byte)(Reader.ReadByte() * 8.2258064516129032258064516129032);                                          Colors[j] = Palette[ColorIndex];                                          Colors[j].A = Alpha;                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Leave the next pixel count pixels in the color channel filled with the transparent color'                                   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel                                   //command has no pixel data.                                  case 0x03:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          Colors[j] = Color.Transparent;                                          Colors[j].A = 0;                                          ZBuffer[j] = 255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Set the next pixel count pixels in the color channel to the palette color indices defined by                                   //the pixel data provided directly after this command.Every byte in the pixel data' minus the                                   //padding byte at the very end(if it exists)' provides a color index value to be copied to the                                   //row for the color channel using the full opacity value of 255 and the closest z-buffer value                                   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the                                   //farthest z-buffer value of 255.                                  case 0x06:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                            Colors[j].A = (Palette[ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;                                          ZBuffer[j] = (Palette[ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                              }                          }                          break;                      //Leave the next count rows in the color channel filled with the transparent color'                       //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.                      case 0x04:                          for (int j = 0; j < Count; j++)                          {                              Color[] Colors = new Color[Width];                                for (int k = 0; k < Width; k++)                              {                                  Colors[k] = Color.Transparent;                                  Colors[k].A = 0;                                  ZBuffer[k] = 255;                              }                                Texture.SetData<Color>(Colors' 0' Colors.Length);                          }                          break;                      case 0x05:                          EndMarker = true;                          break;                  }              }
Magic Number,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while(!EndMarker)              {                  ushort Marker = Reader.ReadUShort();                  var Command = Marker >> 13;                  var Count = Marker & 0x1FFF;                    switch(Command)                  {                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes                       //the size in bytes of the row's command/count bytes together with the supplied pixel data. In                       //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a                       //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the                       //remainder is transparent. The pixel commands are:                      case 0x00:                          for(int i = 0; i < Count; i++)                          {                              ushort PxMarker = Reader.ReadUShort();                              var PxCommand = PxMarker >> 13;                              var PxCount = PxMarker & 0x1FFF;                                Color[] Colors;                                switch(PxCommand)                              {                                  //Set the next pixel count pixels in the z-buffer and color channels to the values defined                                   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel                                   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row                                   //for the z-buffer channel and color channel' respectively' in that order' using the full                                   //opacity value of 255 for each pixel that is not the transparent color.                                  case 0x01:                                      Colors = new Color[PxCount];                                        for(int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                      //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values                                       //defined by the pixel data provided directly after this command. Every group of 3 bytes in                                       //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity                                       //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'                                       //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale                                       //in the range 0-31' and the z buffer is in range 0-255.                                  case 0x02:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          byte Alpha = (byte)(Reader.ReadByte() * 8.2258064516129032258064516129032);                                          Colors[j] = Palette[ColorIndex];                                          Colors[j].A = Alpha;                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Leave the next pixel count pixels in the color channel filled with the transparent color'                                   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel                                   //command has no pixel data.                                  case 0x03:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          Colors[j] = Color.Transparent;                                          Colors[j].A = 0;                                          ZBuffer[j] = 255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Set the next pixel count pixels in the color channel to the palette color indices defined by                                   //the pixel data provided directly after this command.Every byte in the pixel data' minus the                                   //padding byte at the very end(if it exists)' provides a color index value to be copied to the                                   //row for the color channel using the full opacity value of 255 and the closest z-buffer value                                   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the                                   //farthest z-buffer value of 255.                                  case 0x06:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                            Colors[j].A = (Palette[ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;                                          ZBuffer[j] = (Palette[ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                              }                          }                          break;                      //Leave the next count rows in the color channel filled with the transparent color'                       //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.                      case 0x04:                          for (int j = 0; j < Count; j++)                          {                              Color[] Colors = new Color[Width];                                for (int k = 0; k < Width; k++)                              {                                  Colors[k] = Color.Transparent;                                  Colors[k].A = 0;                                  ZBuffer[k] = 255;                              }                                Texture.SetData<Color>(Colors' 0' Colors.Length);                          }                          break;                      case 0x05:                          EndMarker = true;                          break;                  }              }
Magic Number,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while(!EndMarker)              {                  ushort Marker = Reader.ReadUShort();                  var Command = Marker >> 13;                  var Count = Marker & 0x1FFF;                    switch(Command)                  {                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes                       //the size in bytes of the row's command/count bytes together with the supplied pixel data. In                       //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a                       //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the                       //remainder is transparent. The pixel commands are:                      case 0x00:                          for(int i = 0; i < Count; i++)                          {                              ushort PxMarker = Reader.ReadUShort();                              var PxCommand = PxMarker >> 13;                              var PxCount = PxMarker & 0x1FFF;                                Color[] Colors;                                switch(PxCommand)                              {                                  //Set the next pixel count pixels in the z-buffer and color channels to the values defined                                   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel                                   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row                                   //for the z-buffer channel and color channel' respectively' in that order' using the full                                   //opacity value of 255 for each pixel that is not the transparent color.                                  case 0x01:                                      Colors = new Color[PxCount];                                        for(int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                      //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values                                       //defined by the pixel data provided directly after this command. Every group of 3 bytes in                                       //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity                                       //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'                                       //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale                                       //in the range 0-31' and the z buffer is in range 0-255.                                  case 0x02:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          byte Alpha = (byte)(Reader.ReadByte() * 8.2258064516129032258064516129032);                                          Colors[j] = Palette[ColorIndex];                                          Colors[j].A = Alpha;                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Leave the next pixel count pixels in the color channel filled with the transparent color'                                   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel                                   //command has no pixel data.                                  case 0x03:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          Colors[j] = Color.Transparent;                                          Colors[j].A = 0;                                          ZBuffer[j] = 255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Set the next pixel count pixels in the color channel to the palette color indices defined by                                   //the pixel data provided directly after this command.Every byte in the pixel data' minus the                                   //padding byte at the very end(if it exists)' provides a color index value to be copied to the                                   //row for the color channel using the full opacity value of 255 and the closest z-buffer value                                   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the                                   //farthest z-buffer value of 255.                                  case 0x06:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                            Colors[j].A = (Palette[ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;                                          ZBuffer[j] = (Palette[ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                              }                          }                          break;                      //Leave the next count rows in the color channel filled with the transparent color'                       //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.                      case 0x04:                          for (int j = 0; j < Count; j++)                          {                              Color[] Colors = new Color[Width];                                for (int k = 0; k < Width; k++)                              {                                  Colors[k] = Color.Transparent;                                  Colors[k].A = 0;                                  ZBuffer[k] = 255;                              }                                Texture.SetData<Color>(Colors' 0' Colors.Length);                          }                          break;                      case 0x05:                          EndMarker = true;                          break;                  }              }
Magic Number,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while(!EndMarker)              {                  ushort Marker = Reader.ReadUShort();                  var Command = Marker >> 13;                  var Count = Marker & 0x1FFF;                    switch(Command)                  {                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes                       //the size in bytes of the row's command/count bytes together with the supplied pixel data. In                       //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a                       //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the                       //remainder is transparent. The pixel commands are:                      case 0x00:                          for(int i = 0; i < Count; i++)                          {                              ushort PxMarker = Reader.ReadUShort();                              var PxCommand = PxMarker >> 13;                              var PxCount = PxMarker & 0x1FFF;                                Color[] Colors;                                switch(PxCommand)                              {                                  //Set the next pixel count pixels in the z-buffer and color channels to the values defined                                   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel                                   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row                                   //for the z-buffer channel and color channel' respectively' in that order' using the full                                   //opacity value of 255 for each pixel that is not the transparent color.                                  case 0x01:                                      Colors = new Color[PxCount];                                        for(int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                      //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values                                       //defined by the pixel data provided directly after this command. Every group of 3 bytes in                                       //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity                                       //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'                                       //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale                                       //in the range 0-31' and the z buffer is in range 0-255.                                  case 0x02:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          byte Alpha = (byte)(Reader.ReadByte() * 8.2258064516129032258064516129032);                                          Colors[j] = Palette[ColorIndex];                                          Colors[j].A = Alpha;                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Leave the next pixel count pixels in the color channel filled with the transparent color'                                   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel                                   //command has no pixel data.                                  case 0x03:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          Colors[j] = Color.Transparent;                                          Colors[j].A = 0;                                          ZBuffer[j] = 255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Set the next pixel count pixels in the color channel to the palette color indices defined by                                   //the pixel data provided directly after this command.Every byte in the pixel data' minus the                                   //padding byte at the very end(if it exists)' provides a color index value to be copied to the                                   //row for the color channel using the full opacity value of 255 and the closest z-buffer value                                   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the                                   //farthest z-buffer value of 255.                                  case 0x06:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                            Colors[j].A = (Palette[ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;                                          ZBuffer[j] = (Palette[ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                              }                          }                          break;                      //Leave the next count rows in the color channel filled with the transparent color'                       //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.                      case 0x04:                          for (int j = 0; j < Count; j++)                          {                              Color[] Colors = new Color[Width];                                for (int k = 0; k < Width; k++)                              {                                  Colors[k] = Color.Transparent;                                  Colors[k].A = 0;                                  ZBuffer[k] = 255;                              }                                Texture.SetData<Color>(Colors' 0' Colors.Length);                          }                          break;                      case 0x05:                          EndMarker = true;                          break;                  }              }
Magic Number,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while(!EndMarker)              {                  ushort Marker = Reader.ReadUShort();                  var Command = Marker >> 13;                  var Count = Marker & 0x1FFF;                    switch(Command)                  {                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes                       //the size in bytes of the row's command/count bytes together with the supplied pixel data. In                       //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a                       //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the                       //remainder is transparent. The pixel commands are:                      case 0x00:                          for(int i = 0; i < Count; i++)                          {                              ushort PxMarker = Reader.ReadUShort();                              var PxCommand = PxMarker >> 13;                              var PxCount = PxMarker & 0x1FFF;                                Color[] Colors;                                switch(PxCommand)                              {                                  //Set the next pixel count pixels in the z-buffer and color channels to the values defined                                   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel                                   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row                                   //for the z-buffer channel and color channel' respectively' in that order' using the full                                   //opacity value of 255 for each pixel that is not the transparent color.                                  case 0x01:                                      Colors = new Color[PxCount];                                        for(int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                      //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values                                       //defined by the pixel data provided directly after this command. Every group of 3 bytes in                                       //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity                                       //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'                                       //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale                                       //in the range 0-31' and the z buffer is in range 0-255.                                  case 0x02:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          byte Alpha = (byte)(Reader.ReadByte() * 8.2258064516129032258064516129032);                                          Colors[j] = Palette[ColorIndex];                                          Colors[j].A = Alpha;                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Leave the next pixel count pixels in the color channel filled with the transparent color'                                   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel                                   //command has no pixel data.                                  case 0x03:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          Colors[j] = Color.Transparent;                                          Colors[j].A = 0;                                          ZBuffer[j] = 255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Set the next pixel count pixels in the color channel to the palette color indices defined by                                   //the pixel data provided directly after this command.Every byte in the pixel data' minus the                                   //padding byte at the very end(if it exists)' provides a color index value to be copied to the                                   //row for the color channel using the full opacity value of 255 and the closest z-buffer value                                   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the                                   //farthest z-buffer value of 255.                                  case 0x06:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                            Colors[j].A = (Palette[ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;                                          ZBuffer[j] = (Palette[ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                              }                          }                          break;                      //Leave the next count rows in the color channel filled with the transparent color'                       //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.                      case 0x04:                          for (int j = 0; j < Count; j++)                          {                              Color[] Colors = new Color[Width];                                for (int k = 0; k < Width; k++)                              {                                  Colors[k] = Color.Transparent;                                  Colors[k].A = 0;                                  ZBuffer[k] = 255;                              }                                Texture.SetData<Color>(Colors' 0' Colors.Length);                          }                          break;                      case 0x05:                          EndMarker = true;                          break;                  }              }
Magic Number,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while(!EndMarker)              {                  ushort Marker = Reader.ReadUShort();                  var Command = Marker >> 13;                  var Count = Marker & 0x1FFF;                    switch(Command)                  {                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes                       //the size in bytes of the row's command/count bytes together with the supplied pixel data. In                       //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a                       //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the                       //remainder is transparent. The pixel commands are:                      case 0x00:                          for(int i = 0; i < Count; i++)                          {                              ushort PxMarker = Reader.ReadUShort();                              var PxCommand = PxMarker >> 13;                              var PxCount = PxMarker & 0x1FFF;                                Color[] Colors;                                switch(PxCommand)                              {                                  //Set the next pixel count pixels in the z-buffer and color channels to the values defined                                   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel                                   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row                                   //for the z-buffer channel and color channel' respectively' in that order' using the full                                   //opacity value of 255 for each pixel that is not the transparent color.                                  case 0x01:                                      Colors = new Color[PxCount];                                        for(int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                      //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values                                       //defined by the pixel data provided directly after this command. Every group of 3 bytes in                                       //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity                                       //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'                                       //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale                                       //in the range 0-31' and the z buffer is in range 0-255.                                  case 0x02:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          byte Alpha = (byte)(Reader.ReadByte() * 8.2258064516129032258064516129032);                                          Colors[j] = Palette[ColorIndex];                                          Colors[j].A = Alpha;                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Leave the next pixel count pixels in the color channel filled with the transparent color'                                   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel                                   //command has no pixel data.                                  case 0x03:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          Colors[j] = Color.Transparent;                                          Colors[j].A = 0;                                          ZBuffer[j] = 255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Set the next pixel count pixels in the color channel to the palette color indices defined by                                   //the pixel data provided directly after this command.Every byte in the pixel data' minus the                                   //padding byte at the very end(if it exists)' provides a color index value to be copied to the                                   //row for the color channel using the full opacity value of 255 and the closest z-buffer value                                   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the                                   //farthest z-buffer value of 255.                                  case 0x06:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                            Colors[j].A = (Palette[ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;                                          ZBuffer[j] = (Palette[ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                              }                          }                          break;                      //Leave the next count rows in the color channel filled with the transparent color'                       //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.                      case 0x04:                          for (int j = 0; j < Count; j++)                          {                              Color[] Colors = new Color[Width];                                for (int k = 0; k < Width; k++)                              {                                  Colors[k] = Color.Transparent;                                  Colors[k].A = 0;                                  ZBuffer[k] = 255;                              }                                Texture.SetData<Color>(Colors' 0' Colors.Length);                          }                          break;                      case 0x05:                          EndMarker = true;                          break;                  }              }
Magic Number,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while(!EndMarker)              {                  ushort Marker = Reader.ReadUShort();                  var Command = Marker >> 13;                  var Count = Marker & 0x1FFF;                    switch(Command)                  {                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes                       //the size in bytes of the row's command/count bytes together with the supplied pixel data. In                       //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a                       //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the                       //remainder is transparent. The pixel commands are:                      case 0x00:                          for(int i = 0; i < Count; i++)                          {                              ushort PxMarker = Reader.ReadUShort();                              var PxCommand = PxMarker >> 13;                              var PxCount = PxMarker & 0x1FFF;                                Color[] Colors;                                switch(PxCommand)                              {                                  //Set the next pixel count pixels in the z-buffer and color channels to the values defined                                   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel                                   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row                                   //for the z-buffer channel and color channel' respectively' in that order' using the full                                   //opacity value of 255 for each pixel that is not the transparent color.                                  case 0x01:                                      Colors = new Color[PxCount];                                        for(int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                      //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values                                       //defined by the pixel data provided directly after this command. Every group of 3 bytes in                                       //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity                                       //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'                                       //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale                                       //in the range 0-31' and the z buffer is in range 0-255.                                  case 0x02:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          byte Alpha = (byte)(Reader.ReadByte() * 8.2258064516129032258064516129032);                                          Colors[j] = Palette[ColorIndex];                                          Colors[j].A = Alpha;                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Leave the next pixel count pixels in the color channel filled with the transparent color'                                   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel                                   //command has no pixel data.                                  case 0x03:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          Colors[j] = Color.Transparent;                                          Colors[j].A = 0;                                          ZBuffer[j] = 255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Set the next pixel count pixels in the color channel to the palette color indices defined by                                   //the pixel data provided directly after this command.Every byte in the pixel data' minus the                                   //padding byte at the very end(if it exists)' provides a color index value to be copied to the                                   //row for the color channel using the full opacity value of 255 and the closest z-buffer value                                   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the                                   //farthest z-buffer value of 255.                                  case 0x06:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                            Colors[j].A = (Palette[ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;                                          ZBuffer[j] = (Palette[ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                              }                          }                          break;                      //Leave the next count rows in the color channel filled with the transparent color'                       //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.                      case 0x04:                          for (int j = 0; j < Count; j++)                          {                              Color[] Colors = new Color[Width];                                for (int k = 0; k < Width; k++)                              {                                  Colors[k] = Color.Transparent;                                  Colors[k].A = 0;                                  ZBuffer[k] = 255;                              }                                Texture.SetData<Color>(Colors' 0' Colors.Length);                          }                          break;                      case 0x05:                          EndMarker = true;                          break;                  }              }
Magic Number,Files.IFF,STR,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: FileReader Reader = new FileReader(new MemoryStream(m_Data)' false' Encoding.GetEncoding(1252));
Magic Number,Files.IFF,STR,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: if((Reader.StreamLength - Reader.Position) > 2)              {                  switch(Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                    Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,STR,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: if((Reader.StreamLength - Reader.Position) > 2)              {                  switch(Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                    Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,STR,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: if((Reader.StreamLength - Reader.Position) > 2)              {                  switch(Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                    Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,STR,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: if((Reader.StreamLength - Reader.Position) > 2)              {                  switch(Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                    Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,TTAs,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,TTAs,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,TTAs,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.IFF,TTAs,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2)              {                  switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }              }
Magic Number,Files.Vitaboy,Anim,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: Translations = new float[TranslationsCount' 3];
Magic Number,Files.Vitaboy,Anim,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: for(int i = 0; i < TranslationsCount; i++)              {                  Translations[i' 0] = m_Reader.ReadFloat();                  Translations[i' 1] = m_Reader.ReadFloat();                  Translations[i' 2] = m_Reader.ReadFloat();              }
Magic Number,Files.Vitaboy,Anim,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: Rotations = new float[RotationsCount' 4];
Magic Number,Files.Vitaboy,Anim,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: for (int i = 0; i < RotationsCount; i++)              {                  Rotations[i' 0] = m_Reader.ReadFloat();                  Rotations[i' 1] = m_Reader.ReadFloat();                  Rotations[i' 2] = m_Reader.ReadFloat();                  Rotations[i' 3] = m_Reader.ReadFloat();              }
Magic Number,Files.Vitaboy,Anim,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: for (int i = 0; i < RotationsCount; i++)              {                  Rotations[i' 0] = m_Reader.ReadFloat();                  Rotations[i' 1] = m_Reader.ReadFloat();                  Rotations[i' 2] = m_Reader.ReadFloat();                  Rotations[i' 3] = m_Reader.ReadFloat();              }
Magic Number,Files.Vitaboy,Binding,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Binding.cs,Binding,The following statement contains a magic number: if (AssetType == 8)              {                  //A 4-byte unsigned integer specifying the type of data that follows; should be 0xA96F6D42 for cAssetKey                  Reader.ReadUInt32();                  FileID = Reader.ReadUInt32();                  TypeID = Reader.ReadUInt32();                  MeshID = new UniqueFileID(TypeID' FileID);              }
Magic Number,Files.Vitaboy,Binding,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Binding.cs,Binding,The following statement contains a magic number: if (AssetType == 8)              {                  //A 4-byte unsigned integer specifying the type of data that follows; should be 0xA96F6D42 for cAssetKey                  Reader.ReadUInt32();                  FileID = Reader.ReadUInt32();                  TypeID = Reader.ReadUInt32();                  TextureID = new UniqueFileID(TypeID' FileID);              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.objTargaHeader.ImageDataOffset > 0)                  {                      // padding bytes                      byte[] padding = new byte[this.intPadding];                      MemoryStream msData = null;                                                               // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.objTargaHeader.ImageDataOffset' SeekOrigin.Begin);                                                                 // get the size in bytes of each row in the image                      int intImageRowByteSize = (int)this.objTargaHeader.Width * ((int)this.objTargaHeader.BytesPerPixel);                        // get the size in bytes of the whole image                      int intImageByteSize = intImageRowByteSize * (int)this.objTargaHeader.Height;                                                            // is this a RLE compressed image type                      if (this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE ||                         this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED ||                         this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_TRUE_COLOR)                      {                            #region COMPRESSED                                                        // RLE Packet info                              byte bRLEPacket = 0;                              int intRLEPacketType = -1;                              int intRLEPixelCount = 0;                              byte[] bRunLengthPixel = null;                                // used to keep track of bytes read                              int intImageBytesRead = 0;                              int intImageRowBytesRead = 0;                                // keep reading until we have the all image bytes                              while (intImageBytesRead < intImageByteSize)                              {                                  // get the RLE packet                                  bRLEPacket = binReader.ReadByte();                                  intRLEPacketType = Utilities.GetBits(bRLEPacket' 7' 1);                                  intRLEPixelCount = Utilities.GetBits(bRLEPacket' 0' 7) + 1;                                    // check the RLE packet type                                  if ((RLEPacketType)intRLEPacketType == RLEPacketType.RUN_LENGTH)                                  {                                      // get the pixel color data                                      bRunLengthPixel = binReader.ReadBytes((int)this.objTargaHeader.BytesPerPixel);                                        // add the number of pixels specified using the read pixel color                                      for (int i = 0; i < intRLEPixelCount; i++)                                      {                                          foreach (byte b in bRunLengthPixel)                                              row.Add(b);                                            // increment the byte counts                                          intImageRowBytesRead += bRunLengthPixel.Length;                                          intImageBytesRead += bRunLengthPixel.Length;                                            // if we have read a full image row                                          // add the row to the row list and clear it                                          // restart row byte count                                          if (intImageRowBytesRead == intImageRowByteSize)                                          {                                              rows.Add(row);                                              row = new System.Collections.Generic.List<byte>();                                              intImageRowBytesRead = 0;                                                                                        }                                      }                                    }                                    else if ((RLEPacketType)intRLEPacketType == RLEPacketType.RAW)                                  {                                      // get the number of bytes to read based on the read pixel count                                      int intBytesToRead = intRLEPixelCount * (int)this.objTargaHeader.BytesPerPixel;                                        // read each byte                                      for (int i = 0;i < intBytesToRead;i++)                                      {                                          row.Add(binReader.ReadByte());                                            // increment the byte counts                                          intImageBytesRead++;                                          intImageRowBytesRead++;                                            // if we have read a full image row                                          // add the row to the row list and clear it                                          // restart row byte count                                          if (intImageRowBytesRead == intImageRowByteSize)                                          {                                              rows.Add(row);                                              row = new System.Collections.Generic.List<byte>();                                              intImageRowBytesRead = 0;                                          }                                        }                                    }                              }                            #endregion                        }                        else                      {                          #region NON-COMPRESSED                            // loop through each row in the image                          for (int i = 0; i < (int)this.objTargaHeader.Height; i++)                          {                              // loop through each byte in the row                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  // add the byte to the row                                  row.Add(binReader.ReadByte());                              }                                // add row to the list of rows                              rows.Add(row);                                // create a new row                              row = new System.Collections.Generic.List<byte>();                          }                                                      #endregion                      }                        // flag that states whether or not to reverse the location of all rows.                      bool blnRowsReverse = false;                        // flag that states whether or not to reverse the bytes in each row.                      bool blnEachRowReverse = false;                        // use FirstPixelDestination to determine the alignment of the                       // image data byte                      switch (this.objTargaHeader.FirstPixelDestination)                      {                          case FirstPixelDestination.TOP_LEFT:                              blnRowsReverse = false;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.TOP_RIGHT:                              blnRowsReverse = false;                              blnEachRowReverse = false;                              break;                            case FirstPixelDestination.BOTTOM_LEFT:                              blnRowsReverse = true;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.BOTTOM_RIGHT:                          case FirstPixelDestination.UNKNOWN:                              blnRowsReverse = true;                              blnEachRowReverse = false;                                break;                      }                        // write the bytes from each row into a memory stream and get the                       // resulting byte array                      using (msData = new MemoryStream())                      {                            // do we reverse the rows in the row list.                          if (blnRowsReverse == true)                              rows.Reverse();                            // go through each row                          for (int i = 0; i < rows.Count; i++)                          {                              // do we reverse the bytes in the row                              if (blnEachRowReverse == true)                                  rows[i].Reverse();                                // get the byte array for the row                              byte[] brow = rows[i].ToArray();                                // write the row bytes and padding bytes to the memory streem                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          // get the image byte array                          data = msData.ToArray();                                                                             }                    }                  else                  {                      this.ClearAll();                      throw new IOException(@"Error loading file' No image data in file.");                  }              }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.objTargaHeader.ImageDataOffset > 0)                  {                      // padding bytes                      byte[] padding = new byte[this.intPadding];                      MemoryStream msData = null;                                                               // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.objTargaHeader.ImageDataOffset' SeekOrigin.Begin);                                                                 // get the size in bytes of each row in the image                      int intImageRowByteSize = (int)this.objTargaHeader.Width * ((int)this.objTargaHeader.BytesPerPixel);                        // get the size in bytes of the whole image                      int intImageByteSize = intImageRowByteSize * (int)this.objTargaHeader.Height;                                                            // is this a RLE compressed image type                      if (this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE ||                         this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED ||                         this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_TRUE_COLOR)                      {                            #region COMPRESSED                                                        // RLE Packet info                              byte bRLEPacket = 0;                              int intRLEPacketType = -1;                              int intRLEPixelCount = 0;                              byte[] bRunLengthPixel = null;                                // used to keep track of bytes read                              int intImageBytesRead = 0;                              int intImageRowBytesRead = 0;                                // keep reading until we have the all image bytes                              while (intImageBytesRead < intImageByteSize)                              {                                  // get the RLE packet                                  bRLEPacket = binReader.ReadByte();                                  intRLEPacketType = Utilities.GetBits(bRLEPacket' 7' 1);                                  intRLEPixelCount = Utilities.GetBits(bRLEPacket' 0' 7) + 1;                                    // check the RLE packet type                                  if ((RLEPacketType)intRLEPacketType == RLEPacketType.RUN_LENGTH)                                  {                                      // get the pixel color data                                      bRunLengthPixel = binReader.ReadBytes((int)this.objTargaHeader.BytesPerPixel);                                        // add the number of pixels specified using the read pixel color                                      for (int i = 0; i < intRLEPixelCount; i++)                                      {                                          foreach (byte b in bRunLengthPixel)                                              row.Add(b);                                            // increment the byte counts                                          intImageRowBytesRead += bRunLengthPixel.Length;                                          intImageBytesRead += bRunLengthPixel.Length;                                            // if we have read a full image row                                          // add the row to the row list and clear it                                          // restart row byte count                                          if (intImageRowBytesRead == intImageRowByteSize)                                          {                                              rows.Add(row);                                              row = new System.Collections.Generic.List<byte>();                                              intImageRowBytesRead = 0;                                                                                        }                                      }                                    }                                    else if ((RLEPacketType)intRLEPacketType == RLEPacketType.RAW)                                  {                                      // get the number of bytes to read based on the read pixel count                                      int intBytesToRead = intRLEPixelCount * (int)this.objTargaHeader.BytesPerPixel;                                        // read each byte                                      for (int i = 0;i < intBytesToRead;i++)                                      {                                          row.Add(binReader.ReadByte());                                            // increment the byte counts                                          intImageBytesRead++;                                          intImageRowBytesRead++;                                            // if we have read a full image row                                          // add the row to the row list and clear it                                          // restart row byte count                                          if (intImageRowBytesRead == intImageRowByteSize)                                          {                                              rows.Add(row);                                              row = new System.Collections.Generic.List<byte>();                                              intImageRowBytesRead = 0;                                          }                                        }                                    }                              }                            #endregion                        }                        else                      {                          #region NON-COMPRESSED                            // loop through each row in the image                          for (int i = 0; i < (int)this.objTargaHeader.Height; i++)                          {                              // loop through each byte in the row                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  // add the byte to the row                                  row.Add(binReader.ReadByte());                              }                                // add row to the list of rows                              rows.Add(row);                                // create a new row                              row = new System.Collections.Generic.List<byte>();                          }                                                      #endregion                      }                        // flag that states whether or not to reverse the location of all rows.                      bool blnRowsReverse = false;                        // flag that states whether or not to reverse the bytes in each row.                      bool blnEachRowReverse = false;                        // use FirstPixelDestination to determine the alignment of the                       // image data byte                      switch (this.objTargaHeader.FirstPixelDestination)                      {                          case FirstPixelDestination.TOP_LEFT:                              blnRowsReverse = false;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.TOP_RIGHT:                              blnRowsReverse = false;                              blnEachRowReverse = false;                              break;                            case FirstPixelDestination.BOTTOM_LEFT:                              blnRowsReverse = true;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.BOTTOM_RIGHT:                          case FirstPixelDestination.UNKNOWN:                              blnRowsReverse = true;                              blnEachRowReverse = false;                                break;                      }                        // write the bytes from each row into a memory stream and get the                       // resulting byte array                      using (msData = new MemoryStream())                      {                            // do we reverse the rows in the row list.                          if (blnRowsReverse == true)                              rows.Reverse();                            // go through each row                          for (int i = 0; i < rows.Count; i++)                          {                              // do we reverse the bytes in the row                              if (blnEachRowReverse == true)                                  rows[i].Reverse();                                // get the byte array for the row                              byte[] brow = rows[i].ToArray();                                // write the row bytes and padding bytes to the memory streem                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          // get the image byte array                          data = msData.ToArray();                                                                             }                    }                  else                  {                      this.ClearAll();                      throw new IOException(@"Error loading file' No image data in file.");                  }              }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intStride = (((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3;
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intStride = (((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3;
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intStride = (((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3;
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intPadding = this.intStride - ((((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth) + 7) / 8);
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intPadding = this.intStride - ((((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth) + 7) / 8);
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: if (this.objTargaHeader.ColorMap.Count > 0)              {                  // get the Bitmap's current palette                  ColorPalette pal = this.bmpTargaImage.Palette;                    // loop trough each color in the loaded file's color map                  for (int i = 0; i < this.objTargaHeader.ColorMap.Count; i++)                  {                      // is the AttributesType 0 or 1 bit                      if (this.objTargaExtensionArea.AttributesType == 0 ||                          this.objTargaExtensionArea.AttributesType == 1)                          // use 255 for alpha ( 255 = opaque/visible ) so we can see the image                          pal.Entries[i] = Color.FromArgb(255' this.objTargaHeader.ColorMap[i].R' this.objTargaHeader.ColorMap[i].G' this.objTargaHeader.ColorMap[i].B);                        else                          // use whatever value is there                          pal.Entries[i] = this.objTargaHeader.ColorMap[i];                    }                    // set the new palette back to the Bitmap object                  this.bmpTargaImage.Palette = pal;                    // set the palette to the thumbnail also' if there is one                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Palette = pal;                  }              }              else              { // no color map                      // check to see if this is a Black and White (Greyscale)                  if (this.objTargaHeader.PixelDepth == 8 && (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_BLACK_AND_WHITE ||                      this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE))                  {                      // get the current palette                      ColorPalette pal = this.bmpTargaImage.Palette;                        // create the Greyscale palette                      for (int i = 0; i < 256; i++)                      {                          pal.Entries[i] = Color.FromArgb(i' i' i);                      }                        // set the new palette back to the Bitmap object                      this.bmpTargaImage.Palette = pal;                        // set the palette to the thumbnail also' if there is one                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Palette = pal;                      }                  }                                  }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: if (this.objTargaHeader.ColorMap.Count > 0)              {                  // get the Bitmap's current palette                  ColorPalette pal = this.bmpTargaImage.Palette;                    // loop trough each color in the loaded file's color map                  for (int i = 0; i < this.objTargaHeader.ColorMap.Count; i++)                  {                      // is the AttributesType 0 or 1 bit                      if (this.objTargaExtensionArea.AttributesType == 0 ||                          this.objTargaExtensionArea.AttributesType == 1)                          // use 255 for alpha ( 255 = opaque/visible ) so we can see the image                          pal.Entries[i] = Color.FromArgb(255' this.objTargaHeader.ColorMap[i].R' this.objTargaHeader.ColorMap[i].G' this.objTargaHeader.ColorMap[i].B);                        else                          // use whatever value is there                          pal.Entries[i] = this.objTargaHeader.ColorMap[i];                    }                    // set the new palette back to the Bitmap object                  this.bmpTargaImage.Palette = pal;                    // set the palette to the thumbnail also' if there is one                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Palette = pal;                  }              }              else              { // no color map                      // check to see if this is a Black and White (Greyscale)                  if (this.objTargaHeader.PixelDepth == 8 && (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_BLACK_AND_WHITE ||                      this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE))                  {                      // get the current palette                      ColorPalette pal = this.bmpTargaImage.Palette;                        // create the Greyscale palette                      for (int i = 0; i < 256; i++)                      {                          pal.Entries[i] = Color.FromArgb(i' i' i);                      }                        // set the new palette back to the Bitmap object                      this.bmpTargaImage.Palette = pal;                        // set the palette to the thumbnail also' if there is one                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Palette = pal;                      }                  }                                  }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: if (this.objTargaHeader.ColorMap.Count > 0)              {                  // get the Bitmap's current palette                  ColorPalette pal = this.bmpTargaImage.Palette;                    // loop trough each color in the loaded file's color map                  for (int i = 0; i < this.objTargaHeader.ColorMap.Count; i++)                  {                      // is the AttributesType 0 or 1 bit                      if (this.objTargaExtensionArea.AttributesType == 0 ||                          this.objTargaExtensionArea.AttributesType == 1)                          // use 255 for alpha ( 255 = opaque/visible ) so we can see the image                          pal.Entries[i] = Color.FromArgb(255' this.objTargaHeader.ColorMap[i].R' this.objTargaHeader.ColorMap[i].G' this.objTargaHeader.ColorMap[i].B);                        else                          // use whatever value is there                          pal.Entries[i] = this.objTargaHeader.ColorMap[i];                    }                    // set the new palette back to the Bitmap object                  this.bmpTargaImage.Palette = pal;                    // set the palette to the thumbnail also' if there is one                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Palette = pal;                  }              }              else              { // no color map                      // check to see if this is a Black and White (Greyscale)                  if (this.objTargaHeader.PixelDepth == 8 && (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_BLACK_AND_WHITE ||                      this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE))                  {                      // get the current palette                      ColorPalette pal = this.bmpTargaImage.Palette;                        // create the Greyscale palette                      for (int i = 0; i < 256; i++)                      {                          pal.Entries[i] = Color.FromArgb(i' i' i);                      }                        // set the new palette back to the Bitmap object                      this.bmpTargaImage.Palette = pal;                        // set the palette to the thumbnail also' if there is one                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Palette = pal;                      }                  }                                  }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int r1 = Utilities.GetBits(one' 2' 5);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int r1 = Utilities.GetBits(one' 2' 5);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int r = r1 << 3;
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int bit = Utilities.GetBits(one' 0' 2);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int g1 = bit << 6;
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: bit = Utilities.GetBits(two' 5' 3);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: bit = Utilities.GetBits(two' 5' 3);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int g2 = bit << 3;
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int b1 = Utilities.GetBits(two' 0' 5);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int b = b1 << 3;
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int a1 = Utilities.GetBits(one' 7' 1);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int a = a1 * 255;
Missing Default,Files.Manager,FileManager,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following switch statement is missing a default case: switch(TypeID)                          {                              case FAR3TypeIDs.ANIM:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Anim(Data)));                                  break;                              case FAR3TypeIDs.APR:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Appearance(Data)));                                  break;                              case FAR3TypeIDs.BND:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Binding(Data)));                                  break;                              case FAR3TypeIDs.COL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Collection(Data)));                                  break;                              case FAR3TypeIDs.HAG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new HandGroup(Data)));                                  break;                              case FAR3TypeIDs.MESH:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Mesh(Data)));                                  break;                              case FAR3TypeIDs.OFT:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Outfit(Data)));                                  break;                              case FAR3TypeIDs.PO:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new PurchasableOutfit(Data)));                                  break;                              case FAR3TypeIDs.SKEL:                                  AddItem(ID' new Asset(ID' (uint)Data.Length' new Skeleton(Data)));                                  break;                              case FAR3TypeIDs.TGA:                                  lock (MemStream)                                  {                                      using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                      {                                          TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          MemStream.Seek(0' SeekOrigin.Begin);                                          AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                      }                                  }                                  break;                              case FAR3TypeIDs.PNG:                              case FAR3TypeIDs.PackedPNG:                                  AddItem(ID' new Asset(ID' (uint)Data.Length'                                       Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  break;                              case FAR3TypeIDs.JPG:                                  try                                  {                                      using (BMap = new Bitmap(Data))                                      {                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                          BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                          BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                          BMap.Dispose();                                          MemStream.Seek(0' SeekOrigin.Begin);                                      }                                        AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                          Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                  }                                  catch                                  {                                      try                                      {                                          MemStream.Dispose();                                          AddItem(ID' new Asset(ID' (uint)Data.Length'                                              Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                      }                                      catch(Exception) //Most likely a TGA' sigh.                                      {                                          MemStream = new MemoryStream();                                            using (Paloma.TargaImage TGA = new Paloma.TargaImage(Data))                                          {                                              TGA.Image.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                              TGA.Dispose();                                              MemStream.Seek(0' SeekOrigin.Begin);                                              AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                      }                                  }                                  break;                              case FAR3TypeIDs.BMP:                                  if (IsBMP(Data))                                  {                                      lock (MemStream)                                      {                                          try                                          {                                              using (BMap = new Bitmap(Data))                                              {                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 0' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(255' 1' 255));                                                  BMap.MakeTransparent(System.Drawing.Color.FromArgb(254' 2' 254));                                                  BMap.Save(MemStream' System.Drawing.Imaging.ImageFormat.Png);                                                  MemStream.Seek(0' SeekOrigin.Begin);                                              }                                                AddItem(ID' new Asset(ID' (uint)MemStream.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' MemStream)));                                          }                                          catch (Exception)                                          {                                              MemStream.Dispose();                                                AddItem(ID' new Asset(ID' (uint)Data.Length'                                                  Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                          }                                      }                                  }                                  else                                  {                                      AddItem(ID' new Asset(ID' (uint)Data.Length'                                           Texture2D.FromStream(m_Game.GraphicsDevice' Data)));                                  }                                  break;                          }
Missing Default,Files.IFF,CST,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following switch statement is missing a default case: switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }
Missing Default,Files.IFF,CTSS,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following switch statement is missing a default case: switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }
Missing Default,Files.IFF,DGRP,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following switch statement is missing a default case: switch(m_Version)              {                  case 20000:                      ImageCount = Reader.ReadUShort();                      break;                  case 20001:                      ImageCount = Reader.ReadUShort();                      break;                  case 20003:                      ImageCount = Reader.ReadUInt32();                      break;                  case 20004:                      ImageCount = Reader.ReadUInt32();                      break;              }
Missing Default,Files.IFF,Iff,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\Iff.cs,Init,The following switch statement is missing a default case: switch (Chunk.Type)                  {                      case IFFChunkTypes.FBMP:                          FBMP FBMPChunk = new FBMP(Chunk);                          m_FBMPChunks.Add(Chunk.ID' FBMPChunk);                          break;                      case IFFChunkTypes.FWAV:                          FWAV FWAVChunk = new FWAV(Chunk);                          m_FWAVChunks.Add(Chunk.ID' FWAVChunk);                          break;                      case IFFChunkTypes.BMP_:                          BMP_ BMPChunk = new BMP_(Chunk);                          m_BMP_Chunks.Add(Chunk.ID' BMPChunk);                          break;                      case IFFChunkTypes.DGRP:                          DGRP DGRPChunk = new DGRP(Chunk);                          m_DGRPChunks.Add(Chunk.ID' DGRPChunk);                          break;                      case IFFChunkTypes.BCON:                          BCON BCONChunk = new BCON(Chunk);                          m_BCONChunks.Add(Chunk.ID' BCONChunk);                          break;                      case IFFChunkTypes.GLOB:                          GLOB GlobChunk = new GLOB(Chunk);                          m_GLOBChunks.Add(Chunk.ID' GlobChunk);                          break;                      case IFFChunkTypes.OBJD:                          OBJD OBJDChunk = new OBJD(Chunk);                          m_OBJDs.Add(OBJDChunk);                          break;                      case IFFChunkTypes.TTAs:                          TTAs TTAsChunk = new TTAs(Chunk);                          m_TTAsChunks.Add(Chunk.ID' TTAsChunk);                          break;                      case IFFChunkTypes.TTAB:                          TTAB TTABChunk = new TTAB(Chunk);                          TTABChunk.Type = Chunk.Type;                          TTABChunk.ID = Chunk.ID;                          m_TTABChunks.Add(Chunk.ID' TTABChunk);                          break;                      case IFFChunkTypes.TPRP:                          TPRP TPRPChunk = new TPRP(Chunk);                          m_TPRPChunks.Add(Chunk.ID' TPRPChunk);                          break;                      case IFFChunkTypes.STR:                          STR STRChunk = new STR(Chunk);                          m_STRChunks.Add(Chunk.ID' STRChunk);                          break;                      case IFFChunkTypes.BHAV:                          BHAV BHAVChunk = new BHAV(Chunk);                          m_BHAVChunks.Add(Chunk.ID' BHAVChunk);                          break;                      case IFFChunkTypes.OBJf:                          OBJf OBJfChunk = new OBJf(Chunk);                          m_OBJfChunks.Add(Chunk.ID' OBJfChunk);                          break;                      case IFFChunkTypes.FCNS:                          FCNS FCNSChunk = new FCNS(Chunk);                          m_FCNSChunks.Add(Chunk.ID' FCNSChunk);                          break;                      case IFFChunkTypes.SPR:                          SPR SPRChunk = new SPR(Chunk);                          m_SPRChunks.Add(Chunk.ID' SPRChunk);                          break;                      case IFFChunkTypes.SPR2:                          SPR2 SPR2Chunk = new SPR2(Chunk);                          m_SPR2Chunks.Add(Chunk.ID' SPR2Chunk);                          break;                      case IFFChunkTypes.PALT:                          PALT PALTChunk = new PALT(Chunk);                          m_PALTChunks.Add(Chunk.ID' PALTChunk);                          break;                      case IFFChunkTypes.CTSS:                          CTSS CTSSChunk = new CTSS(Chunk);                          m_CTSSChunks.Add(Chunk.ID' CTSSChunk);                          break;                      case IFFChunkTypes.CST:                          CST CSTChunk = new CST(Chunk);                          m_CSTChunks.Add(Chunk.ID' CSTChunk);                          break;                  }
Missing Default,Files.IFF,OBJD,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following switch statement is missing a default case: switch(Version)              {                  case 136:                      m_NumFields = 80;                      break;                  case 138:                      m_NumFields = 95;                      break;                  case 139:                      m_NumFields = 96;                      break;                  case 140:                      m_NumFields = 97;                      break;                  case 141:                      m_NumFields = 97;                      break;                  case 142:                      m_NumFields = 105;                      break;              }
Missing Default,Files.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPRFrame,The following switch statement is missing a default case: switch(Cmd)                  {                      case 0x04:                          for(byte j = 0; j < Count; j++)                          {                              byte PxCmd = Reader.ReadByte();                              byte PxCount = Reader.ReadByte();                              Color[] Pixels;                                switch(PxCmd)                              {                                  case 0x01:                                      //Leave the next pixel count pixels as transparent. This pixel command has no pixel data.                                      Pixels = new Color[Count];                                      for (int k = 0; k < Count; k++)                                          Pixels[k] = Color.Transparent;                                        Texture.SetData<Color>(Pixels' 0' Count);                                      break;                                  case 0x02:                                      //Fill the next pixel count pixels with a single palette color.                                       //The pixel data is two bytes: the first byte denotes the palette color                                       //index' and the second byte is padding (which is always equal to the                                       //first byte but is ignored).                                      Pixels = new Color[Count];                                      byte ColorIndex = Reader.ReadByte();                                        for (int k = 0; k < Count; k++)                                          Pixels[k] = Palette[ColorIndex];                                        Texture.SetData<Color>(Pixels' 0' Count);                                      break;                                  case 0x03:                                      //Set the next pixel count pixels to the palette color indices defined by                                       //the pixel data provided directly after this command. Each byte in the pixel data'                                       //minus the padding byte at the very end (if it exists)' is a color index value to                                       //be copied to the row.                                      Pixels = new Color[Count];                                        for (int k = 0; k < Count; k++)                                          Pixels[k] = Palette[Reader.ReadByte()];                                        Texture.SetData<Color>(Pixels' 0' Count);                                      break;                                  case 0x09:                                      //Leave the next count rows as transparent.                                      for (int k = 0; k < Count; k++)                                      {                                          Pixels = new Color[Width];                                          for (int l = 0; l < Width; l++)                                              Pixels[l] = Color.Transparent;                                            Texture.SetData<Color>(Pixels' 0' Width);                                      }                                      break;                              }                          }                          break;                  }
Missing Default,Files.IFF,SPRFrame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPRFrame,The following switch statement is missing a default case: switch(PxCmd)                              {                                  case 0x01:                                      //Leave the next pixel count pixels as transparent. This pixel command has no pixel data.                                      Pixels = new Color[Count];                                      for (int k = 0; k < Count; k++)                                          Pixels[k] = Color.Transparent;                                        Texture.SetData<Color>(Pixels' 0' Count);                                      break;                                  case 0x02:                                      //Fill the next pixel count pixels with a single palette color.                                       //The pixel data is two bytes: the first byte denotes the palette color                                       //index' and the second byte is padding (which is always equal to the                                       //first byte but is ignored).                                      Pixels = new Color[Count];                                      byte ColorIndex = Reader.ReadByte();                                        for (int k = 0; k < Count; k++)                                          Pixels[k] = Palette[ColorIndex];                                        Texture.SetData<Color>(Pixels' 0' Count);                                      break;                                  case 0x03:                                      //Set the next pixel count pixels to the palette color indices defined by                                       //the pixel data provided directly after this command. Each byte in the pixel data'                                       //minus the padding byte at the very end (if it exists)' is a color index value to                                       //be copied to the row.                                      Pixels = new Color[Count];                                        for (int k = 0; k < Count; k++)                                          Pixels[k] = Palette[Reader.ReadByte()];                                        Texture.SetData<Color>(Pixels' 0' Count);                                      break;                                  case 0x09:                                      //Leave the next count rows as transparent.                                      for (int k = 0; k < Count; k++)                                      {                                          Pixels = new Color[Width];                                          for (int l = 0; l < Width; l++)                                              Pixels[l] = Color.Transparent;                                            Texture.SetData<Color>(Pixels' 0' Width);                                      }                                      break;                              }
Missing Default,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following switch statement is missing a default case: switch(Command)                  {                      //Fill this row with pixel data that directly follows; the count byte of the row command denotes                       //the size in bytes of the row's command/count bytes together with the supplied pixel data. In                       //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a                       //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the                       //remainder is transparent. The pixel commands are:                      case 0x00:                          for(int i = 0; i < Count; i++)                          {                              ushort PxMarker = Reader.ReadUShort();                              var PxCommand = PxMarker >> 13;                              var PxCount = PxMarker & 0x1FFF;                                Color[] Colors;                                switch(PxCommand)                              {                                  //Set the next pixel count pixels in the z-buffer and color channels to the values defined                                   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel                                   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row                                   //for the z-buffer channel and color channel' respectively' in that order' using the full                                   //opacity value of 255 for each pixel that is not the transparent color.                                  case 0x01:                                      Colors = new Color[PxCount];                                        for(int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                      //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values                                       //defined by the pixel data provided directly after this command. Every group of 3 bytes in                                       //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity                                       //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'                                       //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale                                       //in the range 0-31' and the z buffer is in range 0-255.                                  case 0x02:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          byte Alpha = (byte)(Reader.ReadByte() * 8.2258064516129032258064516129032);                                          Colors[j] = Palette[ColorIndex];                                          Colors[j].A = Alpha;                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Leave the next pixel count pixels in the color channel filled with the transparent color'                                   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel                                   //command has no pixel data.                                  case 0x03:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          Colors[j] = Color.Transparent;                                          Colors[j].A = 0;                                          ZBuffer[j] = 255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Set the next pixel count pixels in the color channel to the palette color indices defined by                                   //the pixel data provided directly after this command.Every byte in the pixel data' minus the                                   //padding byte at the very end(if it exists)' provides a color index value to be copied to the                                   //row for the color channel using the full opacity value of 255 and the closest z-buffer value                                   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the                                   //farthest z-buffer value of 255.                                  case 0x06:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                            Colors[j].A = (Palette[ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;                                          ZBuffer[j] = (Palette[ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                              }                          }                          break;                      //Leave the next count rows in the color channel filled with the transparent color'                       //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.                      case 0x04:                          for (int j = 0; j < Count; j++)                          {                              Color[] Colors = new Color[Width];                                for (int k = 0; k < Width; k++)                              {                                  Colors[k] = Color.Transparent;                                  Colors[k].A = 0;                                  ZBuffer[k] = 255;                              }                                Texture.SetData<Color>(Colors' 0' Colors.Length);                          }                          break;                      case 0x05:                          EndMarker = true;                          break;                  }
Missing Default,Files.IFF,SPR2Frame,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following switch statement is missing a default case: switch(PxCommand)                              {                                  //Set the next pixel count pixels in the z-buffer and color channels to the values defined                                   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel                                   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row                                   //for the z-buffer channel and color channel' respectively' in that order' using the full                                   //opacity value of 255 for each pixel that is not the transparent color.                                  case 0x01:                                      Colors = new Color[PxCount];                                        for(int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                      //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values                                       //defined by the pixel data provided directly after this command. Every group of 3 bytes in                                       //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity                                       //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'                                       //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale                                       //in the range 0-31' and the z buffer is in range 0-255.                                  case 0x02:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte Luminosity = Reader.ReadByte();                                          byte ColorIndex = Reader.ReadByte();                                          byte Alpha = (byte)(Reader.ReadByte() * 8.2258064516129032258064516129032);                                          Colors[j] = Palette[ColorIndex];                                          Colors[j].A = Alpha;                                          ZBuffer[j] = Luminosity;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Leave the next pixel count pixels in the color channel filled with the transparent color'                                   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel                                   //command has no pixel data.                                  case 0x03:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          Colors[j] = Color.Transparent;                                          Colors[j].A = 0;                                          ZBuffer[j] = 255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                                  //Set the next pixel count pixels in the color channel to the palette color indices defined by                                   //the pixel data provided directly after this command.Every byte in the pixel data' minus the                                   //padding byte at the very end(if it exists)' provides a color index value to be copied to the                                   //row for the color channel using the full opacity value of 255 and the closest z-buffer value                                   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the                                   //farthest z-buffer value of 255.                                  case 0x06:                                      Colors = new Color[PxCount];                                        for (int j = 0; j < PxCount; j++)                                      {                                          byte ColorIndex = Reader.ReadByte();                                          Colors[j] = Palette[ColorIndex];                                            Colors[j].A = (Palette[ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;                                          ZBuffer[j] = (Palette[ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;                                      }                                      Texture.SetData<Color>(Colors' 0' Colors.Length);                                      break;                              }
Missing Default,Files.IFF,STR,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following switch statement is missing a default case: switch(Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                    Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }
Missing Default,Files.IFF,TTAs,C:\repos\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following switch statement is missing a default case: switch (Version)                  {                      case 0:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadPascalString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -1:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -2:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = LanguageCodes.unused;                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -3:                          NumStrings = Reader.ReadUShort();                            for (int i = 0; i < NumStrings; i++)                          {                              TranslatedString Str = new TranslatedString();                              Str.LangCode = (LanguageCodes)Reader.ReadByte();                              Str.TranslatedStr = Reader.ReadCString();                              Reader.ReadCString(); //Comment                                if (Strings.ContainsKey(Str.LangCode))                                  Strings[Str.LangCode].Add(Str);                              else                              {                                  List<TranslatedString> LanguageSet = new List<TranslatedString>();                                  LanguageSet.Add(Str);                                  Strings.Add(Str.LangCode' LanguageSet);                              }                          }                            break;                      case -4:                          byte LanguageSets = Reader.ReadByte();                          for (int i = 0; i < LanguageSets; i++)                          {                              NumStrings = Reader.ReadUShort();                                for (int j = 0; j < NumStrings; j++)                              {                                  TranslatedString Str = new TranslatedString();                                  Str.LangCode = (LanguageCodes)(Reader.ReadByte() + 1);                                  Str.TranslatedStr = Reader.ReadString();                                  Reader.ReadString(); //Comment                                    if (Strings.ContainsKey(Str.LangCode))                                      Strings[Str.LangCode].Add(Str);                                  else                                  {                                      List<TranslatedString> LanguageSet = new List<TranslatedString>();                                      LanguageSet.Add(Str);                                      Strings.Add(Str.LangCode' LanguageSet);                                  }                              }                          }                            break;                  }
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The following switch statement is missing a default case: switch (this.objTargaHeader.FirstPixelDestination)                      {                          case FirstPixelDestination.TOP_LEFT:                              blnRowsReverse = false;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.TOP_RIGHT:                              blnRowsReverse = false;                              blnEachRowReverse = false;                              break;                            case FirstPixelDestination.BOTTOM_LEFT:                              blnRowsReverse = true;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.BOTTOM_RIGHT:                          case FirstPixelDestination.UNKNOWN:                              blnRowsReverse = true;                              blnEachRowReverse = false;                                break;                      }
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following switch statement is missing a default case: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following switch statement is missing a default case: switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following switch statement is missing a default case: switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following switch statement is missing a default case: switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }
