Implementation smell,Namespace,Class,File,Method,Description
Long Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The method has 133 lines of code.
Long Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The method has 180 lines of code.
Complex Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,Cyclomatic complexity of the method is 9
Complex Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,Cyclomatic complexity of the method is 8
Complex Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,Cyclomatic complexity of the method is 10
Complex Method,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,Dispose,Cyclomatic complexity of the method is 9
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaAuthorNameByteLength is 33.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaAuthorCommentsByteLength is 37.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaJobNameByteLength is 30.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaSoftwareIDByteLength is 33.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaSoftwareVersionLetterByteLength is 44.
Long Identifier,Paloma,TargaConstants,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,,The length of the parameter ExtensionAreaColorCorrectionTableValueLength is 44.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The length of the statement  "                if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The length of the statement  "                        string Signature = System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.FooterSignatureByteLength)).TrimEnd('\0'); " is 133.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The length of the statement  "                        if (string.Compare(Signature' TargaConstants.TargaFooterASCIISignature' StringComparison.InvariantCultureIgnoreCase) == 0) " is 122.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The length of the statement  "                            string ResChar = System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.FooterReservedCharByteLength)).TrimEnd('\0'); " is 134.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The length of the statement  "            if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "            if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetAuthorName(System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaAuthorNameByteLength)).TrimEnd('\0')); " is 164.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetAuthorComments(System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaAuthorCommentsByteLength)).TrimEnd('\0')); " is 172.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        string strStamp = iMonth.ToString(CultureInfo.CurrentCulture) + @"/" + iDay.ToString(CultureInfo.CurrentCulture) + @"/" + iYear.ToString(CultureInfo.CurrentCulture) + @" "; " is 172.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        strStamp += iHour.ToString(CultureInfo.CurrentCulture) + @":" + iMinute.ToString(CultureInfo.CurrentCulture) + @":" + iSecond.ToString(CultureInfo.CurrentCulture); " is 163.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetJobName(System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaJobNameByteLength)).TrimEnd('\0')); " is 158.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetSoftwareID(System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaSoftwareIDByteLength)).TrimEnd('\0')); " is 164.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        string strVersionLetter = System.Text.Encoding.ASCII.GetString(binReader.ReadBytes(TargaConstants.ExtensionAreaSoftwareVersionLetterByteLength)).TrimEnd('\0'); " is 159.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The length of the statement  "                        this.objTargaExtensionArea.SetSoftwareID(iVersionNumber.ToString(@"F2"' CultureInfo.CurrentCulture) + strVersionLetter); " is 120.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The length of the statement  "            if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The length of the statement  "            this.intStride = (((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes " is 124.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The length of the statement  "                        pal.Entries[i] = Color.FromArgb(255' this.objTargaHeader.ColorMap[i].R' this.objTargaHeader.ColorMap[i].G' this.objTargaHeader.ColorMap[i].B); " is 142.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The length of the statement  "            if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true) " is 129.
Long Statement,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The length of the statement  "                    System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>(); " is 158.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAFooterInfo,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAExtensionArea,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Complex Conditional,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The conditional expression  "binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true"  is complex.
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAHeaderInfo,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  try                  {                      // set the cursor at the beginning of the file.                      binReader.BaseStream.Seek(0' SeekOrigin.Begin);                        // read the header properties from the file                      this.objTargaHeader.SetImageIDLength(binReader.ReadByte());                      this.objTargaHeader.SetColorMapType((ColorMapType)binReader.ReadByte());                      this.objTargaHeader.SetImageType((ImageType)binReader.ReadByte());                        this.objTargaHeader.SetColorMapFirstEntryIndex(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapLength(binReader.ReadInt16());                      this.objTargaHeader.SetColorMapEntrySize(binReader.ReadByte());                        this.objTargaHeader.SetXOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetYOrigin(binReader.ReadInt16());                      this.objTargaHeader.SetWidth(binReader.ReadInt16());                      this.objTargaHeader.SetHeight(binReader.ReadInt16());                        byte pixeldepth = binReader.ReadByte();                      switch (pixeldepth)                      {                          case 8:                          case 16:                          case 24:                          case 32:                              this.objTargaHeader.SetPixelDepth(pixeldepth);                              break;                            default:                              this.ClearAll();                              throw new IOException("Targa Image only supports 8' 16' 24' or 32 bit pixel depths.");                      }                                              byte ImageDescriptor = binReader.ReadByte();                      this.objTargaHeader.SetAttributeBits((byte)Utilities.GetBits(ImageDescriptor' 0' 4));                        this.objTargaHeader.SetVerticalTransferOrder((VerticalTransferOrder)Utilities.GetBits(ImageDescriptor' 5' 1));                      this.objTargaHeader.SetHorizontalTransferOrder((HorizontalTransferOrder)Utilities.GetBits(ImageDescriptor' 4' 1));                        // load ImageID value if any                      if (this.objTargaHeader.ImageIDLength > 0)                      {                          byte[] ImageIDValueBytes = binReader.ReadBytes(this.objTargaHeader.ImageIDLength);                          this.objTargaHeader.SetImageIDValue(System.Text.Encoding.ASCII.GetString(ImageIDValueBytes).TrimEnd('\0'));                      }                  }                  catch (Exception)                  {                      this.ClearAll();                      throw;                  }                      // load color map if it's included and/or needed                  // Only needed for UNCOMPRESSED_COLOR_MAPPED and RUN_LENGTH_ENCODED_COLOR_MAPPED                  // image types. If color map is included for other file types we can ignore it.                  if (this.objTargaHeader.ColorMapType == ColorMapType.COLOR_MAP_INCLUDED)                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          if (this.objTargaHeader.ColorMapLength > 0)                          {                              try                              {                                  for (int i = 0; i < this.objTargaHeader.ColorMapLength; i++)                                  {                                      int a = 0;                                      int r = 0;                                      int g = 0;                                      int b = 0;                                        // load each color map entry based on the ColorMapEntrySize value                                      switch (this.objTargaHeader.ColorMapEntrySize)                                      {                                          case 15:                                              byte[] color15 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color15[1]' color15[0]));                                              break;                                          case 16:                                              byte[] color16 = binReader.ReadBytes(2);                                              // remember that the bytes are stored in reverse oreder                                              this.objTargaHeader.ColorMap.Add(Utilities.GetColorFrom2Bytes(color16[1]' color16[0]));                                              break;                                          case 24:                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(r' g' b));                                              break;                                          case 32:                                              a = Convert.ToInt32(binReader.ReadByte());                                              b = Convert.ToInt32(binReader.ReadByte());                                              g = Convert.ToInt32(binReader.ReadByte());                                              r = Convert.ToInt32(binReader.ReadByte());                                              this.objTargaHeader.ColorMap.Add(System.Drawing.Color.FromArgb(a' r' g' b));                                              break;                                          default:                                              this.ClearAll();                                              throw new IOException("TargaImage only supports ColorMap Entry Sizes of 15' 16' 24 or 32 bits.");                                                                                    }                                      }                              }                              catch (Exception)                              {                                  this.ClearAll();                                  throw;                              }                                                            }                          else                          {                              this.ClearAll();                              throw new IOException("Image Type requires a Color Map and Color Map Length is zero.");                          }                      }                      }                  else                  {                      if (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_COLOR_MAPPED ||                           this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED)                      {                          this.ClearAll();                          throw new IOException("Image Type requires a Color Map and there was not a Color Map included in the file.");                      }                  }                  }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.objTargaHeader.ImageDataOffset > 0)                  {                      // padding bytes                      byte[] padding = new byte[this.intPadding];                      MemoryStream msData = null;                                                               // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.objTargaHeader.ImageDataOffset' SeekOrigin.Begin);                                                                 // get the size in bytes of each row in the image                      int intImageRowByteSize = (int)this.objTargaHeader.Width * ((int)this.objTargaHeader.BytesPerPixel);                        // get the size in bytes of the whole image                      int intImageByteSize = intImageRowByteSize * (int)this.objTargaHeader.Height;                                                            // is this a RLE compressed image type                      if (this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE ||                         this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED ||                         this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_TRUE_COLOR)                      {                            #region COMPRESSED                                                        // RLE Packet info                              byte bRLEPacket = 0;                              int intRLEPacketType = -1;                              int intRLEPixelCount = 0;                              byte[] bRunLengthPixel = null;                                // used to keep track of bytes read                              int intImageBytesRead = 0;                              int intImageRowBytesRead = 0;                                // keep reading until we have the all image bytes                              while (intImageBytesRead < intImageByteSize)                              {                                  // get the RLE packet                                  bRLEPacket = binReader.ReadByte();                                  intRLEPacketType = Utilities.GetBits(bRLEPacket' 7' 1);                                  intRLEPixelCount = Utilities.GetBits(bRLEPacket' 0' 7) + 1;                                    // check the RLE packet type                                  if ((RLEPacketType)intRLEPacketType == RLEPacketType.RUN_LENGTH)                                  {                                      // get the pixel color data                                      bRunLengthPixel = binReader.ReadBytes((int)this.objTargaHeader.BytesPerPixel);                                        // add the number of pixels specified using the read pixel color                                      for (int i = 0; i < intRLEPixelCount; i++)                                      {                                          foreach (byte b in bRunLengthPixel)                                              row.Add(b);                                            // increment the byte counts                                          intImageRowBytesRead += bRunLengthPixel.Length;                                          intImageBytesRead += bRunLengthPixel.Length;                                            // if we have read a full image row                                          // add the row to the row list and clear it                                          // restart row byte count                                          if (intImageRowBytesRead == intImageRowByteSize)                                          {                                              rows.Add(row);                                              row = new System.Collections.Generic.List<byte>();                                              intImageRowBytesRead = 0;                                                                                        }                                      }                                    }                                    else if ((RLEPacketType)intRLEPacketType == RLEPacketType.RAW)                                  {                                      // get the number of bytes to read based on the read pixel count                                      int intBytesToRead = intRLEPixelCount * (int)this.objTargaHeader.BytesPerPixel;                                        // read each byte                                      for (int i = 0;i < intBytesToRead;i++)                                      {                                          row.Add(binReader.ReadByte());                                            // increment the byte counts                                          intImageBytesRead++;                                          intImageRowBytesRead++;                                            // if we have read a full image row                                          // add the row to the row list and clear it                                          // restart row byte count                                          if (intImageRowBytesRead == intImageRowByteSize)                                          {                                              rows.Add(row);                                              row = new System.Collections.Generic.List<byte>();                                              intImageRowBytesRead = 0;                                          }                                        }                                    }                              }                            #endregion                        }                        else                      {                          #region NON-COMPRESSED                            // loop through each row in the image                          for (int i = 0; i < (int)this.objTargaHeader.Height; i++)                          {                              // loop through each byte in the row                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  // add the byte to the row                                  row.Add(binReader.ReadByte());                              }                                // add row to the list of rows                              rows.Add(row);                                // create a new row                              row = new System.Collections.Generic.List<byte>();                          }                                                      #endregion                      }                        // flag that states whether or not to reverse the location of all rows.                      bool blnRowsReverse = false;                        // flag that states whether or not to reverse the bytes in each row.                      bool blnEachRowReverse = false;                        // use FirstPixelDestination to determine the alignment of the                       // image data byte                      switch (this.objTargaHeader.FirstPixelDestination)                      {                          case FirstPixelDestination.TOP_LEFT:                              blnRowsReverse = false;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.TOP_RIGHT:                              blnRowsReverse = false;                              blnEachRowReverse = false;                              break;                            case FirstPixelDestination.BOTTOM_LEFT:                              blnRowsReverse = true;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.BOTTOM_RIGHT:                          case FirstPixelDestination.UNKNOWN:                              blnRowsReverse = true;                              blnEachRowReverse = false;                                break;                      }                        // write the bytes from each row into a memory stream and get the                       // resulting byte array                      using (msData = new MemoryStream())                      {                            // do we reverse the rows in the row list.                          if (blnRowsReverse == true)                              rows.Reverse();                            // go through each row                          for (int i = 0; i < rows.Count; i++)                          {                              // do we reverse the bytes in the row                              if (blnEachRowReverse == true)                                  rows[i].Reverse();                                // get the byte array for the row                              byte[] brow = rows[i].ToArray();                                // write the row bytes and padding bytes to the memory streem                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          // get the image byte array                          data = msData.ToArray();                                                                             }                    }                  else                  {                      this.ClearAll();                      throw new IOException(@"Error loading file' No image data in file.");                  }              }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.objTargaHeader.ImageDataOffset > 0)                  {                      // padding bytes                      byte[] padding = new byte[this.intPadding];                      MemoryStream msData = null;                                                               // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.objTargaHeader.ImageDataOffset' SeekOrigin.Begin);                                                                 // get the size in bytes of each row in the image                      int intImageRowByteSize = (int)this.objTargaHeader.Width * ((int)this.objTargaHeader.BytesPerPixel);                        // get the size in bytes of the whole image                      int intImageByteSize = intImageRowByteSize * (int)this.objTargaHeader.Height;                                                            // is this a RLE compressed image type                      if (this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE ||                         this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_COLOR_MAPPED ||                         this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_TRUE_COLOR)                      {                            #region COMPRESSED                                                        // RLE Packet info                              byte bRLEPacket = 0;                              int intRLEPacketType = -1;                              int intRLEPixelCount = 0;                              byte[] bRunLengthPixel = null;                                // used to keep track of bytes read                              int intImageBytesRead = 0;                              int intImageRowBytesRead = 0;                                // keep reading until we have the all image bytes                              while (intImageBytesRead < intImageByteSize)                              {                                  // get the RLE packet                                  bRLEPacket = binReader.ReadByte();                                  intRLEPacketType = Utilities.GetBits(bRLEPacket' 7' 1);                                  intRLEPixelCount = Utilities.GetBits(bRLEPacket' 0' 7) + 1;                                    // check the RLE packet type                                  if ((RLEPacketType)intRLEPacketType == RLEPacketType.RUN_LENGTH)                                  {                                      // get the pixel color data                                      bRunLengthPixel = binReader.ReadBytes((int)this.objTargaHeader.BytesPerPixel);                                        // add the number of pixels specified using the read pixel color                                      for (int i = 0; i < intRLEPixelCount; i++)                                      {                                          foreach (byte b in bRunLengthPixel)                                              row.Add(b);                                            // increment the byte counts                                          intImageRowBytesRead += bRunLengthPixel.Length;                                          intImageBytesRead += bRunLengthPixel.Length;                                            // if we have read a full image row                                          // add the row to the row list and clear it                                          // restart row byte count                                          if (intImageRowBytesRead == intImageRowByteSize)                                          {                                              rows.Add(row);                                              row = new System.Collections.Generic.List<byte>();                                              intImageRowBytesRead = 0;                                                                                        }                                      }                                    }                                    else if ((RLEPacketType)intRLEPacketType == RLEPacketType.RAW)                                  {                                      // get the number of bytes to read based on the read pixel count                                      int intBytesToRead = intRLEPixelCount * (int)this.objTargaHeader.BytesPerPixel;                                        // read each byte                                      for (int i = 0;i < intBytesToRead;i++)                                      {                                          row.Add(binReader.ReadByte());                                            // increment the byte counts                                          intImageBytesRead++;                                          intImageRowBytesRead++;                                            // if we have read a full image row                                          // add the row to the row list and clear it                                          // restart row byte count                                          if (intImageRowBytesRead == intImageRowByteSize)                                          {                                              rows.Add(row);                                              row = new System.Collections.Generic.List<byte>();                                              intImageRowBytesRead = 0;                                          }                                        }                                    }                              }                            #endregion                        }                        else                      {                          #region NON-COMPRESSED                            // loop through each row in the image                          for (int i = 0; i < (int)this.objTargaHeader.Height; i++)                          {                              // loop through each byte in the row                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  // add the byte to the row                                  row.Add(binReader.ReadByte());                              }                                // add row to the list of rows                              rows.Add(row);                                // create a new row                              row = new System.Collections.Generic.List<byte>();                          }                                                      #endregion                      }                        // flag that states whether or not to reverse the location of all rows.                      bool blnRowsReverse = false;                        // flag that states whether or not to reverse the bytes in each row.                      bool blnEachRowReverse = false;                        // use FirstPixelDestination to determine the alignment of the                       // image data byte                      switch (this.objTargaHeader.FirstPixelDestination)                      {                          case FirstPixelDestination.TOP_LEFT:                              blnRowsReverse = false;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.TOP_RIGHT:                              blnRowsReverse = false;                              blnEachRowReverse = false;                              break;                            case FirstPixelDestination.BOTTOM_LEFT:                              blnRowsReverse = true;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.BOTTOM_RIGHT:                          case FirstPixelDestination.UNKNOWN:                              blnRowsReverse = true;                              blnEachRowReverse = false;                                break;                      }                        // write the bytes from each row into a memory stream and get the                       // resulting byte array                      using (msData = new MemoryStream())                      {                            // do we reverse the rows in the row list.                          if (blnRowsReverse == true)                              rows.Reverse();                            // go through each row                          for (int i = 0; i < rows.Count; i++)                          {                              // do we reverse the bytes in the row                              if (blnEachRowReverse == true)                                  rows[i].Reverse();                                // get the byte array for the row                              byte[] brow = rows[i].ToArray();                                // write the row bytes and padding bytes to the memory streem                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          // get the image byte array                          data = msData.ToArray();                                                                             }                    }                  else                  {                      this.ClearAll();                      throw new IOException(@"Error loading file' No image data in file.");                  }              }              else              {                  this.ClearAll();                  throw new IOException(@"Error loading file' could not read file from disk.");              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intStride = (((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3;
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intStride = (((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3;
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intStride = (((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3;
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intPadding = this.intStride - ((((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth) + 7) / 8);
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: this.intPadding = this.intStride - ((((int)this.objTargaHeader.Width * (int)this.objTargaHeader.PixelDepth) + 7) / 8);
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: if (this.objTargaHeader.ColorMap.Count > 0)              {                  // get the Bitmap's current palette                  ColorPalette pal = this.bmpTargaImage.Palette;                    // loop trough each color in the loaded file's color map                  for (int i = 0; i < this.objTargaHeader.ColorMap.Count; i++)                  {                      // is the AttributesType 0 or 1 bit                      if (this.objTargaExtensionArea.AttributesType == 0 ||                          this.objTargaExtensionArea.AttributesType == 1)                          // use 255 for alpha ( 255 = opaque/visible ) so we can see the image                          pal.Entries[i] = Color.FromArgb(255' this.objTargaHeader.ColorMap[i].R' this.objTargaHeader.ColorMap[i].G' this.objTargaHeader.ColorMap[i].B);                        else                          // use whatever value is there                          pal.Entries[i] = this.objTargaHeader.ColorMap[i];                    }                    // set the new palette back to the Bitmap object                  this.bmpTargaImage.Palette = pal;                    // set the palette to the thumbnail also' if there is one                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Palette = pal;                  }              }              else              { // no color map                      // check to see if this is a Black and White (Greyscale)                  if (this.objTargaHeader.PixelDepth == 8 && (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_BLACK_AND_WHITE ||                      this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE))                  {                      // get the current palette                      ColorPalette pal = this.bmpTargaImage.Palette;                        // create the Greyscale palette                      for (int i = 0; i < 256; i++)                      {                          pal.Entries[i] = Color.FromArgb(i' i' i);                      }                        // set the new palette back to the Bitmap object                      this.bmpTargaImage.Palette = pal;                        // set the palette to the thumbnail also' if there is one                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Palette = pal;                      }                  }                                  }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: if (this.objTargaHeader.ColorMap.Count > 0)              {                  // get the Bitmap's current palette                  ColorPalette pal = this.bmpTargaImage.Palette;                    // loop trough each color in the loaded file's color map                  for (int i = 0; i < this.objTargaHeader.ColorMap.Count; i++)                  {                      // is the AttributesType 0 or 1 bit                      if (this.objTargaExtensionArea.AttributesType == 0 ||                          this.objTargaExtensionArea.AttributesType == 1)                          // use 255 for alpha ( 255 = opaque/visible ) so we can see the image                          pal.Entries[i] = Color.FromArgb(255' this.objTargaHeader.ColorMap[i].R' this.objTargaHeader.ColorMap[i].G' this.objTargaHeader.ColorMap[i].B);                        else                          // use whatever value is there                          pal.Entries[i] = this.objTargaHeader.ColorMap[i];                    }                    // set the new palette back to the Bitmap object                  this.bmpTargaImage.Palette = pal;                    // set the palette to the thumbnail also' if there is one                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Palette = pal;                  }              }              else              { // no color map                      // check to see if this is a Black and White (Greyscale)                  if (this.objTargaHeader.PixelDepth == 8 && (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_BLACK_AND_WHITE ||                      this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE))                  {                      // get the current palette                      ColorPalette pal = this.bmpTargaImage.Palette;                        // create the Greyscale palette                      for (int i = 0; i < 256; i++)                      {                          pal.Entries[i] = Color.FromArgb(i' i' i);                      }                        // set the new palette back to the Bitmap object                      this.bmpTargaImage.Palette = pal;                        // set the palette to the thumbnail also' if there is one                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Palette = pal;                      }                  }                                  }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadTGAImage,The following statement contains a magic number: if (this.objTargaHeader.ColorMap.Count > 0)              {                  // get the Bitmap's current palette                  ColorPalette pal = this.bmpTargaImage.Palette;                    // loop trough each color in the loaded file's color map                  for (int i = 0; i < this.objTargaHeader.ColorMap.Count; i++)                  {                      // is the AttributesType 0 or 1 bit                      if (this.objTargaExtensionArea.AttributesType == 0 ||                          this.objTargaExtensionArea.AttributesType == 1)                          // use 255 for alpha ( 255 = opaque/visible ) so we can see the image                          pal.Entries[i] = Color.FromArgb(255' this.objTargaHeader.ColorMap[i].R' this.objTargaHeader.ColorMap[i].G' this.objTargaHeader.ColorMap[i].B);                        else                          // use whatever value is there                          pal.Entries[i] = this.objTargaHeader.ColorMap[i];                    }                    // set the new palette back to the Bitmap object                  this.bmpTargaImage.Palette = pal;                    // set the palette to the thumbnail also' if there is one                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Palette = pal;                  }              }              else              { // no color map                      // check to see if this is a Black and White (Greyscale)                  if (this.objTargaHeader.PixelDepth == 8 && (this.objTargaHeader.ImageType == ImageType.UNCOMPRESSED_BLACK_AND_WHITE ||                      this.objTargaHeader.ImageType == ImageType.RUN_LENGTH_ENCODED_BLACK_AND_WHITE))                  {                      // get the current palette                      ColorPalette pal = this.bmpTargaImage.Palette;                        // create the Greyscale palette                      for (int i = 0; i < 256; i++)                      {                          pal.Entries[i] = Color.FromArgb(i' i' i);                      }                        // set the new palette back to the Bitmap object                      this.bmpTargaImage.Palette = pal;                        // set the palette to the thumbnail also' if there is one                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Palette = pal;                      }                  }                                  }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following statement contains a magic number: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following statement contains a magic number: if (binReader != null && binReader.BaseStream != null && binReader.BaseStream.Length > 0 && binReader.BaseStream.CanSeek == true)              {                  if (this.ExtensionArea.PostageStampOffset > 0)                  {                        // seek to the beginning of the image data using the ImageDataOffset value                      binReader.BaseStream.Seek(this.ExtensionArea.PostageStampOffset' SeekOrigin.Begin);                        int iWidth = (int)binReader.ReadByte();                      int iHeight = (int)binReader.ReadByte();                        int iStride = ((iWidth * (int)this.objTargaHeader.PixelDepth + 31) & ~31) >> 3; // width in bytes                      int iPadding = iStride - (((iWidth * (int)this.objTargaHeader.PixelDepth) + 7) / 8);                        System.Collections.Generic.List<System.Collections.Generic.List<byte>> objRows = new System.Collections.Generic.List<System.Collections.Generic.List<byte>>();                      System.Collections.Generic.List<byte> objRow = new System.Collections.Generic.List<byte>();                              byte[] padding = new byte[iPadding];                      MemoryStream msData = null;                      bool blnEachRowReverse = false;                      bool blnRowsReverse = false;                                              using (msData = new MemoryStream())                      {                          // get the size in bytes of each row in the image                          int intImageRowByteSize = iWidth * ((int)this.objTargaHeader.PixelDepth / 8);                            // thumbnails are never compressed                          for (int i = 0; i < iHeight; i++)                          {                              for (int j = 0; j < intImageRowByteSize; j++)                              {                                  objRow.Add(binReader.ReadByte());                              }                              objRows.Add(objRow);                              objRow = new System.Collections.Generic.List<byte>();                          }                                                    switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }                            if (blnRowsReverse == true)                              objRows.Reverse();                            for (int i = 0; i < objRows.Count; i++)                          {                              if (blnEachRowReverse == true)                                  objRows[i].Reverse();                                byte[] brow = objRows[i].ToArray();                              msData.Write(brow' 0' brow.Length);                              msData.Write(padding' 0' padding.Length);                          }                          data = msData.ToArray();                      }                        if (data != null && data.Length > 0)                      {                          this.ThumbnailByteHandle = GCHandle.Alloc(data' GCHandleType.Pinned);                          this.bmpImageThumbnail = new Bitmap(iWidth' iHeight' iStride' pfPixelFormat'                                                          this.ThumbnailByteHandle.AddrOfPinnedObject());                        }                                                             }                  else                  {                      if (this.bmpImageThumbnail != null)                      {                          this.bmpImageThumbnail.Dispose();                          this.bmpImageThumbnail = null;                      }                  }              }              else              {                  if (this.bmpImageThumbnail != null)                  {                      this.bmpImageThumbnail.Dispose();                      this.bmpImageThumbnail = null;                  }              }
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int r1 = Utilities.GetBits(one' 2' 5);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int r1 = Utilities.GetBits(one' 2' 5);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int r = r1 << 3;
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int bit = Utilities.GetBits(one' 0' 2);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int g1 = bit << 6;
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: bit = Utilities.GetBits(two' 5' 3);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: bit = Utilities.GetBits(two' 5' 3);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int g2 = bit << 3;
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int b1 = Utilities.GetBits(two' 0' 5);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int b = b1 << 3;
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int a1 = Utilities.GetBits(one' 7' 1);
Magic Number,Paloma,Utilities,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetColorFrom2Bytes,The following statement contains a magic number: int a = a1 * 255;
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadImageBytes,The following switch statement is missing a default case: switch (this.objTargaHeader.FirstPixelDestination)                      {                          case FirstPixelDestination.TOP_LEFT:                              blnRowsReverse = false;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.TOP_RIGHT:                              blnRowsReverse = false;                              blnEachRowReverse = false;                              break;                            case FirstPixelDestination.BOTTOM_LEFT:                              blnRowsReverse = true;                              blnEachRowReverse = true;                              break;                            case FirstPixelDestination.BOTTOM_RIGHT:                          case FirstPixelDestination.UNKNOWN:                              blnRowsReverse = true;                              blnEachRowReverse = false;                                break;                      }
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following switch statement is missing a default case: switch (this.objTargaHeader.PixelDepth)              {                  case 8:                      pfTargaPixelFormat = PixelFormat.Format8bppIndexed;                      break;                    case 16:                      //PixelFormat.Format16bppArgb1555                      //PixelFormat.Format16bppRgb555                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                      }                        break;                    case 24:                      pfTargaPixelFormat = PixelFormat.Format24bppRgb;                      break;                    case 32:                      //PixelFormat.Format32bppArgb                      //PixelFormat.Format32bppPArgb                      //PixelFormat.Format32bppRgb                      if (this.Format == TGAFormat.NEW_TGA)                      {                          switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }                      }                      else                      {                          pfTargaPixelFormat = PixelFormat.Format32bppRgb;                          break;                      }                                                                    break;                                }
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following switch statement is missing a default case: switch (this.objTargaExtensionArea.AttributesType)                          {                              case 0:                              case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppRgb555;                                  break;                                case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format16bppArgb1555;                                  break;                          }
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,GetPixelFormat,The following switch statement is missing a default case: switch (this.objTargaExtensionArea.AttributesType)                          {                                                            case 1:                              case 2: // no alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppRgb;                                  break;                                case 0:                              case 3: // useful alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppArgb;                                  break;                                case 4: // premultiplied alpha data                                  pfTargaPixelFormat = PixelFormat.Format32bppPArgb;                                  break;                            }
Missing Default,Paloma,TargaImage,C:\repos\Afr0_Project-Dollhouse\Other\libs\TargaImage\TargaImage.cs,LoadThumbnail,The following switch statement is missing a default case: switch (this.objTargaHeader.FirstPixelDestination)                          {                              case FirstPixelDestination.TOP_LEFT:                                  break;                                case FirstPixelDestination.TOP_RIGHT:                                  blnRowsReverse = false;                                  blnEachRowReverse = false;                                  break;                                case FirstPixelDestination.BOTTOM_LEFT:                                  break;                                case FirstPixelDestination.BOTTOM_RIGHT:                              case FirstPixelDestination.UNKNOWN:                                  blnRowsReverse = true;                                  blnEachRowReverse = false;                                    break;                          }
