Implementation smell,Namespace,Class,File,Method,Description
Long Method,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The method has 116 lines of code.
Long Method,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,extractFARArchiveToolStripMenuItem_Click,The method has 219 lines of code.
Complex Method,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,extractFARArchiveToolStripMenuItem_Click,Cyclomatic complexity of the method is 8
Long Parameter List,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,ArrayCopy2,The method has 5 parameters. Parameters: Src' SrcPos' Dest' DestPos' Length
Long Identifier,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,,The length of the parameter openFARArchiveToolStripMenuItem is 31.
Long Identifier,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,,The length of the parameter extractFARArchiveToolStripMenuItem is 34.
Long Statement,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The length of the statement  "            this.extractFARArchiveToolStripMenuItem.Click += new System.EventHandler(this.extractFARArchiveToolStripMenuItem_Click); " is 120.
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Decompresser,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6)              {                  /*m_CompressedSize = Reader.ReadUInt32();                  int Signature = Reader.ReadUInt16();                    //If the data isn't compressed.                  m_DecompressedSize = m_CompressedSize;                    if (Signature == 0xFB10)                  {                      short A = (short)Reader.ReadByte();                      short B = (short)Reader.ReadByte();                      short C = (short)Reader.ReadByte();                      m_DecompressedSize = A * 65536 + B * 256 + C;*/                        byte[] DecompressedData = new byte[(int)m_DecompressedSize];                      int DataPos = 0;                        m_Compressed = true;                      //int Pos = 9;                      int Pos = 0;                      long Control1 = 0;                        while (Control1 != 0xFC && Pos < Data.Length)                      {                          Control1 = Data[Pos];                          Pos++;                            if (Pos == Data.Length)                              break;                            if (Control1 >= 0 && Control1 <= 127)                          {                              // 0x00 - 0x7F                              long control2 = Data[Pos];                              Pos++;  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x60) << 3) + (control2) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if ((Control1 >= 128 && Control1 <= 191))                          {                              // 0x80 - 0xBF                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                                long numberOfPlainText = (control2 >> 6) & 0x03;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                                int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);                              long numberToCopyFromOffset = (Control1 & 0x3F) + 4;                              OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);                              DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                          else if (Control1 >= 192 && Control1 <= 223)                           {                              // 0xC0 - 0xDF                              long numberOfPlainText = (Control1 & 0x03);                              long control2 = Data[Pos];                              Pos++;                              long control3 = Data[Pos];                              Pos++;                              long control4 = Data[Pos];                              Pos++;                              ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);                              DataPos += (int)numberOfPlainText;                              Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	  	                        int offset = (int) (((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	                        long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	                        OffsetCopy(ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	                        DataPos += (int)numberToCopyFromOffset;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                          else if (Control1 >= 224 && Control1 <= 251)                          {  	                        // 0xE0 - 0xFB  	                        long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;                          }                           else                          {  	                        long numberOfPlainText = (Control1 & 0x03);  	                        ArrayCopy2(Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);    	                        DataPos += (int)numberOfPlainText;  	                        Pos += (int)numberOfPlainText;                                if (DataPos == (DecompressedData.Length))                                  break;  	                    }                      }                        return DecompressedData;                  }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,DetermineArchiveType,The following statement contains a magic number: string Header = Encoding.ASCII.GetString(Reader.ReadBytes(8));
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,DetermineArchiveType,The following statement contains a magic number: if (Header == "FAR!byAZ")              {                  uint Version = Reader.ReadUInt32();                  MessageBox.Show("Version: " + Version.ToString());                    if (Version == 3)                  {                      Reader.Close();                      return ArchiveType.FAR3;                  }                    Reader.Close();                  return ArchiveType.FAR;              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenDBPF,The following statement contains a magic number: string Header = Encoding.ASCII.GetString(Reader.ReadBytes(4));
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenDBPF,The following statement contains a magic number: Reader.ReadBytes(12);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenDBPF,The following statement contains a magic number: for (int i = 0; i < IndexEntryCount; i++)              {                  DBPFEntry Entry = new DBPFEntry();                  Entry.TypeID = Reader.ReadUInt32();                  Entry.GroupID = Reader.ReadUInt32();                  Entry.InstanceID = Reader.ReadUInt32();                    if(IndexMaj == 7 && IndexMin == 1)                      Entry.InstanceID2 = Reader.ReadUInt32();                    Entry.DataOffset = Reader.ReadUInt32();                  Entry.DataSize = Reader.ReadUInt32();                    m_DBPFEntries.Add(Entry);              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenDatArchive,The following statement contains a magic number: string Header = Encoding.ASCII.GetString(Reader.ReadBytes(8));
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenDatArchive,The following statement contains a magic number: if ((Header != "FAR!byAZ") || (Version != 3))              {                  MessageBox.Show("Archive wasn't a valid FAR V.3 archive!");                  return;              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenDatArchive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++)              {                  Far3Entry Entry = new Far3Entry();                  Entry.DecompressedFileSize = Reader.ReadUInt32();                  Logger.Write("DecompressedFilesize: " + Entry.DecompressedFileSize + "\r\n");                  byte[] Dummy = Reader.ReadBytes(3);                  Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                  Logger.Write("CompressedFilesize: " + Entry.CompressedFileSize + "\r\n");                  //Entry.CompressedFileSize = Convert.ToUInt32(Reader.ReadBytes(3));                  Entry.DataType = Reader.ReadByte();                  Logger.Write("DataType: " + Entry.DataType + "\r\n");                  //Entry.CompressedSpecifics = Reader.ReadUInt16();                  //Entry.PowerValue = Reader.ReadByte();                  //Entry.Unknown = Reader.ReadByte();                  Entry.DataOffset = Reader.ReadUInt32();                  Logger.Write("DataOffset: " + Entry.DataOffset + "\r\n");                  //Entry.Unknown2 = Reader.ReadUInt16();                  Entry.Compressed = Reader.ReadByte();                  Logger.Write("Compressed: " + Entry.Compressed + "\r\n");                  Entry.AccessNumber = Reader.ReadByte();                  Logger.Write("AccessNumber: " + Entry.AccessNumber + "\r\n");                  Entry.FilenameLength = Reader.ReadUInt16();                  Logger.Write("FilenameLength: " + Entry.FilenameLength + "\r\n");                  Entry.TypeID = Reader.ReadUInt32();                  Logger.Write("TypeID: " + Entry.TypeID + "\r\n");                  Entry.FileID = Reader.ReadUInt32();                  Logger.Write("FileID: " + Entry.FileID + "\r\n");                  Entry.Filename = Encoding.ASCII.GetString(Reader.ReadBytes(Entry.FilenameLength));                  Logger.Write("Filename: " + Entry.Filename + "\r\n");                  Logger.Write("\r\n");                    m_Far3Entries.Add(Entry);                  LstFiles.Items.Add(Entry.Filename + "' " + string.Format("{0:X}"' Entry.FileID));              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenDatArchive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++)              {                  Far3Entry Entry = new Far3Entry();                  Entry.DecompressedFileSize = Reader.ReadUInt32();                  Logger.Write("DecompressedFilesize: " + Entry.DecompressedFileSize + "\r\n");                  byte[] Dummy = Reader.ReadBytes(3);                  Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                  Logger.Write("CompressedFilesize: " + Entry.CompressedFileSize + "\r\n");                  //Entry.CompressedFileSize = Convert.ToUInt32(Reader.ReadBytes(3));                  Entry.DataType = Reader.ReadByte();                  Logger.Write("DataType: " + Entry.DataType + "\r\n");                  //Entry.CompressedSpecifics = Reader.ReadUInt16();                  //Entry.PowerValue = Reader.ReadByte();                  //Entry.Unknown = Reader.ReadByte();                  Entry.DataOffset = Reader.ReadUInt32();                  Logger.Write("DataOffset: " + Entry.DataOffset + "\r\n");                  //Entry.Unknown2 = Reader.ReadUInt16();                  Entry.Compressed = Reader.ReadByte();                  Logger.Write("Compressed: " + Entry.Compressed + "\r\n");                  Entry.AccessNumber = Reader.ReadByte();                  Logger.Write("AccessNumber: " + Entry.AccessNumber + "\r\n");                  Entry.FilenameLength = Reader.ReadUInt16();                  Logger.Write("FilenameLength: " + Entry.FilenameLength + "\r\n");                  Entry.TypeID = Reader.ReadUInt32();                  Logger.Write("TypeID: " + Entry.TypeID + "\r\n");                  Entry.FileID = Reader.ReadUInt32();                  Logger.Write("FileID: " + Entry.FileID + "\r\n");                  Entry.Filename = Encoding.ASCII.GetString(Reader.ReadBytes(Entry.FilenameLength));                  Logger.Write("Filename: " + Entry.Filename + "\r\n");                  Logger.Write("\r\n");                    m_Far3Entries.Add(Entry);                  LstFiles.Items.Add(Entry.Filename + "' " + string.Format("{0:X}"' Entry.FileID));              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenDatArchive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++)              {                  Far3Entry Entry = new Far3Entry();                  Entry.DecompressedFileSize = Reader.ReadUInt32();                  Logger.Write("DecompressedFilesize: " + Entry.DecompressedFileSize + "\r\n");                  byte[] Dummy = Reader.ReadBytes(3);                  Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                  Logger.Write("CompressedFilesize: " + Entry.CompressedFileSize + "\r\n");                  //Entry.CompressedFileSize = Convert.ToUInt32(Reader.ReadBytes(3));                  Entry.DataType = Reader.ReadByte();                  Logger.Write("DataType: " + Entry.DataType + "\r\n");                  //Entry.CompressedSpecifics = Reader.ReadUInt16();                  //Entry.PowerValue = Reader.ReadByte();                  //Entry.Unknown = Reader.ReadByte();                  Entry.DataOffset = Reader.ReadUInt32();                  Logger.Write("DataOffset: " + Entry.DataOffset + "\r\n");                  //Entry.Unknown2 = Reader.ReadUInt16();                  Entry.Compressed = Reader.ReadByte();                  Logger.Write("Compressed: " + Entry.Compressed + "\r\n");                  Entry.AccessNumber = Reader.ReadByte();                  Logger.Write("AccessNumber: " + Entry.AccessNumber + "\r\n");                  Entry.FilenameLength = Reader.ReadUInt16();                  Logger.Write("FilenameLength: " + Entry.FilenameLength + "\r\n");                  Entry.TypeID = Reader.ReadUInt32();                  Logger.Write("TypeID: " + Entry.TypeID + "\r\n");                  Entry.FileID = Reader.ReadUInt32();                  Logger.Write("FileID: " + Entry.FileID + "\r\n");                  Entry.Filename = Encoding.ASCII.GetString(Reader.ReadBytes(Entry.FilenameLength));                  Logger.Write("Filename: " + Entry.Filename + "\r\n");                  Logger.Write("\r\n");                    m_Far3Entries.Add(Entry);                  LstFiles.Items.Add(Entry.Filename + "' " + string.Format("{0:X}"' Entry.FileID));              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenDatArchive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++)              {                  Far3Entry Entry = new Far3Entry();                  Entry.DecompressedFileSize = Reader.ReadUInt32();                  Logger.Write("DecompressedFilesize: " + Entry.DecompressedFileSize + "\r\n");                  byte[] Dummy = Reader.ReadBytes(3);                  Entry.CompressedFileSize = (uint)((Dummy[0] << 0) | (Dummy[1] << 8) | (Dummy[2]) << 16);                  Logger.Write("CompressedFilesize: " + Entry.CompressedFileSize + "\r\n");                  //Entry.CompressedFileSize = Convert.ToUInt32(Reader.ReadBytes(3));                  Entry.DataType = Reader.ReadByte();                  Logger.Write("DataType: " + Entry.DataType + "\r\n");                  //Entry.CompressedSpecifics = Reader.ReadUInt16();                  //Entry.PowerValue = Reader.ReadByte();                  //Entry.Unknown = Reader.ReadByte();                  Entry.DataOffset = Reader.ReadUInt32();                  Logger.Write("DataOffset: " + Entry.DataOffset + "\r\n");                  //Entry.Unknown2 = Reader.ReadUInt16();                  Entry.Compressed = Reader.ReadByte();                  Logger.Write("Compressed: " + Entry.Compressed + "\r\n");                  Entry.AccessNumber = Reader.ReadByte();                  Logger.Write("AccessNumber: " + Entry.AccessNumber + "\r\n");                  Entry.FilenameLength = Reader.ReadUInt16();                  Logger.Write("FilenameLength: " + Entry.FilenameLength + "\r\n");                  Entry.TypeID = Reader.ReadUInt32();                  Logger.Write("TypeID: " + Entry.TypeID + "\r\n");                  Entry.FileID = Reader.ReadUInt32();                  Logger.Write("FileID: " + Entry.FileID + "\r\n");                  Entry.Filename = Encoding.ASCII.GetString(Reader.ReadBytes(Entry.FilenameLength));                  Logger.Write("Filename: " + Entry.Filename + "\r\n");                  Logger.Write("\r\n");                    m_Far3Entries.Add(Entry);                  LstFiles.Items.Add(Entry.Filename + "' " + string.Format("{0:X}"' Entry.FileID));              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,OpenFARArchive,The following statement contains a magic number: string Header = Encoding.ASCII.GetString(Reader.ReadBytes(8));
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,extractFARArchiveToolStripMenuItem_Click,The following statement contains a magic number: if (FBrowserDiag.ShowDialog() == DialogResult.OK)              {                  if (m_CurrentFile.Contains(".dat"))                  {                      if (m_CurrentArchiveType == ArchiveType.FAR3)                      {                          foreach (Far3Entry Entry in m_Far3Entries)                          {                              Reader.BaseStream.Seek(Entry.DataOffset' SeekOrigin.Begin);                                if (Entry.Filename.Contains(".bmp"))                              {                                  if (Entry.TypeID == 1)                                  {                                      byte[] DecompressedBuffer = Decompress(Reader' Entry);                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(DecompressedBuffer);                                      Writer.Close();                                  }                                  else //TypeID should be 0x856DDBAC' meaning the entry isn't compressed.                                  {                                      uint Filesize = Entry.DecompressedFileSize;                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(Reader.ReadBytes((int)Filesize));                                      Writer.Close();                                  }                              }                              else if (Entry.Filename.Contains(".tga"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".skel"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".anim"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".mesh"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".bnd"))                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".apr")) //APpeaRance                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".oft")) //OutFiT                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".png"))                              {                                  if (Entry.TypeID == 24)                                  {                                      //int Filesize = (int)Entry.DecompressedFileSize;                                      byte[] DecompressedBuffer = Decompress(Reader' Entry);                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(DecompressedBuffer);                                      Writer.Close();                                  }                                  else //TypeID should be 14' which means entry isn't compressed.                                  {                                      uint Filesize = Entry.DecompressedFileSize;                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(Reader.ReadBytes((int)Filesize));                                      Writer.Close();                                  }                              }                              else if (Entry.Filename.Contains(".po")) //Purchasable Object                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".col")) //COLlection                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".hag")) //Group?                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".jpg"))                              {                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                          }                      }                      else if (m_CurrentArchiveType == ArchiveType.DBPF)                      {                          foreach (DBPFEntry Entry in m_DBPFEntries)                          {                              Reader.BaseStream.Seek(Entry.DataOffset' SeekOrigin.Begin);                              byte[] Data = Reader.ReadBytes((int)Entry.DataSize);                                //NOTE: TypeID and GroupID are the same for all entries' so to differentiate the type'                              //      the header of each file has to be read.                              byte[] HeaderBuf = new byte[2];                              Array.Copy(Data' HeaderBuf' 2);                              string Header = Encoding.ASCII.GetString(HeaderBuf);                                switch (Header)                              {                                  case "XA":                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".xa"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "UT": //UTalk                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".utk"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "WA": //Wav                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".wav"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "TK": //Tracks                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".tkdt"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "BM": //BMP (TSOAudio.dat)                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".bmp"));                                      Writer.Write(Data);                                      Writer.Close();                                                                            break;                                  case "HI": //Hitlist                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".bmp"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "# ": //UIScript (TSOAudio.dat)                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".uis"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  default: //MP3 has no fileheader!                                      if (Entry.TypeID != 0x7B1ACFCD)                                      {                                          Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".mp3"));                                          Writer.Write(Data);                                          Writer.Close();                                      }                                        break;                              }                                if (Entry.TypeID == 0x7B1ACFCD) //Unknown                              {                                  Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".unknown"));                                  Writer.Write(Data);                                  Writer.Close();                              }                          }                      }                  }                  else if (m_CurrentFile.Contains(".far"))                  {                      foreach(FarEntry Entry in m_FarEntries)                      {                          Reader.BaseStream.Seek((long)Entry.DataOffset' SeekOrigin.Begin);                          byte[] Data = Reader.ReadBytes(Entry.DataLength);                            Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                          Writer.Write(Data);                          Writer.Close();                      }                  }              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,extractFARArchiveToolStripMenuItem_Click,The following statement contains a magic number: if (FBrowserDiag.ShowDialog() == DialogResult.OK)              {                  if (m_CurrentFile.Contains(".dat"))                  {                      if (m_CurrentArchiveType == ArchiveType.FAR3)                      {                          foreach (Far3Entry Entry in m_Far3Entries)                          {                              Reader.BaseStream.Seek(Entry.DataOffset' SeekOrigin.Begin);                                if (Entry.Filename.Contains(".bmp"))                              {                                  if (Entry.TypeID == 1)                                  {                                      byte[] DecompressedBuffer = Decompress(Reader' Entry);                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(DecompressedBuffer);                                      Writer.Close();                                  }                                  else //TypeID should be 0x856DDBAC' meaning the entry isn't compressed.                                  {                                      uint Filesize = Entry.DecompressedFileSize;                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(Reader.ReadBytes((int)Filesize));                                      Writer.Close();                                  }                              }                              else if (Entry.Filename.Contains(".tga"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".skel"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".anim"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".mesh"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".bnd"))                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".apr")) //APpeaRance                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".oft")) //OutFiT                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".png"))                              {                                  if (Entry.TypeID == 24)                                  {                                      //int Filesize = (int)Entry.DecompressedFileSize;                                      byte[] DecompressedBuffer = Decompress(Reader' Entry);                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(DecompressedBuffer);                                      Writer.Close();                                  }                                  else //TypeID should be 14' which means entry isn't compressed.                                  {                                      uint Filesize = Entry.DecompressedFileSize;                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(Reader.ReadBytes((int)Filesize));                                      Writer.Close();                                  }                              }                              else if (Entry.Filename.Contains(".po")) //Purchasable Object                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".col")) //COLlection                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".hag")) //Group?                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".jpg"))                              {                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                          }                      }                      else if (m_CurrentArchiveType == ArchiveType.DBPF)                      {                          foreach (DBPFEntry Entry in m_DBPFEntries)                          {                              Reader.BaseStream.Seek(Entry.DataOffset' SeekOrigin.Begin);                              byte[] Data = Reader.ReadBytes((int)Entry.DataSize);                                //NOTE: TypeID and GroupID are the same for all entries' so to differentiate the type'                              //      the header of each file has to be read.                              byte[] HeaderBuf = new byte[2];                              Array.Copy(Data' HeaderBuf' 2);                              string Header = Encoding.ASCII.GetString(HeaderBuf);                                switch (Header)                              {                                  case "XA":                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".xa"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "UT": //UTalk                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".utk"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "WA": //Wav                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".wav"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "TK": //Tracks                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".tkdt"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "BM": //BMP (TSOAudio.dat)                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".bmp"));                                      Writer.Write(Data);                                      Writer.Close();                                                                            break;                                  case "HI": //Hitlist                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".bmp"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "# ": //UIScript (TSOAudio.dat)                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".uis"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  default: //MP3 has no fileheader!                                      if (Entry.TypeID != 0x7B1ACFCD)                                      {                                          Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".mp3"));                                          Writer.Write(Data);                                          Writer.Close();                                      }                                        break;                              }                                if (Entry.TypeID == 0x7B1ACFCD) //Unknown                              {                                  Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".unknown"));                                  Writer.Write(Data);                                  Writer.Close();                              }                          }                      }                  }                  else if (m_CurrentFile.Contains(".far"))                  {                      foreach(FarEntry Entry in m_FarEntries)                      {                          Reader.BaseStream.Seek((long)Entry.DataOffset' SeekOrigin.Begin);                          byte[] Data = Reader.ReadBytes(Entry.DataLength);                            Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                          Writer.Write(Data);                          Writer.Close();                      }                  }              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,extractFARArchiveToolStripMenuItem_Click,The following statement contains a magic number: if (FBrowserDiag.ShowDialog() == DialogResult.OK)              {                  if (m_CurrentFile.Contains(".dat"))                  {                      if (m_CurrentArchiveType == ArchiveType.FAR3)                      {                          foreach (Far3Entry Entry in m_Far3Entries)                          {                              Reader.BaseStream.Seek(Entry.DataOffset' SeekOrigin.Begin);                                if (Entry.Filename.Contains(".bmp"))                              {                                  if (Entry.TypeID == 1)                                  {                                      byte[] DecompressedBuffer = Decompress(Reader' Entry);                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(DecompressedBuffer);                                      Writer.Close();                                  }                                  else //TypeID should be 0x856DDBAC' meaning the entry isn't compressed.                                  {                                      uint Filesize = Entry.DecompressedFileSize;                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(Reader.ReadBytes((int)Filesize));                                      Writer.Close();                                  }                              }                              else if (Entry.Filename.Contains(".tga"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".skel"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".anim"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".mesh"))                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".bnd"))                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".apr")) //APpeaRance                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".oft")) //OutFiT                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".png"))                              {                                  if (Entry.TypeID == 24)                                  {                                      //int Filesize = (int)Entry.DecompressedFileSize;                                      byte[] DecompressedBuffer = Decompress(Reader' Entry);                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(DecompressedBuffer);                                      Writer.Close();                                  }                                  else //TypeID should be 14' which means entry isn't compressed.                                  {                                      uint Filesize = Entry.DecompressedFileSize;                                        Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                      Writer.Write(Reader.ReadBytes((int)Filesize));                                      Writer.Close();                                  }                              }                              else if (Entry.Filename.Contains(".po")) //Purchasable Object                              {                                  //int Filesize = Entry.CalculateFileSize();                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".col")) //COLlection                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".hag")) //Group?                              {                                  byte[] DecompressedBuffer = Decompress(Reader' Entry);                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(DecompressedBuffer);                                  Writer.Close();                              }                              else if (Entry.Filename.Contains(".jpg"))                              {                                  uint Filesize = Entry.DecompressedFileSize;                                    Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                                  Writer.Write(Reader.ReadBytes((int)Filesize));                                  Writer.Close();                              }                          }                      }                      else if (m_CurrentArchiveType == ArchiveType.DBPF)                      {                          foreach (DBPFEntry Entry in m_DBPFEntries)                          {                              Reader.BaseStream.Seek(Entry.DataOffset' SeekOrigin.Begin);                              byte[] Data = Reader.ReadBytes((int)Entry.DataSize);                                //NOTE: TypeID and GroupID are the same for all entries' so to differentiate the type'                              //      the header of each file has to be read.                              byte[] HeaderBuf = new byte[2];                              Array.Copy(Data' HeaderBuf' 2);                              string Header = Encoding.ASCII.GetString(HeaderBuf);                                switch (Header)                              {                                  case "XA":                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".xa"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "UT": //UTalk                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".utk"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "WA": //Wav                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".wav"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "TK": //Tracks                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".tkdt"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "BM": //BMP (TSOAudio.dat)                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".bmp"));                                      Writer.Write(Data);                                      Writer.Close();                                                                            break;                                  case "HI": //Hitlist                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".bmp"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  case "# ": //UIScript (TSOAudio.dat)                                      Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".uis"));                                      Writer.Write(Data);                                      Writer.Close();                                        break;                                  default: //MP3 has no fileheader!                                      if (Entry.TypeID != 0x7B1ACFCD)                                      {                                          Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".mp3"));                                          Writer.Write(Data);                                          Writer.Close();                                      }                                        break;                              }                                if (Entry.TypeID == 0x7B1ACFCD) //Unknown                              {                                  Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.InstanceID + ".unknown"));                                  Writer.Write(Data);                                  Writer.Close();                              }                          }                      }                  }                  else if (m_CurrentFile.Contains(".far"))                  {                      foreach(FarEntry Entry in m_FarEntries)                      {                          Reader.BaseStream.Seek((long)Entry.DataOffset' SeekOrigin.Begin);                          byte[] Data = Reader.ReadBytes(Entry.DataLength);                            Writer = new BinaryWriter(File.Create(FBrowserDiag.SelectedPath + "\\" + Entry.Filename));                          Writer.Write(Data);                          Writer.Close();                      }                  }              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,Decompress,The following statement contains a magic number: Reader.ReadBytes(9);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,Decompress,The following statement contains a magic number: if (CompressionID == 0xFB10)              {                  byte[] Dummy = Reader.ReadBytes(3);                  uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                    Decompresser Dec = new Decompresser();                  Dec.CompressedSize = Filesize;                  Dec.DecompressedSize = DecompressedSize;                    return Dec.Decompress(Reader.ReadBytes((int)Filesize));              }              else //The entry wasn't compressed...              {                  Reader.BaseStream.Seek((Reader.BaseStream.Position - 15)' SeekOrigin.Begin);                  return Reader.ReadBytes((int)Entry.DecompressedFileSize);              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,Decompress,The following statement contains a magic number: if (CompressionID == 0xFB10)              {                  byte[] Dummy = Reader.ReadBytes(3);                  uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                    Decompresser Dec = new Decompresser();                  Dec.CompressedSize = Filesize;                  Dec.DecompressedSize = DecompressedSize;                    return Dec.Decompress(Reader.ReadBytes((int)Filesize));              }              else //The entry wasn't compressed...              {                  Reader.BaseStream.Seek((Reader.BaseStream.Position - 15)' SeekOrigin.Begin);                  return Reader.ReadBytes((int)Entry.DecompressedFileSize);              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,Decompress,The following statement contains a magic number: if (CompressionID == 0xFB10)              {                  byte[] Dummy = Reader.ReadBytes(3);                  uint DecompressedSize = (uint)((Dummy[0] << 0x10) | (Dummy[1] << 0x08) | +Dummy[2]);                    Decompresser Dec = new Decompresser();                  Dec.CompressedSize = Filesize;                  Dec.DecompressedSize = DecompressedSize;                    return Dec.Decompress(Reader.ReadBytes((int)Filesize));              }              else //The entry wasn't compressed...              {                  Reader.BaseStream.Seek((Reader.BaseStream.Position - 15)' SeekOrigin.Begin);                  return Reader.ReadBytes((int)Entry.DecompressedFileSize);              }
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(445' 24);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(445' 24);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.openFARArchiveToolStripMenuItem.Size = new System.Drawing.Size(159' 22);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.openFARArchiveToolStripMenuItem.Size = new System.Drawing.Size(159' 22);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractFARArchiveToolStripMenuItem.Size = new System.Drawing.Size(159' 22);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.extractFARArchiveToolStripMenuItem.Size = new System.Drawing.Size(159' 22);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem.Size = new System.Drawing.Size(44' 20);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem1.Size = new System.Drawing.Size(116' 22);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.aboutToolStripMenuItem1.Size = new System.Drawing.Size(116' 22);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstFiles.Location = new System.Drawing.Point(178' 161);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstFiles.Location = new System.Drawing.Point(178' 161);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstFiles.Size = new System.Drawing.Size(255' 238);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LstFiles.Size = new System.Drawing.Size(255' 238);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblFileList.Location = new System.Drawing.Point(175' 141);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblFileList.Location = new System.Drawing.Point(175' 141);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblFileList.Size = new System.Drawing.Size(42' 13);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblFileList.Size = new System.Drawing.Size(42' 13);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.LblFileList.TabIndex = 2;
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(445' 411);
Magic Number,FarExtractor,Form1,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\Form1.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(445' 411);
Magic Number,FarExtractor,HexConverter,C:\repos\Afr0_Project-Dollhouse\Other\tools\FarExtractor\FarExtractor\HexConverter.cs,ByteArrayToHexString,The following statement contains a magic number: int LengthRequired = (ArrayToConvert.Length + Delimiter.Length) * 2;
