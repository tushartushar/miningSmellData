Implementation smell,Namespace,Class,File,Method,Description
Long Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetBitmap,The method has 111 lines of code.
Long Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The method has 177 lines of code.
Long Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The method has 161 lines of code.
Long Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The method has 175 lines of code.
Complex Method,FreeImageAPI.Plugins,LocalPlugin,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,LocalPlugin,Cyclomatic complexity of the method is 16
Complex Method,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanline,Cyclomatic complexity of the method is 21
Complex Method,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanlines,Cyclomatic complexity of the method is 22
Complex Method,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SelectActiveFrame,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,Cyclomatic complexity of the method is 10
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetBitmap,Cyclomatic complexity of the method is 13
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateFromHbitmap,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,Cyclomatic complexity of the method is 10
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,Cyclomatic complexity of the method is 10
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormat,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,Cyclomatic complexity of the method is 40
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,Cyclomatic complexity of the method is 34
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,Cyclomatic complexity of the method is 32
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CloneMetadataEx,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,Cyclomatic complexity of the method is 15
Complex Method,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CheckColorType,Cyclomatic complexity of the method is 13
Complex Method,FreeImageAPI.Metadata,MetadataTag,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MetadataTag.cs,SetArrayValue,Cyclomatic complexity of the method is 9
Complex Method,FreeImageAPI.Metadata,MetadataTag,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MetadataTag.cs,CheckType,Cyclomatic complexity of the method is 16
Long Parameter List,FreeImageAPI.Plugins,LocalPlugin,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,LoadProc,The method has 5 parameters. Parameters: io' handle' page' flags' data
Long Parameter List,FreeImageAPI.Plugins,LocalPlugin,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,SaveProc,The method has 6 parameters. Parameters: io' dib' handle' page' flags' data
Long Parameter List,FreeImageAPI.Plugins,LocalPlugin,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,Read,The method has 5 parameters. Parameters: io' handle' size' count' buffer
Long Parameter List,FreeImageAPI.Plugins,LocalPlugin,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,Write,The method has 5 parameters. Parameters: io' handle' size' count' buffer
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The method has 5 parameters. Parameters: width' height' stride' format' scan0
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The method has 5 parameters. Parameters: width' height' stride' format' bits
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The method has 6 parameters. Parameters: width' height' stride' bpp' type' scan0
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The method has 6 parameters. Parameters: width' height' stride' bpp' type' bits
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,The method has 5 parameters. Parameters: filename' insertPosition' format' loadFlags' saveFlags
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,EnlargeCanvas,The method has 5 parameters. Parameters: left' top' right' bottom' color
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,EnlargeCanvas,The method has 6 parameters. Parameters: left' top' right' bottom' color' options
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetEnlargedInstance,The method has 5 parameters. Parameters: left' top' right' bottom' color
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetEnlargedInstance,The method has 6 parameters. Parameters: left' top' right' bottom' color' options
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,Rotate,The method has 6 parameters. Parameters: angle' xShift' yShift' xOrigin' yOrigin' useMask
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetRotatedInstance,The method has 6 parameters. Parameters: angle' xShift' yShift' xOrigin' yOrigin' useMask
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,JPEGCrop,The method has 6 parameters. Parameters: source' destination' left' top' right' bottom
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetAdjustColorsLookupTable,The method has 5 parameters. Parameters: lookUpTable' brightness' contrast' gamma' invert
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,The method has 5 parameters. Parameters: filename' bitmap' format' loadFlags' saveFlags
Long Parameter List,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,The method has 6 parameters. Parameters: filename' bitmap' insertPosition' format' loadFlags' saveFlags
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Allocate,The method has 6 parameters. Parameters: width' height' bpp' red_mask' green_mask' blue_mask
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateT,The method has 7 parameters. Parameters: type' width' height' bpp' red_mask' green_mask' blue_mask
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateEx,The method has 9 parameters. Parameters: width' height' bpp' color' options' palette' red_mask' green_mask' blue_mask
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateExT,The method has 10 parameters. Parameters: type' width' height' bpp' color' options' palette' red_mask' green_mask' blue_mask
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveToHandle,The method has 5 parameters. Parameters: fif' dib' io' handle' flags
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,RegisterLocalPlugin,The method has 5 parameters. Parameters: proc_address' format' description' extension' regexpr
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,RegisterExternalPlugin,The method has 5 parameters. Parameters: path' format' description' extension' regexpr
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,OpenMultiBitmap,The method has 6 parameters. Parameters: fif' filename' create_new' read_only' keep_cache_in_memory' flags
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The method has 5 parameters. Parameters: dib' quantize' PaletteSize' ReserveSize' ReservePalette
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertFromRawBits,The method has 9 parameters. Parameters: bits' width' height' pitch' bpp' red_mask' green_mask' blue_mask' topdown
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertFromRawBits,The method has 9 parameters. Parameters: bits' width' height' pitch' bpp' red_mask' green_mask' blue_mask' topdown
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertToRawBits,The method has 8 parameters. Parameters: bits' dib' pitch' bpp' red_mask' green_mask' blue_mask' topdown
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertToRawBits,The method has 8 parameters. Parameters: bits' dib' pitch' bpp' red_mask' green_mask' blue_mask' topdown
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,RotateEx,The method has 7 parameters. Parameters: dib' angle' x_shift' y_shift' x_origin' y_origin' use_mask
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,EnlargeCanvas,The method has 7 parameters. Parameters: dib' left' top' right' bottom' color' options
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Copy,The method has 5 parameters. Parameters: dib' left' top' right' bottom
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Paste,The method has 5 parameters. Parameters: dst' src' left' top' alpha
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,JPEGCrop,The method has 6 parameters. Parameters: src_file' dst_file' left' top' right' bottom
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetAdjustColorsLookupTable,The method has 5 parameters. Parameters: lookUpTable' brightness' contrast' gamma' invert
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AdjustColors,The method has 5 parameters. Parameters: dib' brightness' contrast' gamma' invert
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ApplyColorMapping,The method has 6 parameters. Parameters: dib' srccolors' dstcolors' count' ignore_alpha' swap
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ApplyPaletteIndexMapping,The method has 5 parameters. Parameters: dib' srcindices' dstindices' count' swap
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateEx,The method has 6 parameters. Parameters: width' height' bpp' color' options' palette
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateEx,The method has 9 parameters. Parameters: width' height' bpp' color' options' palette' red_mask' green_mask' blue_mask
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateExT,The method has 7 parameters. Parameters: type' width' height' bpp' color' options' palette
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateExT,The method has 10 parameters. Parameters: type' width' height' bpp' color' options' palette' red_mask' green_mask' blue_mask
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertFromRawBits,The method has 10 parameters. Parameters: bits' type' width' height' pitch' bpp' red_mask' green_mask' blue_mask' topdown
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertFromRawBits,The method has 10 parameters. Parameters: bits' type' width' height' pitch' bpp' red_mask' green_mask' blue_mask' topdown
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveEx,The method has 6 parameters. Parameters: dib' filename' format' flags' colorDepth' unloadSource
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveToStream,The method has 5 parameters. Parameters: dib' stream' format' flags' unloadSource
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveToStream,The method has 5 parameters. Parameters: dib' stream' format' flags' colorDepth
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveToStream,The method has 6 parameters. Parameters: dib' stream' format' flags' colorDepth' unloadSource
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,OpenMultiBitmapEx,The method has 5 parameters. Parameters: filename' format' create_new' read_only' keep_cache_in_memory
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,OpenMultiBitmapEx,The method has 6 parameters. Parameters: filename' format' flags' create_new' read_only' keep_cache_in_memory
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The method has 6 parameters. Parameters: format' type' bpp' red_mask' green_mask' blue_mask
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The method has 5 parameters. Parameters: type' bpp' red_mask' green_mask' blue_mask
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The method has 6 parameters. Parameters: dib' conversion' threshold' ditherMethod' quantizationMethod' unloadSource
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The method has 5 parameters. Parameters: dib' quantize' PaletteSize' ReservePalette' minColorDepth
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The method has 5 parameters. Parameters: dib' quantize' PaletteSize' ReservePalette' bpp
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,EnlargeCanvas,The method has 7 parameters. Parameters: dib' left' top' right' bottom' color' options
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateDIBSection,The method has 6 parameters. Parameters: hdc' pbmi' iUsage' ppvBits' hSection' dwOffset
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateDIBitmap,The method has 6 parameters. Parameters: hdc' lpbmih' fdwInit' lpbInit' lpbmi' fuUsage
Long Parameter List,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetDIBits,The method has 7 parameters. Parameters: hdc' hbmp' uStartScan' cScanLines' lpvBits' lpbmi' uUsage
Long Statement,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The length of the statement  "						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK) " is 145.
Long Statement,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The length of the statement  "						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK) " is 145.
Complex Conditional,FreeImageAPI.Plugins,PluginRepository,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\PluginRepository.cs,Plugin,The conditional expression  "plugin.Format.ToLower().Contains(expression) ||  					plugin.RegExpr.ToLower().Contains(expression) ||  					plugin.ValidExtension(expression' StringComparison.CurrentCultureIgnoreCase) ||  					plugin.ValidFilename(expression' StringComparison.CurrentCultureIgnoreCase)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "(forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "(forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "(forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "(forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Resize,The conditional expression  "(str != null) && (min >= 0) && (max >= 0) && (min <= max)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Resize,The conditional expression  "(array != null) && (min >= 0) && (max >= 0) && (min <= max)"  is complex.
Virtual Method Call from Constructor,FreeImageAPI.Plugins,LocalPlugin,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,LocalPlugin,The constructor "LocalPlugin" calls a virtual method "GetImplementedMethods".
Empty Catch Block,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetWrapperVersion,The method has an empty catch block.
Empty Catch Block,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetBitmap,The method has an empty catch block.
Empty Catch Block,FreeImageAPI.IO,fi_handle,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\fi_handle.cs,GetObject,The method has an empty catch block.
Empty Catch Block,FreeImageAPI.IO,fi_handle,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\fi_handle.cs,Dispose,The method has an empty catch block.
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The following statement contains a magic number: dib = FreeImage.Allocate(  				width'  				height'  				24'  				FreeImage.FI_RGBA_RED_MASK'  				FreeImage.FI_RGBA_GREEN_MASK'  				FreeImage.FI_RGBA_BLUE_MASK);
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanline,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: result = new Scanline<FI1BIT>(dib' scanline' width); break;  						case 4u: result = new Scanline<FI4BIT>(dib' scanline' width); break;  						case 8u: result = new Scanline<Byte>(dib' scanline' width); break;  						case 16u:  							if ((RedMask == FreeImage.FI16_555_RED_MASK) &&  								(GreenMask == FreeImage.FI16_555_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_555_BLUE_MASK))  							{  								result = new Scanline<FI16RGB555>(dib' scanline' width);  							}  							else if ((RedMask == FreeImage.FI16_565_RED_MASK) &&  								(GreenMask == FreeImage.FI16_565_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_565_BLUE_MASK))  							{  								result = new Scanline<FI16RGB565>(dib' scanline' width);  							}  							else  							{  								result = new Scanline<UInt16>(dib' scanline' width);  							}  							break;  						case 24u: result = new Scanline<RGBTRIPLE>(dib' scanline' width); break;  						case 32u: result = new Scanline<RGBQUAD>(dib' scanline' width); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: result = new Scanline<FICOMPLEX>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: result = new Scanline<Double>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: result = new Scanline<Single>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT16: result = new Scanline<Int16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT32: result = new Scanline<Int32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: result = new Scanline<FIRGB16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: result = new Scanline<FIRGBA16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: result = new Scanline<FIRGBAF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: result = new Scanline<FIRGBF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: result = new Scanline<UInt16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: result = new Scanline<UInt32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanline,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: result = new Scanline<FI1BIT>(dib' scanline' width); break;  						case 4u: result = new Scanline<FI4BIT>(dib' scanline' width); break;  						case 8u: result = new Scanline<Byte>(dib' scanline' width); break;  						case 16u:  							if ((RedMask == FreeImage.FI16_555_RED_MASK) &&  								(GreenMask == FreeImage.FI16_555_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_555_BLUE_MASK))  							{  								result = new Scanline<FI16RGB555>(dib' scanline' width);  							}  							else if ((RedMask == FreeImage.FI16_565_RED_MASK) &&  								(GreenMask == FreeImage.FI16_565_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_565_BLUE_MASK))  							{  								result = new Scanline<FI16RGB565>(dib' scanline' width);  							}  							else  							{  								result = new Scanline<UInt16>(dib' scanline' width);  							}  							break;  						case 24u: result = new Scanline<RGBTRIPLE>(dib' scanline' width); break;  						case 32u: result = new Scanline<RGBQUAD>(dib' scanline' width); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: result = new Scanline<FICOMPLEX>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: result = new Scanline<Double>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: result = new Scanline<Single>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT16: result = new Scanline<Int16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT32: result = new Scanline<Int32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: result = new Scanline<FIRGB16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: result = new Scanline<FIRGBA16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: result = new Scanline<FIRGBAF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: result = new Scanline<FIRGBF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: result = new Scanline<UInt16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: result = new Scanline<UInt32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanline,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: result = new Scanline<FI1BIT>(dib' scanline' width); break;  						case 4u: result = new Scanline<FI4BIT>(dib' scanline' width); break;  						case 8u: result = new Scanline<Byte>(dib' scanline' width); break;  						case 16u:  							if ((RedMask == FreeImage.FI16_555_RED_MASK) &&  								(GreenMask == FreeImage.FI16_555_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_555_BLUE_MASK))  							{  								result = new Scanline<FI16RGB555>(dib' scanline' width);  							}  							else if ((RedMask == FreeImage.FI16_565_RED_MASK) &&  								(GreenMask == FreeImage.FI16_565_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_565_BLUE_MASK))  							{  								result = new Scanline<FI16RGB565>(dib' scanline' width);  							}  							else  							{  								result = new Scanline<UInt16>(dib' scanline' width);  							}  							break;  						case 24u: result = new Scanline<RGBTRIPLE>(dib' scanline' width); break;  						case 32u: result = new Scanline<RGBQUAD>(dib' scanline' width); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: result = new Scanline<FICOMPLEX>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: result = new Scanline<Double>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: result = new Scanline<Single>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT16: result = new Scanline<Int16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT32: result = new Scanline<Int32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: result = new Scanline<FIRGB16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: result = new Scanline<FIRGBA16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: result = new Scanline<FIRGBAF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: result = new Scanline<FIRGBF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: result = new Scanline<UInt16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: result = new Scanline<UInt32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanline,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: result = new Scanline<FI1BIT>(dib' scanline' width); break;  						case 4u: result = new Scanline<FI4BIT>(dib' scanline' width); break;  						case 8u: result = new Scanline<Byte>(dib' scanline' width); break;  						case 16u:  							if ((RedMask == FreeImage.FI16_555_RED_MASK) &&  								(GreenMask == FreeImage.FI16_555_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_555_BLUE_MASK))  							{  								result = new Scanline<FI16RGB555>(dib' scanline' width);  							}  							else if ((RedMask == FreeImage.FI16_565_RED_MASK) &&  								(GreenMask == FreeImage.FI16_565_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_565_BLUE_MASK))  							{  								result = new Scanline<FI16RGB565>(dib' scanline' width);  							}  							else  							{  								result = new Scanline<UInt16>(dib' scanline' width);  							}  							break;  						case 24u: result = new Scanline<RGBTRIPLE>(dib' scanline' width); break;  						case 32u: result = new Scanline<RGBQUAD>(dib' scanline' width); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: result = new Scanline<FICOMPLEX>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: result = new Scanline<Double>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: result = new Scanline<Single>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT16: result = new Scanline<Int16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT32: result = new Scanline<Int32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: result = new Scanline<FIRGB16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: result = new Scanline<FIRGBA16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: result = new Scanline<FIRGBAF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: result = new Scanline<FIRGBF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: result = new Scanline<UInt16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: result = new Scanline<UInt32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanline,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: result = new Scanline<FI1BIT>(dib' scanline' width); break;  						case 4u: result = new Scanline<FI4BIT>(dib' scanline' width); break;  						case 8u: result = new Scanline<Byte>(dib' scanline' width); break;  						case 16u:  							if ((RedMask == FreeImage.FI16_555_RED_MASK) &&  								(GreenMask == FreeImage.FI16_555_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_555_BLUE_MASK))  							{  								result = new Scanline<FI16RGB555>(dib' scanline' width);  							}  							else if ((RedMask == FreeImage.FI16_565_RED_MASK) &&  								(GreenMask == FreeImage.FI16_565_GREEN_MASK) &&  								(BlueMask == FreeImage.FI16_565_BLUE_MASK))  							{  								result = new Scanline<FI16RGB565>(dib' scanline' width);  							}  							else  							{  								result = new Scanline<UInt16>(dib' scanline' width);  							}  							break;  						case 24u: result = new Scanline<RGBTRIPLE>(dib' scanline' width); break;  						case 32u: result = new Scanline<RGBQUAD>(dib' scanline' width); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: result = new Scanline<FICOMPLEX>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: result = new Scanline<Double>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: result = new Scanline<Single>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT16: result = new Scanline<Int16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_INT32: result = new Scanline<Int32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: result = new Scanline<FIRGB16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: result = new Scanline<FIRGBA16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: result = new Scanline<FIRGBAF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: result = new Scanline<FIRGBF>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: result = new Scanline<UInt16>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: result = new Scanline<UInt32>(dib' scanline' width); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanlines,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: list = new List<Scanline<FI1BIT>>(height); break;  						case 4u: list = new List<Scanline<FI4BIT>>(height); break;  						case 8u: list = new List<Scanline<Byte>>(height); break;  						case 16u:  							if (FreeImage.IsRGB555(dib))  							{  								list = new List<Scanline<FI16RGB555>>(height);  							}  							else if (FreeImage.IsRGB565(dib))  							{  								list = new List<Scanline<FI16RGB565>>(height);  							}  							else  							{  								list = new List<Scanline<UInt16>>(height);  							}  							break;  						case 24u: list = new List<Scanline<RGBTRIPLE>>(height); break;  						case 32u: list = new List<Scanline<RGBQUAD>>(height); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: list = new List<Scanline<FICOMPLEX>>(height); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: list = new List<Scanline<Double>>(height); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: list = new List<Scanline<Single>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT16: list = new List<Scanline<Int16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT32: list = new List<Scanline<Int32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: list = new List<Scanline<FIRGB16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: list = new List<Scanline<FIRGBA16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: list = new List<Scanline<FIRGBAF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: list = new List<Scanline<FIRGBF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: list = new List<Scanline<UInt16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: list = new List<Scanline<UInt32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanlines,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: list = new List<Scanline<FI1BIT>>(height); break;  						case 4u: list = new List<Scanline<FI4BIT>>(height); break;  						case 8u: list = new List<Scanline<Byte>>(height); break;  						case 16u:  							if (FreeImage.IsRGB555(dib))  							{  								list = new List<Scanline<FI16RGB555>>(height);  							}  							else if (FreeImage.IsRGB565(dib))  							{  								list = new List<Scanline<FI16RGB565>>(height);  							}  							else  							{  								list = new List<Scanline<UInt16>>(height);  							}  							break;  						case 24u: list = new List<Scanline<RGBTRIPLE>>(height); break;  						case 32u: list = new List<Scanline<RGBQUAD>>(height); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: list = new List<Scanline<FICOMPLEX>>(height); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: list = new List<Scanline<Double>>(height); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: list = new List<Scanline<Single>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT16: list = new List<Scanline<Int16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT32: list = new List<Scanline<Int32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: list = new List<Scanline<FIRGB16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: list = new List<Scanline<FIRGBA16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: list = new List<Scanline<FIRGBAF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: list = new List<Scanline<FIRGBF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: list = new List<Scanline<UInt16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: list = new List<Scanline<UInt32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanlines,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: list = new List<Scanline<FI1BIT>>(height); break;  						case 4u: list = new List<Scanline<FI4BIT>>(height); break;  						case 8u: list = new List<Scanline<Byte>>(height); break;  						case 16u:  							if (FreeImage.IsRGB555(dib))  							{  								list = new List<Scanline<FI16RGB555>>(height);  							}  							else if (FreeImage.IsRGB565(dib))  							{  								list = new List<Scanline<FI16RGB565>>(height);  							}  							else  							{  								list = new List<Scanline<UInt16>>(height);  							}  							break;  						case 24u: list = new List<Scanline<RGBTRIPLE>>(height); break;  						case 32u: list = new List<Scanline<RGBQUAD>>(height); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: list = new List<Scanline<FICOMPLEX>>(height); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: list = new List<Scanline<Double>>(height); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: list = new List<Scanline<Single>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT16: list = new List<Scanline<Int16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT32: list = new List<Scanline<Int32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: list = new List<Scanline<FIRGB16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: list = new List<Scanline<FIRGBA16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: list = new List<Scanline<FIRGBAF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: list = new List<Scanline<FIRGBF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: list = new List<Scanline<UInt16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: list = new List<Scanline<UInt32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanlines,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: list = new List<Scanline<FI1BIT>>(height); break;  						case 4u: list = new List<Scanline<FI4BIT>>(height); break;  						case 8u: list = new List<Scanline<Byte>>(height); break;  						case 16u:  							if (FreeImage.IsRGB555(dib))  							{  								list = new List<Scanline<FI16RGB555>>(height);  							}  							else if (FreeImage.IsRGB565(dib))  							{  								list = new List<Scanline<FI16RGB565>>(height);  							}  							else  							{  								list = new List<Scanline<UInt16>>(height);  							}  							break;  						case 24u: list = new List<Scanline<RGBTRIPLE>>(height); break;  						case 32u: list = new List<Scanline<RGBQUAD>>(height); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: list = new List<Scanline<FICOMPLEX>>(height); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: list = new List<Scanline<Double>>(height); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: list = new List<Scanline<Single>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT16: list = new List<Scanline<Int16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT32: list = new List<Scanline<Int32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: list = new List<Scanline<FIRGB16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: list = new List<Scanline<FIRGBA16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: list = new List<Scanline<FIRGBAF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: list = new List<Scanline<FIRGBF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: list = new List<Scanline<UInt16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: list = new List<Scanline<UInt32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanlines,The following statement contains a magic number: switch (FreeImage.GetImageType(dib))  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:    					switch (FreeImage.GetBPP(dib))  					{  						case 1u: list = new List<Scanline<FI1BIT>>(height); break;  						case 4u: list = new List<Scanline<FI4BIT>>(height); break;  						case 8u: list = new List<Scanline<Byte>>(height); break;  						case 16u:  							if (FreeImage.IsRGB555(dib))  							{  								list = new List<Scanline<FI16RGB555>>(height);  							}  							else if (FreeImage.IsRGB565(dib))  							{  								list = new List<Scanline<FI16RGB565>>(height);  							}  							else  							{  								list = new List<Scanline<UInt16>>(height);  							}  							break;  						case 24u: list = new List<Scanline<RGBTRIPLE>>(height); break;  						case 32u: list = new List<Scanline<RGBQUAD>>(height); break;  						default: throw new ArgumentException("Color depth is not supported.");  					}  					break;    				case FREE_IMAGE_TYPE.FIT_COMPLEX: list = new List<Scanline<FICOMPLEX>>(height); break;  				case FREE_IMAGE_TYPE.FIT_DOUBLE: list = new List<Scanline<Double>>(height); break;  				case FREE_IMAGE_TYPE.FIT_FLOAT: list = new List<Scanline<Single>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT16: list = new List<Scanline<Int16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_INT32: list = new List<Scanline<Int32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGB16: list = new List<Scanline<FIRGB16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBA16: list = new List<Scanline<FIRGBA16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBAF: list = new List<Scanline<FIRGBAF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_RGBF: list = new List<Scanline<FIRGBF>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT16: list = new List<Scanline<UInt16>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UINT32: list = new List<Scanline<UInt32>>(height); break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  				default: throw new ArgumentException("Type is not supported.");  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following statement contains a magic number: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,Rotate,The following statement contains a magic number: ColorDepth == 4
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,Rotate,The following statement contains a magic number: ColorDepth == 4
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetRotatedInstance,The following statement contains a magic number: ColorDepth == 4
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetRotatedInstance,The following statement contains a magic number: ColorDepth == 4
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetHistogram,The following statement contains a magic number: histogram = new int[256];
Magic Number,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetAdjustColorsLookupTable,The following statement contains a magic number: lookUpTable.Length != 256
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,MemoryArray,The following statement contains a magic number: T[] dummy = new T[2];
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI1BIT)(((baseAddress[index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI1BIT)(((baseAddress[index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI1BIT)(((baseAddress[index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress[index / 8] |= (byte)(1 << (7 - (index % 8)));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress[index / 8] |= (byte)(1 << (7 - (index % 8)));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress[index / 8] |= (byte)(1 << (7 - (index % 8)));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: result = new byte[(length + 7) / 8];
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: result = new byte[(length + 7) / 8];
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 8)) = *((int*)(src + 8));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 8)) = *((int*)(src + 8));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 12)) = *((int*)(src + 12));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 12)) = *((int*)(src + 12));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: dest += 8;
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: src += 8;
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: (len & 8) != 0
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: dest += 4;
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: src += 4;
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: (len & 4) != 0
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: dest += 2;
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: src += 2;
Magic Number,FreeImageAPI,MemoryArray<T>,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: (len & 2) != 0
Magic Number,FreeImageAPI,Palette,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\Palette.cs,Palette,The following statement contains a magic number: FreeImage.GetBPP(dib) > 8u
Magic Number,FreeImageAPI,Palette,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\Palette.cs,Colorize,The following statement contains a magic number: Colorize(color' 0.5d);
Magic Number,FreeImageAPI,Palette,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\Palette.cs,Colorize,The following statement contains a magic number: r = (255 - red) / (length - splitSize);
Magic Number,FreeImageAPI,Palette,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\Palette.cs,Colorize,The following statement contains a magic number: g = (255 - green) / (length - splitSize);
Magic Number,FreeImageAPI,Palette,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\Palette.cs,Colorize,The following statement contains a magic number: b = (255 - blue) / (length - splitSize);
Magic Number,FreeImageAPI,FI16RGB555,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) +  				(((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB555,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) +  				(((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB555,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) +  				(((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB555,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) +  				(((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB555,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) +  				(((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB555,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) +  				(((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB565,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) +  				(((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB565,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) +  				(((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB565,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) +  				(((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB565,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) +  				(((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB565,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) +  				(((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));
Magic Number,FreeImageAPI,FI16RGB565,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)(  				(((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) +  				(((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) +  				(((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: int maxDen = (Int32.MaxValue / (int)value) - 2;
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: maxDen = maxDen < 10000 ? maxDen : 10000;
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: maxDen = maxDen < 10000 ? maxDen : 10000;
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: Math.Abs(((decimal)numerator / (decimal)denominator) - value) > 0.0001m
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: Math.Abs(((decimal)numerator / (decimal)denominator) - value) > 0.0001m
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,GetDigits,The following statement contains a magic number: value *= 10;
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,CreateContinuedFraction,The following statement contains a magic number: decimal epsilon = 0.0000001m;
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,ApproximateFraction,The following statement contains a magic number: mul *= 10;
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,ApproximateFraction,The following statement contains a magic number: digits <= 9
Magic Number,FreeImageAPI,FIRational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,ApproximateFraction,The following statement contains a magic number: int numerator = (int)Math.Floor(value * (decimal)i + 0.5m);
Magic Number,FreeImageAPI,FIRGB16,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGB16.cs,FIRGB16,The following statement contains a magic number: red = (ushort)(color.R << 8);
Magic Number,FreeImageAPI,FIRGB16,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGB16.cs,FIRGB16,The following statement contains a magic number: green = (ushort)(color.G << 8);
Magic Number,FreeImageAPI,FIRGB16,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGB16.cs,FIRGB16,The following statement contains a magic number: blue = (ushort)(color.B << 8);
Magic Number,FreeImageAPI,FIRGBA16,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBA16.cs,FIRGBA16,The following statement contains a magic number: red = (ushort)(color.R << 8);
Magic Number,FreeImageAPI,FIRGBA16,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBA16.cs,FIRGBA16,The following statement contains a magic number: green = (ushort)(color.G << 8);
Magic Number,FreeImageAPI,FIRGBA16,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBA16.cs,FIRGBA16,The following statement contains a magic number: blue = (ushort)(color.B << 8);
Magic Number,FreeImageAPI,FIRGBA16,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBA16.cs,FIRGBA16,The following statement contains a magic number: alpha = (ushort)(color.A << 8);
Magic Number,FreeImageAPI,FIRGBAF,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBAF.cs,FIRGBAF,The following statement contains a magic number: red = (float)color.R / 255f;
Magic Number,FreeImageAPI,FIRGBAF,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBAF.cs,FIRGBAF,The following statement contains a magic number: green = (float)color.G / 255f;
Magic Number,FreeImageAPI,FIRGBAF,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBAF.cs,FIRGBAF,The following statement contains a magic number: blue = (float)color.B / 255f;
Magic Number,FreeImageAPI,FIRGBAF,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBAF.cs,FIRGBAF,The following statement contains a magic number: alpha = (float)color.A / 255f;
Magic Number,FreeImageAPI,FIRGBF,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBF.cs,FIRGBF,The following statement contains a magic number: red = (float)color.R / 255f;
Magic Number,FreeImageAPI,FIRGBF,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBF.cs,FIRGBF,The following statement contains a magic number: green = (float)color.G / 255f;
Magic Number,FreeImageAPI,FIRGBF,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBF.cs,FIRGBF,The following statement contains a magic number: blue = (float)color.B / 255f;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateEx,The following statement contains a magic number: (palette != null) && (bpp <= 8) && (palette.Length < (1 << bpp))
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateExT,The following statement contains a magic number: (palette != null) && (bpp <= 8) && (palette.Length < (1 << bpp))
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetBitmap,The following statement contains a magic number: (format == PixelFormat.Undefined) && (GetBPP(dib) == 16u)
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,LoadMultiBitmapFromStream,The following statement contains a magic number: const int blockSize = 1024;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetResolutionX,The following statement contains a magic number: return (uint)(0.5d + 0.0254d * GetDotsPerMeterX(dib));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetResolutionX,The following statement contains a magic number: return (uint)(0.5d + 0.0254d * GetDotsPerMeterX(dib));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetResolutionY,The following statement contains a magic number: return (uint)(0.5d + 0.0254d * GetDotsPerMeterY(dib));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetResolutionY,The following statement contains a magic number: return (uint)(0.5d + 0.0254d * GetDotsPerMeterY(dib));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SetResolutionX,The following statement contains a magic number: SetDotsPerMeterX(dib' (uint)((double)res / 0.0254d + 0.5d));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SetResolutionX,The following statement contains a magic number: SetDotsPerMeterX(dib' (uint)((double)res / 0.0254d + 0.5d));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SetResolutionY,The following statement contains a magic number: SetDotsPerMeterY(dib' (uint)((double)res / 0.0254d + 0.5d));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SetResolutionY,The following statement contains a magic number: SetDotsPerMeterY(dib' (uint)((double)res / 0.0254d + 0.5d));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,IsGreyscaleImage,The following statement contains a magic number: switch (bpp)  			{  				case 1:  				case 4:  				case 8:  					RGBQUAD* palette = (RGBQUAD*)GetPalette(dib);  					uint paletteLength = GetColorsUsed(dib);  					for (int i = 0; i < paletteLength; i++)  					{  						if (palette[i].rgbRed != palette[i].rgbGreen ||  							palette[i].rgbRed != palette[i].rgbBlue)  						{  							result = false;  							break;  						}  					}  					break;  				default:  					result = false;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,IsGreyscaleImage,The following statement contains a magic number: switch (bpp)  			{  				case 1:  				case 4:  				case 8:  					RGBQUAD* palette = (RGBQUAD*)GetPalette(dib);  					uint paletteLength = GetColorsUsed(dib);  					for (int i = 0; i < paletteLength; i++)  					{  						if (palette[i].rgbRed != palette[i].rgbGreen ||  							palette[i].rgbRed != palette[i].rgbBlue)  						{  							result = false;  							break;  						}  					}  					break;  				default:  					result = false;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:  						result = PixelFormat.Format1bppIndexed;  						break;  					case 4:  						result = PixelFormat.Format4bppIndexed;  						break;  					case 8:  						result = PixelFormat.Format8bppIndexed;  						break;  					case 16:  						if ((GetBlueMask(dib) == FI16_565_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_565_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_565_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb565;  						}  						if ((GetBlueMask(dib) == FI16_555_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_555_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_555_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb555;  						}  						break;  					case 24:  						result = PixelFormat.Format24bppRgb;  						break;  					case 32:  						result = PixelFormat.Format32bppArgb;  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:  						result = PixelFormat.Format1bppIndexed;  						break;  					case 4:  						result = PixelFormat.Format4bppIndexed;  						break;  					case 8:  						result = PixelFormat.Format8bppIndexed;  						break;  					case 16:  						if ((GetBlueMask(dib) == FI16_565_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_565_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_565_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb565;  						}  						if ((GetBlueMask(dib) == FI16_555_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_555_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_555_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb555;  						}  						break;  					case 24:  						result = PixelFormat.Format24bppRgb;  						break;  					case 32:  						result = PixelFormat.Format32bppArgb;  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:  						result = PixelFormat.Format1bppIndexed;  						break;  					case 4:  						result = PixelFormat.Format4bppIndexed;  						break;  					case 8:  						result = PixelFormat.Format8bppIndexed;  						break;  					case 16:  						if ((GetBlueMask(dib) == FI16_565_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_565_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_565_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb565;  						}  						if ((GetBlueMask(dib) == FI16_555_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_555_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_555_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb555;  						}  						break;  					case 24:  						result = PixelFormat.Format24bppRgb;  						break;  					case 32:  						result = PixelFormat.Format32bppArgb;  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:  						result = PixelFormat.Format1bppIndexed;  						break;  					case 4:  						result = PixelFormat.Format4bppIndexed;  						break;  					case 8:  						result = PixelFormat.Format8bppIndexed;  						break;  					case 16:  						if ((GetBlueMask(dib) == FI16_565_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_565_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_565_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb565;  						}  						if ((GetBlueMask(dib) == FI16_555_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_555_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_555_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb555;  						}  						break;  					case 24:  						result = PixelFormat.Format24bppRgb;  						break;  					case 32:  						result = PixelFormat.Format32bppArgb;  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:  						result = PixelFormat.Format1bppIndexed;  						break;  					case 4:  						result = PixelFormat.Format4bppIndexed;  						break;  					case 8:  						result = PixelFormat.Format8bppIndexed;  						break;  					case 16:  						if ((GetBlueMask(dib) == FI16_565_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_565_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_565_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb565;  						}  						if ((GetBlueMask(dib) == FI16_555_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_555_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_555_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb555;  						}  						break;  					case 24:  						result = PixelFormat.Format24bppRgb;  						break;  					case 32:  						result = PixelFormat.Format32bppArgb;  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type)  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:  					switch (bpp)  					{  						case 1:  						case 4:  						case 8:  							result = true;  							break;  						case 16:  							result = true;  							red_mask = FI16_555_RED_MASK;  							green_mask = FI16_555_GREEN_MASK;  							blue_mask = FI16_555_BLUE_MASK;  							break;  						case 24:  						case 32:  							result = true;  							red_mask = FI_RGBA_RED_MASK;  							green_mask = FI_RGBA_GREEN_MASK;  							blue_mask = FI_RGBA_BLUE_MASK;  							break;  					}  					break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  					break;  				default:  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type)  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:  					switch (bpp)  					{  						case 1:  						case 4:  						case 8:  							result = true;  							break;  						case 16:  							result = true;  							red_mask = FI16_555_RED_MASK;  							green_mask = FI16_555_GREEN_MASK;  							blue_mask = FI16_555_BLUE_MASK;  							break;  						case 24:  						case 32:  							result = true;  							red_mask = FI_RGBA_RED_MASK;  							green_mask = FI_RGBA_GREEN_MASK;  							blue_mask = FI_RGBA_BLUE_MASK;  							break;  					}  					break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  					break;  				default:  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type)  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:  					switch (bpp)  					{  						case 1:  						case 4:  						case 8:  							result = true;  							break;  						case 16:  							result = true;  							red_mask = FI16_555_RED_MASK;  							green_mask = FI16_555_GREEN_MASK;  							blue_mask = FI16_555_BLUE_MASK;  							break;  						case 24:  						case 32:  							result = true;  							red_mask = FI_RGBA_RED_MASK;  							green_mask = FI_RGBA_GREEN_MASK;  							blue_mask = FI_RGBA_BLUE_MASK;  							break;  					}  					break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  					break;  				default:  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type)  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:  					switch (bpp)  					{  						case 1:  						case 4:  						case 8:  							result = true;  							break;  						case 16:  							result = true;  							red_mask = FI16_555_RED_MASK;  							green_mask = FI16_555_GREEN_MASK;  							blue_mask = FI16_555_BLUE_MASK;  							break;  						case 24:  						case 32:  							result = true;  							red_mask = FI_RGBA_RED_MASK;  							green_mask = FI_RGBA_GREEN_MASK;  							blue_mask = FI_RGBA_BLUE_MASK;  							break;  					}  					break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  					break;  				default:  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type)  			{  				case FREE_IMAGE_TYPE.FIT_BITMAP:  					switch (bpp)  					{  						case 1:  						case 4:  						case 8:  							result = true;  							break;  						case 16:  							result = true;  							red_mask = FI16_555_RED_MASK;  							green_mask = FI16_555_GREEN_MASK;  							blue_mask = FI16_555_BLUE_MASK;  							break;  						case 24:  						case 32:  							result = true;  							red_mask = FI_RGBA_RED_MASK;  							green_mask = FI_RGBA_GREEN_MASK;  							blue_mask = FI_RGBA_BLUE_MASK;  							break;  					}  					break;  				case FREE_IMAGE_TYPE.FIT_UNKNOWN:  					break;  				default:  					result = true;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp)  				{  					case 32:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 24:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 16:  						short* sPtr1' sPtr2;  						short mask = (short)(GetRedMask(dib1) | GetGreenMask(dib1) | GetBlueMask(dib1));  						if (mask == -1)  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								if (!CompareMemory(sPtr1' sPtr1' line))  								{  									return false;  								}  							}  						}  						else  						{  							for (int i = 0; i < height; i++)  							{  								sPtr1 = (short*)GetScanLine(dib1' i);  								sPtr2 = (short*)GetScanLine(dib2' i);  								for (int x = 0; x < width; x++)  								{  									if ((sPtr1[x] & mask) != (sPtr2[x] & mask))  									{  										return false;  									}  								}  							}  						}  						break;  					case 8:  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (!CompareMemory(ptr1' ptr2' line))  							{  								return false;  							}  						}  						break;  					case 4:  						fullBytes = (int)width / 2;  						shift = (width % 2) == 0 ? 8 : 4;  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					case 1:  						fullBytes = (int)width / 8;  						shift = 8 - ((int)width % 8);  						for (int i = 0; i < height; i++)  						{  							ptr1 = (byte*)GetScanLine(dib1' i);  							ptr2 = (byte*)GetScanLine(dib2' i);  							if (fullBytes != 0)  							{  								if (!CompareMemory(ptr1' ptr2' fullBytes))  								{  									return false;  								}  								ptr1 += fullBytes;  								ptr2 += fullBytes;  							}  							if (shift != 8)  							{  								if ((ptr1[0] >> shift) != (ptr2[0] >> shift))  								{  									return false;  								}  							}  						}  						break;  					default:  						throw new NotSupportedException("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth(  				dib'  				conversion'  				128'  				FREE_IMAGE_DITHER.FID_FS'  				FREE_IMAGE_QUANTIZE.FIQ_WUQUANT'  				false);
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth(  				dib'  				conversion'  				128'  				FREE_IMAGE_DITHER.FID_FS'  				FREE_IMAGE_QUANTIZE.FIQ_WUQUANT'  				unloadSource);
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth(  				dib'  				conversion'  				128'  				ditherMethod'  				FREE_IMAGE_QUANTIZE.FIQ_WUQUANT'  				false);
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth(  				dib'  				conversion'  				128'  				FREE_IMAGE_DITHER.FID_FS'  				quantizationMethod'  				false);
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth(  				dib'  				conversion'  				128'  				ditherMethod'  				FREE_IMAGE_QUANTIZE.FIQ_WUQUANT'  				unloadSource);
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth(  				dib'  				conversion'  				128'  				FREE_IMAGE_DITHER.FID_FS'  				quantizationMethod'  				unloadSource);
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: bpp = 8;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: PaletteSize >= 256
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: bpp == 8
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang)  				{  					case 90:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						for (int y = 0; y < width; y++)  						{  							yOrg = height - 1;  							for (int x = 0; x < height; x++' yOrg--)  							{  								index = src[yOrg][y];  								dst[y][x] = index;  							}  						}  						break;  					case 180:  						result = Allocate(width' height' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);    						yOrg = height - 1;  						for (int y = 0; y < height; y++' yOrg--)  						{  							xOrg = width - 1;  							for (int x = 0; x < width; x++' xOrg--)  							{  								index = src[yOrg][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 270:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						xOrg = width - 1;  						for (int y = 0; y < width; y++' xOrg--)  						{  							for (int x = 0; x < height; x++)  							{  								index = src[x][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 0:  					case 360:  						result = Clone(dib);  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang)  				{  					case 90:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						for (int y = 0; y < width; y++)  						{  							yOrg = height - 1;  							for (int x = 0; x < height; x++' yOrg--)  							{  								index = src[yOrg][y];  								dst[y][x] = index;  							}  						}  						break;  					case 180:  						result = Allocate(width' height' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);    						yOrg = height - 1;  						for (int y = 0; y < height; y++' yOrg--)  						{  							xOrg = width - 1;  							for (int x = 0; x < width; x++' xOrg--)  							{  								index = src[yOrg][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 270:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						xOrg = width - 1;  						for (int y = 0; y < width; y++' xOrg--)  						{  							for (int x = 0; x < height; x++)  							{  								index = src[x][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 0:  					case 360:  						result = Clone(dib);  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang)  				{  					case 90:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						for (int y = 0; y < width; y++)  						{  							yOrg = height - 1;  							for (int x = 0; x < height; x++' yOrg--)  							{  								index = src[yOrg][y];  								dst[y][x] = index;  							}  						}  						break;  					case 180:  						result = Allocate(width' height' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);    						yOrg = height - 1;  						for (int y = 0; y < height; y++' yOrg--)  						{  							xOrg = width - 1;  							for (int x = 0; x < width; x++' xOrg--)  							{  								index = src[yOrg][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 270:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						xOrg = width - 1;  						for (int y = 0; y < width; y++' xOrg--)  						{  							for (int x = 0; x < height; x++)  							{  								index = src[x][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 0:  					case 360:  						result = Clone(dib);  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang)  				{  					case 90:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						for (int y = 0; y < width; y++)  						{  							yOrg = height - 1;  							for (int x = 0; x < height; x++' yOrg--)  							{  								index = src[yOrg][y];  								dst[y][x] = index;  							}  						}  						break;  					case 180:  						result = Allocate(width' height' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);    						yOrg = height - 1;  						for (int y = 0; y < height; y++' yOrg--)  						{  							xOrg = width - 1;  							for (int x = 0; x < width; x++' xOrg--)  							{  								index = src[yOrg][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 270:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						xOrg = width - 1;  						for (int y = 0; y < width; y++' xOrg--)  						{  							for (int x = 0; x < height; x++)  							{  								index = src[x][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 0:  					case 360:  						result = Clone(dib);  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang)  				{  					case 90:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						for (int y = 0; y < width; y++)  						{  							yOrg = height - 1;  							for (int x = 0; x < height; x++' yOrg--)  							{  								index = src[yOrg][y];  								dst[y][x] = index;  							}  						}  						break;  					case 180:  						result = Allocate(width' height' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);    						yOrg = height - 1;  						for (int y = 0; y < height; y++' yOrg--)  						{  							xOrg = width - 1;  							for (int x = 0; x < width; x++' xOrg--)  							{  								index = src[yOrg][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 270:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						xOrg = width - 1;  						for (int y = 0; y < width; y++' xOrg--)  						{  							for (int x = 0; x < height; x++)  							{  								index = src[x][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 0:  					case 360:  						result = Clone(dib);  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang)  				{  					case 90:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						for (int y = 0; y < width; y++)  						{  							yOrg = height - 1;  							for (int x = 0; x < height; x++' yOrg--)  							{  								index = src[yOrg][y];  								dst[y][x] = index;  							}  						}  						break;  					case 180:  						result = Allocate(width' height' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);    						yOrg = height - 1;  						for (int y = 0; y < height; y++' yOrg--)  						{  							xOrg = width - 1;  							for (int x = 0; x < width; x++' xOrg--)  							{  								index = src[yOrg][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 270:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						xOrg = width - 1;  						for (int y = 0; y < width; y++' xOrg--)  						{  							for (int x = 0; x < height; x++)  							{  								index = src[x][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 0:  					case 360:  						result = Clone(dib);  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang)  				{  					case 90:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						for (int y = 0; y < width; y++)  						{  							yOrg = height - 1;  							for (int x = 0; x < height; x++' yOrg--)  							{  								index = src[yOrg][y];  								dst[y][x] = index;  							}  						}  						break;  					case 180:  						result = Allocate(width' height' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);    						yOrg = height - 1;  						for (int y = 0; y < height; y++' yOrg--)  						{  							xOrg = width - 1;  							for (int x = 0; x < width; x++' xOrg--)  							{  								index = src[yOrg][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 270:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						xOrg = width - 1;  						for (int y = 0; y < width; y++' xOrg--)  						{  							for (int x = 0; x < height; x++)  							{  								index = src[x][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 0:  					case 360:  						result = Clone(dib);  						break;  				}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: (GetImageType(dib) == FREE_IMAGE_TYPE.FIT_BITMAP) &&  				(GetBPP(dib) == 4) &&  				((ang % 90) == 0)
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: (GetImageType(dib) == FREE_IMAGE_TYPE.FIT_BITMAP) &&  				(GetBPP(dib) == 4) &&  				((ang % 90) == 0)
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateShrunkenPaletteLUT,The following statement contains a magic number: color.rgbReserved = 255;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateShrunkenPaletteLUT,The following statement contains a magic number: (!dib.IsNull) && (GetImageType(dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP(dib) <= 8)
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 8)) = *((int*)(src + 8));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 8)) = *((int*)(src + 8));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 12)) = *((int*)(src + 12));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 12)) = *((int*)(src + 12));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: dest += 8;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: src += 8;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: (len & 8) != 0
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: dest += 4;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: src += 4;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: (len & 4) != 0
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: dest += 2;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: src += 2;
Magic Number,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: (len & 2) != 0
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: int maxDen = (Int32.MaxValue / (int)value) - 2;
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: maxDen = maxDen < 10000 ? maxDen : 10000;
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: maxDen = maxDen < 10000 ? maxDen : 10000;
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: Math.Abs(((decimal)numerator / (decimal)denominator) - value) > 0.0001m
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: Math.Abs(((decimal)numerator / (decimal)denominator) - value) > 0.0001m
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,GetDigits,The following statement contains a magic number: value *= 10;
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,CreateContinuedFraction,The following statement contains a magic number: decimal epsilon = 0.0000001m;
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,ApproximateFraction,The following statement contains a magic number: mul *= 10;
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,ApproximateFraction,The following statement contains a magic number: digits <= 9
Magic Number,FreeImageAPI,FIURational,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,ApproximateFraction,The following statement contains a magic number: uint numerator = (uint)Math.Floor(value * (decimal)u + 0.5m);
Magic Number,FreeImageAPI.IO,StreamWrapper,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\StreamWrapper.cs,Seek,The following statement contains a magic number: byte[] buffer = new byte[1024];
Magic Number,FreeImageAPI.IO,StreamWrapper,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\StreamWrapper.cs,Fill,The following statement contains a magic number: byte[] buffer = new byte[1024];
Duplicate Code,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The method contains a code clone-set at the following line numbers (starting from the method definition): ((115' 136)' (140' 161))
Missing Default,FreeImageAPI,FreeImageBitmap,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following switch statement is missing a default case: switch (rotateFlipType)  			{  				case RotateFlipType.RotateNoneFlipX:    					FreeImage.FlipHorizontal(dib);  					break;    				case RotateFlipType.RotateNoneFlipY:    					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.RotateNoneFlipXY:    					FreeImage.FlipHorizontal(dib);  					FreeImage.FlipVertical(dib);  					break;    				case RotateFlipType.Rotate90FlipNone:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					break;    				case RotateFlipType.Rotate90FlipX:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					break;    				case RotateFlipType.Rotate90FlipY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate90FlipXY:    					newDib = (bpp == 4u) ? FreeImage.Rotate4bit(dib' 90d) : FreeImage.Rotate(dib' 90d);  					FreeImage.FlipHorizontal(newDib);  					FreeImage.FlipVertical(newDib);  					break;    				case RotateFlipType.Rotate180FlipXY:  					newDib = FreeImage.Clone(dib);  					break;  			}
Missing Default,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following switch statement is missing a default case: switch (GetBPP(dib))  				{  					case 1:  						result = PixelFormat.Format1bppIndexed;  						break;  					case 4:  						result = PixelFormat.Format4bppIndexed;  						break;  					case 8:  						result = PixelFormat.Format8bppIndexed;  						break;  					case 16:  						if ((GetBlueMask(dib) == FI16_565_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_565_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_565_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb565;  						}  						if ((GetBlueMask(dib) == FI16_555_BLUE_MASK) &&  							(GetGreenMask(dib) == FI16_555_GREEN_MASK) &&  							(GetRedMask(dib) == FI16_555_RED_MASK))  						{  							result = PixelFormat.Format16bppRgb555;  						}  						break;  					case 24:  						result = PixelFormat.Format24bppRgb;  						break;  					case 32:  						result = PixelFormat.Format32bppArgb;  						break;  				}
Missing Default,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following switch statement is missing a default case: switch (format)  			{  				case PixelFormat.Format1bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 1;  					result = true;  					break;  				case PixelFormat.Format4bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 4;  					result = true;  					break;  				case PixelFormat.Format8bppIndexed:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 8;  					result = true;  					break;  				case PixelFormat.Format16bppRgb565:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_565_RED_MASK;  					green_mask = FI16_565_GREEN_MASK;  					blue_mask = FI16_565_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppRgb555:  				case PixelFormat.Format16bppArgb1555:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 16;  					red_mask = FI16_555_RED_MASK;  					green_mask = FI16_555_GREEN_MASK;  					blue_mask = FI16_555_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format24bppRgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 24;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format32bppRgb:  				case PixelFormat.Format32bppArgb:  				case PixelFormat.Format32bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_BITMAP;  					bpp = 32;  					red_mask = FI_RGBA_RED_MASK;  					green_mask = FI_RGBA_GREEN_MASK;  					blue_mask = FI_RGBA_BLUE_MASK;  					result = true;  					break;  				case PixelFormat.Format16bppGrayScale:  					type = FREE_IMAGE_TYPE.FIT_UINT16;  					bpp = 16;  					result = true;  					break;  				case PixelFormat.Format48bppRgb:  					type = FREE_IMAGE_TYPE.FIT_RGB16;  					bpp = 48;  					result = true;  					break;  				case PixelFormat.Format64bppArgb:  				case PixelFormat.Format64bppPArgb:  					type = FREE_IMAGE_TYPE.FIT_RGBA16;  					bpp = 64;  					result = true;  					break;  			}
Missing Default,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following switch statement is missing a default case: switch (bpp)  					{  						case 1:  						case 4:  						case 8:  							result = true;  							break;  						case 16:  							result = true;  							red_mask = FI16_555_RED_MASK;  							green_mask = FI16_555_GREEN_MASK;  							blue_mask = FI16_555_BLUE_MASK;  							break;  						case 24:  						case 32:  							result = true;  							red_mask = FI_RGBA_RED_MASK;  							green_mask = FI_RGBA_GREEN_MASK;  							blue_mask = FI_RGBA_BLUE_MASK;  							break;  					}
Missing Default,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following switch statement is missing a default case: switch (GetBPP(dib))  				{  					case 1:    						result = 1;  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							break;  						}    						if ((*(byte*)GetScanLine(dib' 0) & 0x80) == 0)  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) > 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						else  						{  							for (int y = 0; y < height; y++)  							{  								byte* scanline = (byte*)GetScanLine(dib' y);  								int mask = 0x80;  								for (int x = 0; x < width; x++)  								{  									if ((scanline[x / 8] & mask) == 0)  									{  										return 2;  									}  									mask = (mask == 0x1) ? 0x80 : (mask >> 1);  								}  							}  						}  						break;    					case 4:    						bitArray = new BitArray(0x10);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							bool top = true;  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								if (top)  								{  									hashcode = lut[scanline[x / 2] >> 4];  								}  								else  								{  									hashcode = lut[scanline[x / 2] & 0xF];  								}  								top = !top;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 8:    						bitArray = new BitArray(0x100);  						lut = CreateShrunkenPaletteLUT(dib' out uniquePalEnts);  						if (uniquePalEnts == 1)  						{  							result = 1;  							break;  						}    						for (int y = 0; (y < height) && (result < uniquePalEnts); y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; (x < width) && (result < uniquePalEnts); x++)  							{  								hashcode = lut[scanline[x]];  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 16:    						bitArray = new BitArray(0x10000);    						for (int y = 0; y < height; y++)  						{  							short* scanline = (short*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 24:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							byte* scanline = (byte*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline += 3)  							{  								hashcode = *((int*)scanline) & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;    					case 32:    						bitArray = new BitArray(0x1000000);    						for (int y = 0; y < height; y++)  						{  							int* scanline = (int*)GetScanLine(dib' y);  							for (int x = 0; x < width; x++' scanline++)  							{  								hashcode = *scanline & 0x00FFFFFF;  								if (!bitArray[hashcode])  								{  									bitArray[hashcode] = true;  									result++;  								}  							}  						}  						break;  				}
Missing Default,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following switch statement is missing a default case: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF)  				{  					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Threshold(dib' threshold);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Threshold(dib' threshold);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:    						if (bpp != 1)  						{  							if (forceGreyscale)  							{  								result = Dither(dib' ditherMethod);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 2' null' 1);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								result = Dither(dib' ditherMethod);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:    						if (bpp != 4)  						{  							// Special case when 1bpp and FIC_PALETTE  							if (forceGreyscale ||  								((bpp == 1) && (GetColorType(dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE)))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantizeEx(dibTemp' quantizationMethod' 16' null' 4);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) ||  								(reorderPalette && isGreyscale))  							{  								dibTemp = ConvertToGreyscale(dib);  								result = ConvertTo4Bits(dibTemp);  								Unload(dibTemp);  							}  						}    						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:    						if (bpp != 8)  						{  							if (forceGreyscale)  							{  								result = ConvertToGreyscale(dib);  							}  							else  							{  								dibTemp = ConvertTo24Bits(dib);  								result = ColorQuantize(dibTemp' quantizationMethod);  								Unload(dibTemp);  							}  						}  						else  						{  							bool isGreyscale = IsGreyscaleImage(dib);  							if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale))  							{  								result = ConvertToGreyscale(dib);  							}  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits555(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_555_RED_MASK || GetGreenMask(dib) != FI16_555_GREEN_MASK || GetBlueMask(dib) != FI16_555_BLUE_MASK)  						{  							result = ConvertTo16Bits555(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo16Bits565(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 16 || GetRedMask(dib) != FI16_565_RED_MASK || GetGreenMask(dib) != FI16_565_GREEN_MASK || GetBlueMask(dib) != FI16_565_BLUE_MASK)  						{  							result = ConvertTo16Bits565(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo24Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 24)  						{  							result = ConvertTo24Bits(dib);  						}  						break;    					case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:    						if (forceGreyscale)  						{  							dibTemp = ConvertToGreyscale(dib);  							result = ConvertTo32Bits(dibTemp);  							Unload(dibTemp);  						}  						else if (bpp != 32)  						{  							result = ConvertTo32Bits(dib);  						}  						break;  				}
Missing Default,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following switch statement is missing a default case: switch (ang)  				{  					case 90:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						for (int y = 0; y < width; y++)  						{  							yOrg = height - 1;  							for (int x = 0; x < height; x++' yOrg--)  							{  								index = src[yOrg][y];  								dst[y][x] = index;  							}  						}  						break;  					case 180:  						result = Allocate(width' height' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);    						yOrg = height - 1;  						for (int y = 0; y < height; y++' yOrg--)  						{  							xOrg = width - 1;  							for (int x = 0; x < width; x++' xOrg--)  							{  								index = src[yOrg][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 270:  						result = Allocate(height' width' 4' 0' 0' 0);  						if (result.IsNull)  						{  							break;  						}  						CopyPalette(dib' result);  						src = Get04BitScanlines(dib);  						dst = Get04BitScanlines(result);  						xOrg = width - 1;  						for (int y = 0; y < width; y++' xOrg--)  						{  							for (int x = 0; x < height; x++)  							{  								index = src[x][xOrg];  								dst[y][x] = index;  							}  						}  						break;  					case 0:  					case 360:  						result = Clone(dib);  						break;  				}
Missing Default,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following switch statement is missing a default case: switch (bpp)  			{  				case 1:  					result = 4;  					break;  				case 4:  					result = 8;  					break;  				case 8:  					result = 16;  					break;  				case 16:  					result = 24;  					break;  				case 24:  					result = 32;  					break;  			}
Missing Default,FreeImageAPI,FreeImage,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following switch statement is missing a default case: switch (bpp)  			{  				case 32:  					result = 24;  					break;  				case 24:  					result = 16;  					break;  				case 16:  					result = 8;  					break;  				case 8:  					result = 4;  					break;  				case 4:  					result = 1;  					break;  			}
Missing Default,FreeImageAPI.Metadata,MetadataTag,D:\research\architectureSmells\repos\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MetadataTag.cs,CheckType,The following switch statement is missing a default case: switch (type)  				{  					case FREE_IMAGE_MDTYPE.FIDT_ASCII:  						return dataType == typeof(string);  					case FREE_IMAGE_MDTYPE.FIDT_BYTE:  						return dataType == typeof(byte);  					case FREE_IMAGE_MDTYPE.FIDT_DOUBLE:  						return dataType == typeof(double);  					case FREE_IMAGE_MDTYPE.FIDT_FLOAT:  						return dataType == typeof(float);  					case FREE_IMAGE_MDTYPE.FIDT_IFD:  						return dataType == typeof(uint);  					case FREE_IMAGE_MDTYPE.FIDT_LONG:  						return dataType == typeof(uint);  					case FREE_IMAGE_MDTYPE.FIDT_NOTYPE:  						return false;  					case FREE_IMAGE_MDTYPE.FIDT_PALETTE:  						return dataType == typeof(RGBQUAD);  					case FREE_IMAGE_MDTYPE.FIDT_RATIONAL:  						return dataType == typeof(FIURational);  					case FREE_IMAGE_MDTYPE.FIDT_SBYTE:  						return dataType == typeof(sbyte);  					case FREE_IMAGE_MDTYPE.FIDT_SHORT:  						return dataType == typeof(ushort);  					case FREE_IMAGE_MDTYPE.FIDT_SLONG:  						return dataType == typeof(int);  					case FREE_IMAGE_MDTYPE.FIDT_SRATIONAL:  						return dataType == typeof(FIRational);  					case FREE_IMAGE_MDTYPE.FIDT_SSHORT:  						return dataType == typeof(short);  					case FREE_IMAGE_MDTYPE.FIDT_UNDEFINED:  						return dataType == typeof(byte);  				}
