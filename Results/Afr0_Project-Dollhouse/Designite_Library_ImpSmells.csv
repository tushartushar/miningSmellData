Implementation smell,Namespace,Class,File,Method,Description
Long Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The method has 139 lines of code.
Long Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The method has 128 lines of code.
Long Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The method has 126 lines of code.
Complex Method,FreeImageAPI.Plugins,LocalPlugin,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,LocalPlugin,Cyclomatic complexity of the method is 16
Complex Method,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanline,Cyclomatic complexity of the method is 39
Complex Method,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanlines,Cyclomatic complexity of the method is 40
Complex Method,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,Cyclomatic complexity of the method is 29
Complex Method,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SelectActiveFrame,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,Cyclomatic complexity of the method is 10
Complex Method,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetBitmap,Cyclomatic complexity of the method is 15
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateFromHbitmap,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,IsGreyscaleImage,Cyclomatic complexity of the method is 13
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,Cyclomatic complexity of the method is 23
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,Cyclomatic complexity of the method is 66
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,Cyclomatic complexity of the method is 59
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,Cyclomatic complexity of the method is 58
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,Cyclomatic complexity of the method is 48
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CloneMetadataEx,Cyclomatic complexity of the method is 11
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,Cyclomatic complexity of the method is 41
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,Cyclomatic complexity of the method is 15
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,Cyclomatic complexity of the method is 15
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,PrepareBitmapColorDepth,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,Cyclomatic complexity of the method is 8
Complex Method,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CheckColorType,Cyclomatic complexity of the method is 39
Complex Method,FreeImageAPI.IO,StreamWrapper,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\StreamWrapper.cs,Seek,Cyclomatic complexity of the method is 15
Complex Method,FreeImageAPI.Metadata,MetadataTag,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MetadataTag.cs,SetArrayValue,Cyclomatic complexity of the method is 9
Long Parameter List,FreeImageAPI.Plugins,LocalPlugin,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,LoadProc,The method has 5 parameters.
Long Parameter List,FreeImageAPI.Plugins,LocalPlugin,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,SaveProc,The method has 6 parameters.
Long Parameter List,FreeImageAPI.Plugins,LocalPlugin,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,Read,The method has 5 parameters.
Long Parameter List,FreeImageAPI.Plugins,LocalPlugin,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,Write,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,EnlargeCanvas,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,EnlargeCanvas,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetEnlargedInstance,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetEnlargedInstance,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,Rotate,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetRotatedInstance,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,JPEGCrop,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetAdjustColorsLookupTable,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Allocate,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateT,The method has 7 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateEx,The method has 9 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateExT,The method has 10 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveToHandle,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,RegisterLocalPlugin,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,RegisterExternalPlugin,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,OpenMultiBitmap,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertFromRawBits,The method has 9 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertFromRawBits,The method has 9 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertToRawBits,The method has 8 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertToRawBits,The method has 8 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,RotateEx,The method has 7 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,EnlargeCanvas,The method has 7 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Copy,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Paste,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,JPEGCrop,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetAdjustColorsLookupTable,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AdjustColors,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ApplyColorMapping,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ApplyPaletteIndexMapping,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateEx,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateEx,The method has 9 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateExT,The method has 7 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateExT,The method has 10 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertFromRawBits,The method has 10 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertFromRawBits,The method has 10 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveEx,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveToStream,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveToStream,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveToStream,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,OpenMultiBitmapEx,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,OpenMultiBitmapEx,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The method has 5 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,EnlargeCanvas,The method has 7 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateDIBSection,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateDIBitmap,The method has 6 parameters.
Long Parameter List,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetDIBits,The method has 7 parameters.
Long Statement,FreeImageAPI.Plugins,PluginRepository,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\PluginRepository.cs,Plugin,The length of the statement  "		if (plugin.Format.ToLower ().Contains (expression) || plugin.RegExpr.ToLower ().Contains (expression) || plugin.ValidExtension (expression' StringComparison.CurrentCultureIgnoreCase) || plugin.ValidFilename (expression' StringComparison.CurrentCultureIgnoreCase)) { " is 265.
Long Statement,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanline,The length of the statement  "			if ((RedMask == FreeImage.FI16_555_RED_MASK) && (GreenMask == FreeImage.FI16_555_GREEN_MASK) && (BlueMask == FreeImage.FI16_555_BLUE_MASK)) { " is 141.
Long Statement,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetScanline,The length of the statement  "			} else if ((RedMask == FreeImage.FI16_565_RED_MASK) && (GreenMask == FreeImage.FI16_565_GREEN_MASK) && (BlueMask == FreeImage.FI16_565_BLUE_MASK)) { " is 148.
Long Statement,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,The length of the statement  "	SaveAdd (saveInformation.filename' bitmap' saveInformation.format' saveInformation.loadFlags' saveInformation.saveFlags); " is 121.
Long Statement,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,The length of the statement  "	SaveAdd (saveInformation.filename' bitmap' insertPosition' saveInformation.format' saveInformation.loadFlags' saveInformation.saveFlags); " is 137.
Long Statement,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SaveAdd,The length of the statement  "	SaveAdd (filename' this' insertPosition' FREE_IMAGE_FORMAT.FIF_UNKNOWN' FREE_IMAGE_LOAD_FLAGS.DEFAULT' FREE_IMAGE_SAVE_FLAGS.DEFAULT); " is 134.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetWrapperVersion,The length of the statement  "			object[] attributes = Assembly.GetAssembly (typeof(FreeImage)).GetCustomAttributes (typeof(AssemblyFileVersionAttribute)' false); " is 129.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,IsAvailable,The length of the statement  "		return (nativeVersion.Major >= wrapperVersion.Major) && (nativeVersion.Minor >= wrapperVersion.Minor) && (nativeVersion.Build >= wrapperVersion.Build); " is 151.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateEx,The length of the statement  "			return AllocateEx (width' height' bpp' handle.AddrOfPinnedObject ()' options' palette' red_mask' green_mask' blue_mask); " is 120.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateExT,The length of the statement  "			return AllocateExT (type' width' height' bpp' handle.AddrOfPinnedObject ()' options' palette' red_mask' green_mask' blue_mask); " is 127.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateFromBitmap,The length of the statement  "	BitmapData data = bitmap.LockBits (new Rectangle (0' 0' bitmap.Width' bitmap.Height)' ImageLockMode.ReadOnly' bitmap.PixelFormat); " is 130.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateFromBitmap,The length of the statement  "	FIBITMAP result = ConvertFromRawBits (data.Scan0' type' data.Width' data.Height' data.Stride' bpp' red_mask' green_mask' blue_mask' true); " is 138.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveEx,The length of the statement  "	return SaveEx (ref dib' filename' FREE_IMAGE_FORMAT.FIF_UNKNOWN' FREE_IMAGE_SAVE_FLAGS.DEFAULT' FREE_IMAGE_COLOR_DEPTH.FICD_AUTO' false); " is 137.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveEx,The length of the statement  "	return SaveEx (ref dib' filename' FREE_IMAGE_FORMAT.FIF_UNKNOWN' FREE_IMAGE_SAVE_FLAGS.DEFAULT' FREE_IMAGE_COLOR_DEPTH.FICD_AUTO' unloadSource); " is 144.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveEx,The length of the statement  "	return SaveEx (ref dib' filename' FREE_IMAGE_FORMAT.FIF_UNKNOWN' flags' FREE_IMAGE_COLOR_DEPTH.FICD_AUTO' unloadSource); " is 120.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveEx,The length of the statement  "	return SaveEx (ref dib' filename' format' FREE_IMAGE_SAVE_FLAGS.DEFAULT' FREE_IMAGE_COLOR_DEPTH.FICD_AUTO' unloadSource); " is 121.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,SaveToStream,The length of the statement  "	return SaveToStream (ref dib' stream' format' FREE_IMAGE_SAVE_FLAGS.DEFAULT' FREE_IMAGE_COLOR_DEPTH.FICD_AUTO' unloadSource); " is 125.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,OpenMultiBitmapEx,The length of the statement  "	return OpenMultiBitmapEx (filename' ref format' FREE_IMAGE_LOAD_FLAGS.DEFAULT' create_new' read_only' keep_cache_in_memory); " is 124.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,OpenMultiBitmapEx,The length of the statement  "	return OpenMultiBitmapEx (filename' ref format' FREE_IMAGE_LOAD_FLAGS.DEFAULT' create_new' read_only' keep_cache_in_memory); " is 124.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The length of the statement  "			if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) { " is 138.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The length of the statement  "			if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) { " is 138.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,IsRGB555,The length of the statement  "	return ((GetRedMask (dib) == FI16_555_RED_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetBlueMask (dib) == FI16_555_BLUE_MASK)); " is 141.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,IsRGB565,The length of the statement  "	return ((GetRedMask (dib) == FI16_565_RED_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetBlueMask (dib) == FI16_565_BLUE_MASK)); " is 141.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The length of the statement  "	return ConvertColorDepth (dib' conversion' 128' FREE_IMAGE_DITHER.FID_FS' FREE_IMAGE_QUANTIZE.FIQ_WUQUANT' unloadSource); " is 121.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The length of the statement  "	return ConvertColorDepth (dib' conversion' threshold' FREE_IMAGE_DITHER.FID_FS' FREE_IMAGE_QUANTIZE.FIQ_WUQUANT' false); " is 120.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The length of the statement  "	return ConvertColorDepth (dib' conversion' threshold' FREE_IMAGE_DITHER.FID_FS' FREE_IMAGE_QUANTIZE.FIQ_WUQUANT' unloadSource); " is 127.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The length of the statement  "			} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) { " is 152.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The length of the statement  "			} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) { " is 152.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,PrepareBitmapColorDepth,The length of the statement  "				throw new ArgumentException ("FreeImage\n\nFreeImage Library plugin " + GetFormatFromFIF (format) + " is unable to write images with a color depth of " + targetBpp + " bpp."); " is 175.
Long Statement,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorToString,The length of the statement  "	return string.Format (System.Globalization.CultureInfo.CurrentCulture' "{{Name={0}' ARGB=({1}' {2}' {3}' {4})}}"' new object[] { " is 128.
Complex Conditional,FreeImageAPI.Plugins,PluginRepository,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\PluginRepository.cs,Plugin,The conditional expression  "plugin.Format.ToLower ().Contains (expression) || plugin.RegExpr.ToLower ().Contains (expression) || plugin.ValidExtension (expression' StringComparison.CurrentCultureIgnoreCase) || plugin.ValidFilename (expression' StringComparison.CurrentCultureIgnoreCase)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "(forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "(forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "(forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "(forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The conditional expression  "bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Resize,The conditional expression  "(str != null) && (min >= 0) && (max >= 0) && (min <= max)"  is complex.
Complex Conditional,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Resize,The conditional expression  "(array != null) && (min >= 0) && (max >= 0) && (min <= max)"  is complex.
Virtual Method Call from Constructor,FreeImageAPI.Plugins,LocalPlugin,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\LocalPlugin.cs,LocalPlugin,The constructor "LocalPlugin" calls a virtual method "GetImplementedMethods".
Empty Catch Block,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetWrapperVersion,The method has an empty catch block.
Empty Catch Block,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetBitmap,The method has an empty catch block.
Empty Catch Block,FreeImageAPI.IO,fi_handle,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\fi_handle.cs,GetObject,The method has an empty catch block.
Empty Catch Block,FreeImageAPI.IO,fi_handle,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\fi_handle.cs,Dispose,The method has an empty catch block.
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,FreeImageBitmap,The following statement contains a magic number: dib = FreeImage.Allocate (width' height' 24' FreeImage.FI_RGBA_RED_MASK' FreeImage.FI_RGBA_GREEN_MASK' FreeImage.FI_RGBA_BLUE_MASK);  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq;  		if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  			throw new Exception ("FreeImage.GetPixelColor() failed");  		}  		return rgbq.Color;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		byte index;  		if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  			throw new Exception ("FreeImage.GetPixelIndex() failed");  		}  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		return palette [index].Color;  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq;  		if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  			throw new Exception ("FreeImage.GetPixelColor() failed");  		}  		return rgbq.Color;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		byte index;  		if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  			throw new Exception ("FreeImage.GetPixelIndex() failed");  		}  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		return palette [index].Color;  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq;  		if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  			throw new Exception ("FreeImage.GetPixelColor() failed");  		}  		return rgbq.Color;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		byte index;  		if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  			throw new Exception ("FreeImage.GetPixelIndex() failed");  		}  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		return palette [index].Color;  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq;  		if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  			throw new Exception ("FreeImage.GetPixelColor() failed");  		}  		return rgbq.Color;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		byte index;  		if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  			throw new Exception ("FreeImage.GetPixelIndex() failed");  		}  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		return palette [index].Color;  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq;  		if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  			throw new Exception ("FreeImage.GetPixelColor() failed");  		}  		return rgbq.Color;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		byte index;  		if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  			throw new Exception ("FreeImage.GetPixelIndex() failed");  		}  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		return palette [index].Color;  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq;  	if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  		throw new Exception ("FreeImage.GetPixelColor() failed");  	}  	return rgbq.Color;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	byte index;  	if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  		throw new Exception ("FreeImage.GetPixelIndex() failed");  	}  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	return palette [index].Color;  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq;  	if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  		throw new Exception ("FreeImage.GetPixelColor() failed");  	}  	return rgbq.Color;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	byte index;  	if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  		throw new Exception ("FreeImage.GetPixelIndex() failed");  	}  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	return palette [index].Color;  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq;  	if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  		throw new Exception ("FreeImage.GetPixelColor() failed");  	}  	return rgbq.Color;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	byte index;  	if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  		throw new Exception ("FreeImage.GetPixelIndex() failed");  	}  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	return palette [index].Color;  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq;  	if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  		throw new Exception ("FreeImage.GetPixelColor() failed");  	}  	return rgbq.Color;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	byte index;  	if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  		throw new Exception ("FreeImage.GetPixelIndex() failed");  	}  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	return palette [index].Color;  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq;  	if (!FreeImage.GetPixelColor (dib' (uint)x' (uint)y' out rgbq)) {  		throw new Exception ("FreeImage.GetPixelColor() failed");  	}  	return rgbq.Color;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	byte index;  	if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  		throw new Exception ("FreeImage.GetPixelIndex() failed");  	}  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	return palette [index].Color;  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	byte index;  	if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  		throw new Exception ("FreeImage.GetPixelIndex() failed");  	}  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	return palette [index].Color;  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetPixel,The following statement contains a magic number: if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	byte index;  	if (!FreeImage.GetPixelIndex (dib' (uint)x' (uint)y' out index)) {  		throw new Exception ("FreeImage.GetPixelIndex() failed");  	}  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	return palette [index].Color;  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq = color;  		if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  			throw new Exception ("FreeImage.SetPixelColor() failed");  		}  		return;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		uint colorsUsed = FreeImage.GetColorsUsed (dib);  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		for (int i = 0; i < colorsUsed; i++) {  			if (palette [i].Color == color) {  				byte index = (byte)i;  				if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  					throw new Exception ("FreeImage.SetPixelIndex() failed");  				}  				return;  			}  		}  		throw new ArgumentOutOfRangeException ("color");  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq = color;  		if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  			throw new Exception ("FreeImage.SetPixelColor() failed");  		}  		return;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		uint colorsUsed = FreeImage.GetColorsUsed (dib);  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		for (int i = 0; i < colorsUsed; i++) {  			if (palette [i].Color == color) {  				byte index = (byte)i;  				if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  					throw new Exception ("FreeImage.SetPixelIndex() failed");  				}  				return;  			}  		}  		throw new ArgumentOutOfRangeException ("color");  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq = color;  		if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  			throw new Exception ("FreeImage.SetPixelColor() failed");  		}  		return;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		uint colorsUsed = FreeImage.GetColorsUsed (dib);  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		for (int i = 0; i < colorsUsed; i++) {  			if (palette [i].Color == color) {  				byte index = (byte)i;  				if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  					throw new Exception ("FreeImage.SetPixelIndex() failed");  				}  				return;  			}  		}  		throw new ArgumentOutOfRangeException ("color");  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq = color;  		if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  			throw new Exception ("FreeImage.SetPixelColor() failed");  		}  		return;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		uint colorsUsed = FreeImage.GetColorsUsed (dib);  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		for (int i = 0; i < colorsUsed; i++) {  			if (palette [i].Color == color) {  				byte index = (byte)i;  				if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  					throw new Exception ("FreeImage.SetPixelIndex() failed");  				}  				return;  			}  		}  		throw new ArgumentOutOfRangeException ("color");  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (FreeImage.GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  		RGBQUAD rgbq = color;  		if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  			throw new Exception ("FreeImage.SetPixelColor() failed");  		}  		return;  	} else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  		uint colorsUsed = FreeImage.GetColorsUsed (dib);  		RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  		for (int i = 0; i < colorsUsed; i++) {  			if (palette [i].Color == color) {  				byte index = (byte)i;  				if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  					throw new Exception ("FreeImage.SetPixelIndex() failed");  				}  				return;  			}  		}  		throw new ArgumentOutOfRangeException ("color");  	}  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq = color;  	if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  		throw new Exception ("FreeImage.SetPixelColor() failed");  	}  	return;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	uint colorsUsed = FreeImage.GetColorsUsed (dib);  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	for (int i = 0; i < colorsUsed; i++) {  		if (palette [i].Color == color) {  			byte index = (byte)i;  			if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  				throw new Exception ("FreeImage.SetPixelIndex() failed");  			}  			return;  		}  	}  	throw new ArgumentOutOfRangeException ("color");  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq = color;  	if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  		throw new Exception ("FreeImage.SetPixelColor() failed");  	}  	return;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	uint colorsUsed = FreeImage.GetColorsUsed (dib);  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	for (int i = 0; i < colorsUsed; i++) {  		if (palette [i].Color == color) {  			byte index = (byte)i;  			if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  				throw new Exception ("FreeImage.SetPixelIndex() failed");  			}  			return;  		}  	}  	throw new ArgumentOutOfRangeException ("color");  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq = color;  	if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  		throw new Exception ("FreeImage.SetPixelColor() failed");  	}  	return;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	uint colorsUsed = FreeImage.GetColorsUsed (dib);  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	for (int i = 0; i < colorsUsed; i++) {  		if (palette [i].Color == color) {  			byte index = (byte)i;  			if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  				throw new Exception ("FreeImage.SetPixelIndex() failed");  			}  			return;  		}  	}  	throw new ArgumentOutOfRangeException ("color");  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq = color;  	if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  		throw new Exception ("FreeImage.SetPixelColor() failed");  	}  	return;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	uint colorsUsed = FreeImage.GetColorsUsed (dib);  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	for (int i = 0; i < colorsUsed; i++) {  		if (palette [i].Color == color) {  			byte index = (byte)i;  			if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  				throw new Exception ("FreeImage.SetPixelIndex() failed");  			}  			return;  		}  	}  	throw new ArgumentOutOfRangeException ("color");  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (ColorDepth == 16 || ColorDepth == 24 || ColorDepth == 32) {  	RGBQUAD rgbq = color;  	if (!FreeImage.SetPixelColor (dib' (uint)x' (uint)y' ref rgbq)) {  		throw new Exception ("FreeImage.SetPixelColor() failed");  	}  	return;  } else if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	uint colorsUsed = FreeImage.GetColorsUsed (dib);  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	for (int i = 0; i < colorsUsed; i++) {  		if (palette [i].Color == color) {  			byte index = (byte)i;  			if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  				throw new Exception ("FreeImage.SetPixelIndex() failed");  			}  			return;  		}  	}  	throw new ArgumentOutOfRangeException ("color");  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	uint colorsUsed = FreeImage.GetColorsUsed (dib);  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	for (int i = 0; i < colorsUsed; i++) {  		if (palette [i].Color == color) {  			byte index = (byte)i;  			if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  				throw new Exception ("FreeImage.SetPixelIndex() failed");  			}  			return;  		}  	}  	throw new ArgumentOutOfRangeException ("color");  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,SetPixel,The following statement contains a magic number: if (ColorDepth == 1 || ColorDepth == 4 || ColorDepth == 8) {  	uint colorsUsed = FreeImage.GetColorsUsed (dib);  	RGBQUAD* palette = (RGBQUAD*)FreeImage.GetPalette (dib);  	for (int i = 0; i < colorsUsed; i++) {  		if (palette [i].Color == color) {  			byte index = (byte)i;  			if (!FreeImage.SetPixelIndex (dib' (uint)x' (uint)y' ref index)) {  				throw new Exception ("FreeImage.SetPixelIndex() failed");  			}  			return;  		}  	}  	throw new ArgumentOutOfRangeException ("color");  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,Rotate,The following statement contains a magic number: if (ColorDepth == 4) {  	result = ReplaceDib (FreeImage.Rotate4bit (dib' angle));  } else {  	result = ReplaceDib (FreeImage.Rotate (dib' angle));  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,Rotate,The following statement contains a magic number: if (ColorDepth == 4) {  	result = ReplaceDib (FreeImage.Rotate4bit (dib' angle));  } else {  	result = ReplaceDib (FreeImage.Rotate (dib' angle' backgroundColor));  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetRotatedInstance,The following statement contains a magic number: if (ColorDepth == 4) {  	newDib = FreeImage.Rotate4bit (dib' angle);  } else {  	newDib = FreeImage.Rotate (dib' angle' backgroundColor);  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetRotatedInstance,The following statement contains a magic number: if (ColorDepth == 4) {  	newDib = FreeImage.Rotate4bit (dib' angle);  } else {  	newDib = FreeImage.Rotate (dib' angle);  }  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetHistogram,The following statement contains a magic number: histogram = new int[256];  
Magic Number,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,GetAdjustColorsLookupTable,The following statement contains a magic number: if (lookUpTable.Length != 256) {  	throw new ArgumentException ("lookUpTable");  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isOneBit) {  	return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  } else if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isOneBit) {  	return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  } else if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isOneBit) {  	return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  } else if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isOneBit) {  	return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  } else if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isOneBit) {  	return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  } else if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isOneBit) {  	return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  } else if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isOneBit) {  	return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  } else if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI1BIT)(((baseAddress [index / 8] & ((1 << (7 - (index % 8))))) == 0) ? 0 : 1);  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: if (isFourBit) {  	return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  } else {  	CopyMemory (ptr' baseAddress + (index * size)' size);  	return buffer [0];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,GetValueInternal,The following statement contains a magic number: return (T)(object)(FI4BIT)(((index % 2) == 0) ? (baseAddress [index / 2] >> 4) : (baseAddress [index / 2] & 0x0F));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isOneBit) {  	if ((FI1BIT)(object)value != 0) {  		baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  	} else {  		baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  	}  } else if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((FI1BIT)(object)value != 0) {  	baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  } else {  	baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((FI1BIT)(object)value != 0) {  	baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  } else {  	baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((FI1BIT)(object)value != 0) {  	baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  } else {  	baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((FI1BIT)(object)value != 0) {  	baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  } else {  	baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((FI1BIT)(object)value != 0) {  	baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  } else {  	baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((FI1BIT)(object)value != 0) {  	baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  } else {  	baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 8] |= (byte)(1 << (7 - (index % 8)));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 8] &= (byte)(~(1 << (7 - (index % 8))));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if (isFourBit) {  	if ((index % 2) == 0) {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  	} else {  		baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  	}  } else {  	buffer [0] = value;  	CopyMemory (baseAddress + (index * size)' ptr' size);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((index % 2) == 0) {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  } else {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((index % 2) == 0) {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  } else {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((index % 2) == 0) {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  } else {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((index % 2) == 0) {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  } else {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((index % 2) == 0) {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  } else {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: if ((index % 2) == 0) {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  } else {  	baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0x0F) | ((FI4BIT)(object)value << 4));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,SetValueInternal,The following statement contains a magic number: baseAddress [index / 2] = (byte)((baseAddress [index / 2] & 0xF0) | ((FI4BIT)(object)value & 0x0F));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: if (isOneBit) {  	result = new byte[(length + 7) / 8];  } else if (isFourBit) {  	result = new byte[(length + 3) / 4];  } else {  	result = new byte[size * length];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: if (isOneBit) {  	result = new byte[(length + 7) / 8];  } else if (isFourBit) {  	result = new byte[(length + 3) / 4];  } else {  	result = new byte[size * length];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: if (isOneBit) {  	result = new byte[(length + 7) / 8];  } else if (isFourBit) {  	result = new byte[(length + 3) / 4];  } else {  	result = new byte[size * length];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: if (isOneBit) {  	result = new byte[(length + 7) / 8];  } else if (isFourBit) {  	result = new byte[(length + 3) / 4];  } else {  	result = new byte[size * length];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: result = new byte[(length + 7) / 8];  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: result = new byte[(length + 7) / 8];  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: if (isFourBit) {  	result = new byte[(length + 3) / 4];  } else {  	result = new byte[size * length];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: if (isFourBit) {  	result = new byte[(length + 3) / 4];  } else {  	result = new byte[size * length];  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: result = new byte[(length + 3) / 4];  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,ToByteArray,The following statement contains a magic number: result = new byte[(length + 3) / 4];  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 8)) = *((int*)(src + 8));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 8)) = *((int*)(src + 8));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 12)) = *((int*)(src + 12));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 12)) = *((int*)(src + 12));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: dest += 8;  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: src += 8;  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 4) != 0) {  	*((int*)dest) = *((int*)src);  	dest += 4;  	src += 4;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 4) != 0) {  	*((int*)dest) = *((int*)src);  	dest += 4;  	src += 4;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 4) != 0) {  	*((int*)dest) = *((int*)src);  	dest += 4;  	src += 4;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: dest += 4;  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: src += 4;  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 2) != 0) {  	*((short*)dest) = *((short*)src);  	dest += 2;  	src += 2;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 2) != 0) {  	*((short*)dest) = *((short*)src);  	dest += 2;  	src += 2;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: if ((len & 2) != 0) {  	*((short*)dest) = *((short*)src);  	dest += 2;  	src += 2;  }  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: dest += 2;  
Magic Number,FreeImageAPI,MemoryArray,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MemoryArray.cs,CopyMemory,The following statement contains a magic number: src += 2;  
Magic Number,FreeImageAPI,Palette,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\Palette.cs,Colorize,The following statement contains a magic number: r = (255 - red) / (length - splitSize);  
Magic Number,FreeImageAPI,Palette,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\Palette.cs,Colorize,The following statement contains a magic number: g = (255 - green) / (length - splitSize);  
Magic Number,FreeImageAPI,Palette,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\Palette.cs,Colorize,The following statement contains a magic number: b = (255 - blue) / (length - splitSize);  
Magic Number,FreeImageAPI,FI16RGB555,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) + (((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB555,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) + (((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB555,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) + (((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB555,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) + (((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB555,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) + (((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB555,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB555.cs,FI16RGB555,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_555_RED_SHIFT) + (((color.G * 31) / 255) << FreeImage.FI16_555_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_555_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB565,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) + (((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB565,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) + (((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB565,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) + (((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB565,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) + (((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB565,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) + (((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FI16RGB565,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FI16RGB565.cs,FI16RGB565,The following statement contains a magic number: value = (ushort)((((color.R * 31) / 255) << FreeImage.FI16_565_RED_SHIFT) + (((color.G * 63) / 255) << FreeImage.FI16_565_GREEN_SHIFT) + (((color.B * 31) / 255) << FreeImage.FI16_565_BLUE_SHIFT));  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: try {  	int sign = value < 0 ? -1 : 1;  	value = Math.Abs (value);  	try {  		int[] contFract = CreateContinuedFraction (value);  		CreateFraction (contFract' out numerator' out denominator);  		Normalize ();  	} catch {  		numerator = 0;  		denominator = 1;  	}  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		int maxDen = (Int32.MaxValue / (int)value) - 2;  		maxDen = maxDen < 10000 ? maxDen : 10000;  		ApproximateFraction (value' maxDen' out numerator' out denominator);  		Normalize ();  		if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  			throw new OverflowException ("Unable to convert value into a fraction");  		}  	}  	numerator *= sign;  	Normalize ();  } catch (Exception ex) {  	throw new OverflowException ("Unable to calculate fraction."' ex);  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: try {  	int sign = value < 0 ? -1 : 1;  	value = Math.Abs (value);  	try {  		int[] contFract = CreateContinuedFraction (value);  		CreateFraction (contFract' out numerator' out denominator);  		Normalize ();  	} catch {  		numerator = 0;  		denominator = 1;  	}  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		int maxDen = (Int32.MaxValue / (int)value) - 2;  		maxDen = maxDen < 10000 ? maxDen : 10000;  		ApproximateFraction (value' maxDen' out numerator' out denominator);  		Normalize ();  		if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  			throw new OverflowException ("Unable to convert value into a fraction");  		}  	}  	numerator *= sign;  	Normalize ();  } catch (Exception ex) {  	throw new OverflowException ("Unable to calculate fraction."' ex);  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: try {  	int sign = value < 0 ? -1 : 1;  	value = Math.Abs (value);  	try {  		int[] contFract = CreateContinuedFraction (value);  		CreateFraction (contFract' out numerator' out denominator);  		Normalize ();  	} catch {  		numerator = 0;  		denominator = 1;  	}  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		int maxDen = (Int32.MaxValue / (int)value) - 2;  		maxDen = maxDen < 10000 ? maxDen : 10000;  		ApproximateFraction (value' maxDen' out numerator' out denominator);  		Normalize ();  		if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  			throw new OverflowException ("Unable to convert value into a fraction");  		}  	}  	numerator *= sign;  	Normalize ();  } catch (Exception ex) {  	throw new OverflowException ("Unable to calculate fraction."' ex);  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  	int maxDen = (Int32.MaxValue / (int)value) - 2;  	maxDen = maxDen < 10000 ? maxDen : 10000;  	ApproximateFraction (value' maxDen' out numerator' out denominator);  	Normalize ();  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		throw new OverflowException ("Unable to convert value into a fraction");  	}  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  	int maxDen = (Int32.MaxValue / (int)value) - 2;  	maxDen = maxDen < 10000 ? maxDen : 10000;  	ApproximateFraction (value' maxDen' out numerator' out denominator);  	Normalize ();  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		throw new OverflowException ("Unable to convert value into a fraction");  	}  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  	int maxDen = (Int32.MaxValue / (int)value) - 2;  	maxDen = maxDen < 10000 ? maxDen : 10000;  	ApproximateFraction (value' maxDen' out numerator' out denominator);  	Normalize ();  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		throw new OverflowException ("Unable to convert value into a fraction");  	}  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: maxDen = maxDen < 10000 ? maxDen : 10000;  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,FIRational,The following statement contains a magic number: maxDen = maxDen < 10000 ? maxDen : 10000;  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,GetDigits,The following statement contains a magic number: while (value != 0) {  	value *= 10;  	value -= decimal.Truncate (value);  	result++;  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,GetDigits,The following statement contains a magic number: value *= 10;  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,ApproximateFraction,The following statement contains a magic number: if (digits <= 9) {  	int mul = 1;  	for (int i = 1; i <= digits; i++) {  		mul *= 10;  	}  	if (mul <= maxDen) {  		num = (int)(value * mul);  		den = mul;  		return;  	}  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,ApproximateFraction,The following statement contains a magic number: if (digits <= 9) {  	int mul = 1;  	for (int i = 1; i <= digits; i++) {  		mul *= 10;  	}  	if (mul <= maxDen) {  		num = (int)(value * mul);  		den = mul;  		return;  	}  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,ApproximateFraction,The following statement contains a magic number: for (int i = 1; i <= digits; i++) {  	mul *= 10;  }  
Magic Number,FreeImageAPI,FIRational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRational.cs,ApproximateFraction,The following statement contains a magic number: mul *= 10;  
Magic Number,FreeImageAPI,FIRGB16,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGB16.cs,FIRGB16,The following statement contains a magic number: red = (ushort)(color.R << 8);  
Magic Number,FreeImageAPI,FIRGB16,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGB16.cs,FIRGB16,The following statement contains a magic number: green = (ushort)(color.G << 8);  
Magic Number,FreeImageAPI,FIRGB16,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGB16.cs,FIRGB16,The following statement contains a magic number: blue = (ushort)(color.B << 8);  
Magic Number,FreeImageAPI,FIRGBA16,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBA16.cs,FIRGBA16,The following statement contains a magic number: red = (ushort)(color.R << 8);  
Magic Number,FreeImageAPI,FIRGBA16,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBA16.cs,FIRGBA16,The following statement contains a magic number: green = (ushort)(color.G << 8);  
Magic Number,FreeImageAPI,FIRGBA16,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBA16.cs,FIRGBA16,The following statement contains a magic number: blue = (ushort)(color.B << 8);  
Magic Number,FreeImageAPI,FIRGBA16,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIRGBA16.cs,FIRGBA16,The following statement contains a magic number: alpha = (ushort)(color.A << 8);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateEx,The following statement contains a magic number: if ((palette != null) && (bpp <= 8) && (palette.Length < (1 << bpp)))  	return FIBITMAP.Zero;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,AllocateExT,The following statement contains a magic number: if ((palette != null) && (bpp <= 8) && (palette.Length < (1 << bpp)))  	return FIBITMAP.Zero;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,IsGreyscaleImage,The following statement contains a magic number: switch (bpp) {  case 1:  case 4:  case 8:  	RGBQUAD* palette = (RGBQUAD*)GetPalette (dib);  	uint paletteLength = GetColorsUsed (dib);  	for (int i = 0; i < paletteLength; i++) {  		if (palette [i].rgbRed != palette [i].rgbGreen || palette [i].rgbRed != palette [i].rgbBlue) {  			result = false;  			break;  		}  	}  	break;  default:  	result = false;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,IsGreyscaleImage,The following statement contains a magic number: switch (bpp) {  case 1:  case 4:  case 8:  	RGBQUAD* palette = (RGBQUAD*)GetPalette (dib);  	uint paletteLength = GetColorsUsed (dib);  	for (int i = 0; i < paletteLength; i++) {  		if (palette [i].rgbRed != palette [i].rgbGreen || palette [i].rgbRed != palette [i].rgbBlue) {  			result = false;  			break;  		}  	}  	break;  default:  	result = false;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (GetBPP (dib)) {  	case 1:  		result = PixelFormat.Format1bppIndexed;  		break;  	case 4:  		result = PixelFormat.Format4bppIndexed;  		break;  	case 8:  		result = PixelFormat.Format8bppIndexed;  		break;  	case 16:  		if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  			result = PixelFormat.Format16bppRgb565;  		}  		if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  			result = PixelFormat.Format16bppRgb555;  		}  		break;  	case 24:  		result = PixelFormat.Format24bppRgb;  		break;  	case 32:  		result = PixelFormat.Format32bppArgb;  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (GetBPP (dib)) {  	case 1:  		result = PixelFormat.Format1bppIndexed;  		break;  	case 4:  		result = PixelFormat.Format4bppIndexed;  		break;  	case 8:  		result = PixelFormat.Format8bppIndexed;  		break;  	case 16:  		if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  			result = PixelFormat.Format16bppRgb565;  		}  		if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  			result = PixelFormat.Format16bppRgb555;  		}  		break;  	case 24:  		result = PixelFormat.Format24bppRgb;  		break;  	case 32:  		result = PixelFormat.Format32bppArgb;  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (GetBPP (dib)) {  	case 1:  		result = PixelFormat.Format1bppIndexed;  		break;  	case 4:  		result = PixelFormat.Format4bppIndexed;  		break;  	case 8:  		result = PixelFormat.Format8bppIndexed;  		break;  	case 16:  		if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  			result = PixelFormat.Format16bppRgb565;  		}  		if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  			result = PixelFormat.Format16bppRgb555;  		}  		break;  	case 24:  		result = PixelFormat.Format24bppRgb;  		break;  	case 32:  		result = PixelFormat.Format32bppArgb;  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (GetBPP (dib)) {  	case 1:  		result = PixelFormat.Format1bppIndexed;  		break;  	case 4:  		result = PixelFormat.Format4bppIndexed;  		break;  	case 8:  		result = PixelFormat.Format8bppIndexed;  		break;  	case 16:  		if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  			result = PixelFormat.Format16bppRgb565;  		}  		if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  			result = PixelFormat.Format16bppRgb555;  		}  		break;  	case 24:  		result = PixelFormat.Format24bppRgb;  		break;  	case 32:  		result = PixelFormat.Format32bppArgb;  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (GetBPP (dib)) {  	case 1:  		result = PixelFormat.Format1bppIndexed;  		break;  	case 4:  		result = PixelFormat.Format4bppIndexed;  		break;  	case 8:  		result = PixelFormat.Format8bppIndexed;  		break;  	case 16:  		if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  			result = PixelFormat.Format16bppRgb565;  		}  		if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  			result = PixelFormat.Format16bppRgb555;  		}  		break;  	case 24:  		result = PixelFormat.Format24bppRgb;  		break;  	case 32:  		result = PixelFormat.Format32bppArgb;  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = PixelFormat.Format1bppIndexed;  	break;  case 4:  	result = PixelFormat.Format4bppIndexed;  	break;  case 8:  	result = PixelFormat.Format8bppIndexed;  	break;  case 16:  	if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  		result = PixelFormat.Format16bppRgb565;  	}  	if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  		result = PixelFormat.Format16bppRgb555;  	}  	break;  case 24:  	result = PixelFormat.Format24bppRgb;  	break;  case 32:  	result = PixelFormat.Format32bppArgb;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = PixelFormat.Format1bppIndexed;  	break;  case 4:  	result = PixelFormat.Format4bppIndexed;  	break;  case 8:  	result = PixelFormat.Format8bppIndexed;  	break;  case 16:  	if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  		result = PixelFormat.Format16bppRgb565;  	}  	if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  		result = PixelFormat.Format16bppRgb555;  	}  	break;  case 24:  	result = PixelFormat.Format24bppRgb;  	break;  case 32:  	result = PixelFormat.Format32bppArgb;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = PixelFormat.Format1bppIndexed;  	break;  case 4:  	result = PixelFormat.Format4bppIndexed;  	break;  case 8:  	result = PixelFormat.Format8bppIndexed;  	break;  case 16:  	if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  		result = PixelFormat.Format16bppRgb565;  	}  	if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  		result = PixelFormat.Format16bppRgb555;  	}  	break;  case 24:  	result = PixelFormat.Format24bppRgb;  	break;  case 32:  	result = PixelFormat.Format32bppArgb;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = PixelFormat.Format1bppIndexed;  	break;  case 4:  	result = PixelFormat.Format4bppIndexed;  	break;  case 8:  	result = PixelFormat.Format8bppIndexed;  	break;  case 16:  	if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  		result = PixelFormat.Format16bppRgb565;  	}  	if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  		result = PixelFormat.Format16bppRgb555;  	}  	break;  case 24:  	result = PixelFormat.Format24bppRgb;  	break;  case 32:  	result = PixelFormat.Format32bppArgb;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = PixelFormat.Format1bppIndexed;  	break;  case 4:  	result = PixelFormat.Format4bppIndexed;  	break;  case 8:  	result = PixelFormat.Format8bppIndexed;  	break;  case 16:  	if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  		result = PixelFormat.Format16bppRgb565;  	}  	if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  		result = PixelFormat.Format16bppRgb555;  	}  	break;  case 24:  	result = PixelFormat.Format24bppRgb;  	break;  case 32:  	result = PixelFormat.Format32bppArgb;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: bpp = 4;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: bpp = 8;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: bpp = 16;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: bpp = 16;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: bpp = 24;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: bpp = 32;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: bpp = 16;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: bpp = 48;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following statement contains a magic number: bpp = 64;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type) {  case FREE_IMAGE_TYPE.FIT_BITMAP:  	switch (bpp) {  	case 1:  	case 4:  	case 8:  		result = true;  		break;  	case 16:  		result = true;  		red_mask = FI16_555_RED_MASK;  		green_mask = FI16_555_GREEN_MASK;  		blue_mask = FI16_555_BLUE_MASK;  		break;  	case 24:  	case 32:  		result = true;  		red_mask = FI_RGBA_RED_MASK;  		green_mask = FI_RGBA_GREEN_MASK;  		blue_mask = FI_RGBA_BLUE_MASK;  		break;  	}  	break;  case FREE_IMAGE_TYPE.FIT_UNKNOWN:  	break;  default:  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type) {  case FREE_IMAGE_TYPE.FIT_BITMAP:  	switch (bpp) {  	case 1:  	case 4:  	case 8:  		result = true;  		break;  	case 16:  		result = true;  		red_mask = FI16_555_RED_MASK;  		green_mask = FI16_555_GREEN_MASK;  		blue_mask = FI16_555_BLUE_MASK;  		break;  	case 24:  	case 32:  		result = true;  		red_mask = FI_RGBA_RED_MASK;  		green_mask = FI_RGBA_GREEN_MASK;  		blue_mask = FI_RGBA_BLUE_MASK;  		break;  	}  	break;  case FREE_IMAGE_TYPE.FIT_UNKNOWN:  	break;  default:  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type) {  case FREE_IMAGE_TYPE.FIT_BITMAP:  	switch (bpp) {  	case 1:  	case 4:  	case 8:  		result = true;  		break;  	case 16:  		result = true;  		red_mask = FI16_555_RED_MASK;  		green_mask = FI16_555_GREEN_MASK;  		blue_mask = FI16_555_BLUE_MASK;  		break;  	case 24:  	case 32:  		result = true;  		red_mask = FI_RGBA_RED_MASK;  		green_mask = FI_RGBA_GREEN_MASK;  		blue_mask = FI_RGBA_BLUE_MASK;  		break;  	}  	break;  case FREE_IMAGE_TYPE.FIT_UNKNOWN:  	break;  default:  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type) {  case FREE_IMAGE_TYPE.FIT_BITMAP:  	switch (bpp) {  	case 1:  	case 4:  	case 8:  		result = true;  		break;  	case 16:  		result = true;  		red_mask = FI16_555_RED_MASK;  		green_mask = FI16_555_GREEN_MASK;  		blue_mask = FI16_555_BLUE_MASK;  		break;  	case 24:  	case 32:  		result = true;  		red_mask = FI_RGBA_RED_MASK;  		green_mask = FI_RGBA_GREEN_MASK;  		blue_mask = FI_RGBA_BLUE_MASK;  		break;  	}  	break;  case FREE_IMAGE_TYPE.FIT_UNKNOWN:  	break;  default:  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (type) {  case FREE_IMAGE_TYPE.FIT_BITMAP:  	switch (bpp) {  	case 1:  	case 4:  	case 8:  		result = true;  		break;  	case 16:  		result = true;  		red_mask = FI16_555_RED_MASK;  		green_mask = FI16_555_GREEN_MASK;  		blue_mask = FI16_555_BLUE_MASK;  		break;  	case 24:  	case 32:  		result = true;  		red_mask = FI_RGBA_RED_MASK;  		green_mask = FI_RGBA_GREEN_MASK;  		blue_mask = FI_RGBA_BLUE_MASK;  		break;  	}  	break;  case FREE_IMAGE_TYPE.FIT_UNKNOWN:  	break;  default:  	result = true;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (bpp) {  case 1:  case 4:  case 8:  	result = true;  	break;  case 16:  	result = true;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	break;  case 24:  case 32:  	result = true;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (bpp) {  case 1:  case 4:  case 8:  	result = true;  	break;  case 16:  	result = true;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	break;  case 24:  case 32:  	result = true;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (bpp) {  case 1:  case 4:  case 8:  	result = true;  	break;  case 16:  	result = true;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	break;  case 24:  case 32:  	result = true;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (bpp) {  case 1:  case 4:  case 8:  	result = true;  	break;  case 16:  	result = true;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	break;  case 24:  case 32:  	result = true;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following statement contains a magic number: switch (bpp) {  case 1:  case 4:  case 8:  	result = true;  	break;  case 16:  	result = true;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	break;  case 24:  case 32:  	result = true;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (type == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (bpp) {  	case 32:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 24:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 16:  		short* sPtr1' sPtr2;  		short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  		if (mask == -1) {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				if (!CompareMemory (sPtr1' sPtr1' line)) {  					return false;  				}  			}  		} else {  			for (int i = 0; i < height; i++) {  				sPtr1 = (short*)GetScanLine (dib1' i);  				sPtr2 = (short*)GetScanLine (dib2' i);  				for (int x = 0; x < width; x++) {  					if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  						return false;  					}  				}  			}  		}  		break;  	case 8:  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (!CompareMemory (ptr1' ptr2' line)) {  				return false;  			}  		}  		break;  	case 4:  		fullBytes = (int)width / 2;  		shift = (width % 2) == 0 ? 8 : 4;  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	case 1:  		fullBytes = (int)width / 8;  		shift = 8 - ((int)width % 8);  		for (int i = 0; i < height; i++) {  			ptr1 = (byte*)GetScanLine (dib1' i);  			ptr2 = (byte*)GetScanLine (dib2' i);  			if (fullBytes != 0) {  				if (!CompareMemory (ptr1' ptr2' fullBytes)) {  					return false;  				}  				ptr1 += fullBytes;  				ptr2 += fullBytes;  			}  			if (shift != 8) {  				if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  					return false;  				}  			}  		}  		break;  	default:  		throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  	}  } else {  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: switch (bpp) {  case 32:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 24:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 16:  	short* sPtr1' sPtr2;  	short mask = (short)(GetRedMask (dib1) | GetGreenMask (dib1) | GetBlueMask (dib1));  	if (mask == -1) {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			if (!CompareMemory (sPtr1' sPtr1' line)) {  				return false;  			}  		}  	} else {  		for (int i = 0; i < height; i++) {  			sPtr1 = (short*)GetScanLine (dib1' i);  			sPtr2 = (short*)GetScanLine (dib2' i);  			for (int x = 0; x < width; x++) {  				if ((sPtr1 [x] & mask) != (sPtr2 [x] & mask)) {  					return false;  				}  			}  		}  	}  	break;  case 8:  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (!CompareMemory (ptr1' ptr2' line)) {  			return false;  		}  	}  	break;  case 4:  	fullBytes = (int)width / 2;  	shift = (width % 2) == 0 ? 8 : 4;  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  case 1:  	fullBytes = (int)width / 8;  	shift = 8 - ((int)width % 8);  	for (int i = 0; i < height; i++) {  		ptr1 = (byte*)GetScanLine (dib1' i);  		ptr2 = (byte*)GetScanLine (dib2' i);  		if (fullBytes != 0) {  			if (!CompareMemory (ptr1' ptr2' fullBytes)) {  				return false;  			}  			ptr1 += fullBytes;  			ptr2 += fullBytes;  		}  		if (shift != 8) {  			if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  				return false;  			}  		}  	}  	break;  default:  	throw new NotSupportedException ("Only 1' 4' 8' 16' 24 and 32 bpp bitmaps are supported.");  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: fullBytes = (int)width / 2;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: shift = (width % 2) == 0 ? 8 : 4;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: shift = (width % 2) == 0 ? 8 : 4;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: shift = (width % 2) == 0 ? 8 : 4;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: for (int i = 0; i < height; i++) {  	ptr1 = (byte*)GetScanLine (dib1' i);  	ptr2 = (byte*)GetScanLine (dib2' i);  	if (fullBytes != 0) {  		if (!CompareMemory (ptr1' ptr2' fullBytes)) {  			return false;  		}  		ptr1 += fullBytes;  		ptr2 += fullBytes;  	}  	if (shift != 8) {  		if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (shift != 8) {  	if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  		return false;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: fullBytes = (int)width / 8;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: shift = 8 - ((int)width % 8);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: shift = 8 - ((int)width % 8);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: for (int i = 0; i < height; i++) {  	ptr1 = (byte*)GetScanLine (dib1' i);  	ptr2 = (byte*)GetScanLine (dib2' i);  	if (fullBytes != 0) {  		if (!CompareMemory (ptr1' ptr2' fullBytes)) {  			return false;  		}  		ptr1 += fullBytes;  		ptr2 += fullBytes;  	}  	if (shift != 8) {  		if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  			return false;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CompareData,The following statement contains a magic number: if (shift != 8) {  	if ((ptr1 [0] >> shift) != (ptr2 [0] >> shift)) {  		return false;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	BitArray bitArray;  	int uniquePalEnts;  	int hashcode;  	byte[] lut;  	int width = (int)GetWidth (dib);  	int height = (int)GetHeight (dib);  	switch (GetBPP (dib)) {  	case 1:  		result = 1;  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			break;  		}  		if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) > 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		} else {  			for (int y = 0; y < height; y++) {  				byte* scanline = (byte*)GetScanLine (dib' y);  				int mask = 0x80;  				for (int x = 0; x < width; x++) {  					if ((scanline [x / 8] & mask) == 0) {  						return 2;  					}  					mask = (mask == 0x1) ? 0x80 : (mask >> 1);  				}  			}  		}  		break;  	case 4:  		bitArray = new BitArray (0x10);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			bool top = true;  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				if (top) {  					hashcode = lut [scanline [x / 2] >> 4];  				} else {  					hashcode = lut [scanline [x / 2] & 0xF];  				}  				top = !top;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 8:  		bitArray = new BitArray (0x100);  		lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  		if (uniquePalEnts == 1) {  			result = 1;  			break;  		}  		for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  				hashcode = lut [scanline [x]];  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 16:  		bitArray = new BitArray (0x10000);  		for (int y = 0; y < height; y++) {  			short* scanline = (short*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 24:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline += 3) {  				hashcode = *((int*)scanline) & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	case 32:  		bitArray = new BitArray (0x1000000);  		for (int y = 0; y < height; y++) {  			int* scanline = (int*)GetScanLine (dib' y);  			for (int x = 0; x < width; x++' scanline++) {  				hashcode = *scanline & 0x00FFFFFF;  				if (!bitArray [hashcode]) {  					bitArray [hashcode] = true;  					result++;  				}  			}  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		int mask = 0x80;  		for (int x = 0; x < width; x++) {  			if ((scanline [x / 8] & mask) > 0) {  				return 2;  			}  			mask = (mask == 0x1) ? 0x80 : (mask >> 1);  		}  	}  } else {  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		int mask = 0x80;  		for (int x = 0; x < width; x++) {  			if ((scanline [x / 8] & mask) == 0) {  				return 2;  			}  			mask = (mask == 0x1) ? 0x80 : (mask >> 1);  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		int mask = 0x80;  		for (int x = 0; x < width; x++) {  			if ((scanline [x / 8] & mask) > 0) {  				return 2;  			}  			mask = (mask == 0x1) ? 0x80 : (mask >> 1);  		}  	}  } else {  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		int mask = 0x80;  		for (int x = 0; x < width; x++) {  			if ((scanline [x / 8] & mask) == 0) {  				return 2;  			}  			mask = (mask == 0x1) ? 0x80 : (mask >> 1);  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		int mask = 0x80;  		for (int x = 0; x < width; x++) {  			if ((scanline [x / 8] & mask) > 0) {  				return 2;  			}  			mask = (mask == 0x1) ? 0x80 : (mask >> 1);  		}  	}  } else {  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		int mask = 0x80;  		for (int x = 0; x < width; x++) {  			if ((scanline [x / 8] & mask) == 0) {  				return 2;  			}  			mask = (mask == 0x1) ? 0x80 : (mask >> 1);  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		int mask = 0x80;  		for (int x = 0; x < width; x++) {  			if ((scanline [x / 8] & mask) > 0) {  				return 2;  			}  			mask = (mask == 0x1) ? 0x80 : (mask >> 1);  		}  	}  } else {  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		int mask = 0x80;  		for (int x = 0; x < width; x++) {  			if ((scanline [x / 8] & mask) == 0) {  				return 2;  			}  			mask = (mask == 0x1) ? 0x80 : (mask >> 1);  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	byte* scanline = (byte*)GetScanLine (dib' y);  	int mask = 0x80;  	for (int x = 0; x < width; x++) {  		if ((scanline [x / 8] & mask) > 0) {  			return 2;  		}  		mask = (mask == 0x1) ? 0x80 : (mask >> 1);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	byte* scanline = (byte*)GetScanLine (dib' y);  	int mask = 0x80;  	for (int x = 0; x < width; x++) {  		if ((scanline [x / 8] & mask) > 0) {  			return 2;  		}  		mask = (mask == 0x1) ? 0x80 : (mask >> 1);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	if ((scanline [x / 8] & mask) > 0) {  		return 2;  	}  	mask = (mask == 0x1) ? 0x80 : (mask >> 1);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	if ((scanline [x / 8] & mask) > 0) {  		return 2;  	}  	mask = (mask == 0x1) ? 0x80 : (mask >> 1);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if ((scanline [x / 8] & mask) > 0) {  	return 2;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if ((scanline [x / 8] & mask) > 0) {  	return 2;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: return 2;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	byte* scanline = (byte*)GetScanLine (dib' y);  	int mask = 0x80;  	for (int x = 0; x < width; x++) {  		if ((scanline [x / 8] & mask) == 0) {  			return 2;  		}  		mask = (mask == 0x1) ? 0x80 : (mask >> 1);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	byte* scanline = (byte*)GetScanLine (dib' y);  	int mask = 0x80;  	for (int x = 0; x < width; x++) {  		if ((scanline [x / 8] & mask) == 0) {  			return 2;  		}  		mask = (mask == 0x1) ? 0x80 : (mask >> 1);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	if ((scanline [x / 8] & mask) == 0) {  		return 2;  	}  	mask = (mask == 0x1) ? 0x80 : (mask >> 1);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int x = 0; x < width; x++) {  	if ((scanline [x / 8] & mask) == 0) {  		return 2;  	}  	mask = (mask == 0x1) ? 0x80 : (mask >> 1);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if ((scanline [x / 8] & mask) == 0) {  	return 2;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if ((scanline [x / 8] & mask) == 0) {  	return 2;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: return 2;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  	byte* scanline = (byte*)GetScanLine (dib' y);  	bool top = true;  	for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  		if (top) {  			hashcode = lut [scanline [x / 2] >> 4];  		} else {  			hashcode = lut [scanline [x / 2] & 0xF];  		}  		top = !top;  		if (!bitArray [hashcode]) {  			bitArray [hashcode] = true;  			result++;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  	byte* scanline = (byte*)GetScanLine (dib' y);  	bool top = true;  	for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  		if (top) {  			hashcode = lut [scanline [x / 2] >> 4];  		} else {  			hashcode = lut [scanline [x / 2] & 0xF];  		}  		top = !top;  		if (!bitArray [hashcode]) {  			bitArray [hashcode] = true;  			result++;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  	byte* scanline = (byte*)GetScanLine (dib' y);  	bool top = true;  	for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  		if (top) {  			hashcode = lut [scanline [x / 2] >> 4];  		} else {  			hashcode = lut [scanline [x / 2] & 0xF];  		}  		top = !top;  		if (!bitArray [hashcode]) {  			bitArray [hashcode] = true;  			result++;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  	if (top) {  		hashcode = lut [scanline [x / 2] >> 4];  	} else {  		hashcode = lut [scanline [x / 2] & 0xF];  	}  	top = !top;  	if (!bitArray [hashcode]) {  		bitArray [hashcode] = true;  		result++;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  	if (top) {  		hashcode = lut [scanline [x / 2] >> 4];  	} else {  		hashcode = lut [scanline [x / 2] & 0xF];  	}  	top = !top;  	if (!bitArray [hashcode]) {  		bitArray [hashcode] = true;  		result++;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  	if (top) {  		hashcode = lut [scanline [x / 2] >> 4];  	} else {  		hashcode = lut [scanline [x / 2] & 0xF];  	}  	top = !top;  	if (!bitArray [hashcode]) {  		bitArray [hashcode] = true;  		result++;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (top) {  	hashcode = lut [scanline [x / 2] >> 4];  } else {  	hashcode = lut [scanline [x / 2] & 0xF];  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (top) {  	hashcode = lut [scanline [x / 2] >> 4];  } else {  	hashcode = lut [scanline [x / 2] & 0xF];  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: if (top) {  	hashcode = lut [scanline [x / 2] >> 4];  } else {  	hashcode = lut [scanline [x / 2] & 0xF];  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: hashcode = lut [scanline [x / 2] >> 4];  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: hashcode = lut [scanline [x / 2] >> 4];  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: hashcode = lut [scanline [x / 2] & 0xF];  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int y = 0; y < height; y++) {  	byte* scanline = (byte*)GetScanLine (dib' y);  	for (int x = 0; x < width; x++' scanline += 3) {  		hashcode = *((int*)scanline) & 0x00FFFFFF;  		if (!bitArray [hashcode]) {  			bitArray [hashcode] = true;  			result++;  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: for (int x = 0; x < width; x++' scanline += 3) {  	hashcode = *((int*)scanline) & 0x00FFFFFF;  	if (!bitArray [hashcode]) {  		bitArray [hashcode] = true;  		result++;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following statement contains a magic number: scanline += 3
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth (dib' conversion' 128' FREE_IMAGE_DITHER.FID_FS' FREE_IMAGE_QUANTIZE.FIQ_WUQUANT' false);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth (dib' conversion' 128' FREE_IMAGE_DITHER.FID_FS' FREE_IMAGE_QUANTIZE.FIQ_WUQUANT' unloadSource);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth (dib' conversion' 128' ditherMethod' FREE_IMAGE_QUANTIZE.FIQ_WUQUANT' false);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth (dib' conversion' 128' FREE_IMAGE_DITHER.FID_FS' quantizationMethod' false);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth (dib' conversion' 128' ditherMethod' FREE_IMAGE_QUANTIZE.FIQ_WUQUANT' unloadSource);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: return ConvertColorDepth (dib' conversion' 128' FREE_IMAGE_DITHER.FID_FS' quantizationMethod' unloadSource);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) {  	switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Threshold (dib' threshold);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Threshold (dib' threshold);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  		if (bpp != 1) {  			if (forceGreyscale) {  				result = Dither (dib' ditherMethod);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = Dither (dib' ditherMethod);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  		if (bpp != 4) {  			// Special case when 1bpp and FIC_PALETTE  			if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				dibTemp = ConvertToGreyscale (dib);  				result = ConvertTo4Bits (dibTemp);  				Unload (dibTemp);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  		if (bpp != 8) {  			if (forceGreyscale) {  				result = ConvertToGreyscale (dib);  			} else {  				dibTemp = ConvertTo24Bits (dib);  				result = ColorQuantize (dibTemp' quantizationMethod);  				Unload (dibTemp);  			}  		} else {  			bool isGreyscale = IsGreyscaleImage (dib);  			if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  				result = ConvertToGreyscale (dib);  			}  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits555 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  			result = ConvertTo16Bits555 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo16Bits565 (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  			result = ConvertTo16Bits565 (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo24Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 24) {  			result = ConvertTo24Bits (dib);  		}  		break;  	case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  		if (forceGreyscale) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo32Bits (dibTemp);  			Unload (dibTemp);  		} else if (bpp != 32) {  			result = ConvertTo32Bits (dib);  		}  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 1) {  	if (forceGreyscale) {  		result = Threshold (dib' threshold);  	} else {  		dibTemp = ConvertTo24Bits (dib);  		result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  		Unload (dibTemp);  	}  } else {  	bool isGreyscale = IsGreyscaleImage (dib);  	if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  		result = Threshold (dib' threshold);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (forceGreyscale) {  	result = Threshold (dib' threshold);  } else {  	dibTemp = ConvertTo24Bits (dib);  	result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  	Unload (dibTemp);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 1) {  	if (forceGreyscale) {  		result = Dither (dib' ditherMethod);  	} else {  		dibTemp = ConvertTo24Bits (dib);  		result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  		Unload (dibTemp);  	}  } else {  	bool isGreyscale = IsGreyscaleImage (dib);  	if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  		result = Dither (dib' ditherMethod);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (forceGreyscale) {  	result = Dither (dib' ditherMethod);  } else {  	dibTemp = ConvertTo24Bits (dib);  	result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  	Unload (dibTemp);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 4) {  	// Special case when 1bpp and FIC_PALETTE  	if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo4Bits (dibTemp);  		Unload (dibTemp);  	} else {  		dibTemp = ConvertTo24Bits (dib);  		result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  		Unload (dibTemp);  	}  } else {  	bool isGreyscale = IsGreyscaleImage (dib);  	if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo4Bits (dibTemp);  		Unload (dibTemp);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 4) {  	// Special case when 1bpp and FIC_PALETTE  	if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo4Bits (dibTemp);  		Unload (dibTemp);  	} else {  		dibTemp = ConvertTo24Bits (dib);  		result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  		Unload (dibTemp);  	}  } else {  	bool isGreyscale = IsGreyscaleImage (dib);  	if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo4Bits (dibTemp);  		Unload (dibTemp);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 4) {  	// Special case when 1bpp and FIC_PALETTE  	if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo4Bits (dibTemp);  		Unload (dibTemp);  	} else {  		dibTemp = ConvertTo24Bits (dib);  		result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  		Unload (dibTemp);  	}  } else {  	bool isGreyscale = IsGreyscaleImage (dib);  	if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo4Bits (dibTemp);  		Unload (dibTemp);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  	dibTemp = ConvertToGreyscale (dib);  	result = ConvertTo4Bits (dibTemp);  	Unload (dibTemp);  } else {  	dibTemp = ConvertTo24Bits (dib);  	result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  	Unload (dibTemp);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  	dibTemp = ConvertToGreyscale (dib);  	result = ConvertTo4Bits (dibTemp);  	Unload (dibTemp);  } else {  	dibTemp = ConvertTo24Bits (dib);  	result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  	Unload (dibTemp);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 8) {  	if (forceGreyscale) {  		result = ConvertToGreyscale (dib);  	} else {  		dibTemp = ConvertTo24Bits (dib);  		result = ColorQuantize (dibTemp' quantizationMethod);  		Unload (dibTemp);  	}  } else {  	bool isGreyscale = IsGreyscaleImage (dib);  	if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  		result = ConvertToGreyscale (dib);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (forceGreyscale) {  	dibTemp = ConvertToGreyscale (dib);  	result = ConvertTo16Bits555 (dibTemp);  	Unload (dibTemp);  } else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  	result = ConvertTo16Bits555 (dib);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  	result = ConvertTo16Bits555 (dib);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (forceGreyscale) {  	dibTemp = ConvertToGreyscale (dib);  	result = ConvertTo16Bits565 (dibTemp);  	Unload (dibTemp);  } else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  	result = ConvertTo16Bits565 (dib);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  	result = ConvertTo16Bits565 (dib);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (forceGreyscale) {  	dibTemp = ConvertToGreyscale (dib);  	result = ConvertTo24Bits (dibTemp);  	Unload (dibTemp);  } else if (bpp != 24) {  	result = ConvertTo24Bits (dib);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 24) {  	result = ConvertTo24Bits (dib);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (forceGreyscale) {  	dibTemp = ConvertToGreyscale (dib);  	result = ConvertTo32Bits (dibTemp);  	Unload (dibTemp);  } else if (bpp != 32) {  	result = ConvertTo32Bits (dib);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following statement contains a magic number: if (bpp != 32) {  	result = ConvertTo32Bits (dib);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (minColorDepth) {  	int bpp;  	if (PaletteSize >= 256)  		bpp = 8;  	else if (PaletteSize > 2)  		bpp = 4;  	else  		bpp = 1;  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' bpp);  } else {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' 8);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (minColorDepth) {  	int bpp;  	if (PaletteSize >= 256)  		bpp = 8;  	else if (PaletteSize > 2)  		bpp = 4;  	else  		bpp = 1;  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' bpp);  } else {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' 8);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (minColorDepth) {  	int bpp;  	if (PaletteSize >= 256)  		bpp = 8;  	else if (PaletteSize > 2)  		bpp = 4;  	else  		bpp = 1;  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' bpp);  } else {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' 8);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (minColorDepth) {  	int bpp;  	if (PaletteSize >= 256)  		bpp = 8;  	else if (PaletteSize > 2)  		bpp = 4;  	else  		bpp = 1;  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' bpp);  } else {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' 8);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (minColorDepth) {  	int bpp;  	if (PaletteSize >= 256)  		bpp = 8;  	else if (PaletteSize > 2)  		bpp = 4;  	else  		bpp = 1;  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' bpp);  } else {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' 8);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (PaletteSize >= 256)  	bpp = 8;  else if (PaletteSize > 2)  	bpp = 4;  else  	bpp = 1;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (PaletteSize >= 256)  	bpp = 8;  else if (PaletteSize > 2)  	bpp = 4;  else  	bpp = 1;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (PaletteSize >= 256)  	bpp = 8;  else if (PaletteSize > 2)  	bpp = 4;  else  	bpp = 1;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (PaletteSize >= 256)  	bpp = 8;  else if (PaletteSize > 2)  	bpp = 4;  else  	bpp = 1;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: bpp = 8;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (PaletteSize > 2)  	bpp = 4;  else  	bpp = 1;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (PaletteSize > 2)  	bpp = 4;  else  	bpp = 1;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: bpp = 4;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: result = ColorQuantizeEx (dib' quantize' PaletteSize' ReservePalette' 8);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: unsafe {  	FIBITMAP result = FIBITMAP.Zero;  	FIBITMAP temp = FIBITMAP.Zero;  	int reservedSize = (ReservePalette == null) ? 0 : ReservePalette.Length;  	if (bpp == 8) {  		result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  	} else if (bpp == 4) {  		temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	} else if (bpp == 1) {  		temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	}  	UnloadEx (ref temp);  	return result;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: unsafe {  	FIBITMAP result = FIBITMAP.Zero;  	FIBITMAP temp = FIBITMAP.Zero;  	int reservedSize = (ReservePalette == null) ? 0 : ReservePalette.Length;  	if (bpp == 8) {  		result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  	} else if (bpp == 4) {  		temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	} else if (bpp == 1) {  		temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	}  	UnloadEx (ref temp);  	return result;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: unsafe {  	FIBITMAP result = FIBITMAP.Zero;  	FIBITMAP temp = FIBITMAP.Zero;  	int reservedSize = (ReservePalette == null) ? 0 : ReservePalette.Length;  	if (bpp == 8) {  		result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  	} else if (bpp == 4) {  		temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	} else if (bpp == 1) {  		temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	}  	UnloadEx (ref temp);  	return result;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: unsafe {  	FIBITMAP result = FIBITMAP.Zero;  	FIBITMAP temp = FIBITMAP.Zero;  	int reservedSize = (ReservePalette == null) ? 0 : ReservePalette.Length;  	if (bpp == 8) {  		result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  	} else if (bpp == 4) {  		temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	} else if (bpp == 1) {  		temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	}  	UnloadEx (ref temp);  	return result;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: unsafe {  	FIBITMAP result = FIBITMAP.Zero;  	FIBITMAP temp = FIBITMAP.Zero;  	int reservedSize = (ReservePalette == null) ? 0 : ReservePalette.Length;  	if (bpp == 8) {  		result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  	} else if (bpp == 4) {  		temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	} else if (bpp == 1) {  		temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	}  	UnloadEx (ref temp);  	return result;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: unsafe {  	FIBITMAP result = FIBITMAP.Zero;  	FIBITMAP temp = FIBITMAP.Zero;  	int reservedSize = (ReservePalette == null) ? 0 : ReservePalette.Length;  	if (bpp == 8) {  		result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  	} else if (bpp == 4) {  		temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	} else if (bpp == 1) {  		temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	}  	UnloadEx (ref temp);  	return result;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: unsafe {  	FIBITMAP result = FIBITMAP.Zero;  	FIBITMAP temp = FIBITMAP.Zero;  	int reservedSize = (ReservePalette == null) ? 0 : ReservePalette.Length;  	if (bpp == 8) {  		result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  	} else if (bpp == 4) {  		temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	} else if (bpp == 1) {  		temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  		if (!temp.IsNull) {  			result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  			CloneMetadata (result' temp);  			CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  			for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  				Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  				Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  				for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  					dstScanline [x] = srcScanline [x];  				}  			}  		}  	}  	UnloadEx (ref temp);  	return result;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 8) {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  } else if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 8) {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  } else if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 8) {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  } else if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 8) {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  } else if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 8) {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  } else if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 8) {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  } else if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 8) {  	result = ColorQuantizeEx (dib' quantize' PaletteSize' reservedSize' ReservePalette);  } else if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 4) {  	temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  } else if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: temp = ColorQuantizeEx (dib' quantize' Math.Min (16' PaletteSize)' reservedSize' ReservePalette);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (!temp.IsNull) {  	result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  	CloneMetadata (result' temp);  	CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  	for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  		Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  		Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  		for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  			dstScanline [x] = srcScanline [x];  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (!temp.IsNull) {  	result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  	CloneMetadata (result' temp);  	CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  	for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  		Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  		Scanline<FI4BIT> dstScanline = new Scanline<FI4BIT> (result' y);  		for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  			dstScanline [x] = srcScanline [x];  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 4' 0' 0' 0);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 16);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (bpp == 1) {  	temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  	if (!temp.IsNull) {  		result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  		CloneMetadata (result' temp);  		CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  		for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  			Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  			Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  			for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  				dstScanline [x] = srcScanline [x];  			}  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: temp = ColorQuantizeEx (dib' quantize' 2' reservedSize' ReservePalette);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: if (!temp.IsNull) {  	result = Allocate ((int)GetWidth (temp)' (int)GetHeight (temp)' 1' 0' 0' 0);  	CloneMetadata (result' temp);  	CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  	for (int y = (int)GetHeight (temp) - 1; y >= 0; y--) {  		Scanline<byte> srcScanline = new Scanline<byte> (temp' y);  		Scanline<FI1BIT> dstScanline = new Scanline<FI1BIT> (result' y);  		for (int x = (int)GetWidth (temp) - 1; x >= 0; x--) {  			dstScanline [x] = srcScanline [x];  		}  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ColorQuantizeEx,The following statement contains a magic number: CopyMemory (GetPalette (result)' GetPalette (temp)' sizeof(RGBQUAD) * 2);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: if ((GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) == 4) && ((ang % 90) == 0)) {  	int width' height' xOrg' yOrg;  	Scanline<FI4BIT>[] src' dst;  	width = (int)GetWidth (dib);  	height = (int)GetHeight (dib);  	byte index = 0;  	switch (ang) {  	case 90:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		for (int y = 0; y < width; y++) {  			yOrg = height - 1;  			for (int x = 0; x < height; x++' yOrg--) {  				index = src [yOrg] [y];  				dst [y] [x] = index;  			}  		}  		break;  	case 180:  		result = Allocate (width' height' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		yOrg = height - 1;  		for (int y = 0; y < height; y++' yOrg--) {  			xOrg = width - 1;  			for (int x = 0; x < width; x++' xOrg--) {  				index = src [yOrg] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 270:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		xOrg = width - 1;  		for (int y = 0; y < width; y++' xOrg--) {  			for (int x = 0; x < height; x++) {  				index = src [x] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 0:  	case 360:  		result = Clone (dib);  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: if ((GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) == 4) && ((ang % 90) == 0)) {  	int width' height' xOrg' yOrg;  	Scanline<FI4BIT>[] src' dst;  	width = (int)GetWidth (dib);  	height = (int)GetHeight (dib);  	byte index = 0;  	switch (ang) {  	case 90:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		for (int y = 0; y < width; y++) {  			yOrg = height - 1;  			for (int x = 0; x < height; x++' yOrg--) {  				index = src [yOrg] [y];  				dst [y] [x] = index;  			}  		}  		break;  	case 180:  		result = Allocate (width' height' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		yOrg = height - 1;  		for (int y = 0; y < height; y++' yOrg--) {  			xOrg = width - 1;  			for (int x = 0; x < width; x++' xOrg--) {  				index = src [yOrg] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 270:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		xOrg = width - 1;  		for (int y = 0; y < width; y++' xOrg--) {  			for (int x = 0; x < height; x++) {  				index = src [x] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 0:  	case 360:  		result = Clone (dib);  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: if ((GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) == 4) && ((ang % 90) == 0)) {  	int width' height' xOrg' yOrg;  	Scanline<FI4BIT>[] src' dst;  	width = (int)GetWidth (dib);  	height = (int)GetHeight (dib);  	byte index = 0;  	switch (ang) {  	case 90:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		for (int y = 0; y < width; y++) {  			yOrg = height - 1;  			for (int x = 0; x < height; x++' yOrg--) {  				index = src [yOrg] [y];  				dst [y] [x] = index;  			}  		}  		break;  	case 180:  		result = Allocate (width' height' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		yOrg = height - 1;  		for (int y = 0; y < height; y++' yOrg--) {  			xOrg = width - 1;  			for (int x = 0; x < width; x++' xOrg--) {  				index = src [yOrg] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 270:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		xOrg = width - 1;  		for (int y = 0; y < width; y++' xOrg--) {  			for (int x = 0; x < height; x++) {  				index = src [x] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 0:  	case 360:  		result = Clone (dib);  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: if ((GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) == 4) && ((ang % 90) == 0)) {  	int width' height' xOrg' yOrg;  	Scanline<FI4BIT>[] src' dst;  	width = (int)GetWidth (dib);  	height = (int)GetHeight (dib);  	byte index = 0;  	switch (ang) {  	case 90:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		for (int y = 0; y < width; y++) {  			yOrg = height - 1;  			for (int x = 0; x < height; x++' yOrg--) {  				index = src [yOrg] [y];  				dst [y] [x] = index;  			}  		}  		break;  	case 180:  		result = Allocate (width' height' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		yOrg = height - 1;  		for (int y = 0; y < height; y++' yOrg--) {  			xOrg = width - 1;  			for (int x = 0; x < width; x++' xOrg--) {  				index = src [yOrg] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 270:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		xOrg = width - 1;  		for (int y = 0; y < width; y++' xOrg--) {  			for (int x = 0; x < height; x++) {  				index = src [x] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 0:  	case 360:  		result = Clone (dib);  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: if ((GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) == 4) && ((ang % 90) == 0)) {  	int width' height' xOrg' yOrg;  	Scanline<FI4BIT>[] src' dst;  	width = (int)GetWidth (dib);  	height = (int)GetHeight (dib);  	byte index = 0;  	switch (ang) {  	case 90:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		for (int y = 0; y < width; y++) {  			yOrg = height - 1;  			for (int x = 0; x < height; x++' yOrg--) {  				index = src [yOrg] [y];  				dst [y] [x] = index;  			}  		}  		break;  	case 180:  		result = Allocate (width' height' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		yOrg = height - 1;  		for (int y = 0; y < height; y++' yOrg--) {  			xOrg = width - 1;  			for (int x = 0; x < width; x++' xOrg--) {  				index = src [yOrg] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 270:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		xOrg = width - 1;  		for (int y = 0; y < width; y++' xOrg--) {  			for (int x = 0; x < height; x++) {  				index = src [x] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 0:  	case 360:  		result = Clone (dib);  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: if ((GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) == 4) && ((ang % 90) == 0)) {  	int width' height' xOrg' yOrg;  	Scanline<FI4BIT>[] src' dst;  	width = (int)GetWidth (dib);  	height = (int)GetHeight (dib);  	byte index = 0;  	switch (ang) {  	case 90:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		for (int y = 0; y < width; y++) {  			yOrg = height - 1;  			for (int x = 0; x < height; x++' yOrg--) {  				index = src [yOrg] [y];  				dst [y] [x] = index;  			}  		}  		break;  	case 180:  		result = Allocate (width' height' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		yOrg = height - 1;  		for (int y = 0; y < height; y++' yOrg--) {  			xOrg = width - 1;  			for (int x = 0; x < width; x++' xOrg--) {  				index = src [yOrg] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 270:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		xOrg = width - 1;  		for (int y = 0; y < width; y++' xOrg--) {  			for (int x = 0; x < height; x++) {  				index = src [x] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 0:  	case 360:  		result = Clone (dib);  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: if ((GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) == 4) && ((ang % 90) == 0)) {  	int width' height' xOrg' yOrg;  	Scanline<FI4BIT>[] src' dst;  	width = (int)GetWidth (dib);  	height = (int)GetHeight (dib);  	byte index = 0;  	switch (ang) {  	case 90:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		for (int y = 0; y < width; y++) {  			yOrg = height - 1;  			for (int x = 0; x < height; x++' yOrg--) {  				index = src [yOrg] [y];  				dst [y] [x] = index;  			}  		}  		break;  	case 180:  		result = Allocate (width' height' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		yOrg = height - 1;  		for (int y = 0; y < height; y++' yOrg--) {  			xOrg = width - 1;  			for (int x = 0; x < width; x++' xOrg--) {  				index = src [yOrg] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 270:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		xOrg = width - 1;  		for (int y = 0; y < width; y++' xOrg--) {  			for (int x = 0; x < height; x++) {  				index = src [x] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 0:  	case 360:  		result = Clone (dib);  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: if ((GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) == 4) && ((ang % 90) == 0)) {  	int width' height' xOrg' yOrg;  	Scanline<FI4BIT>[] src' dst;  	width = (int)GetWidth (dib);  	height = (int)GetHeight (dib);  	byte index = 0;  	switch (ang) {  	case 90:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		for (int y = 0; y < width; y++) {  			yOrg = height - 1;  			for (int x = 0; x < height; x++' yOrg--) {  				index = src [yOrg] [y];  				dst [y] [x] = index;  			}  		}  		break;  	case 180:  		result = Allocate (width' height' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		yOrg = height - 1;  		for (int y = 0; y < height; y++' yOrg--) {  			xOrg = width - 1;  			for (int x = 0; x < width; x++' xOrg--) {  				index = src [yOrg] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 270:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		xOrg = width - 1;  		for (int y = 0; y < width; y++' xOrg--) {  			for (int x = 0; x < height; x++) {  				index = src [x] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 0:  	case 360:  		result = Clone (dib);  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: if ((GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) == 4) && ((ang % 90) == 0)) {  	int width' height' xOrg' yOrg;  	Scanline<FI4BIT>[] src' dst;  	width = (int)GetWidth (dib);  	height = (int)GetHeight (dib);  	byte index = 0;  	switch (ang) {  	case 90:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		for (int y = 0; y < width; y++) {  			yOrg = height - 1;  			for (int x = 0; x < height; x++' yOrg--) {  				index = src [yOrg] [y];  				dst [y] [x] = index;  			}  		}  		break;  	case 180:  		result = Allocate (width' height' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		yOrg = height - 1;  		for (int y = 0; y < height; y++' yOrg--) {  			xOrg = width - 1;  			for (int x = 0; x < width; x++' xOrg--) {  				index = src [yOrg] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 270:  		result = Allocate (height' width' 4' 0' 0' 0);  		if (result.IsNull) {  			break;  		}  		CopyPalette (dib' result);  		src = Get04BitScanlines (dib);  		dst = Get04BitScanlines (result);  		xOrg = width - 1;  		for (int y = 0; y < width; y++' xOrg--) {  			for (int x = 0; x < height; x++) {  				index = src [x] [xOrg];  				dst [y] [x] = index;  			}  		}  		break;  	case 0:  	case 360:  		result = Clone (dib);  		break;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang) {  case 90:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	for (int y = 0; y < width; y++) {  		yOrg = height - 1;  		for (int x = 0; x < height; x++' yOrg--) {  			index = src [yOrg] [y];  			dst [y] [x] = index;  		}  	}  	break;  case 180:  	result = Allocate (width' height' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	yOrg = height - 1;  	for (int y = 0; y < height; y++' yOrg--) {  		xOrg = width - 1;  		for (int x = 0; x < width; x++' xOrg--) {  			index = src [yOrg] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 270:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	xOrg = width - 1;  	for (int y = 0; y < width; y++' xOrg--) {  		for (int x = 0; x < height; x++) {  			index = src [x] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 0:  case 360:  	result = Clone (dib);  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang) {  case 90:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	for (int y = 0; y < width; y++) {  		yOrg = height - 1;  		for (int x = 0; x < height; x++' yOrg--) {  			index = src [yOrg] [y];  			dst [y] [x] = index;  		}  	}  	break;  case 180:  	result = Allocate (width' height' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	yOrg = height - 1;  	for (int y = 0; y < height; y++' yOrg--) {  		xOrg = width - 1;  		for (int x = 0; x < width; x++' xOrg--) {  			index = src [yOrg] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 270:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	xOrg = width - 1;  	for (int y = 0; y < width; y++' xOrg--) {  		for (int x = 0; x < height; x++) {  			index = src [x] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 0:  case 360:  	result = Clone (dib);  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang) {  case 90:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	for (int y = 0; y < width; y++) {  		yOrg = height - 1;  		for (int x = 0; x < height; x++' yOrg--) {  			index = src [yOrg] [y];  			dst [y] [x] = index;  		}  	}  	break;  case 180:  	result = Allocate (width' height' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	yOrg = height - 1;  	for (int y = 0; y < height; y++' yOrg--) {  		xOrg = width - 1;  		for (int x = 0; x < width; x++' xOrg--) {  			index = src [yOrg] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 270:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	xOrg = width - 1;  	for (int y = 0; y < width; y++' xOrg--) {  		for (int x = 0; x < height; x++) {  			index = src [x] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 0:  case 360:  	result = Clone (dib);  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang) {  case 90:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	for (int y = 0; y < width; y++) {  		yOrg = height - 1;  		for (int x = 0; x < height; x++' yOrg--) {  			index = src [yOrg] [y];  			dst [y] [x] = index;  		}  	}  	break;  case 180:  	result = Allocate (width' height' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	yOrg = height - 1;  	for (int y = 0; y < height; y++' yOrg--) {  		xOrg = width - 1;  		for (int x = 0; x < width; x++' xOrg--) {  			index = src [yOrg] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 270:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	xOrg = width - 1;  	for (int y = 0; y < width; y++' xOrg--) {  		for (int x = 0; x < height; x++) {  			index = src [x] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 0:  case 360:  	result = Clone (dib);  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang) {  case 90:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	for (int y = 0; y < width; y++) {  		yOrg = height - 1;  		for (int x = 0; x < height; x++' yOrg--) {  			index = src [yOrg] [y];  			dst [y] [x] = index;  		}  	}  	break;  case 180:  	result = Allocate (width' height' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	yOrg = height - 1;  	for (int y = 0; y < height; y++' yOrg--) {  		xOrg = width - 1;  		for (int x = 0; x < width; x++' xOrg--) {  			index = src [yOrg] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 270:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	xOrg = width - 1;  	for (int y = 0; y < width; y++' xOrg--) {  		for (int x = 0; x < height; x++) {  			index = src [x] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 0:  case 360:  	result = Clone (dib);  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang) {  case 90:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	for (int y = 0; y < width; y++) {  		yOrg = height - 1;  		for (int x = 0; x < height; x++' yOrg--) {  			index = src [yOrg] [y];  			dst [y] [x] = index;  		}  	}  	break;  case 180:  	result = Allocate (width' height' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	yOrg = height - 1;  	for (int y = 0; y < height; y++' yOrg--) {  		xOrg = width - 1;  		for (int x = 0; x < width; x++' xOrg--) {  			index = src [yOrg] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 270:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	xOrg = width - 1;  	for (int y = 0; y < width; y++' xOrg--) {  		for (int x = 0; x < height; x++) {  			index = src [x] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 0:  case 360:  	result = Clone (dib);  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: switch (ang) {  case 90:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	for (int y = 0; y < width; y++) {  		yOrg = height - 1;  		for (int x = 0; x < height; x++' yOrg--) {  			index = src [yOrg] [y];  			dst [y] [x] = index;  		}  	}  	break;  case 180:  	result = Allocate (width' height' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	yOrg = height - 1;  	for (int y = 0; y < height; y++' yOrg--) {  		xOrg = width - 1;  		for (int x = 0; x < width; x++' xOrg--) {  			index = src [yOrg] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 270:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	xOrg = width - 1;  	for (int y = 0; y < width; y++' xOrg--) {  		for (int x = 0; x < height; x++) {  			index = src [x] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 0:  case 360:  	result = Clone (dib);  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: result = Allocate (height' width' 4' 0' 0' 0);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: result = Allocate (width' height' 4' 0' 0' 0);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following statement contains a magic number: result = Allocate (height' width' 4' 0' 0' 0);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: result = 4;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: result = 8;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: result = 16;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: result = 24;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following statement contains a magic number: result = 32;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: result = 24;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: result = 16;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: result = 8;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following statement contains a magic number: result = 4;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateShrunkenPaletteLUT,The following statement contains a magic number: if ((!dib.IsNull) && (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) <= 8)) {  	int size = (int)GetColorsUsed (dib);  	List<RGBQUAD> newPalette = new List<RGBQUAD> (size);  	List<byte> lut = new List<byte> (size);  	RGBQUAD* palette = (RGBQUAD*)GetPalette (dib);  	RGBQUAD color;  	int index;  	for (int i = 0; i < size; i++) {  		color = palette [i];  		color.rgbReserved = 255;  		// ignore alpha  		index = newPalette.IndexOf (color);  		if (index < 0) {  			newPalette.Add (color);  			lut.Add ((byte)(newPalette.Count - 1));  		} else {  			lut.Add ((byte)index);  		}  	}  	result = lut.ToArray ();  	uniqueColors = newPalette.Count;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateShrunkenPaletteLUT,The following statement contains a magic number: if ((!dib.IsNull) && (GetImageType (dib) == FREE_IMAGE_TYPE.FIT_BITMAP) && (GetBPP (dib) <= 8)) {  	int size = (int)GetColorsUsed (dib);  	List<RGBQUAD> newPalette = new List<RGBQUAD> (size);  	List<byte> lut = new List<byte> (size);  	RGBQUAD* palette = (RGBQUAD*)GetPalette (dib);  	RGBQUAD color;  	int index;  	for (int i = 0; i < size; i++) {  		color = palette [i];  		color.rgbReserved = 255;  		// ignore alpha  		index = newPalette.IndexOf (color);  		if (index < 0) {  			newPalette.Add (color);  			lut.Add ((byte)(newPalette.Count - 1));  		} else {  			lut.Add ((byte)index);  		}  	}  	result = lut.ToArray ();  	uniqueColors = newPalette.Count;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateShrunkenPaletteLUT,The following statement contains a magic number: for (int i = 0; i < size; i++) {  	color = palette [i];  	color.rgbReserved = 255;  	// ignore alpha  	index = newPalette.IndexOf (color);  	if (index < 0) {  		newPalette.Add (color);  		lut.Add ((byte)(newPalette.Count - 1));  	} else {  		lut.Add ((byte)index);  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CreateShrunkenPaletteLUT,The following statement contains a magic number: color.rgbReserved = 255;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len >= 0x10) {  	do {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		*((int*)(dest + 8)) = *((int*)(src + 8));  		*((int*)(dest + 12)) = *((int*)(src + 12));  		dest += 0x10;  		src += 0x10;  	} while ((len -= 0x10) >= 0x10);  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: do {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	*((int*)(dest + 8)) = *((int*)(src + 8));  	*((int*)(dest + 12)) = *((int*)(src + 12));  	dest += 0x10;  	src += 0x10;  } while ((len -= 0x10) >= 0x10);  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 8)) = *((int*)(src + 8));  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 8)) = *((int*)(src + 8));  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 12)) = *((int*)(src + 12));  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 12)) = *((int*)(src + 12));  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if (len > 0) {  	if ((len & 8) != 0) {  		*((int*)dest) = *((int*)src);  		*((int*)(dest + 4)) = *((int*)(src + 4));  		dest += 8;  		src += 8;  	}  	if ((len & 4) != 0) {  		*((int*)dest) = *((int*)src);  		dest += 4;  		src += 4;  	}  	if ((len & 2) != 0) {  		*((short*)dest) = *((short*)src);  		dest += 2;  		src += 2;  	}  	if ((len & 1) != 0) {  		*dest = *src;  	}  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 8) != 0) {  	*((int*)dest) = *((int*)src);  	*((int*)(dest + 4)) = *((int*)(src + 4));  	dest += 8;  	src += 8;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: *((int*)(dest + 4)) = *((int*)(src + 4));  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: dest += 8;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: src += 8;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 4) != 0) {  	*((int*)dest) = *((int*)src);  	dest += 4;  	src += 4;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 4) != 0) {  	*((int*)dest) = *((int*)src);  	dest += 4;  	src += 4;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 4) != 0) {  	*((int*)dest) = *((int*)src);  	dest += 4;  	src += 4;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: dest += 4;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: src += 4;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 2) != 0) {  	*((short*)dest) = *((short*)src);  	dest += 2;  	src += 2;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 2) != 0) {  	*((short*)dest) = *((short*)src);  	dest += 2;  	src += 2;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: if ((len & 2) != 0) {  	*((short*)dest) = *((short*)src);  	dest += 2;  	src += 2;  }  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: dest += 2;  
Magic Number,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,CopyMemory,The following statement contains a magic number: src += 2;  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: try {  	if (value < 0) {  		throw new OverflowException ("value");  	}  	try {  		int[] contFract = CreateContinuedFraction (value);  		CreateFraction (contFract' out numerator' out denominator);  		Normalize ();  	} catch {  		numerator = 0;  		denominator = 1;  	}  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		int maxDen = (Int32.MaxValue / (int)value) - 2;  		maxDen = maxDen < 10000 ? maxDen : 10000;  		ApproximateFraction (value' maxDen' out numerator' out denominator);  		Normalize ();  		if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  			throw new OverflowException ("Unable to convert value into a fraction");  		}  	}  	Normalize ();  } catch (Exception ex) {  	throw new OverflowException ("Unable to calculate fraction."' ex);  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: try {  	if (value < 0) {  		throw new OverflowException ("value");  	}  	try {  		int[] contFract = CreateContinuedFraction (value);  		CreateFraction (contFract' out numerator' out denominator);  		Normalize ();  	} catch {  		numerator = 0;  		denominator = 1;  	}  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		int maxDen = (Int32.MaxValue / (int)value) - 2;  		maxDen = maxDen < 10000 ? maxDen : 10000;  		ApproximateFraction (value' maxDen' out numerator' out denominator);  		Normalize ();  		if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  			throw new OverflowException ("Unable to convert value into a fraction");  		}  	}  	Normalize ();  } catch (Exception ex) {  	throw new OverflowException ("Unable to calculate fraction."' ex);  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: try {  	if (value < 0) {  		throw new OverflowException ("value");  	}  	try {  		int[] contFract = CreateContinuedFraction (value);  		CreateFraction (contFract' out numerator' out denominator);  		Normalize ();  	} catch {  		numerator = 0;  		denominator = 1;  	}  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		int maxDen = (Int32.MaxValue / (int)value) - 2;  		maxDen = maxDen < 10000 ? maxDen : 10000;  		ApproximateFraction (value' maxDen' out numerator' out denominator);  		Normalize ();  		if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  			throw new OverflowException ("Unable to convert value into a fraction");  		}  	}  	Normalize ();  } catch (Exception ex) {  	throw new OverflowException ("Unable to calculate fraction."' ex);  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  	int maxDen = (Int32.MaxValue / (int)value) - 2;  	maxDen = maxDen < 10000 ? maxDen : 10000;  	ApproximateFraction (value' maxDen' out numerator' out denominator);  	Normalize ();  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		throw new OverflowException ("Unable to convert value into a fraction");  	}  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  	int maxDen = (Int32.MaxValue / (int)value) - 2;  	maxDen = maxDen < 10000 ? maxDen : 10000;  	ApproximateFraction (value' maxDen' out numerator' out denominator);  	Normalize ();  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		throw new OverflowException ("Unable to convert value into a fraction");  	}  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  	int maxDen = (Int32.MaxValue / (int)value) - 2;  	maxDen = maxDen < 10000 ? maxDen : 10000;  	ApproximateFraction (value' maxDen' out numerator' out denominator);  	Normalize ();  	if (Math.Abs (((decimal)numerator / (decimal)denominator) - value) > 0.0001m) {  		throw new OverflowException ("Unable to convert value into a fraction");  	}  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: maxDen = maxDen < 10000 ? maxDen : 10000;  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,FIURational,The following statement contains a magic number: maxDen = maxDen < 10000 ? maxDen : 10000;  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,GetDigits,The following statement contains a magic number: while (value != 0) {  	value *= 10;  	value -= decimal.Truncate (value);  	result++;  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,GetDigits,The following statement contains a magic number: value *= 10;  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,ApproximateFraction,The following statement contains a magic number: if (digits <= 9) {  	uint mul = 1;  	for (int i = 1; i <= digits; i++) {  		mul *= 10;  	}  	if (mul <= maxDen) {  		num = (uint)(value * mul);  		den = mul;  		return;  	}  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,ApproximateFraction,The following statement contains a magic number: if (digits <= 9) {  	uint mul = 1;  	for (int i = 1; i <= digits; i++) {  		mul *= 10;  	}  	if (mul <= maxDen) {  		num = (uint)(value * mul);  		den = mul;  		return;  	}  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,ApproximateFraction,The following statement contains a magic number: for (int i = 1; i <= digits; i++) {  	mul *= 10;  }  
Magic Number,FreeImageAPI,FIURational,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Structs\FIURational.cs,ApproximateFraction,The following statement contains a magic number: mul *= 10;  
Magic Number,FreeImageAPI.IO,StreamWrapper,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\StreamWrapper.cs,Seek,The following statement contains a magic number: if ((newPosition > memoryStream.Length) && (!eos)) {  	memoryStream.Position = memoryStream.Length;  	int bytesToRead = (int)(newPosition - memoryStream.Length);  	byte[] buffer = new byte[1024];  	do {  		bytesToRead -= Read (buffer' 0' (bytesToRead >= buffer.Length) ? buffer.Length : bytesToRead);  	} while ((bytesToRead > 0) && (!eos));  }  
Magic Number,FreeImageAPI.IO,StreamWrapper,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\StreamWrapper.cs,Fill,The following statement contains a magic number: if (!eos) {  	memoryStream.Position = memoryStream.Length;  	int bytesRead = 0;  	byte[] buffer = new byte[1024];  	do {  		bytesRead = stream.Read (buffer' 0' buffer.Length);  		memoryStream.Write (buffer' 0' bytesRead);  	} while (bytesRead != 0);  	eos = true;  }  
Missing Default,FreeImageAPI,FreeImageBitmap,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\FreeImageBitmap.cs,RotateFlip,The following switch statement is missing a default case: switch (rotateFlipType) {  case RotateFlipType.RotateNoneFlipX:  	FreeImage.FlipHorizontal (dib);  	break;  case RotateFlipType.RotateNoneFlipY:  	FreeImage.FlipVertical (dib);  	break;  case RotateFlipType.RotateNoneFlipXY:  	FreeImage.FlipHorizontal (dib);  	FreeImage.FlipVertical (dib);  	break;  case RotateFlipType.Rotate90FlipNone:  	newDib = (bpp == 4u) ? FreeImage.Rotate4bit (dib' 90d) : FreeImage.Rotate (dib' 90d);  	break;  case RotateFlipType.Rotate90FlipX:  	newDib = (bpp == 4u) ? FreeImage.Rotate4bit (dib' 90d) : FreeImage.Rotate (dib' 90d);  	FreeImage.FlipHorizontal (newDib);  	break;  case RotateFlipType.Rotate90FlipY:  	newDib = (bpp == 4u) ? FreeImage.Rotate4bit (dib' 90d) : FreeImage.Rotate (dib' 90d);  	FreeImage.FlipVertical (newDib);  	break;  case RotateFlipType.Rotate90FlipXY:  	newDib = (bpp == 4u) ? FreeImage.Rotate4bit (dib' 90d) : FreeImage.Rotate (dib' 90d);  	FreeImage.FlipHorizontal (newDib);  	FreeImage.FlipVertical (newDib);  	break;  case RotateFlipType.Rotate180FlipXY:  	newDib = FreeImage.Clone (dib);  	break;  }  
Missing Default,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPixelFormat,The following switch statement is missing a default case: switch (GetBPP (dib)) {  case 1:  	result = PixelFormat.Format1bppIndexed;  	break;  case 4:  	result = PixelFormat.Format4bppIndexed;  	break;  case 8:  	result = PixelFormat.Format8bppIndexed;  	break;  case 16:  	if ((GetBlueMask (dib) == FI16_565_BLUE_MASK) && (GetGreenMask (dib) == FI16_565_GREEN_MASK) && (GetRedMask (dib) == FI16_565_RED_MASK)) {  		result = PixelFormat.Format16bppRgb565;  	}  	if ((GetBlueMask (dib) == FI16_555_BLUE_MASK) && (GetGreenMask (dib) == FI16_555_GREEN_MASK) && (GetRedMask (dib) == FI16_555_RED_MASK)) {  		result = PixelFormat.Format16bppRgb555;  	}  	break;  case 24:  	result = PixelFormat.Format24bppRgb;  	break;  case 32:  	result = PixelFormat.Format32bppArgb;  	break;  }  
Missing Default,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetFormatParameters,The following switch statement is missing a default case: switch (format) {  case PixelFormat.Format1bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 1;  	result = true;  	break;  case PixelFormat.Format4bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 4;  	result = true;  	break;  case PixelFormat.Format8bppIndexed:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 8;  	result = true;  	break;  case PixelFormat.Format16bppRgb565:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_565_RED_MASK;  	green_mask = FI16_565_GREEN_MASK;  	blue_mask = FI16_565_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppRgb555:  case PixelFormat.Format16bppArgb1555:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 16;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format24bppRgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 24;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format32bppRgb:  case PixelFormat.Format32bppArgb:  case PixelFormat.Format32bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_BITMAP;  	bpp = 32;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	result = true;  	break;  case PixelFormat.Format16bppGrayScale:  	type = FREE_IMAGE_TYPE.FIT_UINT16;  	bpp = 16;  	result = true;  	break;  case PixelFormat.Format48bppRgb:  	type = FREE_IMAGE_TYPE.FIT_RGB16;  	bpp = 48;  	result = true;  	break;  case PixelFormat.Format64bppArgb:  case PixelFormat.Format64bppPArgb:  	type = FREE_IMAGE_TYPE.FIT_RGBA16;  	bpp = 64;  	result = true;  	break;  }  
Missing Default,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetTypeParameters,The following switch statement is missing a default case: switch (bpp) {  case 1:  case 4:  case 8:  	result = true;  	break;  case 16:  	result = true;  	red_mask = FI16_555_RED_MASK;  	green_mask = FI16_555_GREEN_MASK;  	blue_mask = FI16_555_BLUE_MASK;  	break;  case 24:  case 32:  	result = true;  	red_mask = FI_RGBA_RED_MASK;  	green_mask = FI_RGBA_GREEN_MASK;  	blue_mask = FI_RGBA_BLUE_MASK;  	break;  }  
Missing Default,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetUniqueColors,The following switch statement is missing a default case: switch (GetBPP (dib)) {  case 1:  	result = 1;  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		break;  	}  	if ((*(byte*)GetScanLine (dib' 0) & 0x80) == 0) {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) > 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	} else {  		for (int y = 0; y < height; y++) {  			byte* scanline = (byte*)GetScanLine (dib' y);  			int mask = 0x80;  			for (int x = 0; x < width; x++) {  				if ((scanline [x / 8] & mask) == 0) {  					return 2;  				}  				mask = (mask == 0x1) ? 0x80 : (mask >> 1);  			}  		}  	}  	break;  case 4:  	bitArray = new BitArray (0x10);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		bool top = true;  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			if (top) {  				hashcode = lut [scanline [x / 2] >> 4];  			} else {  				hashcode = lut [scanline [x / 2] & 0xF];  			}  			top = !top;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 8:  	bitArray = new BitArray (0x100);  	lut = CreateShrunkenPaletteLUT (dib' out uniquePalEnts);  	if (uniquePalEnts == 1) {  		result = 1;  		break;  	}  	for (int y = 0; (y < height) && (result < uniquePalEnts); y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; (x < width) && (result < uniquePalEnts); x++) {  			hashcode = lut [scanline [x]];  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 16:  	bitArray = new BitArray (0x10000);  	for (int y = 0; y < height; y++) {  		short* scanline = (short*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 24:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		byte* scanline = (byte*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline += 3) {  			hashcode = *((int*)scanline) & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  case 32:  	bitArray = new BitArray (0x1000000);  	for (int y = 0; y < height; y++) {  		int* scanline = (int*)GetScanLine (dib' y);  		for (int x = 0; x < width; x++' scanline++) {  			hashcode = *scanline & 0x00FFFFFF;  			if (!bitArray [hashcode]) {  				bitArray [hashcode] = true;  				result++;  			}  		}  	}  	break;  }  
Missing Default,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,ConvertColorDepth,The following switch statement is missing a default case: switch (conversion & (FREE_IMAGE_COLOR_DEPTH)0xFF) {  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_THRESHOLD:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Threshold (dib' threshold);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Threshold (dib' threshold);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_01_BPP_DITHER:  	if (bpp != 1) {  		if (forceGreyscale) {  			result = Dither (dib' ditherMethod);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 2' null' 1);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = Dither (dib' ditherMethod);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_04_BPP:  	if (bpp != 4) {  		// Special case when 1bpp and FIC_PALETTE  		if (forceGreyscale || ((bpp == 1) && (GetColorType (dib) == FREE_IMAGE_COLOR_TYPE.FIC_PALETTE))) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantizeEx (dibTemp' quantizationMethod' 16' null' 4);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			dibTemp = ConvertToGreyscale (dib);  			result = ConvertTo4Bits (dibTemp);  			Unload (dibTemp);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_08_BPP:  	if (bpp != 8) {  		if (forceGreyscale) {  			result = ConvertToGreyscale (dib);  		} else {  			dibTemp = ConvertTo24Bits (dib);  			result = ColorQuantize (dibTemp' quantizationMethod);  			Unload (dibTemp);  		}  	} else {  		bool isGreyscale = IsGreyscaleImage (dib);  		if ((forceGreyscale && (!isGreyscale)) || (reorderPalette && isGreyscale)) {  			result = ConvertToGreyscale (dib);  		}  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP_555:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits555 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_555_RED_MASK || GetGreenMask (dib) != FI16_555_GREEN_MASK || GetBlueMask (dib) != FI16_555_BLUE_MASK) {  		result = ConvertTo16Bits555 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_16_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo16Bits565 (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 16 || GetRedMask (dib) != FI16_565_RED_MASK || GetGreenMask (dib) != FI16_565_GREEN_MASK || GetBlueMask (dib) != FI16_565_BLUE_MASK) {  		result = ConvertTo16Bits565 (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_24_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo24Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 24) {  		result = ConvertTo24Bits (dib);  	}  	break;  case FREE_IMAGE_COLOR_DEPTH.FICD_32_BPP:  	if (forceGreyscale) {  		dibTemp = ConvertToGreyscale (dib);  		result = ConvertTo32Bits (dibTemp);  		Unload (dibTemp);  	} else if (bpp != 32) {  		result = ConvertTo32Bits (dib);  	}  	break;  }  
Missing Default,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,Rotate4bit,The following switch statement is missing a default case: switch (ang) {  case 90:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	for (int y = 0; y < width; y++) {  		yOrg = height - 1;  		for (int x = 0; x < height; x++' yOrg--) {  			index = src [yOrg] [y];  			dst [y] [x] = index;  		}  	}  	break;  case 180:  	result = Allocate (width' height' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	yOrg = height - 1;  	for (int y = 0; y < height; y++' yOrg--) {  		xOrg = width - 1;  		for (int x = 0; x < width; x++' xOrg--) {  			index = src [yOrg] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 270:  	result = Allocate (height' width' 4' 0' 0' 0);  	if (result.IsNull) {  		break;  	}  	CopyPalette (dib' result);  	src = Get04BitScanlines (dib);  	dst = Get04BitScanlines (result);  	xOrg = width - 1;  	for (int y = 0; y < width; y++' xOrg--) {  		for (int x = 0; x < height; x++) {  			index = src [x] [xOrg];  			dst [y] [x] = index;  		}  	}  	break;  case 0:  case 360:  	result = Clone (dib);  	break;  }  
Missing Default,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetNextColorDepth,The following switch statement is missing a default case: switch (bpp) {  case 1:  	result = 4;  	break;  case 4:  	result = 8;  	break;  case 8:  	result = 16;  	break;  case 16:  	result = 24;  	break;  case 24:  	result = 32;  	break;  }  
Missing Default,FreeImageAPI,FreeImage,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\FreeImageStaticImports.cs,GetPrevousColorDepth,The following switch statement is missing a default case: switch (bpp) {  case 32:  	result = 24;  	break;  case 24:  	result = 16;  	break;  case 16:  	result = 8;  	break;  case 8:  	result = 4;  	break;  case 4:  	result = 1;  	break;  }  
Missing Default,FreeImageAPI.Metadata,MetadataTag,F:\newReposMay17\Afr0_Project-Dollhouse\Other\tools\Bob\Bob\FreeImage\Wrapper\FreeImage.NET\cs\Library\Classes\MetadataTag.cs,CheckType,The following switch statement is missing a default case: switch (type) {  case FREE_IMAGE_MDTYPE.FIDT_ASCII:  	return dataType == typeof(string);  case FREE_IMAGE_MDTYPE.FIDT_BYTE:  	return dataType == typeof(byte);  case FREE_IMAGE_MDTYPE.FIDT_DOUBLE:  	return dataType == typeof(double);  case FREE_IMAGE_MDTYPE.FIDT_FLOAT:  	return dataType == typeof(float);  case FREE_IMAGE_MDTYPE.FIDT_IFD:  	return dataType == typeof(uint);  case FREE_IMAGE_MDTYPE.FIDT_LONG:  	return dataType == typeof(uint);  case FREE_IMAGE_MDTYPE.FIDT_NOTYPE:  	return false;  case FREE_IMAGE_MDTYPE.FIDT_PALETTE:  	return dataType == typeof(RGBQUAD);  case FREE_IMAGE_MDTYPE.FIDT_RATIONAL:  	return dataType == typeof(FIURational);  case FREE_IMAGE_MDTYPE.FIDT_SBYTE:  	return dataType == typeof(sbyte);  case FREE_IMAGE_MDTYPE.FIDT_SHORT:  	return dataType == typeof(ushort);  case FREE_IMAGE_MDTYPE.FIDT_SLONG:  	return dataType == typeof(int);  case FREE_IMAGE_MDTYPE.FIDT_SRATIONAL:  	return dataType == typeof(FIRational);  case FREE_IMAGE_MDTYPE.FIDT_SSHORT:  	return dataType == typeof(short);  case FREE_IMAGE_MDTYPE.FIDT_UNDEFINED:  	return dataType == typeof(byte);  }  
