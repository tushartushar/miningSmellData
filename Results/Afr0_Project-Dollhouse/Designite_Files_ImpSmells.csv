Implementation smell,Namespace,Class,File,Method,Description
Long Method,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The method has 152 lines of code.
Long Method,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The method has 140 lines of code.
Long Method,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The method has 161 lines of code.
Long Method,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The method has 114 lines of code.
Long Method,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The method has 120 lines of code.
Complex Method,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,Cyclomatic complexity of the method is 16
Complex Method,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,Cyclomatic complexity of the method is 13
Complex Method,Files.AudioLogic,HLS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,HLS,Cyclomatic complexity of the method is 10
Complex Method,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,Cyclomatic complexity of the method is 9
Complex Method,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,Cyclomatic complexity of the method is 23
Complex Method,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,Cyclomatic complexity of the method is 16
Complex Method,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GetTexture,Cyclomatic complexity of the method is 8
Complex Method,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GetSound,Cyclomatic complexity of the method is 8
Complex Method,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,Cyclomatic complexity of the method is 40
Complex Method,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,Cyclomatic complexity of the method is 74
Complex Method,Files.IFF,CST,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,Cyclomatic complexity of the method is 32
Complex Method,Files.IFF,CTSS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,Cyclomatic complexity of the method is 32
Complex Method,Files.IFF,DGRP,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,Cyclomatic complexity of the method is 13
Complex Method,Files.IFF,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\Iff.cs,Init,Cyclomatic complexity of the method is 81
Complex Method,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,Cyclomatic complexity of the method is 19
Complex Method,Files.IFF,SPRFrame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPRFrame,Cyclomatic complexity of the method is 33
Complex Method,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,Cyclomatic complexity of the method is 37
Complex Method,Files.IFF,STR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,Cyclomatic complexity of the method is 32
Complex Method,Files.IFF,TTAs,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,Cyclomatic complexity of the method is 32
Complex Method,Files.Vitaboy,Mesh,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Mesh.cs,Mesh,Cyclomatic complexity of the method is 13
Complex Method,Files.Vitaboy,Motion,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Motion.cs,Motion,Cyclomatic complexity of the method is 9
Long Parameter List,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,ArrayCopy2,The method has 5 parameters.
Long Identifier,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,Dispose,The length of the parameter CleanupNativeAndManagedResources is 32.
Long Identifier,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files.AudioLogic,HLS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files.DBPF,DBPFArchive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,Dispose,The length of the parameter CleanupNativeAndManagedResources is 32.
Long Identifier,Files.FAR1,FAR1Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR1\FAR1Archive.cs,Dispose,The length of the parameter CleanupNativeAndManagedResources is 32.
Long Identifier,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Dispose,The length of the parameter CleanUpNativeAndManagedResources is 32.
Long Identifier,Files.Manager,Asset,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\Asset.cs,Dispose,The length of the parameter CleanupNativeAndManagedResources is 32.
Long Statement,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The length of the statement  "					Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f; " is 192.
Long Statement,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The length of the statement  "			m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)]; " is 142.
Long Statement,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,ParseHexString,The length of the statement  "	else if (HexStr.Contains ("a") || HexStr.Contains ("b") || HexStr.Contains ("b") || HexStr.Contains ("c") || HexStr.Contains ("d") || HexStr.Contains ("e") || HexStr.Contains ("f")) { " is 183.
Long Statement,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The length of the statement  "	return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56); " is 124.
Long Statement,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The length of the statement  "				while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) { " is 138.
Long Statement,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The length of the statement  "			using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "gamedata/terrain/" : "gamedata\\terrain\\") + Enum.GetName (typeof(FileIDs.TerrainFileIDs)' ID) + ".tga"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) { " is 222.
Long Statement,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The length of the statement  "			using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "gamedata/terrain/newformat/" : "gamedata\\terrain\\newformat\\") + Enum.GetName (typeof(FileIDs.TerrainFileIDs)' ID) + ".tga"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) { " is 243.
Long Statement,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The length of the statement  "						m_Logger.Error ("FileManager.GrabItem():\n" + "Failed to load TGA from 'gamedata\\terrain\\newformat\\':\n" + E.ToString ()); " is 125.
Long Statement,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The length of the statement  "		using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "cities/" : "cities\\") + Split [0] + "_" + Split [1] + (IsLinux ? "/" : "\\") + Split [2] + ".bmp"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) { " is 216.
Long Statement,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The length of the statement  "		using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "uigraphics/holiday/" : "uigraphics\\holiday\\") + Enum.GetName (typeof(FileIDs.UIFileIDs)' ID) + GetExtension (Enum.GetName (typeof(FileIDs.UIFileIDs)' ID))' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) { " is 274.
Long Statement,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The length of the statement  "		using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "uigraphics/hints/" : "uigraphics\\hints\\") + Enum.GetName (typeof(FileIDs.HintsFileIDs)' ID) + ".bmp"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) { " is 220.
Long Statement,Files.IFF,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\Iff.cs,Init,The length of the statement  "	if (!MagicNumber.Equals ("IFF FILE 2.5:TYPE FOLLOWED BY SIZE\0 JAMIE DOORNBOS & MAXIS 1\0"' StringComparison.InvariantCultureIgnoreCase)) " is 137.
Complex Conditional,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,ParseHexString,The conditional expression  "HexStr.Contains ("a") || HexStr.Contains ("b") || HexStr.Contains ("b") || HexStr.Contains ("c") || HexStr.Contains ("d") || HexStr.Contains ("e") || HexStr.Contains ("f")"  is complex.
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_ID = Convert.ToString (m_Reader.ReadBytes (4));  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_UnreadBitsCount = 8;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits (4));  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_VoicedThreshold = (byte)(32 - ReadBits (4));  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower [0] = (ReadBits (4) + 1) * 8;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: m_InnovationPower [0] = (ReadBits (4) + 1) * 8;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadHeader,The following statement contains a magic number: for (int i = 1; i < 64; i++)  	m_InnovationPower [i] = m_InnovationPower [i - 1] * Base;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadBits,The following statement contains a magic number: if ((m_UnreadBitsCount < 8) && (m_Reader.Position < m_Reader.StreamLength)) {  	m_UnreadBitsValue |= m_Reader.ReadByte () << m_UnreadBitsCount;  	m_UnreadBitsCount += 8;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadBits,The following statement contains a magic number: if ((m_UnreadBitsCount < 8) && (m_Reader.Position < m_Reader.StreamLength)) {  	m_UnreadBitsValue |= m_Reader.ReadByte () << m_UnreadBitsCount;  	m_UnreadBitsCount += 8;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,ReadBits,The following statement contains a magic number: m_UnreadBitsCount += 8;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0) {  	int BlockSize = Lesser ((int)Frames' 432);  	DecodeFrame ();  	for (int i = 0; i < BlockSize; i++) {  		int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  		Value = Clamp<int> (Value' -32768' 32767);  		m_Writer.Write ((ushort)Value);  	}  	Frames -= (uint)BlockSize;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0) {  	int BlockSize = Lesser ((int)Frames' 432);  	DecodeFrame ();  	for (int i = 0; i < BlockSize; i++) {  		int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  		Value = Clamp<int> (Value' -32768' 32767);  		m_Writer.Write ((ushort)Value);  	}  	Frames -= (uint)BlockSize;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0) {  	int BlockSize = Lesser ((int)Frames' 432);  	DecodeFrame ();  	for (int i = 0; i < BlockSize; i++) {  		int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  		Value = Clamp<int> (Value' -32768' 32767);  		m_Writer.Write ((ushort)Value);  	}  	Frames -= (uint)BlockSize;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: while (Frames > 0) {  	int BlockSize = Lesser ((int)Frames' 432);  	DecodeFrame ();  	for (int i = 0; i < BlockSize; i++) {  		int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  		Value = Clamp<int> (Value' -32768' 32767);  		m_Writer.Write ((ushort)Value);  	}  	Frames -= (uint)BlockSize;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: for (int i = 0; i < BlockSize; i++) {  	int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  	Value = Clamp<int> (Value' -32768' 32767);  	m_Writer.Write ((ushort)Value);  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: for (int i = 0; i < BlockSize; i++) {  	int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  	Value = Clamp<int> (Value' -32768' 32767);  	m_Writer.Write ((ushort)Value);  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: for (int i = 0; i < BlockSize; i++) {  	int Value = (int)Math.Round (m_DecompressedFrame [324 + i]);  	Value = Clamp<int> (Value' -32768' 32767);  	m_Writer.Write ((ushort)Value);  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: Value = Clamp<int> (Value' -32768' 32767);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,UTKDecode,The following statement contains a magic number: Value = Clamp<int> (Value' -32768' 32767);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	byte index = ReadBits ((byte)((i < 4) ? 6 : 5));  	if (i == 0 && index < m_VoicedThreshold)  		Voiced = true;  	RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: RCDelta [i] = (UTKCosine [index + ((i < 4) ? 0 : 16)] - m_RC [i]) / 4.0f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int Phase = ReadBits (8);  	if (i == 0 && Phase > 216)  		Phase = 216;  	float PitchGain = (float)(ReadBits (4)) / 15.0f;  	float InnovationGain = m_InnovationPower [ReadBits (6)];  	if (m_HalvedExcitation == false) {  		GenerateExcitation (5' ref Excitation' Voiced' 1);  	} else {  		//Fill the excitation window with half as many samples and interpolate the rest.  		int Alignment = ReadBits (1);  		//whether to fill the even or odd samples.  		bool FillWithZero = (ReadBits (1) != 0);  		int Offset = 5 + (1 - Alignment);  		GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  		if (FillWithZero) {  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = 0.0f;  		} else {  			//Use sinc interpolation with 6 neighboring samples.  			for (int j = Offset; j < Offset + 108; j += 2)  				Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  			InnovationGain /= 2.0f;  		}  	}  	for (int j = 0; j < 108; j++)  		m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (i == 0 && Phase > 216)  	Phase = 216;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (i == 0 && Phase > 216)  	Phase = 216;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Phase = 216;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (m_HalvedExcitation == false) {  	GenerateExcitation (5' ref Excitation' Voiced' 1);  } else {  	//Fill the excitation window with half as many samples and interpolate the rest.  	int Alignment = ReadBits (1);  	//whether to fill the even or odd samples.  	bool FillWithZero = (ReadBits (1) != 0);  	int Offset = 5 + (1 - Alignment);  	GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  	if (FillWithZero) {  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = 0.0f;  	} else {  		//Use sinc interpolation with 6 neighboring samples.  		for (int j = Offset; j < Offset + 108; j += 2)  			Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  		InnovationGain /= 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: GenerateExcitation (5' ref Excitation' Voiced' 1);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: GenerateExcitation (5 + Alignment' ref Excitation' Voiced' 2);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  } else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  } else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  } else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  } else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  } else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  } else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  } else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: if (FillWithZero) {  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = 0.0f;  } else {  	//Use sinc interpolation with 6 neighboring samples.  	for (int j = Offset; j < Offset + 108; j += 2)  		Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  	InnovationGain /= 2.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = 0.0f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = 0.0f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: j += 2
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = Offset; j < Offset + 108; j += 2)  	Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: j += 2
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Excitation [j] = (Excitation [j - 1] + Excitation [j + 1]) * .5973859429f - (Excitation [j - 3] + Excitation [j + 3]) * .1145915613f + (Excitation [j - 5] + Excitation [j + 5]) * .0180326793f;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 108; j++)  	m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: m_DecompressedFrame [324 + 108 * i + j] = InnovationGain * Excitation [5 + j] + PitchGain * m_DecompressedFrame [108 * i + j + (216 - Phase)];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy (m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy (m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Array.Copy (m_DecompressedFrame' 324 + 108' m_DecompressedFrame' 0' 324);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	//Linearly interpolate the reflection coefficients for the current subframe.  	for (int j = 0; j < 12; j++)  		m_RC [j] += RCDelta [j];  	Synthesize (i * 12' (i != 3) ? 12 : 396);  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: for (int j = 0; j < 12; j++)  	m_RC [j] += RCDelta [j];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize (i * 12' (i != 3) ? 12 : 396);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize (i * 12' (i != 3) ? 12 : 396);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize (i * 12' (i != 3) ? 12 : 396);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,DecodeFrame,The following statement contains a magic number: Synthesize (i * 12' (i != 3) ? 12 : 396);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (Voiced) {  	int Table = 0;  	int i = Offset;  	while (i < Offset + 108) {  		byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  		//Table = (code < 2 || code > 8);  		Table = (code < 2 || code > 8) ? 1 : 0;  		ReadBits (m_UTKCodeSkips [code]);  		if (code >= 4) {  			//Fill a sample with a value specified by the code; magnitude is limited to 6.0  			Excitation [i] = (code - 1) / 4;  			if ((code & 1) != 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		} else if (code >= 2) {  			//Fill between 7 and 70 samples with 0s  			int x = ReadBits (6) + 7;  			x = Lesser (x' (Offset + 108 - i) / Interval);  			while (x > 0) {  				Excitation [i] = 0.0f;  				i += Interval;  				x--;  			}  		} else {  			//Fill a sample with a custom value with magnitude >= 7.0  			Excitation [i] = 7.0f;  			while (ReadBits (1) != 0)  				Excitation [i]++;  			if (ReadBits (1) == 0)  				Excitation [i] *= -1.0f;  			i += Interval;  		}  	}  } else {  	//Unvoiced: restrict all samples to 0.0' -2.0' or +2.0 without using the codebook  	for (int i = Offset; i < Offset + 108; i += Interval) {  		if (ReadBits (1) == 0)  			Excitation [i] = 0.0f;  		else if (ReadBits (1) == 0)  			Excitation [i] = -2.0f;  		else  			Excitation [i] = 2.0f;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: while (i < Offset + 108) {  	byte code = UTKCodebook [(Table << 8) | (m_UnreadBitsValue & 0xFF)];  	//Table = (code < 2 || code > 8);  	Table = (code < 2 || code > 8) ? 1 : 0;  	ReadBits (m_UTKCodeSkips [code]);  	if (code >= 4) {  		//Fill a sample with a value specified by the code; magnitude is limited to 6.0  		Excitation [i] = (code - 1) / 4;  		if ((code & 1) != 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	} else if (code >= 2) {  		//Fill between 7 and 70 samples with 0s  		int x = ReadBits (6) + 7;  		x = Lesser (x' (Offset + 108 - i) / Interval);  		while (x > 0) {  			Excitation [i] = 0.0f;  			i += Interval;  			x--;  		}  	} else {  		//Fill a sample with a custom value with magnitude >= 7.0  		Excitation [i] = 7.0f;  		while (ReadBits (1) != 0)  			Excitation [i]++;  		if (ReadBits (1) == 0)  			Excitation [i] *= -1.0f;  		i += Interval;  	}  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: Table = (code < 2 || code > 8) ? 1 : 0;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: Table = (code < 2 || code > 8) ? 1 : 0;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  } else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  } else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  } else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  } else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  } else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 4) {  	//Fill a sample with a value specified by the code; magnitude is limited to 6.0  	Excitation [i] = (code - 1) / 4;  	if ((code & 1) != 0)  		Excitation [i] *= -1.0f;  	i += Interval;  } else if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: Excitation [i] = (code - 1) / 4;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: if (code >= 2) {  	//Fill between 7 and 70 samples with 0s  	int x = ReadBits (6) + 7;  	x = Lesser (x' (Offset + 108 - i) / Interval);  	while (x > 0) {  		Excitation [i] = 0.0f;  		i += Interval;  		x--;  	}  } else {  	//Fill a sample with a custom value with magnitude >= 7.0  	Excitation [i] = 7.0f;  	while (ReadBits (1) != 0)  		Excitation [i]++;  	if (ReadBits (1) == 0)  		Excitation [i] *= -1.0f;  	i += Interval;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: x = Lesser (x' (Offset + 108 - i) / Interval);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,GenerateExcitation,The following statement contains a magic number: for (int i = Offset; i < Offset + 108; i += Interval) {  	if (ReadBits (1) == 0)  		Excitation [i] = 0.0f;  	else if (ReadBits (1) == 0)  		Excitation [i] = -2.0f;  	else  		Excitation [i] = 2.0f;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0) {  	for (int i = 0; i < 12; i++) {  		if (++offset == 12)  			offset = 0;  		m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  	}  	m_History [offset--] = m_DecompressedFrame [324 + Sample++];  	Samples--;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0) {  	for (int i = 0; i < 12; i++) {  		if (++offset == 12)  			offset = 0;  		m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  	}  	m_History [offset--] = m_DecompressedFrame [324 + Sample++];  	Samples--;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0) {  	for (int i = 0; i < 12; i++) {  		if (++offset == 12)  			offset = 0;  		m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  	}  	m_History [offset--] = m_DecompressedFrame [324 + Sample++];  	Samples--;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: while (Samples > 0) {  	for (int i = 0; i < 12; i++) {  		if (++offset == 12)  			offset = 0;  		m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  	}  	m_History [offset--] = m_DecompressedFrame [324 + Sample++];  	Samples--;  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	if (++offset == 12)  		offset = 0;  	m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	if (++offset == 12)  		offset = 0;  	m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: for (int i = 0; i < 12; i++) {  	if (++offset == 12)  		offset = 0;  	m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: if (++offset == 12)  	offset = 0;  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: m_DecompressedFrame [324 + Sample] += LPC [i] * m_History [offset];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,Synthesize,The following statement contains a magic number: m_History [offset--] = m_DecompressedFrame [324 + Sample++];  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: Array.Copy (RC' 0' RCTemp' 1' 11);  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++) {  	LPC [i] = 0.0f;  	for (j = 11; j >= 0; j--) {  		LPC [i] -= RC [j] * RCTemp [j];  		if (j != 11)  			RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  	}  	RCTemp [0] = LPCTemp [i] = LPC [i];  	for (j = 0; j < i; j++)  		LPC [i] -= LPCTemp [i - j - 1] * LPC [j];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++) {  	LPC [i] = 0.0f;  	for (j = 11; j >= 0; j--) {  		LPC [i] -= RC [j] * RCTemp [j];  		if (j != 11)  			RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  	}  	RCTemp [0] = LPCTemp [i] = LPC [i];  	for (j = 0; j < i; j++)  		LPC [i] -= LPCTemp [i - j - 1] * LPC [j];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (i = 0; i < 12; i++) {  	LPC [i] = 0.0f;  	for (j = 11; j >= 0; j--) {  		LPC [i] -= RC [j] * RCTemp [j];  		if (j != 11)  			RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  	}  	RCTemp [0] = LPCTemp [i] = LPC [i];  	for (j = 0; j < i; j++)  		LPC [i] -= LPCTemp [i - j - 1] * LPC [j];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (j = 11; j >= 0; j--) {  	LPC [i] -= RC [j] * RCTemp [j];  	if (j != 11)  		RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: for (j = 11; j >= 0; j--) {  	LPC [i] -= RC [j] * RCTemp [j];  	if (j != 11)  		RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  }  
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: j = 11
Magic Number,Files.AudioFiles,UTKFile2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\UTKFile2.cs,RCtoLPC,The following statement contains a magic number: if (j != 11)  	RCTemp [j + 1] = RCTemp [j] + RC [j] * LPC [i];  
Magic Number,Files.AudioFiles,WavFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\WavFile.cs,ReadHeader,The following statement contains a magic number: m_ChunkID = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  
Magic Number,Files.AudioFiles,WavFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\WavFile.cs,ReadHeader,The following statement contains a magic number: if (m_ChunkID.Equals ("RIFF"' StringComparison.InvariantCultureIgnoreCase)) {  	m_ChunkSize = m_Reader.ReadUInt32 ();  	m_FormatTag = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  	if (!m_FormatTag.Equals ("WAVE"' StringComparison.InvariantCultureIgnoreCase))  		throw new Exception ("WavFile.cs: Not a proper wav file!");  	m_SubChunk1ID = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  	m_SubChunk1Size = m_Reader.ReadUInt32 ();  	m_AudioFormat = m_Reader.ReadUShort ();  	m_NumChannels = m_Reader.ReadUShort ();  	m_SampleRate = m_Reader.ReadUInt32 ();  	m_ByteRate = m_Reader.ReadUInt32 ();  	m_BlockAlign = m_Reader.ReadUShort ();  	m_BitsPerSample = m_Reader.ReadUShort ();  	m_SubChunk2ID = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  	m_Subchunk2Size = m_Reader.ReadUInt32 ();  }  
Magic Number,Files.AudioFiles,WavFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\WavFile.cs,ReadHeader,The following statement contains a magic number: if (m_ChunkID.Equals ("RIFF"' StringComparison.InvariantCultureIgnoreCase)) {  	m_ChunkSize = m_Reader.ReadUInt32 ();  	m_FormatTag = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  	if (!m_FormatTag.Equals ("WAVE"' StringComparison.InvariantCultureIgnoreCase))  		throw new Exception ("WavFile.cs: Not a proper wav file!");  	m_SubChunk1ID = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  	m_SubChunk1Size = m_Reader.ReadUInt32 ();  	m_AudioFormat = m_Reader.ReadUShort ();  	m_NumChannels = m_Reader.ReadUShort ();  	m_SampleRate = m_Reader.ReadUInt32 ();  	m_ByteRate = m_Reader.ReadUInt32 ();  	m_BlockAlign = m_Reader.ReadUShort ();  	m_BitsPerSample = m_Reader.ReadUShort ();  	m_SubChunk2ID = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  	m_Subchunk2Size = m_Reader.ReadUInt32 ();  }  
Magic Number,Files.AudioFiles,WavFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\WavFile.cs,ReadHeader,The following statement contains a magic number: if (m_ChunkID.Equals ("RIFF"' StringComparison.InvariantCultureIgnoreCase)) {  	m_ChunkSize = m_Reader.ReadUInt32 ();  	m_FormatTag = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  	if (!m_FormatTag.Equals ("WAVE"' StringComparison.InvariantCultureIgnoreCase))  		throw new Exception ("WavFile.cs: Not a proper wav file!");  	m_SubChunk1ID = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  	m_SubChunk1Size = m_Reader.ReadUInt32 ();  	m_AudioFormat = m_Reader.ReadUShort ();  	m_NumChannels = m_Reader.ReadUShort ();  	m_SampleRate = m_Reader.ReadUInt32 ();  	m_ByteRate = m_Reader.ReadUInt32 ();  	m_BlockAlign = m_Reader.ReadUShort ();  	m_BitsPerSample = m_Reader.ReadUShort ();  	m_SubChunk2ID = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  	m_Subchunk2Size = m_Reader.ReadUInt32 ();  }  
Magic Number,Files.AudioFiles,WavFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\WavFile.cs,ReadHeader,The following statement contains a magic number: m_FormatTag = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  
Magic Number,Files.AudioFiles,WavFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\WavFile.cs,ReadHeader,The following statement contains a magic number: m_SubChunk1ID = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  
Magic Number,Files.AudioFiles,WavFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\WavFile.cs,ReadHeader,The following statement contains a magic number: m_SubChunk2ID = Encoding.ASCII.GetString (m_Reader.ReadBytes (4));  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = Convert.ToString (m_Reader.ReadBytes (4));  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,LoadFile,The following statement contains a magic number: m_ID = Convert.ToString (m_Reader.ReadBytes (4));  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressFile,The following statement contains a magic number: if (m_Channels == 1)//Mono   {  	while (m_Reader.Position < m_Reader.StreamLength) {  		DecompressMono (m_Reader.ReadBytes (0xF));  	}  } else if (m_Channels == 2)//Stereo   {  	while (m_Reader.Position < m_Reader.StreamLength) {  		DecompressStereo (m_Reader.ReadBytes (0x1E));  	}  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressFile,The following statement contains a magic number: if (m_Channels == 2)//Stereo   {  	while (m_Reader.Position < m_Reader.StreamLength) {  		DecompressStereo (m_Reader.ReadBytes (0x1E));  	}  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2left = (int)EATable [HINIBBLE (bInput) + 4];  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: dleft = (byte)(LONIBBLE (bInput) + 8);  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: c2right = (int)EATable [HINIBBLE (bInput) + 4];  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: dright = (byte)(LONIBBLE (bInput) + 8);  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: for (i = 2; i < 0x1E; i += 2) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = HINIBBLE (InputBuffer [i + 1]);  	// HIGHER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	//Output((SHORT)lCurSampleLeft'(SHORT)lCurSampleRight); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  	// now do just the same for LOWER nibbles...  	// note that nubbles for each channel are packed pairwise into one byte  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	right = LONIBBLE (InputBuffer [i + 1]);  	// LOWER nibble for right channel  	right = (right << 0x1c) >> dright;  	right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  	right = Clip16BitSample (right);  	m_PrevSampleRight = m_CurSampleRight;  	m_CurSampleRight = right;  	// Now we've got lCurSampleLeft and lCurSampleRight which form one stereo  	// sample and all is set for the next step...  	m_Writer.Write ((short)m_CurSampleLeft);  	m_Writer.Write ((short)m_CurSampleRight);  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: i = 2
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: i += 2
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressStereo,The following statement contains a magic number: right = (right + m_CurSampleRight * c1right + m_PrevSampleRight * c2right + 0x80) >> 8;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressMono,The following statement contains a magic number: d = (byte)(LONIBBLE (bInput) + 8);  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressMono,The following statement contains a magic number: c2left = (int)EATable [HINIBBLE (bInput) + 4];  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressMono,The following statement contains a magic number: dleft = (byte)(LONIBBLE (bInput) + 8);  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressMono,The following statement contains a magic number: for (i = 1; i < 0xF; i++) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	// Now we've got lCurSampleLeft which is one mono sample and all is set  	// for the next input nibble...  	//Output((SHORT)lCurSampleLeft); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	// Now we've got lCurSampleLeft which is one mono sample and all is set  	// for the next input byte...  	//Output((SHORT)lCurSampleLeft); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressMono,The following statement contains a magic number: for (i = 1; i < 0xF; i++) {  	left = HINIBBLE (InputBuffer [i]);  	// HIGHER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	// Now we've got lCurSampleLeft which is one mono sample and all is set  	// for the next input nibble...  	//Output((SHORT)lCurSampleLeft); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  	left = LONIBBLE (InputBuffer [i]);  	// LOWER nibble for left channel  	left = (left << 0x1c) >> dleft;  	left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  	left = Clip16BitSample (left);  	m_PrevSampleLeft = m_CurSampleLeft;  	m_CurSampleLeft = left;  	// Now we've got lCurSampleLeft which is one mono sample and all is set  	// for the next input byte...  	//Output((SHORT)lCurSampleLeft); // send the sample to output  	m_Writer.Write ((short)m_CurSampleLeft);  }  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressMono,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,DecompressMono,The following statement contains a magic number: left = (left + m_CurSampleLeft * c1left + m_PrevSampleLeft * c2left + 0x80) >> 8;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)  	return 32767;  else if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)  	return 32767;  else if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)  	return 32767;  else if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample > 32767)  	return 32767;  else if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: return 32767;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: if (sample < -32768)  	return (-32768);  else  	return sample;  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,Clip16BitSample,The following statement contains a magic number: return (-32768);  
Magic Number,Files.AudioFiles,XAFile,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioFiles\XAFile.cs,HINIBBLE,The following statement contains a magic number: return (byte)(((B) >> 4) & 0x0F);  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach (string TrckEvent in TrackEvents) {  	string[] Elements = TrckEvent.Split (''');  	TrackEvent Event = new TrackEvent ();  	Event.Name = Elements [0];  	Event.EventType = (HITEvents)Enum.ToObject (typeof(HITEvents)' ParseHexString (Elements [1]));  	Event.TrackID = (Elements [2].Equals (""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse (Elements [2].Replace ("0x"' "")' NumberStyles.HexNumber);  	Event.Unknown = ParseHexString (Elements [3]);  	Event.Unknown2 = ParseHexString (Elements [4]);  	Event.Unknown3 = ParseHexString (Elements [5]);  	Event.Unknown4 = ParseHexString (Elements [6]);  	Events.Add (Event);  }  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach (string TrckEvent in TrackEvents) {  	string[] Elements = TrckEvent.Split (''');  	TrackEvent Event = new TrackEvent ();  	Event.Name = Elements [0];  	Event.EventType = (HITEvents)Enum.ToObject (typeof(HITEvents)' ParseHexString (Elements [1]));  	Event.TrackID = (Elements [2].Equals (""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse (Elements [2].Replace ("0x"' "")' NumberStyles.HexNumber);  	Event.Unknown = ParseHexString (Elements [3]);  	Event.Unknown2 = ParseHexString (Elements [4]);  	Event.Unknown3 = ParseHexString (Elements [5]);  	Event.Unknown4 = ParseHexString (Elements [6]);  	Events.Add (Event);  }  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach (string TrckEvent in TrackEvents) {  	string[] Elements = TrckEvent.Split (''');  	TrackEvent Event = new TrackEvent ();  	Event.Name = Elements [0];  	Event.EventType = (HITEvents)Enum.ToObject (typeof(HITEvents)' ParseHexString (Elements [1]));  	Event.TrackID = (Elements [2].Equals (""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse (Elements [2].Replace ("0x"' "")' NumberStyles.HexNumber);  	Event.Unknown = ParseHexString (Elements [3]);  	Event.Unknown2 = ParseHexString (Elements [4]);  	Event.Unknown3 = ParseHexString (Elements [5]);  	Event.Unknown4 = ParseHexString (Elements [6]);  	Events.Add (Event);  }  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach (string TrckEvent in TrackEvents) {  	string[] Elements = TrckEvent.Split (''');  	TrackEvent Event = new TrackEvent ();  	Event.Name = Elements [0];  	Event.EventType = (HITEvents)Enum.ToObject (typeof(HITEvents)' ParseHexString (Elements [1]));  	Event.TrackID = (Elements [2].Equals (""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse (Elements [2].Replace ("0x"' "")' NumberStyles.HexNumber);  	Event.Unknown = ParseHexString (Elements [3]);  	Event.Unknown2 = ParseHexString (Elements [4]);  	Event.Unknown3 = ParseHexString (Elements [5]);  	Event.Unknown4 = ParseHexString (Elements [6]);  	Events.Add (Event);  }  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach (string TrckEvent in TrackEvents) {  	string[] Elements = TrckEvent.Split (''');  	TrackEvent Event = new TrackEvent ();  	Event.Name = Elements [0];  	Event.EventType = (HITEvents)Enum.ToObject (typeof(HITEvents)' ParseHexString (Elements [1]));  	Event.TrackID = (Elements [2].Equals (""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse (Elements [2].Replace ("0x"' "")' NumberStyles.HexNumber);  	Event.Unknown = ParseHexString (Elements [3]);  	Event.Unknown2 = ParseHexString (Elements [4]);  	Event.Unknown3 = ParseHexString (Elements [5]);  	Event.Unknown4 = ParseHexString (Elements [6]);  	Events.Add (Event);  }  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: foreach (string TrckEvent in TrackEvents) {  	string[] Elements = TrckEvent.Split (''');  	TrackEvent Event = new TrackEvent ();  	Event.Name = Elements [0];  	Event.EventType = (HITEvents)Enum.ToObject (typeof(HITEvents)' ParseHexString (Elements [1]));  	Event.TrackID = (Elements [2].Equals (""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse (Elements [2].Replace ("0x"' "")' NumberStyles.HexNumber);  	Event.Unknown = ParseHexString (Elements [3]);  	Event.Unknown2 = ParseHexString (Elements [4]);  	Event.Unknown3 = ParseHexString (Elements [5]);  	Event.Unknown4 = ParseHexString (Elements [6]);  	Events.Add (Event);  }  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: Event.TrackID = (Elements [2].Equals (""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse (Elements [2].Replace ("0x"' "")' NumberStyles.HexNumber);  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: Event.TrackID = (Elements [2].Equals (""' StringComparison.InvariantCultureIgnoreCase)) ? 0 : uint.Parse (Elements [2].Replace ("0x"' "")' NumberStyles.HexNumber);  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: Event.Unknown = ParseHexString (Elements [3]);  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: Event.Unknown2 = ParseHexString (Elements [4]);  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: Event.Unknown3 = ParseHexString (Elements [5]);  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,EVT,The following statement contains a magic number: Event.Unknown4 = ParseHexString (Elements [6]);  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,ParseHexString,The following statement contains a magic number: if (HexStr.StartsWith ("0x")) {  	HexStr = HexStr.Substring (2);  	IsHex = true;  } //Sigh' Maxis...  else if (HexStr.Contains ("a") || HexStr.Contains ("b") || HexStr.Contains ("b") || HexStr.Contains ("c") || HexStr.Contains ("d") || HexStr.Contains ("e") || HexStr.Contains ("f")) {  	IsHex = true;  }  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,ParseHexString,The following statement contains a magic number: HexStr = HexStr.Substring (2);  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,ParseHexString,The following statement contains a magic number: if (IsHex) {  	return Convert.ToUInt32 (HexStr' 16);  } else {  	return Convert.ToUInt32 (HexStr);  }  
Magic Number,Files.AudioLogic,EVT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\EVT.cs,ParseHexString,The following statement contains a magic number: return Convert.ToUInt32 (HexStr' 16);  
Magic Number,Files.AudioLogic,HLS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,HLS,The following statement contains a magic number: try {  	if (Unknown == 1)//First format  	 {  		if ((m_Reader.StreamLength - m_Reader.Position) > 4)//... because sometimes it will just end here D:  		 {  			uint Count = m_Reader.ReadUInt32 ();  			for (int i = 0; i < Count; i++)  				SoundsAndHitlists.Add (m_Reader.ReadUInt32 ());  		}  	} else {  		string Str = m_Reader.ReadString ((int)Unknown).Replace ("\n"' "");  		string[] SplitByComma = Str.Split (''');  		for (int i = 0; i < SplitByComma.Length; i++) {  			string[] SplitByDash = SplitByComma [i].Split ('-');  			if (SplitByDash.Length > 1) {  				uint Min = Convert.ToUInt32 (SplitByDash [0]);  				uint Max = Convert.ToUInt32 (SplitByDash [1]);  				for (uint j = Min; j <= Max; j++)  					SoundsAndHitlists.Add (j);  			} else  				SoundsAndHitlists.Add (Convert.ToUInt32 (SplitByComma [i]));  		}  	}  } catch {  	m_Reader.Seek (4);  	for (int i = 0; i < Unknown; i++)  		SoundsAndHitlists.Add (m_Reader.ReadUInt32 ());  	m_Reader.Close ();  }  
Magic Number,Files.AudioLogic,HLS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,HLS,The following statement contains a magic number: try {  	if (Unknown == 1)//First format  	 {  		if ((m_Reader.StreamLength - m_Reader.Position) > 4)//... because sometimes it will just end here D:  		 {  			uint Count = m_Reader.ReadUInt32 ();  			for (int i = 0; i < Count; i++)  				SoundsAndHitlists.Add (m_Reader.ReadUInt32 ());  		}  	} else {  		string Str = m_Reader.ReadString ((int)Unknown).Replace ("\n"' "");  		string[] SplitByComma = Str.Split (''');  		for (int i = 0; i < SplitByComma.Length; i++) {  			string[] SplitByDash = SplitByComma [i].Split ('-');  			if (SplitByDash.Length > 1) {  				uint Min = Convert.ToUInt32 (SplitByDash [0]);  				uint Max = Convert.ToUInt32 (SplitByDash [1]);  				for (uint j = Min; j <= Max; j++)  					SoundsAndHitlists.Add (j);  			} else  				SoundsAndHitlists.Add (Convert.ToUInt32 (SplitByComma [i]));  		}  	}  } catch {  	m_Reader.Seek (4);  	for (int i = 0; i < Unknown; i++)  		SoundsAndHitlists.Add (m_Reader.ReadUInt32 ());  	m_Reader.Close ();  }  
Magic Number,Files.AudioLogic,HLS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,HLS,The following statement contains a magic number: if (Unknown == 1)//First format   {  	if ((m_Reader.StreamLength - m_Reader.Position) > 4)//... because sometimes it will just end here D:  	 {  		uint Count = m_Reader.ReadUInt32 ();  		for (int i = 0; i < Count; i++)  			SoundsAndHitlists.Add (m_Reader.ReadUInt32 ());  	}  } else {  	string Str = m_Reader.ReadString ((int)Unknown).Replace ("\n"' "");  	string[] SplitByComma = Str.Split (''');  	for (int i = 0; i < SplitByComma.Length; i++) {  		string[] SplitByDash = SplitByComma [i].Split ('-');  		if (SplitByDash.Length > 1) {  			uint Min = Convert.ToUInt32 (SplitByDash [0]);  			uint Max = Convert.ToUInt32 (SplitByDash [1]);  			for (uint j = Min; j <= Max; j++)  				SoundsAndHitlists.Add (j);  		} else  			SoundsAndHitlists.Add (Convert.ToUInt32 (SplitByComma [i]));  	}  }  
Magic Number,Files.AudioLogic,HLS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,HLS,The following statement contains a magic number: if ((m_Reader.StreamLength - m_Reader.Position) > 4)//... because sometimes it will just end here D:   {  	uint Count = m_Reader.ReadUInt32 ();  	for (int i = 0; i < Count; i++)  		SoundsAndHitlists.Add (m_Reader.ReadUInt32 ());  }  
Magic Number,Files.AudioLogic,HLS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\HLS.cs,HLS,The following statement contains a magic number: m_Reader.Seek (4);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: TrackName = Elements [2];  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [3].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	SoundID = uint.Parse (Elements [3].Replace ("0x"' "")' NumberStyles.HexNumber);  else  	SoundID = 0;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [3].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	SoundID = uint.Parse (Elements [3].Replace ("0x"' "")' NumberStyles.HexNumber);  else  	SoundID = 0;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: SoundID = uint.Parse (Elements [3].Replace ("0x"' "")' NumberStyles.HexNumber);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (Elements [5].Equals ("\r\n"' StringComparison.InvariantCultureIgnoreCase))  	return;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [5].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Argument = (HITTrackArguments)Enum.Parse (typeof(HITTrackArguments)' Elements [5]);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [5].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Argument = (HITTrackArguments)Enum.Parse (typeof(HITTrackArguments)' Elements [5]);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: Argument = (HITTrackArguments)Enum.Parse (typeof(HITTrackArguments)' Elements [5]);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [7].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	ControlGroup = (HITControlGroup)Enum.Parse (typeof(HITControlGroup)' Elements [7]);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [7].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	ControlGroup = (HITControlGroup)Enum.Parse (typeof(HITControlGroup)' Elements [7]);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: ControlGroup = (HITControlGroup)Enum.Parse (typeof(HITControlGroup)' Elements [7]);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 11 : 12].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	DuckingPriority = int.Parse (Elements [(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 11 : 12].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	DuckingPriority = int.Parse (Elements [(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 11 : 12].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	DuckingPriority = int.Parse (Elements [(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 11 : 12].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	DuckingPriority = int.Parse (Elements [(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 11 : 12].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	DuckingPriority = int.Parse (Elements [(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 11 : 12].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	DuckingPriority = int.Parse (Elements [(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: DuckingPriority = int.Parse (Elements [(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: DuckingPriority = int.Parse (Elements [(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: DuckingPriority = int.Parse (Elements [(m_Version != 2) ? 11 : 12]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 12 : 13].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Looped = (int.Parse (Elements [(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 12 : 13].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Looped = (int.Parse (Elements [(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 12 : 13].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Looped = (int.Parse (Elements [(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 12 : 13].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Looped = (int.Parse (Elements [(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 12 : 13].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Looped = (int.Parse (Elements [(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 12 : 13].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Looped = (int.Parse (Elements [(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: Looped = (int.Parse (Elements [(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: Looped = (int.Parse (Elements [(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: Looped = (int.Parse (Elements [(m_Version != 2) ? 12 : 13]' NumberStyles.Integer) != 0) ? true : false;  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 13 : 14].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Volume = int.Parse (Elements [(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 13 : 14].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Volume = int.Parse (Elements [(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 13 : 14].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Volume = int.Parse (Elements [(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 13 : 14].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Volume = int.Parse (Elements [(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 13 : 14].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Volume = int.Parse (Elements [(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: if (!Elements [(m_Version != 2) ? 13 : 14].Equals (""' StringComparison.InvariantCultureIgnoreCase))  	Volume = int.Parse (Elements [(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: Volume = int.Parse (Elements [(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: Volume = int.Parse (Elements [(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);  
Magic Number,Files.AudioLogic,TRK,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\AudioLogic\TRK.cs,TRK,The following statement contains a magic number: Volume = int.Parse (Elements [(m_Version != 2) ? 13 : 14]' NumberStyles.Integer);  
Magic Number,Files.DBPF,DBPFArchive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (4));  	if (!MagicNumber.Equals ("DBPF"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new DBPFException ("MagicNumber was wrong - DBPFArchive.cs!");  		else {  			m_Reader.Close ();  			return false;  		}  	}  	m_Reader.ReadUInt32 ();  	//MajorVersion  	m_Reader.ReadUInt32 ();  	//MinorVersion  	m_Reader.ReadBytes (12);  	//Reserved.  	m_Reader.ReadBytes (4);  	//Date created.  	m_Reader.ReadBytes (4);  	//Date modified.  	m_Reader.ReadUInt32 ();  	//Index major version.  	IndexEntryCount = m_Reader.ReadUInt32 ();  	IndexOffset = m_Reader.ReadUInt32 ();  	IndexSize = m_Reader.ReadUInt32 ();  	m_Reader.Seek (IndexOffset);  	for (int i = 0; i < IndexEntryCount; i++) {  		DBPFEntry Entry = new DBPFEntry ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.GroupID = m_Reader.ReadUInt32 ();  		Entry.InstanceID = m_Reader.ReadUInt32 ();  		Entry.FileOffset = m_Reader.ReadUInt32 ();  		Entry.FileSize = m_Reader.ReadUInt32 ();  		UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.InstanceID' Entry.GroupID);  		Entry.EntryID = ID;  		m_Entries.Add (ID' Entry);  	}  }  
Magic Number,Files.DBPF,DBPFArchive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (4));  	if (!MagicNumber.Equals ("DBPF"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new DBPFException ("MagicNumber was wrong - DBPFArchive.cs!");  		else {  			m_Reader.Close ();  			return false;  		}  	}  	m_Reader.ReadUInt32 ();  	//MajorVersion  	m_Reader.ReadUInt32 ();  	//MinorVersion  	m_Reader.ReadBytes (12);  	//Reserved.  	m_Reader.ReadBytes (4);  	//Date created.  	m_Reader.ReadBytes (4);  	//Date modified.  	m_Reader.ReadUInt32 ();  	//Index major version.  	IndexEntryCount = m_Reader.ReadUInt32 ();  	IndexOffset = m_Reader.ReadUInt32 ();  	IndexSize = m_Reader.ReadUInt32 ();  	m_Reader.Seek (IndexOffset);  	for (int i = 0; i < IndexEntryCount; i++) {  		DBPFEntry Entry = new DBPFEntry ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.GroupID = m_Reader.ReadUInt32 ();  		Entry.InstanceID = m_Reader.ReadUInt32 ();  		Entry.FileOffset = m_Reader.ReadUInt32 ();  		Entry.FileSize = m_Reader.ReadUInt32 ();  		UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.InstanceID' Entry.GroupID);  		Entry.EntryID = ID;  		m_Entries.Add (ID' Entry);  	}  }  
Magic Number,Files.DBPF,DBPFArchive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (4));  	if (!MagicNumber.Equals ("DBPF"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new DBPFException ("MagicNumber was wrong - DBPFArchive.cs!");  		else {  			m_Reader.Close ();  			return false;  		}  	}  	m_Reader.ReadUInt32 ();  	//MajorVersion  	m_Reader.ReadUInt32 ();  	//MinorVersion  	m_Reader.ReadBytes (12);  	//Reserved.  	m_Reader.ReadBytes (4);  	//Date created.  	m_Reader.ReadBytes (4);  	//Date modified.  	m_Reader.ReadUInt32 ();  	//Index major version.  	IndexEntryCount = m_Reader.ReadUInt32 ();  	IndexOffset = m_Reader.ReadUInt32 ();  	IndexSize = m_Reader.ReadUInt32 ();  	m_Reader.Seek (IndexOffset);  	for (int i = 0; i < IndexEntryCount; i++) {  		DBPFEntry Entry = new DBPFEntry ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.GroupID = m_Reader.ReadUInt32 ();  		Entry.InstanceID = m_Reader.ReadUInt32 ();  		Entry.FileOffset = m_Reader.ReadUInt32 ();  		Entry.FileSize = m_Reader.ReadUInt32 ();  		UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.InstanceID' Entry.GroupID);  		Entry.EntryID = ID;  		m_Entries.Add (ID' Entry);  	}  }  
Magic Number,Files.DBPF,DBPFArchive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (4));  	if (!MagicNumber.Equals ("DBPF"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new DBPFException ("MagicNumber was wrong - DBPFArchive.cs!");  		else {  			m_Reader.Close ();  			return false;  		}  	}  	m_Reader.ReadUInt32 ();  	//MajorVersion  	m_Reader.ReadUInt32 ();  	//MinorVersion  	m_Reader.ReadBytes (12);  	//Reserved.  	m_Reader.ReadBytes (4);  	//Date created.  	m_Reader.ReadBytes (4);  	//Date modified.  	m_Reader.ReadUInt32 ();  	//Index major version.  	IndexEntryCount = m_Reader.ReadUInt32 ();  	IndexOffset = m_Reader.ReadUInt32 ();  	IndexSize = m_Reader.ReadUInt32 ();  	m_Reader.Seek (IndexOffset);  	for (int i = 0; i < IndexEntryCount; i++) {  		DBPFEntry Entry = new DBPFEntry ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.GroupID = m_Reader.ReadUInt32 ();  		Entry.InstanceID = m_Reader.ReadUInt32 ();  		Entry.FileOffset = m_Reader.ReadUInt32 ();  		Entry.FileSize = m_Reader.ReadUInt32 ();  		UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.InstanceID' Entry.GroupID);  		Entry.EntryID = ID;  		m_Entries.Add (ID' Entry);  	}  }  
Magic Number,Files.DBPF,DBPFArchive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: m_Reader.ReadBytes (12);  
Magic Number,Files.DBPF,DBPFArchive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: m_Reader.ReadBytes (4);  
Magic Number,Files.DBPF,DBPFArchive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\DBPF\DBPFArchive.cs,ReadArchive,The following statement contains a magic number: m_Reader.ReadBytes (4);  
Magic Number,Files,Endian,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,Files,Endian,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Endian.cs,SwapInt16,The following statement contains a magic number: return (short)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,Files,Endian,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,Files,Endian,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Endian.cs,SwapUInt16,The following statement contains a magic number: return (ushort)(((v & 0xff) << 8) | ((v >> 8) & 0xff));  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt16,The following statement contains a magic number: return (short)(b [1] + (b [0] << 8));  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b [3] + (b [2] << 8) + (b [1] << 16) + (b [0] << 24);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b [3] + (b [2] << 8) + (b [1] << 16) + (b [0] << 24);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b [3] + (b [2] << 8) + (b [1] << 16) + (b [0] << 24);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b [3] + (b [2] << 8) + (b [1] << 16) + (b [0] << 24);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt32,The following statement contains a magic number: return b [3] + (b [2] << 8) + (b [1] << 16) + (b [0] << 24);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files,FileReader,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileReader.cs,ReadBigEndianInt64,The following statement contains a magic number: return b [7] + (b [6] << 8) + (b [5] << 16) + (b [4] << 24) + (b [3] << 32) + (b [2] << 40) + (b [1] << 48) + (b [0] << 56);  
Magic Number,Files.FAR1,FAR1Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR1\FAR1Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (8));  	if (!MagicNumber.Equals ("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new FAR1Exception ("MagicNumber was wrong - FAR1Archive.cs!");  		else {  			m_Reader.Close ();  			return;  		}  	}  	m_Reader.ReadUInt32 ();  	//Version.  	m_Reader.Seek (m_Reader.ReadUInt32 ());  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		FAR1Entry Entry = new FAR1Entry ();  		Entry.CompressedDataSize = m_Reader.ReadUInt32 ();  		Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.FilenameLength = m_Reader.ReadUShort ();  		Entry.FilenameHash = FileUtilities.GenerateHash (Enc.GetString (m_Reader.ReadBytes (Entry.FilenameLength)));  		m_Entries.Add (Entry);  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (Data.Length > 6) {  	// some Compression Data  	const int MAX_OFFSET = 0x20000;  	const int MAX_COPY_COUNT = 0x404;  	// used to finetune the lookup (small values increase the  	// compression for Big Files)  	const int QFS_MAXITER = 0x80;  	// contains the latest offset for a combination of two  	// characters  	Dictionary<int' ArrayList> cmpmap2 = new Dictionary<int' ArrayList> ();  	// will contain the compressed data (maximal size =  	// uncompressedSize+MAX_COPY_COUNT)  	byte[] cData = new byte[Data.Length + MAX_COPY_COUNT];  	// init some vars  	int writeIndex = 9;  	// leave 9 bytes for the header  	int lastReadIndex = 0;  	ArrayList indexList = null;  	int copyOffset = 0;  	int copyCount = 0;  	int index = -1;  	bool end = false;  	// begin main compression loop  	while (index < Data.Length - 3) {  		// get all Compression Candidates (list of offsets for all  		// occurances of the current 3 bytes)  		do {  			index++;  			if (index >= Data.Length - 2) {  				end = true;  				break;  			}  			int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  			indexList = cmpmap2 [mapindex];  			if (indexList == null) {  				indexList = new ArrayList ();  				cmpmap2.Add (mapindex' indexList);  			}  			indexList.Add (index);  		} while (index < lastReadIndex);  		if (end)  			break;  		// find the longest repeating byte sequence in the index  		// List (for offset copy)  		int offsetCopyCount = 0;  		int loopcount = 1;  		while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  			int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  			if ((index - foundindex) >= MAX_OFFSET) {  				break;  			}  			loopcount++;  			copyCount = 3;  			while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  				copyCount++;  			}  			if (copyCount > offsetCopyCount) {  				offsetCopyCount = copyCount;  				copyOffset = index - foundindex;  			}  		}  		// check if we can compress this  		// In FSH Tool stand additionally this:  		if (offsetCopyCount > Data.Length - index) {  			offsetCopyCount = index - Data.Length;  		}  		if (offsetCopyCount <= 2) {  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  			// 1024  			offsetCopyCount = 0;  		} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  			// 16384  			offsetCopyCount = 0;  		}  		// this is offset-compressable? so do the compression  		if (offsetCopyCount > 0) {  			// plaincopy  			// In FSH Tool stand this (A):  			while (index - lastReadIndex >= 4) {  				copyCount = (index - lastReadIndex) / 4 - 1;  				if (copyCount > 0x1B) {  					copyCount = 0x1B;  				}  				cData [writeIndex++] = (byte)(0xE0 + copyCount);  				copyCount = 4 * copyCount + 4;  				ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  				lastReadIndex += copyCount;  				writeIndex += copyCount;  			}  			// offsetcopy  			copyCount = index - lastReadIndex;  			copyOffset--;  			if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  				cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  				cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  				cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  			} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  				cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  				cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  				cData [writeIndex++] = (byte)(copyOffset & 0xff);  				cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  			}  			// do the offset copy  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			writeIndex += copyCount;  			lastReadIndex += copyCount;  			lastReadIndex += offsetCopyCount;  		}  	}  	// add the End Record  	index = Data.Length;  	// in FSH Tool stand the same as above (A)  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B)  			copyCount = 0x1B;  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	copyCount = index - lastReadIndex;  	cData [writeIndex++] = (byte)(0xfc + copyCount);  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	MemoryStream DataStream = new MemoryStream ();  	BinaryWriter Writer = new BinaryWriter (DataStream);  	// write the header for the compressed data  	// set the compressed size  	Writer.Write ((uint)writeIndex);  	m_CompressedSize = writeIndex;  	// set the MAGICNUMBER  	Writer.Write ((ushort)0xFB10);  	// set the decompressed size  	byte[] revData = BitConverter.GetBytes (Data.Length);  	Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  	Writer.Write (cData);  	//Avoid nasty swearing here!  	Writer.Flush ();  	m_DecompressedSize = Data.Length;  	return DataStream.ToArray ();  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index < Data.Length - 3) {  	// get all Compression Candidates (list of offsets for all  	// occurances of the current 3 bytes)  	do {  		index++;  		if (index >= Data.Length - 2) {  			end = true;  			break;  		}  		int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  		indexList = cmpmap2 [mapindex];  		if (indexList == null) {  			indexList = new ArrayList ();  			cmpmap2.Add (mapindex' indexList);  		}  		indexList.Add (index);  	} while (index < lastReadIndex);  	if (end)  		break;  	// find the longest repeating byte sequence in the index  	// List (for offset copy)  	int offsetCopyCount = 0;  	int loopcount = 1;  	while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  		int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  		if ((index - foundindex) >= MAX_OFFSET) {  			break;  		}  		loopcount++;  		copyCount = 3;  		while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  			copyCount++;  		}  		if (copyCount > offsetCopyCount) {  			offsetCopyCount = copyCount;  			copyOffset = index - foundindex;  		}  	}  	// check if we can compress this  	// In FSH Tool stand additionally this:  	if (offsetCopyCount > Data.Length - index) {  		offsetCopyCount = index - Data.Length;  	}  	if (offsetCopyCount <= 2) {  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  		// 1024  		offsetCopyCount = 0;  	} else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  		// 16384  		offsetCopyCount = 0;  	}  	// this is offset-compressable? so do the compression  	if (offsetCopyCount > 0) {  		// plaincopy  		// In FSH Tool stand this (A):  		while (index - lastReadIndex >= 4) {  			copyCount = (index - lastReadIndex) / 4 - 1;  			if (copyCount > 0x1B) {  				copyCount = 0x1B;  			}  			cData [writeIndex++] = (byte)(0xE0 + copyCount);  			copyCount = 4 * copyCount + 4;  			ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  			lastReadIndex += copyCount;  			writeIndex += copyCount;  		}  		// offsetcopy  		copyCount = index - lastReadIndex;  		copyOffset--;  		if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  			cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  			cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  			cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  		} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  			cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  			cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  			cData [writeIndex++] = (byte)(copyOffset & 0xff);  			cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  		}  		// do the offset copy  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		writeIndex += copyCount;  		lastReadIndex += copyCount;  		lastReadIndex += offsetCopyCount;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: do {  	index++;  	if (index >= Data.Length - 2) {  		end = true;  		break;  	}  	int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  	indexList = cmpmap2 [mapindex];  	if (indexList == null) {  		indexList = new ArrayList ();  		cmpmap2.Add (mapindex' indexList);  	}  	indexList.Add (index);  } while (index < lastReadIndex);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: do {  	index++;  	if (index >= Data.Length - 2) {  		end = true;  		break;  	}  	int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  	indexList = cmpmap2 [mapindex];  	if (indexList == null) {  		indexList = new ArrayList ();  		cmpmap2.Add (mapindex' indexList);  	}  	indexList.Add (index);  } while (index < lastReadIndex);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: do {  	index++;  	if (index >= Data.Length - 2) {  		end = true;  		break;  	}  	int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  	indexList = cmpmap2 [mapindex];  	if (indexList == null) {  		indexList = new ArrayList ();  		cmpmap2.Add (mapindex' indexList);  	}  	indexList.Add (index);  } while (index < lastReadIndex);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: do {  	index++;  	if (index >= Data.Length - 2) {  		end = true;  		break;  	}  	int mapindex = Data [index] + (Data [index + 1] << 8) + (Data [index + 2] << 16);  	indexList = cmpmap2 [mapindex];  	if (indexList == null) {  		indexList = new ArrayList ();  		cmpmap2.Add (mapindex' indexList);  	}  	indexList.Add (index);  } while (index < lastReadIndex);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (index >= Data.Length - 2) {  	end = true;  	break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while ((loopcount < indexList.Count) && (loopcount < QFS_MAXITER)) {  	int foundindex = (int)indexList [(indexList.Count - 1) - loopcount];  	if ((index - foundindex) >= MAX_OFFSET) {  		break;  	}  	loopcount++;  	copyCount = 3;  	while ((Data.Length > index + copyCount) && (Data [index + copyCount] == Data [foundindex + copyCount]) && (copyCount < MAX_COPY_COUNT)) {  		copyCount++;  	}  	if (copyCount > offsetCopyCount) {  		offsetCopyCount = copyCount;  		copyOffset = index - foundindex;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 3;  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount <= 2) {  	offsetCopyCount = 0;  } else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  } else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount <= 2) {  	offsetCopyCount = 0;  } else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  } else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount <= 2) {  	offsetCopyCount = 0;  } else if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  } else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  } else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount == 3) && (copyOffset > 0x400)) {  	// 1024  	offsetCopyCount = 0;  } else if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount == 4) && (copyOffset > 0x4000)) {  	// 16384  	offsetCopyCount = 0;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if (offsetCopyCount > 0) {  	// plaincopy  	// In FSH Tool stand this (A):  	while (index - lastReadIndex >= 4) {  		copyCount = (index - lastReadIndex) / 4 - 1;  		if (copyCount > 0x1B) {  			copyCount = 0x1B;  		}  		cData [writeIndex++] = (byte)(0xE0 + copyCount);  		copyCount = 4 * copyCount + 4;  		ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  		lastReadIndex += copyCount;  		writeIndex += copyCount;  	}  	// offsetcopy  	copyCount = index - lastReadIndex;  	copyOffset--;  	if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  		cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  		cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  		cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  	} else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  		cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  		cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  		cData [writeIndex++] = (byte)(copyOffset & 0xff);  		cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  	}  	// do the offset copy  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	writeIndex += copyCount;  	lastReadIndex += copyCount;  	lastReadIndex += offsetCopyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B) {  		copyCount = 0x1B;  	}  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B) {  		copyCount = 0x1B;  	}  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B) {  		copyCount = 0x1B;  	}  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B) {  		copyCount = 0x1B;  	}  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = (index - lastReadIndex) / 4 - 1;  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x0A) && (copyOffset < 0x400)) {  	cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(((copyOffset >> 8) << 5) + ((offsetCopyCount - 3) << 2) + copyCount);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= 0x43) && (copyOffset < 0x4000)) {  	cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  	cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  } else if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0x80 + (offsetCopyCount - 4));  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)((copyCount << 6) + (copyOffset >> 8));  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: if ((offsetCopyCount <= MAX_COPY_COUNT) && (copyOffset < MAX_OFFSET)) {  	cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  	cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  	cData [writeIndex++] = (byte)(copyOffset & 0xff);  	cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)(0xc0 + ((copyOffset >> 16) << 4) + (((offsetCopyCount - 5) >> 8) << 2) + copyCount);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)((copyOffset >> 8) & 0xff);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: cData [writeIndex++] = (byte)((offsetCopyCount - 5) & 0xff);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B)  		copyCount = 0x1B;  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B)  		copyCount = 0x1B;  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B)  		copyCount = 0x1B;  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: while (index - lastReadIndex >= 4) {  	copyCount = (index - lastReadIndex) / 4 - 1;  	if (copyCount > 0x1B)  		copyCount = 0x1B;  	cData [writeIndex++] = (byte)(0xE0 + copyCount);  	copyCount = 4 * copyCount + 4;  	ArrayCopy2 (Data' lastReadIndex' ref cData' writeIndex' copyCount);  	lastReadIndex += copyCount;  	writeIndex += copyCount;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = (index - lastReadIndex) / 4 - 1;  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: copyCount = 4 * copyCount + 4;  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Compress,The following statement contains a magic number: Writer.Write ((revData [2] << 16) | (revData [1] << 8) | revData [0]);  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Data.Length > 6) {  	byte[] DecompressedData = new byte[(int)m_DecompressedSize];  	int DataPos = 0;  	int Pos = 0;  	long Control1 = 0;  	while (Control1 != 0xFC && Pos < Data.Length) {  		Control1 = Data [Pos];  		Pos++;  		if (Pos == Data.Length)  			break;  		if (Control1 >= 0 && Control1 <= 127) {  			// 0x00 - 0x7F  			long control2 = Data [Pos];  			Pos++;  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if ((Control1 >= 128 && Control1 <= 191)) {  			// 0x80 - 0xBF  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long numberOfPlainText = (control2 >> 6) & 0x03;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  			long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 192 && Control1 <= 223) {  			// 0xC0 - 0xDF  			long numberOfPlainText = (Control1 & 0x03);  			long control2 = Data [Pos];  			Pos++;  			long control3 = Data [Pos];  			Pos++;  			long control4 = Data [Pos];  			Pos++;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  			int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  			long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  			OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  			DataPos += (int)numberToCopyFromOffset;  			if (DataPos == (DecompressedData.Length))  				break;  		} else if (Control1 >= 224 && Control1 <= 251) {  			// 0xE0 - 0xFB  			long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		} else {  			long numberOfPlainText = (Control1 & 0x03);  			ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  			DataPos += (int)numberOfPlainText;  			Pos += (int)numberOfPlainText;  			if (DataPos == (DecompressedData.Length))  				break;  		}  	}  	return DecompressedData;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: while (Control1 != 0xFC && Pos < Data.Length) {  	Control1 = Data [Pos];  	Pos++;  	if (Pos == Data.Length)  		break;  	if (Control1 >= 0 && Control1 <= 127) {  		// 0x00 - 0x7F  		long control2 = Data [Pos];  		Pos++;  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if ((Control1 >= 128 && Control1 <= 191)) {  		// 0x80 - 0xBF  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long numberOfPlainText = (control2 >> 6) & 0x03;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  		long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 192 && Control1 <= 223) {  		// 0xC0 - 0xDF  		long numberOfPlainText = (Control1 & 0x03);  		long control2 = Data [Pos];  		Pos++;  		long control3 = Data [Pos];  		Pos++;  		long control4 = Data [Pos];  		Pos++;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  		int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  		long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  		OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  		DataPos += (int)numberToCopyFromOffset;  		if (DataPos == (DecompressedData.Length))  			break;  	} else if (Control1 >= 224 && Control1 <= 251) {  		// 0xE0 - 0xFB  		long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	} else {  		long numberOfPlainText = (Control1 & 0x03);  		ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  		DataPos += (int)numberOfPlainText;  		Pos += (int)numberOfPlainText;  		if (DataPos == (DecompressedData.Length))  			break;  	}  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 0 && Control1 <= 127) {  	// 0x00 - 0x7F  	long control2 = Data [Pos];  	Pos++;  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x60) << 3) + (control2) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x1C) >> 2) + 3;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if ((Control1 >= 128 && Control1 <= 191)) {  	// 0x80 - 0xBF  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long numberOfPlainText = (control2 >> 6) & 0x03;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((control2 & 0x3F) << 8) + (control3) + 1);  	long numberToCopyFromOffset = (Control1 & 0x3F) + 4;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 192 && Control1 <= 223) {  	// 0xC0 - 0xDF  	long numberOfPlainText = (Control1 & 0x03);  	long control2 = Data [Pos];  	Pos++;  	long control3 = Data [Pos];  	Pos++;  	long control4 = Data [Pos];  	Pos++;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  	int offset = (int)(((Control1 & 0x10) << 12) + (control2 << 8) + (control3) + 1);  	long numberToCopyFromOffset = ((Control1 & 0x0C) << 6) + (control4) + 5;  	OffsetCopy (ref DecompressedData' offset' DataPos' numberToCopyFromOffset);  	DataPos += (int)numberToCopyFromOffset;  	if (DataPos == (DecompressedData.Length))  		break;  } else if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,Decompresser,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\Decompresser.cs,Decompress,The following statement contains a magic number: if (Control1 >= 224 && Control1 <= 251) {  	// 0xE0 - 0xFB  	long numberOfPlainText = ((Control1 & 0x1F) << 2) + 4;  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  } else {  	long numberOfPlainText = (Control1 & 0x03);  	ArrayCopy2 (Data' Pos' ref DecompressedData' DataPos' numberOfPlainText);  	DataPos += (int)numberOfPlainText;  	Pos += (int)numberOfPlainText;  	if (DataPos == (DecompressedData.Length))  		break;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (8));  	if (!MagicNumber.Equals ("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new FAR3Exception ("MagicNumber was wrong - FAR3Archive.cs!");  		else {  			m_Reader.Close ();  			return false;  		}  	}  	m_Reader.ReadUInt32 ();  	//Version.  	m_Reader.Seek ((long)m_Reader.ReadUInt32 ());  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		FAR3Entry Entry = new FAR3Entry ();  		Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		m_Reader.ReadByte ();  		//Unknown.  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Flags = m_Reader.ReadUShort ();  		Entry.FileNameLength = m_Reader.ReadUShort ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Enc.GetString (m_Reader.ReadBytes (Entry.FileNameLength));  		UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.FileID);  		if (!m_Entries.ContainsKey (ID.UniqueID))  			m_Entries.AddOrUpdate (ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (8));  	if (!MagicNumber.Equals ("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new FAR3Exception ("MagicNumber was wrong - FAR3Archive.cs!");  		else {  			m_Reader.Close ();  			return false;  		}  	}  	m_Reader.ReadUInt32 ();  	//Version.  	m_Reader.Seek ((long)m_Reader.ReadUInt32 ());  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		FAR3Entry Entry = new FAR3Entry ();  		Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		m_Reader.ReadByte ();  		//Unknown.  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Flags = m_Reader.ReadUShort ();  		Entry.FileNameLength = m_Reader.ReadUShort ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Enc.GetString (m_Reader.ReadBytes (Entry.FileNameLength));  		UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.FileID);  		if (!m_Entries.ContainsKey (ID.UniqueID))  			m_Entries.AddOrUpdate (ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (8));  	if (!MagicNumber.Equals ("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new FAR3Exception ("MagicNumber was wrong - FAR3Archive.cs!");  		else {  			m_Reader.Close ();  			return false;  		}  	}  	m_Reader.ReadUInt32 ();  	//Version.  	m_Reader.Seek ((long)m_Reader.ReadUInt32 ());  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		FAR3Entry Entry = new FAR3Entry ();  		Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		m_Reader.ReadByte ();  		//Unknown.  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Flags = m_Reader.ReadUShort ();  		Entry.FileNameLength = m_Reader.ReadUShort ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Enc.GetString (m_Reader.ReadBytes (Entry.FileNameLength));  		UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.FileID);  		if (!m_Entries.ContainsKey (ID.UniqueID))  			m_Entries.AddOrUpdate (ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (8));  	if (!MagicNumber.Equals ("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new FAR3Exception ("MagicNumber was wrong - FAR3Archive.cs!");  		else {  			m_Reader.Close ();  			return false;  		}  	}  	m_Reader.ReadUInt32 ();  	//Version.  	m_Reader.Seek ((long)m_Reader.ReadUInt32 ());  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		FAR3Entry Entry = new FAR3Entry ();  		Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		m_Reader.ReadByte ();  		//Unknown.  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Flags = m_Reader.ReadUShort ();  		Entry.FileNameLength = m_Reader.ReadUShort ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Enc.GetString (m_Reader.ReadBytes (Entry.FileNameLength));  		UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.FileID);  		if (!m_Entries.ContainsKey (ID.UniqueID))  			m_Entries.AddOrUpdate (ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: lock (m_Reader) {  	ASCIIEncoding Enc = new ASCIIEncoding ();  	string MagicNumber = Enc.GetString (m_Reader.ReadBytes (8));  	if (!MagicNumber.Equals ("FAR!byAZ"' StringComparison.InvariantCultureIgnoreCase)) {  		if (ThrowException)  			throw new FAR3Exception ("MagicNumber was wrong - FAR3Archive.cs!");  		else {  			m_Reader.Close ();  			return false;  		}  	}  	m_Reader.ReadUInt32 ();  	//Version.  	m_Reader.Seek ((long)m_Reader.ReadUInt32 ());  	uint NumFiles = m_Reader.ReadUInt32 ();  	for (int i = 0; i < NumFiles; i++) {  		FAR3Entry Entry = new FAR3Entry ();  		Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  		byte[] Dummy = m_Reader.ReadBytes (3);  		Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  		m_Reader.ReadByte ();  		//Unknown.  		Entry.DataOffset = m_Reader.ReadUInt32 ();  		Entry.Flags = m_Reader.ReadUShort ();  		Entry.FileNameLength = m_Reader.ReadUShort ();  		Entry.TypeID = m_Reader.ReadUInt32 ();  		Entry.FileID = m_Reader.ReadUInt32 ();  		Entry.Filename = Enc.GetString (m_Reader.ReadBytes (Entry.FileNameLength));  		UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.FileID);  		if (!m_Entries.ContainsKey (ID.UniqueID))  			m_Entries.AddOrUpdate (ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++) {  	FAR3Entry Entry = new FAR3Entry ();  	Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  	byte[] Dummy = m_Reader.ReadBytes (3);  	Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  	m_Reader.ReadByte ();  	//Unknown.  	Entry.DataOffset = m_Reader.ReadUInt32 ();  	Entry.Flags = m_Reader.ReadUShort ();  	Entry.FileNameLength = m_Reader.ReadUShort ();  	Entry.TypeID = m_Reader.ReadUInt32 ();  	Entry.FileID = m_Reader.ReadUInt32 ();  	Entry.Filename = Enc.GetString (m_Reader.ReadBytes (Entry.FileNameLength));  	UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.FileID);  	if (!m_Entries.ContainsKey (ID.UniqueID))  		m_Entries.AddOrUpdate (ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++) {  	FAR3Entry Entry = new FAR3Entry ();  	Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  	byte[] Dummy = m_Reader.ReadBytes (3);  	Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  	m_Reader.ReadByte ();  	//Unknown.  	Entry.DataOffset = m_Reader.ReadUInt32 ();  	Entry.Flags = m_Reader.ReadUShort ();  	Entry.FileNameLength = m_Reader.ReadUShort ();  	Entry.TypeID = m_Reader.ReadUInt32 ();  	Entry.FileID = m_Reader.ReadUInt32 ();  	Entry.Filename = Enc.GetString (m_Reader.ReadBytes (Entry.FileNameLength));  	UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.FileID);  	if (!m_Entries.ContainsKey (ID.UniqueID))  		m_Entries.AddOrUpdate (ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++) {  	FAR3Entry Entry = new FAR3Entry ();  	Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  	byte[] Dummy = m_Reader.ReadBytes (3);  	Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  	m_Reader.ReadByte ();  	//Unknown.  	Entry.DataOffset = m_Reader.ReadUInt32 ();  	Entry.Flags = m_Reader.ReadUShort ();  	Entry.FileNameLength = m_Reader.ReadUShort ();  	Entry.TypeID = m_Reader.ReadUInt32 ();  	Entry.FileID = m_Reader.ReadUInt32 ();  	Entry.Filename = Enc.GetString (m_Reader.ReadBytes (Entry.FileNameLength));  	UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.FileID);  	if (!m_Entries.ContainsKey (ID.UniqueID))  		m_Entries.AddOrUpdate (ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: for (int i = 0; i < NumFiles; i++) {  	FAR3Entry Entry = new FAR3Entry ();  	Entry.DecompressedDataSize = m_Reader.ReadUInt32 ();  	byte[] Dummy = m_Reader.ReadBytes (3);  	Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  	m_Reader.ReadByte ();  	//Unknown.  	Entry.DataOffset = m_Reader.ReadUInt32 ();  	Entry.Flags = m_Reader.ReadUShort ();  	Entry.FileNameLength = m_Reader.ReadUShort ();  	Entry.TypeID = m_Reader.ReadUInt32 ();  	Entry.FileID = m_Reader.ReadUInt32 ();  	Entry.Filename = Enc.GetString (m_Reader.ReadBytes (Entry.FileNameLength));  	UniqueFileID ID = new UniqueFileID (Entry.TypeID' Entry.FileID);  	if (!m_Entries.ContainsKey (ID.UniqueID))  		m_Entries.AddOrUpdate (ID.UniqueID' Entry' (Key' ExistingValue) => ExistingValue = Entry);  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,ReadArchive,The following statement contains a magic number: Entry.CompressedDataSize = (uint)((Dummy [0] << 0) | (Dummy [1] << 8) | (Dummy [2]) << 16);  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: lock (m_Reader) {  	m_Reader.Seek ((long)Entry.DataOffset);  	switch (Entry.TypeID) {  	case 1:  	//BMP  	case 2:  	//TGA  	case 5:  	//SKEL  	case 7:  	//ANIM  	case 9:  	//MESH  	case 11:  	//BND  	case 12:  	//APR  	case 13:  	//OFT  	case 15:  	//PO  	case 16:  	//COL  	case 18:  	//HAG  	case 20:  	//JPG  	case 24:  		//PNG  		return Decompress (Entry);  	case 14:  	//PNG' uncompressed  	default:  		MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  		MemStream.Seek (0' SeekOrigin.Begin);  		return MemStream;  	}  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,GrabEntry,The following statement contains a magic number: switch (Entry.TypeID) {  case 1:  //BMP  case 2:  //TGA  case 5:  //SKEL  case 7:  //ANIM  case 9:  //MESH  case 11:  //BND  case 12:  //APR  case 13:  //OFT  case 15:  //PO  case 16:  //COL  case 18:  //HAG  case 20:  //JPG  case 24:  	//PNG  	return Decompress (Entry);  case 14:  //PNG' uncompressed  default:  	MemoryStream MemStream = new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Decompress,The following statement contains a magic number: m_Reader.ReadBytes (9);  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Decompress,The following statement contains a magic number: if (CompressionID == 0xFB10) {  	byte[] Dummy = m_Reader.ReadBytes (3);  	uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  	Decompresser Dec = new Decompresser ();  	Dec.CompressedSize = CompressedSize;  	Dec.DecompressedSize = DecompressedSize;  	byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)CompressedSize));  	MemoryStream MemStream = new MemoryStream (DecompressedData);  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  } else {  	m_Reader.Seek (m_Reader.Position - 15);  	return new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Decompress,The following statement contains a magic number: if (CompressionID == 0xFB10) {  	byte[] Dummy = m_Reader.ReadBytes (3);  	uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  	Decompresser Dec = new Decompresser ();  	Dec.CompressedSize = CompressedSize;  	Dec.DecompressedSize = DecompressedSize;  	byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)CompressedSize));  	MemoryStream MemStream = new MemoryStream (DecompressedData);  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  } else {  	m_Reader.Seek (m_Reader.Position - 15);  	return new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Decompress,The following statement contains a magic number: if (CompressionID == 0xFB10) {  	byte[] Dummy = m_Reader.ReadBytes (3);  	uint DecompressedSize = (uint)((Dummy [0] << 0x10) | (Dummy [1] << 0x08) | +Dummy [2]);  	Decompresser Dec = new Decompresser ();  	Dec.CompressedSize = CompressedSize;  	Dec.DecompressedSize = DecompressedSize;  	byte[] DecompressedData = Dec.Decompress (m_Reader.ReadBytes ((int)CompressedSize));  	MemoryStream MemStream = new MemoryStream (DecompressedData);  	MemStream.Seek (0' SeekOrigin.Begin);  	return MemStream;  } else {  	m_Reader.Seek (m_Reader.Position - 15);  	return new MemoryStream (m_Reader.ReadBytes ((int)Entry.DecompressedDataSize));  }  
Magic Number,Files.FAR3,FAR3Archive,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FAR3\FAR3Archive.cs,Decompress,The following statement contains a magic number: m_Reader.Seek (m_Reader.Position - 15);  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: foreach (FAR3Archive Archive in m_FAR3Archives) {  	if (Archive.ContainsEntry (ID)) {  		Stream Data = Archive.GrabEntry (ID);  		if (!m_Assets.ContainsKey (ID)) {  			switch (TypeID) {  			case FAR3TypeIDs.ANIM:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  				break;  			case FAR3TypeIDs.APR:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  				break;  			case FAR3TypeIDs.BND:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  				break;  			case FAR3TypeIDs.COL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  				break;  			case FAR3TypeIDs.HAG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  				break;  			case FAR3TypeIDs.MESH:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  				break;  			case FAR3TypeIDs.OFT:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  				break;  			case FAR3TypeIDs.PO:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  				break;  			case FAR3TypeIDs.SKEL:  				AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  				break;  			case FAR3TypeIDs.TGA:  				lock (MemStream) {  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  				break;  			case FAR3TypeIDs.PNG:  			case FAR3TypeIDs.PackedPNG:  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				break;  			case FAR3TypeIDs.JPG:  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						BMap.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch {  					try {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					} catch (Exception)//Most likely a TGA' sigh.  					 {  						MemStream = new MemoryStream ();  						using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  							TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							TGA.Dispose ();  							MemStream.Seek (0' SeekOrigin.Begin);  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						}  					}  				}  				break;  			case FAR3TypeIDs.BMP:  				if (IsBMP (Data)) {  					lock (MemStream) {  						try {  							using (BMap = new Bitmap (Data)) {  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  								BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  								BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  								MemStream.Seek (0' SeekOrigin.Begin);  							}  							AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  						} catch (Exception) {  							MemStream.Dispose ();  							AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  						}  					}  				} else {  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  				break;  			}  		}  		return Data;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Archive.ContainsEntry (ID)) {  	Stream Data = Archive.GrabEntry (ID);  	if (!m_Assets.ContainsKey (ID)) {  		switch (TypeID) {  		case FAR3TypeIDs.ANIM:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  			break;  		case FAR3TypeIDs.APR:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  			break;  		case FAR3TypeIDs.BND:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  			break;  		case FAR3TypeIDs.COL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  			break;  		case FAR3TypeIDs.HAG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  			break;  		case FAR3TypeIDs.MESH:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  			break;  		case FAR3TypeIDs.OFT:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  			break;  		case FAR3TypeIDs.PO:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  			break;  		case FAR3TypeIDs.SKEL:  			AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  			break;  		case FAR3TypeIDs.TGA:  			lock (MemStream) {  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  			break;  		case FAR3TypeIDs.PNG:  		case FAR3TypeIDs.PackedPNG:  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			break;  		case FAR3TypeIDs.JPG:  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					BMap.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch {  				try {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				} catch (Exception)//Most likely a TGA' sigh.  				 {  					MemStream = new MemoryStream ();  					using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  						TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						TGA.Dispose ();  						MemStream.Seek (0' SeekOrigin.Begin);  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					}  				}  			}  			break;  		case FAR3TypeIDs.BMP:  			if (IsBMP (Data)) {  				lock (MemStream) {  					try {  						using (BMap = new Bitmap (Data)) {  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  							BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  							BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  							MemStream.Seek (0' SeekOrigin.Begin);  						}  						AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  					} catch (Exception) {  						MemStream.Dispose ();  						AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  					}  				}  			} else {  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  			break;  		}  	}  	return Data;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (!m_Assets.ContainsKey (ID)) {  	switch (TypeID) {  	case FAR3TypeIDs.ANIM:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  		break;  	case FAR3TypeIDs.APR:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  		break;  	case FAR3TypeIDs.BND:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  		break;  	case FAR3TypeIDs.COL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  		break;  	case FAR3TypeIDs.HAG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  		break;  	case FAR3TypeIDs.MESH:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  		break;  	case FAR3TypeIDs.OFT:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  		break;  	case FAR3TypeIDs.PO:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  		break;  	case FAR3TypeIDs.SKEL:  		AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  		break;  	case FAR3TypeIDs.TGA:  		lock (MemStream) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  		break;  	case FAR3TypeIDs.PNG:  	case FAR3TypeIDs.PackedPNG:  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		break;  	case FAR3TypeIDs.JPG:  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				BMap.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch {  			try {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			} catch (Exception)//Most likely a TGA' sigh.  			 {  				MemStream = new MemoryStream ();  				using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  					TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					TGA.Dispose ();  					MemStream.Seek (0' SeekOrigin.Begin);  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				}  			}  		}  		break;  	case FAR3TypeIDs.BMP:  		if (IsBMP (Data)) {  			lock (MemStream) {  				try {  					using (BMap = new Bitmap (Data)) {  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  						BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  						BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  						MemStream.Seek (0' SeekOrigin.Begin);  					}  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception) {  					MemStream.Dispose ();  					AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  				}  			}  		} else {  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  		break;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		BMap.Dispose ();  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch {  	try {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	} catch (Exception)//Most likely a TGA' sigh.  	 {  		MemStream = new MemoryStream ();  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			TGA.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		BMap.Dispose ();  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch {  	try {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	} catch (Exception)//Most likely a TGA' sigh.  	 {  		MemStream = new MemoryStream ();  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			TGA.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		BMap.Dispose ();  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch {  	try {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	} catch (Exception)//Most likely a TGA' sigh.  	 {  		MemStream = new MemoryStream ();  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			TGA.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		BMap.Dispose ();  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch {  	try {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	} catch (Exception)//Most likely a TGA' sigh.  	 {  		MemStream = new MemoryStream ();  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			TGA.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		BMap.Dispose ();  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch {  	try {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	} catch (Exception)//Most likely a TGA' sigh.  	 {  		MemStream = new MemoryStream ();  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			TGA.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		BMap.Dispose ();  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch {  	try {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	} catch (Exception)//Most likely a TGA' sigh.  	 {  		MemStream = new MemoryStream ();  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			TGA.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		BMap.Dispose ();  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch {  	try {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	} catch (Exception)//Most likely a TGA' sigh.  	 {  		MemStream = new MemoryStream ();  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			TGA.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	BMap.Dispose ();  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	BMap.Dispose ();  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	BMap.Dispose ();  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	BMap.Dispose ();  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	BMap.Dispose ();  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	BMap.Dispose ();  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	BMap.Dispose ();  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (IsBMP (Data)) {  	lock (MemStream) {  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch (Exception) {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  	}  } else {  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (IsBMP (Data)) {  	lock (MemStream) {  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch (Exception) {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  	}  } else {  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (IsBMP (Data)) {  	lock (MemStream) {  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch (Exception) {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  	}  } else {  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (IsBMP (Data)) {  	lock (MemStream) {  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch (Exception) {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  	}  } else {  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (IsBMP (Data)) {  	lock (MemStream) {  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch (Exception) {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  	}  } else {  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (IsBMP (Data)) {  	lock (MemStream) {  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch (Exception) {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  	}  } else {  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (IsBMP (Data)) {  	lock (MemStream) {  		try {  			using (BMap = new Bitmap (Data)) {  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  				BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  				BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  			}  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch (Exception) {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		}  	}  } else {  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: lock (MemStream) {  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch (Exception) {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: lock (MemStream) {  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch (Exception) {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: lock (MemStream) {  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch (Exception) {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: lock (MemStream) {  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch (Exception) {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: lock (MemStream) {  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch (Exception) {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: lock (MemStream) {  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch (Exception) {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: lock (MemStream) {  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch (Exception) {  		MemStream.Dispose ();  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch (Exception) {  	MemStream.Dispose ();  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch (Exception) {  	MemStream.Dispose ();  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch (Exception) {  	MemStream.Dispose ();  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch (Exception) {  	MemStream.Dispose ();  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch (Exception) {  	MemStream.Dispose ();  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch (Exception) {  	MemStream.Dispose ();  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: try {  	using (BMap = new Bitmap (Data)) {  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  		BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  } catch (Exception) {  	MemStream.Dispose ();  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (BMap = new Bitmap (Data)) {  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  	BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  	BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  	MemStream.Seek (0' SeekOrigin.Begin);  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Enum.IsDefined (typeof(FileIDs.TerrainFileIDs)' ID)) {  	if (Enum.GetName (typeof(FileIDs.TerrainFileIDs)' ID).Contains ("road")) {  		using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "gamedata/terrain/" : "gamedata\\terrain\\") + Enum.GetName (typeof(FileIDs.TerrainFileIDs)' ID) + ".tga"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (FS)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	} else {  		using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "gamedata/terrain/newformat/" : "gamedata\\terrain\\newformat\\") + Enum.GetName (typeof(FileIDs.TerrainFileIDs)' ID) + ".tga"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (FS)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				MemStream.Seek (0' SeekOrigin.Begin);  				try {  					AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  				} catch (Exception E) {  					m_Logger.Error ("FileManager.GrabItem():\n" + "Failed to load TGA from 'gamedata\\terrain\\newformat\\':\n" + E.ToString ());  				}  			}  		}  	}  	return MemStream;  } else if (Enum.IsDefined (typeof(FileIDs.CitiesFileIDs)' ID)) {  	string[] Split = Enum.GetName (typeof(FileIDs.CitiesFileIDs)' ID).Split ("_".ToCharArray ());  	using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "cities/" : "cities\\") + Split [0] + "_" + Split [1] + (IsLinux ? "/" : "\\") + Split [2] + ".bmp"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {  		using (BMap = new Bitmap (FS)) {  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		try {  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch (Exception E) {  			m_Logger.Error ("FileManager.GrabItem():\n" + "Failed to load BMP from 'cities\\':\n" + E.ToString ());  		}  		return MemStream;  	}  } else if (Enum.IsDefined (typeof(FileIDs.UIFileIDs)' ID)) {  	using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "uigraphics/holiday/" : "uigraphics\\holiday\\") + Enum.GetName (typeof(FileIDs.UIFileIDs)' ID) + GetExtension (Enum.GetName (typeof(FileIDs.UIFileIDs)' ID))' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {  		using (BMap = new Bitmap (FS)) {  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		return MemStream;  	}  } else if (Enum.IsDefined (typeof(FileIDs.HintsFileIDs)' ID)) {  	using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "uigraphics/hints/" : "uigraphics\\hints\\") + Enum.GetName (typeof(FileIDs.HintsFileIDs)' ID) + ".bmp"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {  		using (BMap = new Bitmap (FS)) {  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		return MemStream;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: if (Enum.IsDefined (typeof(FileIDs.CitiesFileIDs)' ID)) {  	string[] Split = Enum.GetName (typeof(FileIDs.CitiesFileIDs)' ID).Split ("_".ToCharArray ());  	using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "cities/" : "cities\\") + Split [0] + "_" + Split [1] + (IsLinux ? "/" : "\\") + Split [2] + ".bmp"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {  		using (BMap = new Bitmap (FS)) {  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		try {  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		} catch (Exception E) {  			m_Logger.Error ("FileManager.GrabItem():\n" + "Failed to load BMP from 'cities\\':\n" + E.ToString ());  		}  		return MemStream;  	}  } else if (Enum.IsDefined (typeof(FileIDs.UIFileIDs)' ID)) {  	using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "uigraphics/holiday/" : "uigraphics\\holiday\\") + Enum.GetName (typeof(FileIDs.UIFileIDs)' ID) + GetExtension (Enum.GetName (typeof(FileIDs.UIFileIDs)' ID))' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {  		using (BMap = new Bitmap (FS)) {  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		return MemStream;  	}  } else if (Enum.IsDefined (typeof(FileIDs.HintsFileIDs)' ID)) {  	using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "uigraphics/hints/" : "uigraphics\\hints\\") + Enum.GetName (typeof(FileIDs.HintsFileIDs)' ID) + ".bmp"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {  		using (BMap = new Bitmap (FS)) {  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		return MemStream;  	}  }  
Magic Number,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following statement contains a magic number: using (FileStream FS = File.Open (m_StartupDir + (IsLinux ? "cities/" : "cities\\") + Split [0] + "_" + Split [1] + (IsLinux ? "/" : "\\") + Split [2] + ".bmp"' FileMode.Open' FileAccess.Read' FileShare.ReadWrite)) {  	using (BMap = new Bitmap (FS)) {  		BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  		MemStream.Seek (0' SeekOrigin.Begin);  	}  	try {  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch (Exception E) {  		m_Logger.Error ("FileManager.GrabItem():\n" + "Failed to load BMP from 'cities\\':\n" + E.ToString ());  	}  	return MemStream;  }  
Magic Number,Files.IFF,CST,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,CST,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,CST,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,CST,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,CST,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,CST,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,CST,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,CTSS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,CTSS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,CTSS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,CTSS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,CTSS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,CTSS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,CTSS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,DGRP,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following statement contains a magic number: switch (m_Version) {  case 20000:  	ImageCount = Reader.ReadUShort ();  	break;  case 20001:  	ImageCount = Reader.ReadUShort ();  	break;  case 20003:  	ImageCount = Reader.ReadUInt32 ();  	break;  case 20004:  	ImageCount = Reader.ReadUInt32 ();  	break;  }  
Magic Number,Files.IFF,DGRP,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following statement contains a magic number: switch (m_Version) {  case 20000:  	ImageCount = Reader.ReadUShort ();  	break;  case 20001:  	ImageCount = Reader.ReadUShort ();  	break;  case 20003:  	ImageCount = Reader.ReadUInt32 ();  	break;  case 20004:  	ImageCount = Reader.ReadUInt32 ();  	break;  }  
Magic Number,Files.IFF,DGRP,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following statement contains a magic number: switch (m_Version) {  case 20000:  	ImageCount = Reader.ReadUShort ();  	break;  case 20001:  	ImageCount = Reader.ReadUShort ();  	break;  case 20003:  	ImageCount = Reader.ReadUInt32 ();  	break;  case 20004:  	ImageCount = Reader.ReadUInt32 ();  	break;  }  
Magic Number,Files.IFF,DGRP,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following statement contains a magic number: switch (m_Version) {  case 20000:  	ImageCount = Reader.ReadUShort ();  	break;  case 20001:  	ImageCount = Reader.ReadUShort ();  	break;  case 20003:  	ImageCount = Reader.ReadUInt32 ();  	break;  case 20004:  	ImageCount = Reader.ReadUInt32 ();  	break;  }  
Magic Number,Files.IFF,DGRPImg,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRPImg,The following statement contains a magic number: if (Version == 20000 || Version == 20001) {  	SpriteCount = Reader.ReadUShort ();  	DirectionFlags = Reader.ReadByte ();  	ZoomLevel = Reader.ReadByte ();  	for (int i = 0; i < SpriteCount; i++)  		Info.Add (new SpriteInfo (Reader' Version));  } else {  	DirectionFlags = Reader.ReadUInt32 ();  	ZoomLevel = Reader.ReadUInt32 ();  	SpriteCount = Reader.ReadUInt32 ();  	for (int i = 0; i < SpriteCount; i++)  		Info.Add (new SpriteInfo (Reader' Version));  }  
Magic Number,Files.IFF,DGRPImg,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRPImg,The following statement contains a magic number: if (Version == 20000 || Version == 20001) {  	SpriteCount = Reader.ReadUShort ();  	DirectionFlags = Reader.ReadByte ();  	ZoomLevel = Reader.ReadByte ();  	for (int i = 0; i < SpriteCount; i++)  		Info.Add (new SpriteInfo (Reader' Version));  } else {  	DirectionFlags = Reader.ReadUInt32 ();  	ZoomLevel = Reader.ReadUInt32 ();  	SpriteCount = Reader.ReadUInt32 ();  	for (int i = 0; i < SpriteCount; i++)  		Info.Add (new SpriteInfo (Reader' Version));  }  
Magic Number,Files.IFF,SpriteInfo,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,SpriteInfo,The following statement contains a magic number: if (Version == 20000 || Version == 20001) {  	Type = Reader.ReadInt16 ();  	SPRChunkID = Reader.ReadInt16 ();  	SPRFrameNum = Reader.ReadInt16 ();  	Flags = Reader.ReadInt16 ();  	SpriteXOffset = Reader.ReadInt16 ();  	SpriteYOffset = Reader.ReadInt16 ();  	ObjectZOffset = Reader.ReadFloat ();  } else {  	SPRChunkID = Reader.ReadInt32 ();  	SPRFrameNum = Reader.ReadInt32 ();  	SpriteXOffset = Reader.ReadInt32 ();  	SpriteYOffset = Reader.ReadInt32 ();  	ObjectZOffset = Reader.ReadFloat ();  	Flags = Reader.ReadInt32 ();  	if (Version == 20004) {  		ObjectXOffset = Reader.ReadFloat ();  		ObjectYOffset = Reader.ReadFloat ();  	}  }  
Magic Number,Files.IFF,SpriteInfo,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,SpriteInfo,The following statement contains a magic number: if (Version == 20000 || Version == 20001) {  	Type = Reader.ReadInt16 ();  	SPRChunkID = Reader.ReadInt16 ();  	SPRFrameNum = Reader.ReadInt16 ();  	Flags = Reader.ReadInt16 ();  	SpriteXOffset = Reader.ReadInt16 ();  	SpriteYOffset = Reader.ReadInt16 ();  	ObjectZOffset = Reader.ReadFloat ();  } else {  	SPRChunkID = Reader.ReadInt32 ();  	SPRFrameNum = Reader.ReadInt32 ();  	SpriteXOffset = Reader.ReadInt32 ();  	SpriteYOffset = Reader.ReadInt32 ();  	ObjectZOffset = Reader.ReadFloat ();  	Flags = Reader.ReadInt32 ();  	if (Version == 20004) {  		ObjectXOffset = Reader.ReadFloat ();  		ObjectYOffset = Reader.ReadFloat ();  	}  }  
Magic Number,Files.IFF,SpriteInfo,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,SpriteInfo,The following statement contains a magic number: if (Version == 20000 || Version == 20001) {  	Type = Reader.ReadInt16 ();  	SPRChunkID = Reader.ReadInt16 ();  	SPRFrameNum = Reader.ReadInt16 ();  	Flags = Reader.ReadInt16 ();  	SpriteXOffset = Reader.ReadInt16 ();  	SpriteYOffset = Reader.ReadInt16 ();  	ObjectZOffset = Reader.ReadFloat ();  } else {  	SPRChunkID = Reader.ReadInt32 ();  	SPRFrameNum = Reader.ReadInt32 ();  	SpriteXOffset = Reader.ReadInt32 ();  	SpriteYOffset = Reader.ReadInt32 ();  	ObjectZOffset = Reader.ReadFloat ();  	Flags = Reader.ReadInt32 ();  	if (Version == 20004) {  		ObjectXOffset = Reader.ReadFloat ();  		ObjectYOffset = Reader.ReadFloat ();  	}  }  
Magic Number,Files.IFF,SpriteInfo,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,SpriteInfo,The following statement contains a magic number: if (Version == 20004) {  	ObjectXOffset = Reader.ReadFloat ();  	ObjectYOffset = Reader.ReadFloat ();  }  
Magic Number,Files.IFF,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\Iff.cs,Init,The following statement contains a magic number: while ((m_Reader.StreamLength - m_Reader.Position) > 76) {  	IFFChunk Chunk;  	if (m_Device != null)  		Chunk = new IFFChunk (m_Reader' m_Device' this);  	else  		Chunk = new IFFChunk (m_Reader' this);  	switch (Chunk.Type) {  	case IFFChunkTypes.FBMP:  		FBMP FBMPChunk = new FBMP (Chunk);  		m_FBMPChunks.Add (Chunk.ID' FBMPChunk);  		break;  	case IFFChunkTypes.FWAV:  		FWAV FWAVChunk = new FWAV (Chunk);  		m_FWAVChunks.Add (Chunk.ID' FWAVChunk);  		break;  	case IFFChunkTypes.BMP_:  		BMP_ BMPChunk = new BMP_ (Chunk);  		m_BMP_Chunks.Add (Chunk.ID' BMPChunk);  		break;  	case IFFChunkTypes.DGRP:  		DGRP DGRPChunk = new DGRP (Chunk);  		m_DGRPChunks.Add (Chunk.ID' DGRPChunk);  		break;  	case IFFChunkTypes.BCON:  		BCON BCONChunk = new BCON (Chunk);  		m_BCONChunks.Add (Chunk.ID' BCONChunk);  		break;  	case IFFChunkTypes.GLOB:  		GLOB GlobChunk = new GLOB (Chunk);  		m_GLOBChunks.Add (Chunk.ID' GlobChunk);  		break;  	case IFFChunkTypes.OBJD:  		OBJD OBJDChunk = new OBJD (Chunk);  		m_OBJDs.Add (OBJDChunk);  		break;  	case IFFChunkTypes.TTAs:  		TTAs TTAsChunk = new TTAs (Chunk);  		m_TTAsChunks.Add (Chunk.ID' TTAsChunk);  		break;  	case IFFChunkTypes.TTAB:  		TTAB TTABChunk = new TTAB (Chunk);  		TTABChunk.Type = Chunk.Type;  		TTABChunk.ID = Chunk.ID;  		m_TTABChunks.Add (Chunk.ID' TTABChunk);  		break;  	case IFFChunkTypes.TPRP:  		TPRP TPRPChunk = new TPRP (Chunk);  		m_TPRPChunks.Add (Chunk.ID' TPRPChunk);  		break;  	case IFFChunkTypes.STR:  		STR STRChunk = new STR (Chunk);  		m_STRChunks.Add (Chunk.ID' STRChunk);  		break;  	case IFFChunkTypes.BHAV:  		BHAV BHAVChunk = new BHAV (Chunk);  		m_BHAVChunks.Add (Chunk.ID' BHAVChunk);  		break;  	case IFFChunkTypes.OBJf:  		OBJf OBJfChunk = new OBJf (Chunk);  		m_OBJfChunks.Add (Chunk.ID' OBJfChunk);  		break;  	case IFFChunkTypes.FCNS:  		FCNS FCNSChunk = new FCNS (Chunk);  		m_FCNSChunks.Add (Chunk.ID' FCNSChunk);  		break;  	case IFFChunkTypes.SPR:  		SPR SPRChunk = new SPR (Chunk);  		m_SPRChunks.Add (Chunk.ID' SPRChunk);  		break;  	case IFFChunkTypes.SPR2:  		SPR2 SPR2Chunk = new SPR2 (Chunk);  		m_SPR2Chunks.Add (Chunk.ID' SPR2Chunk);  		break;  	case IFFChunkTypes.PALT:  		PALT PALTChunk = new PALT (Chunk);  		m_PALTChunks.Add (Chunk.ID' PALTChunk);  		break;  	case IFFChunkTypes.CTSS:  		CTSS CTSSChunk = new CTSS (Chunk);  		m_CTSSChunks.Add (Chunk.ID' CTSSChunk);  		break;  	case IFFChunkTypes.CST:  		CST CSTChunk = new CST (Chunk);  		m_CSTChunks.Add (Chunk.ID' CSTChunk);  		break;  	}  }  
Magic Number,Files.IFF,IFFChunk,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\IFFChunk.cs,ReadHeader,The following statement contains a magic number: Type = (IFFChunkTypes)Enum.Parse (typeof(IFFChunkTypes)' Reader.ReadString (4).Replace ("#"' "").Replace ("\0"' ""));  
Magic Number,Files.IFF,IFFChunk,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\IFFChunk.cs,ReadHeader,The following statement contains a magic number: Reader.ReadBytes (64);  
Magic Number,Files.IFF,IFFChunk,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\IFFChunk.cs,ReadHeader,The following statement contains a magic number: m_Data = Reader.ReadBytes ((int)(Size - 76));  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: m_NumFields = 80;  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: m_NumFields = 95;  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: m_NumFields = 96;  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: m_NumFields = 97;  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: m_NumFields = 97;  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: m_NumFields = 105;  
Magic Number,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following statement contains a magic number: if (m_NumFields > 80) {  	WallStyleSpriteID = Reader.ReadUShort ();  	RatingHunger = Reader.ReadUShort ();  	RatingComfort = Reader.ReadUShort ();  	RatingHygiene = Reader.ReadUShort ();  	RatingBladder = Reader.ReadUShort ();  	RatingEnergy = Reader.ReadUShort ();  	RatingFun = Reader.ReadUShort ();  	RatingRoom = Reader.ReadUShort ();  	RatingSkillFlags = Reader.ReadUShort ();  }  
Magic Number,Files.IFF,OBJf,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJf.cs,OBJf,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,Files.IFF,OBJf,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJf.cs,OBJf,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,Files.IFF,OBJf,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJf.cs,OBJf,The following statement contains a magic number: Reader.ReadBytes (4);  
Magic Number,Files.IFF,PALT,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\PALT.cs,PALT,The following statement contains a magic number: Reader.ReadBytes (8);  
Magic Number,Files.IFF,SPR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPR,The following statement contains a magic number: if (Version >= 502 && Version <= 505) {  	//TODO: Should this be stored?  	for (int i = 0; i < SpriteCount; i++)  		m_OffsetTable.Add (Reader.ReadUInt32 ());  } else  	m_OffsetTable.Add ((uint)Reader.Position);  
Magic Number,Files.IFF,SPR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPR,The following statement contains a magic number: if (Version >= 502 && Version <= 505) {  	//TODO: Should this be stored?  	for (int i = 0; i < SpriteCount; i++)  		m_OffsetTable.Add (Reader.ReadUInt32 ());  } else  	m_OffsetTable.Add ((uint)Reader.Position);  
Magic Number,Files.IFF,SPRFrame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPRFrame,The following statement contains a magic number: if (Version == 1001) {  	Version = Reader.ReadUInt32 ();  	Size = Reader.ReadUInt32 ();  }  
Magic Number,Files.IFF,SPR2,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2,The following statement contains a magic number: if (Version == 1000) {  	SpriteCount = Reader.ReadUInt32 ();  	m_PaletteID = Reader.ReadUInt32 ();  	for (int i = 0; i < SpriteCount; i++)  		m_OffsetTable.Add (Reader.ReadUInt32 ());  } else {  	m_PaletteID = Reader.ReadUInt32 ();  	SpriteCount = Reader.ReadUInt32 ();  	m_OffsetTable.Add ((uint)Reader.Position);  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: if (SpriteVersion == 1001) {  	Reader.ReadUInt32 ();  	//Version  	Reader.ReadUInt32 ();  	//Size  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while (!EndMarker) {  	ushort Marker = Reader.ReadUShort ();  	var Command = Marker >> 13;  	var Count = Marker & 0x1FFF;  	switch (Command) {  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes   	//the size in bytes of the row's command/count bytes together with the supplied pixel data. In   	//the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   	//block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   	//remainder is transparent. The pixel commands are:  	case 0x00:  		for (int i = 0; i < Count; i++) {  			ushort PxMarker = Reader.ReadUShort ();  			var PxCommand = PxMarker >> 13;  			var PxCount = PxMarker & 0x1FFF;  			Color[] Colors;  			switch (PxCommand) {  			//Set the next pixel count pixels in the z-buffer and color channels to the values defined   			//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   			//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   			//for the z-buffer channel and color channel' respectively' in that order' using the full   			//opacity value of 255 for each pixel that is not the transparent color.  			case 0x01:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   			//defined by the pixel data provided directly after this command. Every group of 3 bytes in   			//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   			//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   			//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   			//in the range 0-31' and the z buffer is in range 0-255.  			case 0x02:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = Alpha;  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Leave the next pixel count pixels in the color channel filled with the transparent color'   			//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   			//command has no pixel data.  			case 0x03:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					Colors [j] = Color.Transparent;  					Colors [j].A = 0;  					ZBuffer [j] = 255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the color channel to the palette color indices defined by   			//the pixel data provided directly after this command.Every byte in the pixel data' minus the   			//padding byte at the very end(if it exists)' provides a color index value to be copied to the   			//row for the color channel using the full opacity value of 255 and the closest z-buffer value   			//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   			//farthest z-buffer value of 255.  			case 0x06:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  					ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			}  		}  		break;  	//Leave the next count rows in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  	case 0x04:  		for (int j = 0; j < Count; j++) {  			Color[] Colors = new Color[Width];  			for (int k = 0; k < Width; k++) {  				Colors [k] = Color.Transparent;  				Colors [k].A = 0;  				ZBuffer [k] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  		}  		break;  	case 0x05:  		EndMarker = true;  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while (!EndMarker) {  	ushort Marker = Reader.ReadUShort ();  	var Command = Marker >> 13;  	var Count = Marker & 0x1FFF;  	switch (Command) {  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes   	//the size in bytes of the row's command/count bytes together with the supplied pixel data. In   	//the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   	//block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   	//remainder is transparent. The pixel commands are:  	case 0x00:  		for (int i = 0; i < Count; i++) {  			ushort PxMarker = Reader.ReadUShort ();  			var PxCommand = PxMarker >> 13;  			var PxCount = PxMarker & 0x1FFF;  			Color[] Colors;  			switch (PxCommand) {  			//Set the next pixel count pixels in the z-buffer and color channels to the values defined   			//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   			//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   			//for the z-buffer channel and color channel' respectively' in that order' using the full   			//opacity value of 255 for each pixel that is not the transparent color.  			case 0x01:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   			//defined by the pixel data provided directly after this command. Every group of 3 bytes in   			//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   			//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   			//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   			//in the range 0-31' and the z buffer is in range 0-255.  			case 0x02:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = Alpha;  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Leave the next pixel count pixels in the color channel filled with the transparent color'   			//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   			//command has no pixel data.  			case 0x03:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					Colors [j] = Color.Transparent;  					Colors [j].A = 0;  					ZBuffer [j] = 255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the color channel to the palette color indices defined by   			//the pixel data provided directly after this command.Every byte in the pixel data' minus the   			//padding byte at the very end(if it exists)' provides a color index value to be copied to the   			//row for the color channel using the full opacity value of 255 and the closest z-buffer value   			//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   			//farthest z-buffer value of 255.  			case 0x06:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  					ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			}  		}  		break;  	//Leave the next count rows in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  	case 0x04:  		for (int j = 0; j < Count; j++) {  			Color[] Colors = new Color[Width];  			for (int k = 0; k < Width; k++) {  				Colors [k] = Color.Transparent;  				Colors [k].A = 0;  				ZBuffer [k] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  		}  		break;  	case 0x05:  		EndMarker = true;  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while (!EndMarker) {  	ushort Marker = Reader.ReadUShort ();  	var Command = Marker >> 13;  	var Count = Marker & 0x1FFF;  	switch (Command) {  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes   	//the size in bytes of the row's command/count bytes together with the supplied pixel data. In   	//the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   	//block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   	//remainder is transparent. The pixel commands are:  	case 0x00:  		for (int i = 0; i < Count; i++) {  			ushort PxMarker = Reader.ReadUShort ();  			var PxCommand = PxMarker >> 13;  			var PxCount = PxMarker & 0x1FFF;  			Color[] Colors;  			switch (PxCommand) {  			//Set the next pixel count pixels in the z-buffer and color channels to the values defined   			//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   			//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   			//for the z-buffer channel and color channel' respectively' in that order' using the full   			//opacity value of 255 for each pixel that is not the transparent color.  			case 0x01:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   			//defined by the pixel data provided directly after this command. Every group of 3 bytes in   			//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   			//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   			//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   			//in the range 0-31' and the z buffer is in range 0-255.  			case 0x02:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = Alpha;  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Leave the next pixel count pixels in the color channel filled with the transparent color'   			//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   			//command has no pixel data.  			case 0x03:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					Colors [j] = Color.Transparent;  					Colors [j].A = 0;  					ZBuffer [j] = 255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the color channel to the palette color indices defined by   			//the pixel data provided directly after this command.Every byte in the pixel data' minus the   			//padding byte at the very end(if it exists)' provides a color index value to be copied to the   			//row for the color channel using the full opacity value of 255 and the closest z-buffer value   			//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   			//farthest z-buffer value of 255.  			case 0x06:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  					ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			}  		}  		break;  	//Leave the next count rows in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  	case 0x04:  		for (int j = 0; j < Count; j++) {  			Color[] Colors = new Color[Width];  			for (int k = 0; k < Width; k++) {  				Colors [k] = Color.Transparent;  				Colors [k].A = 0;  				ZBuffer [k] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  		}  		break;  	case 0x05:  		EndMarker = true;  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while (!EndMarker) {  	ushort Marker = Reader.ReadUShort ();  	var Command = Marker >> 13;  	var Count = Marker & 0x1FFF;  	switch (Command) {  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes   	//the size in bytes of the row's command/count bytes together with the supplied pixel data. In   	//the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   	//block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   	//remainder is transparent. The pixel commands are:  	case 0x00:  		for (int i = 0; i < Count; i++) {  			ushort PxMarker = Reader.ReadUShort ();  			var PxCommand = PxMarker >> 13;  			var PxCount = PxMarker & 0x1FFF;  			Color[] Colors;  			switch (PxCommand) {  			//Set the next pixel count pixels in the z-buffer and color channels to the values defined   			//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   			//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   			//for the z-buffer channel and color channel' respectively' in that order' using the full   			//opacity value of 255 for each pixel that is not the transparent color.  			case 0x01:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   			//defined by the pixel data provided directly after this command. Every group of 3 bytes in   			//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   			//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   			//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   			//in the range 0-31' and the z buffer is in range 0-255.  			case 0x02:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = Alpha;  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Leave the next pixel count pixels in the color channel filled with the transparent color'   			//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   			//command has no pixel data.  			case 0x03:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					Colors [j] = Color.Transparent;  					Colors [j].A = 0;  					ZBuffer [j] = 255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the color channel to the palette color indices defined by   			//the pixel data provided directly after this command.Every byte in the pixel data' minus the   			//padding byte at the very end(if it exists)' provides a color index value to be copied to the   			//row for the color channel using the full opacity value of 255 and the closest z-buffer value   			//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   			//farthest z-buffer value of 255.  			case 0x06:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  					ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			}  		}  		break;  	//Leave the next count rows in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  	case 0x04:  		for (int j = 0; j < Count; j++) {  			Color[] Colors = new Color[Width];  			for (int k = 0; k < Width; k++) {  				Colors [k] = Color.Transparent;  				Colors [k].A = 0;  				ZBuffer [k] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  		}  		break;  	case 0x05:  		EndMarker = true;  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while (!EndMarker) {  	ushort Marker = Reader.ReadUShort ();  	var Command = Marker >> 13;  	var Count = Marker & 0x1FFF;  	switch (Command) {  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes   	//the size in bytes of the row's command/count bytes together with the supplied pixel data. In   	//the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   	//block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   	//remainder is transparent. The pixel commands are:  	case 0x00:  		for (int i = 0; i < Count; i++) {  			ushort PxMarker = Reader.ReadUShort ();  			var PxCommand = PxMarker >> 13;  			var PxCount = PxMarker & 0x1FFF;  			Color[] Colors;  			switch (PxCommand) {  			//Set the next pixel count pixels in the z-buffer and color channels to the values defined   			//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   			//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   			//for the z-buffer channel and color channel' respectively' in that order' using the full   			//opacity value of 255 for each pixel that is not the transparent color.  			case 0x01:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   			//defined by the pixel data provided directly after this command. Every group of 3 bytes in   			//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   			//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   			//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   			//in the range 0-31' and the z buffer is in range 0-255.  			case 0x02:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = Alpha;  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Leave the next pixel count pixels in the color channel filled with the transparent color'   			//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   			//command has no pixel data.  			case 0x03:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					Colors [j] = Color.Transparent;  					Colors [j].A = 0;  					ZBuffer [j] = 255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the color channel to the palette color indices defined by   			//the pixel data provided directly after this command.Every byte in the pixel data' minus the   			//padding byte at the very end(if it exists)' provides a color index value to be copied to the   			//row for the color channel using the full opacity value of 255 and the closest z-buffer value   			//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   			//farthest z-buffer value of 255.  			case 0x06:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  					ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			}  		}  		break;  	//Leave the next count rows in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  	case 0x04:  		for (int j = 0; j < Count; j++) {  			Color[] Colors = new Color[Width];  			for (int k = 0; k < Width; k++) {  				Colors [k] = Color.Transparent;  				Colors [k].A = 0;  				ZBuffer [k] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  		}  		break;  	case 0x05:  		EndMarker = true;  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while (!EndMarker) {  	ushort Marker = Reader.ReadUShort ();  	var Command = Marker >> 13;  	var Count = Marker & 0x1FFF;  	switch (Command) {  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes   	//the size in bytes of the row's command/count bytes together with the supplied pixel data. In   	//the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   	//block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   	//remainder is transparent. The pixel commands are:  	case 0x00:  		for (int i = 0; i < Count; i++) {  			ushort PxMarker = Reader.ReadUShort ();  			var PxCommand = PxMarker >> 13;  			var PxCount = PxMarker & 0x1FFF;  			Color[] Colors;  			switch (PxCommand) {  			//Set the next pixel count pixels in the z-buffer and color channels to the values defined   			//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   			//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   			//for the z-buffer channel and color channel' respectively' in that order' using the full   			//opacity value of 255 for each pixel that is not the transparent color.  			case 0x01:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   			//defined by the pixel data provided directly after this command. Every group of 3 bytes in   			//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   			//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   			//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   			//in the range 0-31' and the z buffer is in range 0-255.  			case 0x02:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = Alpha;  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Leave the next pixel count pixels in the color channel filled with the transparent color'   			//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   			//command has no pixel data.  			case 0x03:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					Colors [j] = Color.Transparent;  					Colors [j].A = 0;  					ZBuffer [j] = 255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the color channel to the palette color indices defined by   			//the pixel data provided directly after this command.Every byte in the pixel data' minus the   			//padding byte at the very end(if it exists)' provides a color index value to be copied to the   			//row for the color channel using the full opacity value of 255 and the closest z-buffer value   			//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   			//farthest z-buffer value of 255.  			case 0x06:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  					ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			}  		}  		break;  	//Leave the next count rows in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  	case 0x04:  		for (int j = 0; j < Count; j++) {  			Color[] Colors = new Color[Width];  			for (int k = 0; k < Width; k++) {  				Colors [k] = Color.Transparent;  				Colors [k].A = 0;  				ZBuffer [k] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  		}  		break;  	case 0x05:  		EndMarker = true;  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: while (!EndMarker) {  	ushort Marker = Reader.ReadUShort ();  	var Command = Marker >> 13;  	var Count = Marker & 0x1FFF;  	switch (Command) {  	//Fill this row with pixel data that directly follows; the count byte of the row command denotes   	//the size in bytes of the row's command/count bytes together with the supplied pixel data. In   	//the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   	//block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   	//remainder is transparent. The pixel commands are:  	case 0x00:  		for (int i = 0; i < Count; i++) {  			ushort PxMarker = Reader.ReadUShort ();  			var PxCommand = PxMarker >> 13;  			var PxCount = PxMarker & 0x1FFF;  			Color[] Colors;  			switch (PxCommand) {  			//Set the next pixel count pixels in the z-buffer and color channels to the values defined   			//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   			//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   			//for the z-buffer channel and color channel' respectively' in that order' using the full   			//opacity value of 255 for each pixel that is not the transparent color.  			case 0x01:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   			//defined by the pixel data provided directly after this command. Every group of 3 bytes in   			//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   			//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   			//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   			//in the range 0-31' and the z buffer is in range 0-255.  			case 0x02:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte Luminosity = Reader.ReadByte ();  					byte ColorIndex = Reader.ReadByte ();  					byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = Alpha;  					ZBuffer [j] = Luminosity;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Leave the next pixel count pixels in the color channel filled with the transparent color'   			//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   			//command has no pixel data.  			case 0x03:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					Colors [j] = Color.Transparent;  					Colors [j].A = 0;  					ZBuffer [j] = 255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			//Set the next pixel count pixels in the color channel to the palette color indices defined by   			//the pixel data provided directly after this command.Every byte in the pixel data' minus the   			//padding byte at the very end(if it exists)' provides a color index value to be copied to the   			//row for the color channel using the full opacity value of 255 and the closest z-buffer value   			//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   			//farthest z-buffer value of 255.  			case 0x06:  				Colors = new Color[PxCount];  				for (int j = 0; j < PxCount; j++) {  					byte ColorIndex = Reader.ReadByte ();  					Colors [j] = Palette [ColorIndex];  					Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  					ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  				}  				Texture.SetData<Color> (Colors' 0' Colors.Length);  				break;  			}  		}  		break;  	//Leave the next count rows in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  	case 0x04:  		for (int j = 0; j < Count; j++) {  			Color[] Colors = new Color[Width];  			for (int k = 0; k < Width; k++) {  				Colors [k] = Color.Transparent;  				Colors [k].A = 0;  				ZBuffer [k] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  		}  		break;  	case 0x05:  		EndMarker = true;  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (Command) {  //Fill this row with pixel data that directly follows; the count byte of the row command denotes   //the size in bytes of the row's command/count bytes together with the supplied pixel data. In   //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   //remainder is transparent. The pixel commands are:  case 0x00:  	for (int i = 0; i < Count; i++) {  		ushort PxMarker = Reader.ReadUShort ();  		var PxCommand = PxMarker >> 13;  		var PxCount = PxMarker & 0x1FFF;  		Color[] Colors;  		switch (PxCommand) {  		//Set the next pixel count pixels in the z-buffer and color channels to the values defined   		//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   		//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   		//for the z-buffer channel and color channel' respectively' in that order' using the full   		//opacity value of 255 for each pixel that is not the transparent color.  		case 0x01:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   		//defined by the pixel data provided directly after this command. Every group of 3 bytes in   		//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   		//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   		//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   		//in the range 0-31' and the z buffer is in range 0-255.  		case 0x02:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = Alpha;  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Leave the next pixel count pixels in the color channel filled with the transparent color'   		//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   		//command has no pixel data.  		case 0x03:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				Colors [j] = Color.Transparent;  				Colors [j].A = 0;  				ZBuffer [j] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the color channel to the palette color indices defined by   		//the pixel data provided directly after this command.Every byte in the pixel data' minus the   		//padding byte at the very end(if it exists)' provides a color index value to be copied to the   		//row for the color channel using the full opacity value of 255 and the closest z-buffer value   		//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   		//farthest z-buffer value of 255.  		case 0x06:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  				ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		}  	}  	break;  //Leave the next count rows in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  case 0x04:  	for (int j = 0; j < Count; j++) {  		Color[] Colors = new Color[Width];  		for (int k = 0; k < Width; k++) {  			Colors [k] = Color.Transparent;  			Colors [k].A = 0;  			ZBuffer [k] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  	}  	break;  case 0x05:  	EndMarker = true;  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (Command) {  //Fill this row with pixel data that directly follows; the count byte of the row command denotes   //the size in bytes of the row's command/count bytes together with the supplied pixel data. In   //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   //remainder is transparent. The pixel commands are:  case 0x00:  	for (int i = 0; i < Count; i++) {  		ushort PxMarker = Reader.ReadUShort ();  		var PxCommand = PxMarker >> 13;  		var PxCount = PxMarker & 0x1FFF;  		Color[] Colors;  		switch (PxCommand) {  		//Set the next pixel count pixels in the z-buffer and color channels to the values defined   		//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   		//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   		//for the z-buffer channel and color channel' respectively' in that order' using the full   		//opacity value of 255 for each pixel that is not the transparent color.  		case 0x01:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   		//defined by the pixel data provided directly after this command. Every group of 3 bytes in   		//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   		//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   		//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   		//in the range 0-31' and the z buffer is in range 0-255.  		case 0x02:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = Alpha;  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Leave the next pixel count pixels in the color channel filled with the transparent color'   		//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   		//command has no pixel data.  		case 0x03:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				Colors [j] = Color.Transparent;  				Colors [j].A = 0;  				ZBuffer [j] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the color channel to the palette color indices defined by   		//the pixel data provided directly after this command.Every byte in the pixel data' minus the   		//padding byte at the very end(if it exists)' provides a color index value to be copied to the   		//row for the color channel using the full opacity value of 255 and the closest z-buffer value   		//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   		//farthest z-buffer value of 255.  		case 0x06:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  				ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		}  	}  	break;  //Leave the next count rows in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  case 0x04:  	for (int j = 0; j < Count; j++) {  		Color[] Colors = new Color[Width];  		for (int k = 0; k < Width; k++) {  			Colors [k] = Color.Transparent;  			Colors [k].A = 0;  			ZBuffer [k] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  	}  	break;  case 0x05:  	EndMarker = true;  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (Command) {  //Fill this row with pixel data that directly follows; the count byte of the row command denotes   //the size in bytes of the row's command/count bytes together with the supplied pixel data. In   //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   //remainder is transparent. The pixel commands are:  case 0x00:  	for (int i = 0; i < Count; i++) {  		ushort PxMarker = Reader.ReadUShort ();  		var PxCommand = PxMarker >> 13;  		var PxCount = PxMarker & 0x1FFF;  		Color[] Colors;  		switch (PxCommand) {  		//Set the next pixel count pixels in the z-buffer and color channels to the values defined   		//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   		//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   		//for the z-buffer channel and color channel' respectively' in that order' using the full   		//opacity value of 255 for each pixel that is not the transparent color.  		case 0x01:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   		//defined by the pixel data provided directly after this command. Every group of 3 bytes in   		//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   		//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   		//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   		//in the range 0-31' and the z buffer is in range 0-255.  		case 0x02:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = Alpha;  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Leave the next pixel count pixels in the color channel filled with the transparent color'   		//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   		//command has no pixel data.  		case 0x03:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				Colors [j] = Color.Transparent;  				Colors [j].A = 0;  				ZBuffer [j] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the color channel to the palette color indices defined by   		//the pixel data provided directly after this command.Every byte in the pixel data' minus the   		//padding byte at the very end(if it exists)' provides a color index value to be copied to the   		//row for the color channel using the full opacity value of 255 and the closest z-buffer value   		//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   		//farthest z-buffer value of 255.  		case 0x06:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  				ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		}  	}  	break;  //Leave the next count rows in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  case 0x04:  	for (int j = 0; j < Count; j++) {  		Color[] Colors = new Color[Width];  		for (int k = 0; k < Width; k++) {  			Colors [k] = Color.Transparent;  			Colors [k].A = 0;  			ZBuffer [k] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  	}  	break;  case 0x05:  	EndMarker = true;  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (Command) {  //Fill this row with pixel data that directly follows; the count byte of the row command denotes   //the size in bytes of the row's command/count bytes together with the supplied pixel data. In   //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   //remainder is transparent. The pixel commands are:  case 0x00:  	for (int i = 0; i < Count; i++) {  		ushort PxMarker = Reader.ReadUShort ();  		var PxCommand = PxMarker >> 13;  		var PxCount = PxMarker & 0x1FFF;  		Color[] Colors;  		switch (PxCommand) {  		//Set the next pixel count pixels in the z-buffer and color channels to the values defined   		//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   		//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   		//for the z-buffer channel and color channel' respectively' in that order' using the full   		//opacity value of 255 for each pixel that is not the transparent color.  		case 0x01:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   		//defined by the pixel data provided directly after this command. Every group of 3 bytes in   		//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   		//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   		//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   		//in the range 0-31' and the z buffer is in range 0-255.  		case 0x02:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = Alpha;  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Leave the next pixel count pixels in the color channel filled with the transparent color'   		//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   		//command has no pixel data.  		case 0x03:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				Colors [j] = Color.Transparent;  				Colors [j].A = 0;  				ZBuffer [j] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the color channel to the palette color indices defined by   		//the pixel data provided directly after this command.Every byte in the pixel data' minus the   		//padding byte at the very end(if it exists)' provides a color index value to be copied to the   		//row for the color channel using the full opacity value of 255 and the closest z-buffer value   		//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   		//farthest z-buffer value of 255.  		case 0x06:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  				ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		}  	}  	break;  //Leave the next count rows in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  case 0x04:  	for (int j = 0; j < Count; j++) {  		Color[] Colors = new Color[Width];  		for (int k = 0; k < Width; k++) {  			Colors [k] = Color.Transparent;  			Colors [k].A = 0;  			ZBuffer [k] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  	}  	break;  case 0x05:  	EndMarker = true;  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (Command) {  //Fill this row with pixel data that directly follows; the count byte of the row command denotes   //the size in bytes of the row's command/count bytes together with the supplied pixel data. In   //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   //remainder is transparent. The pixel commands are:  case 0x00:  	for (int i = 0; i < Count; i++) {  		ushort PxMarker = Reader.ReadUShort ();  		var PxCommand = PxMarker >> 13;  		var PxCount = PxMarker & 0x1FFF;  		Color[] Colors;  		switch (PxCommand) {  		//Set the next pixel count pixels in the z-buffer and color channels to the values defined   		//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   		//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   		//for the z-buffer channel and color channel' respectively' in that order' using the full   		//opacity value of 255 for each pixel that is not the transparent color.  		case 0x01:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   		//defined by the pixel data provided directly after this command. Every group of 3 bytes in   		//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   		//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   		//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   		//in the range 0-31' and the z buffer is in range 0-255.  		case 0x02:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = Alpha;  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Leave the next pixel count pixels in the color channel filled with the transparent color'   		//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   		//command has no pixel data.  		case 0x03:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				Colors [j] = Color.Transparent;  				Colors [j].A = 0;  				ZBuffer [j] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the color channel to the palette color indices defined by   		//the pixel data provided directly after this command.Every byte in the pixel data' minus the   		//padding byte at the very end(if it exists)' provides a color index value to be copied to the   		//row for the color channel using the full opacity value of 255 and the closest z-buffer value   		//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   		//farthest z-buffer value of 255.  		case 0x06:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  				ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		}  	}  	break;  //Leave the next count rows in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  case 0x04:  	for (int j = 0; j < Count; j++) {  		Color[] Colors = new Color[Width];  		for (int k = 0; k < Width; k++) {  			Colors [k] = Color.Transparent;  			Colors [k].A = 0;  			ZBuffer [k] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  	}  	break;  case 0x05:  	EndMarker = true;  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (Command) {  //Fill this row with pixel data that directly follows; the count byte of the row command denotes   //the size in bytes of the row's command/count bytes together with the supplied pixel data. In   //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   //remainder is transparent. The pixel commands are:  case 0x00:  	for (int i = 0; i < Count; i++) {  		ushort PxMarker = Reader.ReadUShort ();  		var PxCommand = PxMarker >> 13;  		var PxCount = PxMarker & 0x1FFF;  		Color[] Colors;  		switch (PxCommand) {  		//Set the next pixel count pixels in the z-buffer and color channels to the values defined   		//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   		//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   		//for the z-buffer channel and color channel' respectively' in that order' using the full   		//opacity value of 255 for each pixel that is not the transparent color.  		case 0x01:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   		//defined by the pixel data provided directly after this command. Every group of 3 bytes in   		//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   		//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   		//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   		//in the range 0-31' and the z buffer is in range 0-255.  		case 0x02:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = Alpha;  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Leave the next pixel count pixels in the color channel filled with the transparent color'   		//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   		//command has no pixel data.  		case 0x03:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				Colors [j] = Color.Transparent;  				Colors [j].A = 0;  				ZBuffer [j] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the color channel to the palette color indices defined by   		//the pixel data provided directly after this command.Every byte in the pixel data' minus the   		//padding byte at the very end(if it exists)' provides a color index value to be copied to the   		//row for the color channel using the full opacity value of 255 and the closest z-buffer value   		//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   		//farthest z-buffer value of 255.  		case 0x06:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  				ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		}  	}  	break;  //Leave the next count rows in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  case 0x04:  	for (int j = 0; j < Count; j++) {  		Color[] Colors = new Color[Width];  		for (int k = 0; k < Width; k++) {  			Colors [k] = Color.Transparent;  			Colors [k].A = 0;  			ZBuffer [k] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  	}  	break;  case 0x05:  	EndMarker = true;  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	ushort PxMarker = Reader.ReadUShort ();  	var PxCommand = PxMarker >> 13;  	var PxCount = PxMarker & 0x1FFF;  	Color[] Colors;  	switch (PxCommand) {  	//Set the next pixel count pixels in the z-buffer and color channels to the values defined   	//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   	//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   	//for the z-buffer channel and color channel' respectively' in that order' using the full   	//opacity value of 255 for each pixel that is not the transparent color.  	case 0x01:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   	//defined by the pixel data provided directly after this command. Every group of 3 bytes in   	//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   	//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   	//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   	//in the range 0-31' and the z buffer is in range 0-255.  	case 0x02:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = Alpha;  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Leave the next pixel count pixels in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   	//command has no pixel data.  	case 0x03:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			Colors [j] = Color.Transparent;  			Colors [j].A = 0;  			ZBuffer [j] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the color channel to the palette color indices defined by   	//the pixel data provided directly after this command.Every byte in the pixel data' minus the   	//padding byte at the very end(if it exists)' provides a color index value to be copied to the   	//row for the color channel using the full opacity value of 255 and the closest z-buffer value   	//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   	//farthest z-buffer value of 255.  	case 0x06:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  			ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	ushort PxMarker = Reader.ReadUShort ();  	var PxCommand = PxMarker >> 13;  	var PxCount = PxMarker & 0x1FFF;  	Color[] Colors;  	switch (PxCommand) {  	//Set the next pixel count pixels in the z-buffer and color channels to the values defined   	//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   	//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   	//for the z-buffer channel and color channel' respectively' in that order' using the full   	//opacity value of 255 for each pixel that is not the transparent color.  	case 0x01:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   	//defined by the pixel data provided directly after this command. Every group of 3 bytes in   	//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   	//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   	//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   	//in the range 0-31' and the z buffer is in range 0-255.  	case 0x02:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = Alpha;  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Leave the next pixel count pixels in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   	//command has no pixel data.  	case 0x03:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			Colors [j] = Color.Transparent;  			Colors [j].A = 0;  			ZBuffer [j] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the color channel to the palette color indices defined by   	//the pixel data provided directly after this command.Every byte in the pixel data' minus the   	//padding byte at the very end(if it exists)' provides a color index value to be copied to the   	//row for the color channel using the full opacity value of 255 and the closest z-buffer value   	//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   	//farthest z-buffer value of 255.  	case 0x06:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  			ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	ushort PxMarker = Reader.ReadUShort ();  	var PxCommand = PxMarker >> 13;  	var PxCount = PxMarker & 0x1FFF;  	Color[] Colors;  	switch (PxCommand) {  	//Set the next pixel count pixels in the z-buffer and color channels to the values defined   	//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   	//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   	//for the z-buffer channel and color channel' respectively' in that order' using the full   	//opacity value of 255 for each pixel that is not the transparent color.  	case 0x01:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   	//defined by the pixel data provided directly after this command. Every group of 3 bytes in   	//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   	//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   	//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   	//in the range 0-31' and the z buffer is in range 0-255.  	case 0x02:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = Alpha;  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Leave the next pixel count pixels in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   	//command has no pixel data.  	case 0x03:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			Colors [j] = Color.Transparent;  			Colors [j].A = 0;  			ZBuffer [j] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the color channel to the palette color indices defined by   	//the pixel data provided directly after this command.Every byte in the pixel data' minus the   	//padding byte at the very end(if it exists)' provides a color index value to be copied to the   	//row for the color channel using the full opacity value of 255 and the closest z-buffer value   	//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   	//farthest z-buffer value of 255.  	case 0x06:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  			ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	ushort PxMarker = Reader.ReadUShort ();  	var PxCommand = PxMarker >> 13;  	var PxCount = PxMarker & 0x1FFF;  	Color[] Colors;  	switch (PxCommand) {  	//Set the next pixel count pixels in the z-buffer and color channels to the values defined   	//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   	//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   	//for the z-buffer channel and color channel' respectively' in that order' using the full   	//opacity value of 255 for each pixel that is not the transparent color.  	case 0x01:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   	//defined by the pixel data provided directly after this command. Every group of 3 bytes in   	//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   	//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   	//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   	//in the range 0-31' and the z buffer is in range 0-255.  	case 0x02:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = Alpha;  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Leave the next pixel count pixels in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   	//command has no pixel data.  	case 0x03:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			Colors [j] = Color.Transparent;  			Colors [j].A = 0;  			ZBuffer [j] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the color channel to the palette color indices defined by   	//the pixel data provided directly after this command.Every byte in the pixel data' minus the   	//padding byte at the very end(if it exists)' provides a color index value to be copied to the   	//row for the color channel using the full opacity value of 255 and the closest z-buffer value   	//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   	//farthest z-buffer value of 255.  	case 0x06:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  			ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int i = 0; i < Count; i++) {  	ushort PxMarker = Reader.ReadUShort ();  	var PxCommand = PxMarker >> 13;  	var PxCount = PxMarker & 0x1FFF;  	Color[] Colors;  	switch (PxCommand) {  	//Set the next pixel count pixels in the z-buffer and color channels to the values defined   	//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   	//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   	//for the z-buffer channel and color channel' respectively' in that order' using the full   	//opacity value of 255 for each pixel that is not the transparent color.  	case 0x01:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   	//defined by the pixel data provided directly after this command. Every group of 3 bytes in   	//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   	//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   	//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   	//in the range 0-31' and the z buffer is in range 0-255.  	case 0x02:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte Luminosity = Reader.ReadByte ();  			byte ColorIndex = Reader.ReadByte ();  			byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = Alpha;  			ZBuffer [j] = Luminosity;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Leave the next pixel count pixels in the color channel filled with the transparent color'   	//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   	//command has no pixel data.  	case 0x03:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			Colors [j] = Color.Transparent;  			Colors [j].A = 0;  			ZBuffer [j] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	//Set the next pixel count pixels in the color channel to the palette color indices defined by   	//the pixel data provided directly after this command.Every byte in the pixel data' minus the   	//padding byte at the very end(if it exists)' provides a color index value to be copied to the   	//row for the color channel using the full opacity value of 255 and the closest z-buffer value   	//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   	//farthest z-buffer value of 255.  	case 0x06:  		Colors = new Color[PxCount];  		for (int j = 0; j < PxCount; j++) {  			byte ColorIndex = Reader.ReadByte ();  			Colors [j] = Palette [ColorIndex];  			Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  			ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  		break;  	}  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (PxCommand) {  //Set the next pixel count pixels in the z-buffer and color channels to the values defined   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   //for the z-buffer channel and color channel' respectively' in that order' using the full   //opacity value of 255 for each pixel that is not the transparent color.  case 0x01:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   //defined by the pixel data provided directly after this command. Every group of 3 bytes in   //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   //in the range 0-31' and the z buffer is in range 0-255.  case 0x02:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = Alpha;  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Leave the next pixel count pixels in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   //command has no pixel data.  case 0x03:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		Colors [j] = Color.Transparent;  		Colors [j].A = 0;  		ZBuffer [j] = 255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the color channel to the palette color indices defined by   //the pixel data provided directly after this command.Every byte in the pixel data' minus the   //padding byte at the very end(if it exists)' provides a color index value to be copied to the   //row for the color channel using the full opacity value of 255 and the closest z-buffer value   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   //farthest z-buffer value of 255.  case 0x06:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  		ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (PxCommand) {  //Set the next pixel count pixels in the z-buffer and color channels to the values defined   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   //for the z-buffer channel and color channel' respectively' in that order' using the full   //opacity value of 255 for each pixel that is not the transparent color.  case 0x01:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   //defined by the pixel data provided directly after this command. Every group of 3 bytes in   //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   //in the range 0-31' and the z buffer is in range 0-255.  case 0x02:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = Alpha;  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Leave the next pixel count pixels in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   //command has no pixel data.  case 0x03:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		Colors [j] = Color.Transparent;  		Colors [j].A = 0;  		ZBuffer [j] = 255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the color channel to the palette color indices defined by   //the pixel data provided directly after this command.Every byte in the pixel data' minus the   //padding byte at the very end(if it exists)' provides a color index value to be copied to the   //row for the color channel using the full opacity value of 255 and the closest z-buffer value   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   //farthest z-buffer value of 255.  case 0x06:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  		ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (PxCommand) {  //Set the next pixel count pixels in the z-buffer and color channels to the values defined   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   //for the z-buffer channel and color channel' respectively' in that order' using the full   //opacity value of 255 for each pixel that is not the transparent color.  case 0x01:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   //defined by the pixel data provided directly after this command. Every group of 3 bytes in   //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   //in the range 0-31' and the z buffer is in range 0-255.  case 0x02:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = Alpha;  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Leave the next pixel count pixels in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   //command has no pixel data.  case 0x03:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		Colors [j] = Color.Transparent;  		Colors [j].A = 0;  		ZBuffer [j] = 255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the color channel to the palette color indices defined by   //the pixel data provided directly after this command.Every byte in the pixel data' minus the   //padding byte at the very end(if it exists)' provides a color index value to be copied to the   //row for the color channel using the full opacity value of 255 and the closest z-buffer value   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   //farthest z-buffer value of 255.  case 0x06:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  		ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: switch (PxCommand) {  //Set the next pixel count pixels in the z-buffer and color channels to the values defined   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   //for the z-buffer channel and color channel' respectively' in that order' using the full   //opacity value of 255 for each pixel that is not the transparent color.  case 0x01:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   //defined by the pixel data provided directly after this command. Every group of 3 bytes in   //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   //in the range 0-31' and the z buffer is in range 0-255.  case 0x02:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = Alpha;  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Leave the next pixel count pixels in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   //command has no pixel data.  case 0x03:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		Colors [j] = Color.Transparent;  		Colors [j].A = 0;  		ZBuffer [j] = 255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the color channel to the palette color indices defined by   //the pixel data provided directly after this command.Every byte in the pixel data' minus the   //padding byte at the very end(if it exists)' provides a color index value to be copied to the   //row for the color channel using the full opacity value of 255 and the closest z-buffer value   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   //farthest z-buffer value of 255.  case 0x06:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  		ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int j = 0; j < PxCount; j++) {  	byte Luminosity = Reader.ReadByte ();  	byte ColorIndex = Reader.ReadByte ();  	byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  	Colors [j] = Palette [ColorIndex];  	Colors [j].A = Alpha;  	ZBuffer [j] = Luminosity;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int j = 0; j < PxCount; j++) {  	Colors [j] = Color.Transparent;  	Colors [j].A = 0;  	ZBuffer [j] = 255;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: ZBuffer [j] = 255;  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int j = 0; j < PxCount; j++) {  	byte ColorIndex = Reader.ReadByte ();  	Colors [j] = Palette [ColorIndex];  	Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  	ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int j = 0; j < PxCount; j++) {  	byte ColorIndex = Reader.ReadByte ();  	Colors [j] = Palette [ColorIndex];  	Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  	ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int j = 0; j < Count; j++) {  	Color[] Colors = new Color[Width];  	for (int k = 0; k < Width; k++) {  		Colors [k] = Color.Transparent;  		Colors [k].A = 0;  		ZBuffer [k] = 255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: for (int k = 0; k < Width; k++) {  	Colors [k] = Color.Transparent;  	Colors [k].A = 0;  	ZBuffer [k] = 255;  }  
Magic Number,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following statement contains a magic number: ZBuffer [k] = 255;  
Magic Number,Files.IFF,STR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,STR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,STR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,STR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,STR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,STR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,STR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,TTAs,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,TTAs,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,TTAs,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,TTAs,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: if ((Reader.StreamLength - Reader.Position) > 2) {  	switch (Version) {  	case 0:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadPascalString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -1:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -2:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = LanguageCodes.unused;  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -3:  		NumStrings = Reader.ReadUShort ();  		for (int i = 0; i < NumStrings; i++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)Reader.ReadByte ();  			Str.TranslatedStr = Reader.ReadCString ();  			Reader.ReadCString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  		break;  	case -4:  		byte LanguageSets = Reader.ReadByte ();  		for (int i = 0; i < LanguageSets; i++) {  			NumStrings = Reader.ReadUShort ();  			for (int j = 0; j < NumStrings; j++) {  				TranslatedString Str = new TranslatedString ();  				Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  				Str.TranslatedStr = Reader.ReadString ();  				Reader.ReadString ();  				//Comment  				if (Strings.ContainsKey (Str.LangCode))  					Strings [Str.LangCode].Add (Str);  				else {  					List<TranslatedString> LanguageSet = new List<TranslatedString> ();  					LanguageSet.Add (Str);  					Strings.Add (Str.LangCode' LanguageSet);  				}  			}  		}  		break;  	}  }  
Magic Number,Files.IFF,TTAs,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,TTAs,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.IFF,TTAs,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following statement contains a magic number: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Magic Number,Files.Vitaboy,Anim,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: Translations = new float[TranslationsCount' 3];  
Magic Number,Files.Vitaboy,Anim,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: for (int i = 0; i < TranslationsCount; i++) {  	Translations [i' 0] = m_Reader.ReadFloat ();  	Translations [i' 1] = m_Reader.ReadFloat ();  	Translations [i' 2] = m_Reader.ReadFloat ();  }  
Magic Number,Files.Vitaboy,Anim,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: Translations [i' 2] = m_Reader.ReadFloat ();  
Magic Number,Files.Vitaboy,Anim,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: Rotations = new float[RotationsCount' 4];  
Magic Number,Files.Vitaboy,Anim,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: for (int i = 0; i < RotationsCount; i++) {  	Rotations [i' 0] = m_Reader.ReadFloat ();  	Rotations [i' 1] = m_Reader.ReadFloat ();  	Rotations [i' 2] = m_Reader.ReadFloat ();  	Rotations [i' 3] = m_Reader.ReadFloat ();  }  
Magic Number,Files.Vitaboy,Anim,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: for (int i = 0; i < RotationsCount; i++) {  	Rotations [i' 0] = m_Reader.ReadFloat ();  	Rotations [i' 1] = m_Reader.ReadFloat ();  	Rotations [i' 2] = m_Reader.ReadFloat ();  	Rotations [i' 3] = m_Reader.ReadFloat ();  }  
Magic Number,Files.Vitaboy,Anim,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: Rotations [i' 2] = m_Reader.ReadFloat ();  
Magic Number,Files.Vitaboy,Anim,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Anim.cs,Anim,The following statement contains a magic number: Rotations [i' 3] = m_Reader.ReadFloat ();  
Magic Number,Files.Vitaboy,Binding,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Binding.cs,Binding,The following statement contains a magic number: if (AssetType == 8) {  	//A 4-byte unsigned integer specifying the type of data that follows; should be 0xA96F6D42 for cAssetKey  	Reader.ReadUInt32 ();  	FileID = Reader.ReadUInt32 ();  	TypeID = Reader.ReadUInt32 ();  	MeshID = new UniqueFileID (TypeID' FileID);  }  
Magic Number,Files.Vitaboy,Binding,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\Vitaboy\Binding.cs,Binding,The following statement contains a magic number: if (AssetType == 8) {  	//A 4-byte unsigned integer specifying the type of data that follows; should be 0xA96F6D42 for cAssetKey  	Reader.ReadUInt32 ();  	FileID = Reader.ReadUInt32 ();  	TypeID = Reader.ReadUInt32 ();  	TextureID = new UniqueFileID (TypeID' FileID);  }  
Missing Default,Files.Manager,FileManager,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\FileManager\FileManager.cs,GrabItem,The following switch statement is missing a default case: switch (TypeID) {  case FAR3TypeIDs.ANIM:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Anim (Data)));  	break;  case FAR3TypeIDs.APR:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Appearance (Data)));  	break;  case FAR3TypeIDs.BND:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Binding (Data)));  	break;  case FAR3TypeIDs.COL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Collection (Data)));  	break;  case FAR3TypeIDs.HAG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new HandGroup (Data)));  	break;  case FAR3TypeIDs.MESH:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Mesh (Data)));  	break;  case FAR3TypeIDs.OFT:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Outfit (Data)));  	break;  case FAR3TypeIDs.PO:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new PurchasableOutfit (Data)));  	break;  case FAR3TypeIDs.SKEL:  	AddItem (ID' new Asset (ID' (uint)Data.Length' new Skeleton (Data)));  	break;  case FAR3TypeIDs.TGA:  	lock (MemStream) {  		using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  			TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			MemStream.Seek (0' SeekOrigin.Begin);  			AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  		}  	}  	break;  case FAR3TypeIDs.PNG:  case FAR3TypeIDs.PackedPNG:  	AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	break;  case FAR3TypeIDs.JPG:  	try {  		using (BMap = new Bitmap (Data)) {  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  			BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  			BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  			BMap.Dispose ();  			MemStream.Seek (0' SeekOrigin.Begin);  		}  		AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  	} catch {  		try {  			MemStream.Dispose ();  			AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  		} catch (Exception)//Most likely a TGA' sigh.  		 {  			MemStream = new MemoryStream ();  			using (Paloma.TargaImage TGA = new Paloma.TargaImage (Data)) {  				TGA.Image.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  				TGA.Dispose ();  				MemStream.Seek (0' SeekOrigin.Begin);  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			}  		}  	}  	break;  case FAR3TypeIDs.BMP:  	if (IsBMP (Data)) {  		lock (MemStream) {  			try {  				using (BMap = new Bitmap (Data)) {  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 0' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (255' 1' 255));  					BMap.MakeTransparent (System.Drawing.Color.FromArgb (254' 2' 254));  					BMap.Save (MemStream' System.Drawing.Imaging.ImageFormat.Png);  					MemStream.Seek (0' SeekOrigin.Begin);  				}  				AddItem (ID' new Asset (ID' (uint)MemStream.Length' Texture2D.FromStream (m_Game.GraphicsDevice' MemStream)));  			} catch (Exception) {  				MemStream.Dispose ();  				AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  			}  		}  	} else {  		AddItem (ID' new Asset (ID' (uint)Data.Length' Texture2D.FromStream (m_Game.GraphicsDevice' Data)));  	}  	break;  }  
Missing Default,Files.IFF,CST,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CST.cs,CST,The following switch statement is missing a default case: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Missing Default,Files.IFF,CTSS,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\CTSS.cs,CTSS,The following switch statement is missing a default case: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Missing Default,Files.IFF,DGRP,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\DGRP.cs,DGRP,The following switch statement is missing a default case: switch (m_Version) {  case 20000:  	ImageCount = Reader.ReadUShort ();  	break;  case 20001:  	ImageCount = Reader.ReadUShort ();  	break;  case 20003:  	ImageCount = Reader.ReadUInt32 ();  	break;  case 20004:  	ImageCount = Reader.ReadUInt32 ();  	break;  }  
Missing Default,Files.IFF,Iff,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\Iff.cs,Init,The following switch statement is missing a default case: switch (Chunk.Type) {  case IFFChunkTypes.FBMP:  	FBMP FBMPChunk = new FBMP (Chunk);  	m_FBMPChunks.Add (Chunk.ID' FBMPChunk);  	break;  case IFFChunkTypes.FWAV:  	FWAV FWAVChunk = new FWAV (Chunk);  	m_FWAVChunks.Add (Chunk.ID' FWAVChunk);  	break;  case IFFChunkTypes.BMP_:  	BMP_ BMPChunk = new BMP_ (Chunk);  	m_BMP_Chunks.Add (Chunk.ID' BMPChunk);  	break;  case IFFChunkTypes.DGRP:  	DGRP DGRPChunk = new DGRP (Chunk);  	m_DGRPChunks.Add (Chunk.ID' DGRPChunk);  	break;  case IFFChunkTypes.BCON:  	BCON BCONChunk = new BCON (Chunk);  	m_BCONChunks.Add (Chunk.ID' BCONChunk);  	break;  case IFFChunkTypes.GLOB:  	GLOB GlobChunk = new GLOB (Chunk);  	m_GLOBChunks.Add (Chunk.ID' GlobChunk);  	break;  case IFFChunkTypes.OBJD:  	OBJD OBJDChunk = new OBJD (Chunk);  	m_OBJDs.Add (OBJDChunk);  	break;  case IFFChunkTypes.TTAs:  	TTAs TTAsChunk = new TTAs (Chunk);  	m_TTAsChunks.Add (Chunk.ID' TTAsChunk);  	break;  case IFFChunkTypes.TTAB:  	TTAB TTABChunk = new TTAB (Chunk);  	TTABChunk.Type = Chunk.Type;  	TTABChunk.ID = Chunk.ID;  	m_TTABChunks.Add (Chunk.ID' TTABChunk);  	break;  case IFFChunkTypes.TPRP:  	TPRP TPRPChunk = new TPRP (Chunk);  	m_TPRPChunks.Add (Chunk.ID' TPRPChunk);  	break;  case IFFChunkTypes.STR:  	STR STRChunk = new STR (Chunk);  	m_STRChunks.Add (Chunk.ID' STRChunk);  	break;  case IFFChunkTypes.BHAV:  	BHAV BHAVChunk = new BHAV (Chunk);  	m_BHAVChunks.Add (Chunk.ID' BHAVChunk);  	break;  case IFFChunkTypes.OBJf:  	OBJf OBJfChunk = new OBJf (Chunk);  	m_OBJfChunks.Add (Chunk.ID' OBJfChunk);  	break;  case IFFChunkTypes.FCNS:  	FCNS FCNSChunk = new FCNS (Chunk);  	m_FCNSChunks.Add (Chunk.ID' FCNSChunk);  	break;  case IFFChunkTypes.SPR:  	SPR SPRChunk = new SPR (Chunk);  	m_SPRChunks.Add (Chunk.ID' SPRChunk);  	break;  case IFFChunkTypes.SPR2:  	SPR2 SPR2Chunk = new SPR2 (Chunk);  	m_SPR2Chunks.Add (Chunk.ID' SPR2Chunk);  	break;  case IFFChunkTypes.PALT:  	PALT PALTChunk = new PALT (Chunk);  	m_PALTChunks.Add (Chunk.ID' PALTChunk);  	break;  case IFFChunkTypes.CTSS:  	CTSS CTSSChunk = new CTSS (Chunk);  	m_CTSSChunks.Add (Chunk.ID' CTSSChunk);  	break;  case IFFChunkTypes.CST:  	CST CSTChunk = new CST (Chunk);  	m_CSTChunks.Add (Chunk.ID' CSTChunk);  	break;  }  
Missing Default,Files.IFF,OBJD,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\OBJD.cs,OBJD,The following switch statement is missing a default case: switch (Version) {  case 136:  	m_NumFields = 80;  	break;  case 138:  	m_NumFields = 95;  	break;  case 139:  	m_NumFields = 96;  	break;  case 140:  	m_NumFields = 97;  	break;  case 141:  	m_NumFields = 97;  	break;  case 142:  	m_NumFields = 105;  	break;  }  
Missing Default,Files.IFF,SPRFrame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPRFrame,The following switch statement is missing a default case: switch (Cmd) {  case 0x04:  	for (byte j = 0; j < Count; j++) {  		byte PxCmd = Reader.ReadByte ();  		byte PxCount = Reader.ReadByte ();  		Color[] Pixels;  		switch (PxCmd) {  		case 0x01:  			//Leave the next pixel count pixels as transparent. This pixel command has no pixel data.  			Pixels = new Color[Count];  			for (int k = 0; k < Count; k++)  				Pixels [k] = Color.Transparent;  			Texture.SetData<Color> (Pixels' 0' Count);  			break;  		case 0x02:  			//Fill the next pixel count pixels with a single palette color.   			//The pixel data is two bytes: the first byte denotes the palette color   			//index' and the second byte is padding (which is always equal to the   			//first byte but is ignored).  			Pixels = new Color[Count];  			byte ColorIndex = Reader.ReadByte ();  			for (int k = 0; k < Count; k++)  				Pixels [k] = Palette [ColorIndex];  			Texture.SetData<Color> (Pixels' 0' Count);  			break;  		case 0x03:  			//Set the next pixel count pixels to the palette color indices defined by   			//the pixel data provided directly after this command. Each byte in the pixel data'   			//minus the padding byte at the very end (if it exists)' is a color index value to   			//be copied to the row.  			Pixels = new Color[Count];  			for (int k = 0; k < Count; k++)  				Pixels [k] = Palette [Reader.ReadByte ()];  			Texture.SetData<Color> (Pixels' 0' Count);  			break;  		case 0x09:  			//Leave the next count rows as transparent.  			for (int k = 0; k < Count; k++) {  				Pixels = new Color[Width];  				for (int l = 0; l < Width; l++)  					Pixels [l] = Color.Transparent;  				Texture.SetData<Color> (Pixels' 0' Width);  			}  			break;  		}  	}  	break;  }  
Missing Default,Files.IFF,SPRFrame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR.cs,SPRFrame,The following switch statement is missing a default case: switch (PxCmd) {  case 0x01:  	//Leave the next pixel count pixels as transparent. This pixel command has no pixel data.  	Pixels = new Color[Count];  	for (int k = 0; k < Count; k++)  		Pixels [k] = Color.Transparent;  	Texture.SetData<Color> (Pixels' 0' Count);  	break;  case 0x02:  	//Fill the next pixel count pixels with a single palette color.   	//The pixel data is two bytes: the first byte denotes the palette color   	//index' and the second byte is padding (which is always equal to the   	//first byte but is ignored).  	Pixels = new Color[Count];  	byte ColorIndex = Reader.ReadByte ();  	for (int k = 0; k < Count; k++)  		Pixels [k] = Palette [ColorIndex];  	Texture.SetData<Color> (Pixels' 0' Count);  	break;  case 0x03:  	//Set the next pixel count pixels to the palette color indices defined by   	//the pixel data provided directly after this command. Each byte in the pixel data'   	//minus the padding byte at the very end (if it exists)' is a color index value to   	//be copied to the row.  	Pixels = new Color[Count];  	for (int k = 0; k < Count; k++)  		Pixels [k] = Palette [Reader.ReadByte ()];  	Texture.SetData<Color> (Pixels' 0' Count);  	break;  case 0x09:  	//Leave the next count rows as transparent.  	for (int k = 0; k < Count; k++) {  		Pixels = new Color[Width];  		for (int l = 0; l < Width; l++)  			Pixels [l] = Color.Transparent;  		Texture.SetData<Color> (Pixels' 0' Width);  	}  	break;  }  
Missing Default,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following switch statement is missing a default case: switch (Command) {  //Fill this row with pixel data that directly follows; the count byte of the row command denotes   //the size in bytes of the row's command/count bytes together with the supplied pixel data. In   //the pixel data' each pixel command consists of a 3-bit/13-bit command/count header followed by a   //block of pixel data padded to a multiple of 2 bytes. If the row is not filled completely' the   //remainder is transparent. The pixel commands are:  case 0x00:  	for (int i = 0; i < Count; i++) {  		ushort PxMarker = Reader.ReadUShort ();  		var PxCommand = PxMarker >> 13;  		var PxCount = PxMarker & 0x1FFF;  		Color[] Colors;  		switch (PxCommand) {  		//Set the next pixel count pixels in the z-buffer and color channels to the values defined   		//by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   		//data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   		//for the z-buffer channel and color channel' respectively' in that order' using the full   		//opacity value of 255 for each pixel that is not the transparent color.  		case 0x01:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   		//defined by the pixel data provided directly after this command. Every group of 3 bytes in   		//the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   		//(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   		//color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   		//in the range 0-31' and the z buffer is in range 0-255.  		case 0x02:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte Luminosity = Reader.ReadByte ();  				byte ColorIndex = Reader.ReadByte ();  				byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = Alpha;  				ZBuffer [j] = Luminosity;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Leave the next pixel count pixels in the color channel filled with the transparent color'   		//in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   		//command has no pixel data.  		case 0x03:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				Colors [j] = Color.Transparent;  				Colors [j].A = 0;  				ZBuffer [j] = 255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		//Set the next pixel count pixels in the color channel to the palette color indices defined by   		//the pixel data provided directly after this command.Every byte in the pixel data' minus the   		//padding byte at the very end(if it exists)' provides a color index value to be copied to the   		//row for the color channel using the full opacity value of 255 and the closest z-buffer value   		//of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   		//farthest z-buffer value of 255.  		case 0x06:  			Colors = new Color[PxCount];  			for (int j = 0; j < PxCount; j++) {  				byte ColorIndex = Reader.ReadByte ();  				Colors [j] = Palette [ColorIndex];  				Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  				ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  			}  			Texture.SetData<Color> (Colors' 0' Colors.Length);  			break;  		}  	}  	break;  //Leave the next count rows in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0.  case 0x04:  	for (int j = 0; j < Count; j++) {  		Color[] Colors = new Color[Width];  		for (int k = 0; k < Width; k++) {  			Colors [k] = Color.Transparent;  			Colors [k].A = 0;  			ZBuffer [k] = 255;  		}  		Texture.SetData<Color> (Colors' 0' Colors.Length);  	}  	break;  case 0x05:  	EndMarker = true;  	break;  }  
Missing Default,Files.IFF,SPR2Frame,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\SPR2.cs,SPR2Frame,The following switch statement is missing a default case: switch (PxCommand) {  //Set the next pixel count pixels in the z-buffer and color channels to the values defined   //by the pixel data provided directly after this command. Every group of 2 bytes in the pixel   //data provides a luminosity (z-buffer) or color index (color) value to be copied to the row   //for the z-buffer channel and color channel' respectively' in that order' using the full   //opacity value of 255 for each pixel that is not the transparent color.  case 0x01:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the z-buffer' color' and alpha channels to the values   //defined by the pixel data provided directly after this command. Every group of 3 bytes in   //the pixel data' minus the padding byte at the very end (if it exists)' provides a luminosity   //(z-buffer and alpha) or color index (color) value to be copied to the row for the z-buffer'   //color' and alpha channels' respectively' in that order. The alpha channel data is grayscale   //in the range 0-31' and the z buffer is in range 0-255.  case 0x02:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte Luminosity = Reader.ReadByte ();  		byte ColorIndex = Reader.ReadByte ();  		byte Alpha = (byte)(Reader.ReadByte () * 8.2258064516129032258064516129032);  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = Alpha;  		ZBuffer [j] = Luminosity;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Leave the next pixel count pixels in the color channel filled with the transparent color'   //in the z-buffer channel filled with 255' and in the alpha channel filled with 0. This pixel   //command has no pixel data.  case 0x03:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		Colors [j] = Color.Transparent;  		Colors [j].A = 0;  		ZBuffer [j] = 255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  //Set the next pixel count pixels in the color channel to the palette color indices defined by   //the pixel data provided directly after this command.Every byte in the pixel data' minus the   //padding byte at the very end(if it exists)' provides a color index value to be copied to the   //row for the color channel using the full opacity value of 255 and the closest z-buffer value   //of 0 if the pixel is not the transparent color' or otherwise the no opacity value of 0 and the   //farthest z-buffer value of 255.  case 0x06:  	Colors = new Color[PxCount];  	for (int j = 0; j < PxCount; j++) {  		byte ColorIndex = Reader.ReadByte ();  		Colors [j] = Palette [ColorIndex];  		Colors [j].A = (Palette [ColorIndex] != Color.Transparent) ? (byte)255 : (byte)0;  		ZBuffer [j] = (Palette [ColorIndex] != Color.Transparent) ? (byte)0 : (byte)255;  	}  	Texture.SetData<Color> (Colors' 0' Colors.Length);  	break;  }  
Missing Default,Files.IFF,STR,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\STR.cs,STR,The following switch statement is missing a default case: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
Missing Default,Files.IFF,TTAs,F:\newReposMay17\Afr0_Project-Dollhouse\TSOClient\Files\Files\IFF\TTAs.cs,TTAs,The following switch statement is missing a default case: switch (Version) {  case 0:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadPascalString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -1:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -2:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = LanguageCodes.unused;  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -3:  	NumStrings = Reader.ReadUShort ();  	for (int i = 0; i < NumStrings; i++) {  		TranslatedString Str = new TranslatedString ();  		Str.LangCode = (LanguageCodes)Reader.ReadByte ();  		Str.TranslatedStr = Reader.ReadCString ();  		Reader.ReadCString ();  		//Comment  		if (Strings.ContainsKey (Str.LangCode))  			Strings [Str.LangCode].Add (Str);  		else {  			List<TranslatedString> LanguageSet = new List<TranslatedString> ();  			LanguageSet.Add (Str);  			Strings.Add (Str.LangCode' LanguageSet);  		}  	}  	break;  case -4:  	byte LanguageSets = Reader.ReadByte ();  	for (int i = 0; i < LanguageSets; i++) {  		NumStrings = Reader.ReadUShort ();  		for (int j = 0; j < NumStrings; j++) {  			TranslatedString Str = new TranslatedString ();  			Str.LangCode = (LanguageCodes)(Reader.ReadByte () + 1);  			Str.TranslatedStr = Reader.ReadString ();  			Reader.ReadString ();  			//Comment  			if (Strings.ContainsKey (Str.LangCode))  				Strings [Str.LangCode].Add (Str);  			else {  				List<TranslatedString> LanguageSet = new List<TranslatedString> ();  				LanguageSet.Add (Str);  				Strings.Add (Str.LangCode' LanguageSet);  			}  		}  	}  	break;  }  
