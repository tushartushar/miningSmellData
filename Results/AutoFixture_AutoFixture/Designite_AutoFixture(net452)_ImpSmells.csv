Implementation smell,Namespace,Class,File,Method,Description
Long Method,AutoFixture,Fixture,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Fixture.cs,Fixture,The method has 107 lines of code.
Complex Method,AutoFixture,NumericSequenceGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\NumericSequenceGenerator.cs,CreateNumericSpecimen,Cyclomatic complexity of the method is 12
Complex Method,AutoFixture,RandomNumericSequenceGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\RandomNumericSequenceGenerator.cs,CreateRandom,Cyclomatic complexity of the method is 12
Complex Method,AutoFixture,RangedNumberGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,CreateAnonymous,Cyclomatic complexity of the method is 11
Complex Method,AutoFixture,RangedNumberGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,Add,Cyclomatic complexity of the method is 12
Complex Method,AutoFixture.Kernel,SpecimenBuilderNode,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SpecimenBuilderNode.cs,GraphEquals,Cyclomatic complexity of the method is 12
Long Identifier,AutoFixture,MutableValueTypeGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\MutableValueTypeGenerator.cs,,The length of the parameter valueTypeWithoutConstructorsSpecification is 41.
Long Statement,AutoFixture,EnumerableExtensions,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\EnumerableExtensions.cs,SetItem,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(index)' string.Format(CultureInfo.CurrentCulture' "The supplied index was less than zero ({0}). Only zero and positive index numbers are supported."' index)); " is 203.
Long Statement,AutoFixture,EnumerableExtensions,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\EnumerableExtensions.cs,SetItem,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(index)' string.Format(CultureInfo.CurrentCulture' "The supplied index ({0}) exceeds the addressable space of the current sequence. The length of the sequence is only {1}."' index' a.Length)); " is 236.
Long Statement,AutoFixture,Fixture,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Fixture.cs,Customize,The length of the statement  "            var c = composerTransformation(SpecimenBuilderNodeFactory.CreateComposer<T>().WithAutoProperties(this.EnableAutoProperties)); " is 125.
Long Statement,AutoFixture.DataAnnotations,RangedRequest,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangedRequest.cs,GetConvertedRangeBoundary,The length of the statement  "                // https://github.com/Microsoft/referencesource/blob/b31308b03e8bd5bf779fb80fda71f31eb959fe0b/System.ComponentModel.DataAnnotations/DataAnnotations/RangeAttribute.cs#L140 " is 170.
Long Statement,AutoFixture.DataAnnotations,StringLengthAttributeRelay,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StringLengthAttributeRelay.cs,Create,The length of the statement  "            return context.Resolve(new ConstrainedStringRequest(stringLengthAttribute.MinimumLength' stringLengthAttribute.MaximumLength)); " is 127.
Long Statement,AutoFixture.Kernel,AutoPropertiesCommand<T>,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\AutoPropertiesCommand.cs,GetProperties,The length of the statement  "            return from pi in this.GetSpecimenType(specimen).GetTypeInfo().GetProperties(BindingFlags.Public | BindingFlags.Instance) " is 121.
Long Statement,AutoFixture.Kernel,ConstructorMethod,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ConstructorMethod.cs,Invoke,The length of the statement  "                                    @"AutoFixture was unable to create an instance of {0}' since it's an abstract class with a public constructor. Please consider changing the definition of {0}; while technically possible' an abstract class with a public constructor represents a design error. For more information please refer to: http://tinyurl.com/lg38t3g. If you are unable to modify the {0} class' you can customize AutoFixture by mapping the class to a concrete type. As an example' imagine that AbstractClassWithPublicConstructor is an abstract class with a public constructor' and that you can't change the definition of that class. In order to work around that issue' you can add a test-specific concrete class that derives from AbstractClassWithPublicConstructor: " is 737.
Long Statement,AutoFixture.Kernel,ConstructorMethod,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ConstructorMethod.cs,Invoke,The length of the statement  "This will cause AutoFixture to create an instance of TestDouble every time AbstractClassWithPublicConstructor is requested. However' please keep in mind that this is only a workaround for the case where you can't address the root cause' which is that an abstract class has a public constructor."' " is 296.
Long Statement,AutoFixture.Kernel,ExpressionReflector,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ExpressionReflector.cs,VerifyIsNonNestedWritableMemberExpression,The length of the statement  "                    "Configuration API doesn't support this feature' therefore please rewrite the expression to avoid nested fields or properties."' " is 128.
Long Statement,AutoFixture.Kernel,IntPtrGuard,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\IntPtrGuard.cs,Create,The length of the statement  "            throw new IllegalRequestException("A request for an IntPtr was detected. This is an unsafe resource that will crash the process if used' so the request is denied. A common source of IntPtr requests are requests for delegates such as Func<T> or Action<T>. If this is the case' the expected workaround is to Customize (Register or Inject) the offending type by specifying a proper creational strategy."); " is 402.
Long Statement,AutoFixture.Kernel,MutableValueTypeWarningThrower,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MutableValueTypeWarningThrower.cs,Create,The length of the statement  "                    @"AutoFixture was unwilling to create an instance from {0}' since it is a value type with no explicit' parameterized constructors. Are you attempting to create an instance of a mutable value type? If so' you should strongly consider changing the design of the value type. However' if you are unable to do so' you can add the {1} customizations to your Fixture instance: " is 369.
Long Statement,AutoFixture.Kernel,NoSpecimenOutputGuard,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\NoSpecimenOutputGuard.cs,Create,The length of the statement  "                throw new ObjectCreationException(string.Format(CultureInfo.CurrentCulture' "The decorated ISpecimenBuilder could not create a specimen based on the request: {0}. This can happen if the request represents an interface or abstract class; if this is the case' register an ISpecimenBuilder that can create specimens based on the request. If this happens in a strongly typed Build<T> expression' try supplying a factory using one of the IFactoryComposer<T> methods."' request)); " is 474.
Long Statement,AutoFixture.Kernel,TemplateMethodQuery,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TemplateMethodQuery.cs,SelectMethods,The length of the statement  "                   where string.Equals(method.Name' this.Template.Name' StringComparison.Ordinal) && (this.Owner != null || method.IsStatic) " is 121.
Long Statement,AutoFixture.Kernel,TerminatingSpecimenBuilder,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TerminatingSpecimenBuilder.cs,Create,The length of the statement  "                    "AutoFixture was unable to create an instance from {0}' most likely because it has no public constructor' is an abstract or non-public type."' " is 142.
Long Statement,AutoFixture.Kernel,ThrowingRecursionGuard,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ThrowingRecursionGuard.cs,HandleRecursiveRequest,The length of the statement  "                    @"AutoFixture was unable to create an instance of type {0} because the traversed object graph contains a circular reference. Information about the circular path follows below. This is the correct behavior when a Fixture is equipped with a ThrowingRecursionBehavior' which is the default. This ensures that you are being made aware of circular references in your code. Your first reaction should be to redesign your API in order to get rid of all circular references. However' if this is not possible (most likely because parts or all of the API is delivered by a third party)' you can replace this default behavior with a different behavior: on the Fixture instance' remove the ThrowingRecursionBehavior from Fixture.Behaviors' and instead add an instance of OmitOnRecursionBehavior: " is 783.
Long Statement,AutoFixture.Kernel,ThrowingRecursionHandler,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ThrowingRecursionHandler.cs,HandleRecursiveRequest,The length of the statement  "                    @"AutoFixture was unable to create an instance of type {0} because the traversed object graph contains a circular reference. Information about the circular path follows below. This is the correct behavior when a Fixture is equipped with a ThrowingRecursionBehavior' which is the default. This ensures that you are being made aware of circular references in your code. Your first reaction should be to redesign your API in order to get rid of all circular references. However' if this is not possible (most likely because parts or all of the API is delivered by a third party)' you can replace this default behavior with a different behavior: on the Fixture instance' remove the ThrowingRecursionBehavior from Fixture.Behaviors' and instead add an instance of OmitOnRecursionBehavior: " is 783.
Complex Conditional,AutoFixture,RangedNumberGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,CreateAnonymous,The conditional expression  "(range.OperandType == typeof(byte) &&                          Convert.ToInt32(                              this.rangedValue'                              CultureInfo.CurrentCulture) > byte.MaxValue) ||                          (range.OperandType == typeof(short) &&                          Convert.ToInt32(                              this.rangedValue'                              CultureInfo.CurrentCulture) > short.MaxValue)"  is complex.
Magic Number,AutoFixture,CharSequenceGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\CharSequenceGenerator.cs,Create,The following statement contains a magic number: this.c > 126
Magic Number,AutoFixture,DictionaryFiller,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\DictionaryFiller.cs,Execute,The following statement contains a magic number: typeArguments.Length != 2
Magic Number,AutoFixture,RandomCharSequenceGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\RandomCharSequenceGenerator.cs,RandomCharSequenceGenerator,The following statement contains a magic number: this.randomPrintableCharNumbers = new RandomNumericSequenceGenerator(33' 126);
Magic Number,AutoFixture,RandomCharSequenceGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\RandomCharSequenceGenerator.cs,RandomCharSequenceGenerator,The following statement contains a magic number: this.randomPrintableCharNumbers = new RandomNumericSequenceGenerator(33' 126);
Magic Number,AutoFixture,RandomNumericSequenceGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\RandomNumericSequenceGenerator.cs,RandomNumericSequenceGenerator,The following statement contains a magic number: limits.Length < 2
Magic Number,AutoFixture,FloatingPointRangedGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\RandomRangedNumberGenerator.cs,Create,The following statement contains a magic number: double halfOffset = (this.factor / 2) * (double)randomValue;
Magic Number,AutoFixture,HighPrecisionRangedGenerator,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\RandomRangedNumberGenerator.cs,Create,The following statement contains a magic number: var halfOffset = (this.factor / 2) * (decimal)randomValue;
Magic Number,AutoFixture.DataAnnotations,Range,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\MinAndMaxLengthAttributeRelay.cs,GetRange,The following statement contains a magic number: var max = maxLengthAttribute?.Length ?? min * 2;
Magic Number,AutoFixture.DataAnnotations,RangedRequest,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangedRequest.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.OperandType.GetHashCode();
Magic Number,AutoFixture.DataAnnotations,RangedRequest,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangedRequest.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.Minimum.GetHashCode();
Magic Number,AutoFixture.DataAnnotations,RangedRequest,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangedRequest.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.Maximum.GetHashCode();
Magic Number,AutoFixture.Dsl,CompositeNodeComposer<T>,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,Compose,The following statement contains a magic number: var isSingle = builders.Take(2).Count() == 1;
Magic Number,AutoFixture.Kernel,DictionaryRelay,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\DictionaryRelay.cs,Create,The following statement contains a magic number: typeArguments.Length != 2
Magic Number,AutoFixture.Kernel,MultipleRelay,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MultipleRelay.cs,MultipleRelay,The following statement contains a magic number: this.count = 3;
Magic Number,AutoFixture.Kernel,RangedSequenceRequest,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\RangedSequenceRequest.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.MinLength;
Magic Number,AutoFixture.Kernel,RangedSequenceRequest,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\RangedSequenceRequest.cs,GetHashCode,The following statement contains a magic number: hashCode = (hashCode * 397) ^ this.MaxLength;
Magic Number,AutoFixture.Kernel,LateBindingParameterScore,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TemplateMethodQuery.cs,CalculateScore,The following statement contains a magic number: return 100;
Magic Number,AutoFixture.Kernel,LateBindingParameterScore,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TemplateMethodQuery.cs,CalculateScore,The following statement contains a magic number: var score = 50 * -(hierarchy.Count - matches);
Magic Number,AutoFixture.Kernel,LateBindingParameterScore,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TemplateMethodQuery.cs,CalculateScore,The following statement contains a magic number: score += CalculateScore(methodTypeArguments' templateTypeArguments) / 10;
Magic Number,AutoFixture.Kernel,LateBindingParameterScore,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TemplateMethodQuery.cs,CalculateScore,The following statement contains a magic number: score += 50 * -Math.Abs(methodTypeArguments.Length - templateTypeArguments.Length);
Magic Number,AutoFixture.Kernel,LateBindingParameterScore,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TemplateMethodQuery.cs,CalculateScore,The following statement contains a magic number: score += 5;
Magic Number,AutoFixture.Kernel,TraceWriter,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TraceWriter.cs,TraceWriter,The following statement contains a magic number: this.TraceRequestFormatter = (tw' r' i) => tw.WriteLine(new string(' '' i * 2) + "Requested: " + r);
Magic Number,AutoFixture.Kernel,TraceWriter,D:\research\architectureSmells\repos\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TraceWriter.cs,TraceWriter,The following statement contains a magic number: this.TraceSpecimenFormatter = (tw' r' i) => tw.WriteLine(new string(' '' i * 2) + "Created: " + r);
