Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ploeh.AutoFixture.DataAnnotations,MinimizationOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\MinimizationOperations.cs,MinimizeHopcroft,The method has 164 lines of code.
Complex Method,Ploeh.AutoFixture,RandomNumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomNumericSequenceGenerator.cs,CreateRandom,Cyclomatic complexity of the method is 13
Complex Method,Ploeh.AutoFixture,RandomRangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomRangedNumberGenerator.cs,ConvertLimit,Cyclomatic complexity of the method is 11
Complex Method,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,Add,Cyclomatic complexity of the method is 13
Complex Method,Ploeh.AutoFixture,NumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\NumericSequenceGenerator.cs,CreateNumericSpecimen,Cyclomatic complexity of the method is 13
Complex Method,Ploeh.AutoFixture.Kernel,SpecimenBuilderNode,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SpecimenBuilderNode.cs,GraphEquals,Cyclomatic complexity of the method is 8
Complex Method,Ploeh.AutoFixture.DataAnnotations,Automaton,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\Automaton.cs,Reduce,Cyclomatic complexity of the method is 10
Complex Method,Ploeh.AutoFixture.DataAnnotations,BasicAutomata,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicAutomata.cs,MakeStringMatcher,Cyclomatic complexity of the method is 10
Complex Method,Ploeh.AutoFixture.DataAnnotations,BasicOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicOperations.cs,AddEpsilons,Cyclomatic complexity of the method is 12
Complex Method,Ploeh.AutoFixture.DataAnnotations,BasicOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicOperations.cs,Concatenate,Cyclomatic complexity of the method is 11
Complex Method,Ploeh.AutoFixture.DataAnnotations,BasicOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicOperations.cs,Intersection,Cyclomatic complexity of the method is 12
Complex Method,Ploeh.AutoFixture.DataAnnotations,BasicOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicOperations.cs,Repeat,Cyclomatic complexity of the method is 9
Complex Method,Ploeh.AutoFixture.DataAnnotations,BasicOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicOperations.cs,Run,Cyclomatic complexity of the method is 10
Complex Method,Ploeh.AutoFixture.DataAnnotations,MinimizationOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\MinimizationOperations.cs,Minimize,Cyclomatic complexity of the method is 10
Complex Method,Ploeh.AutoFixture.DataAnnotations,MinimizationOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\MinimizationOperations.cs,MinimizeHopcroft,Cyclomatic complexity of the method is 32
Complex Method,Ploeh.AutoFixture.DataAnnotations,MinimizationOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\MinimizationOperations.cs,MinimizeHuffman,Cyclomatic complexity of the method is 19
Complex Method,Ploeh.AutoFixture.DataAnnotations,MinimizationOperations,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\MinimizationOperations.cs,AddTriggers,Cyclomatic complexity of the method is 8
Complex Method,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,ToAutomaton,Cyclomatic complexity of the method is 70
Complex Method,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,ToStringBuilder,Cyclomatic complexity of the method is 77
Complex Method,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,GetIdentifiers,Cyclomatic complexity of the method is 16
Complex Method,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,ParseRepeatExp,Cyclomatic complexity of the method is 12
Complex Method,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,ParseSimpleExp,Cyclomatic complexity of the method is 20
Complex Method,Ploeh.AutoFixture.DataAnnotations,TransitionComparer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\TransitionComparer.cs,Compare,Cyclomatic complexity of the method is 17
Long Parameter List,Ploeh.AutoFixture.DataAnnotations,BasicAutomata,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicAutomata.cs,Between,The method has 5 parameters.
Long Parameter List,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,FindLeaves,The method has 6 parameters.
Long Statement,Ploeh.AutoFixture,LazyRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\LazyRelay.cs,Create,The length of the statement  "	var builder = (ILazyBuilder)Activator.CreateInstance (typeof(LazyBuilder<>).MakeGenericType (t.GetGenericArguments ())); " is 120.
Long Statement,Ploeh.AutoFixture,NoDataAnnotationsCustomization,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\NoDataAnnotationsCustomization.cs,Customize,The length of the statement  "	fixture.Customizations.Where (c => dataAnnotationsRelayTypes.Contains (c.GetType ())).ToList ().ForEach (c => fixture.Customizations.Remove (c)); " is 145.
Long Statement,Ploeh.AutoFixture,EnumerableList,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\EnumerableList.cs,SetItem,The length of the statement  "		throw new ArgumentOutOfRangeException (nameof (index)' string.Format (CultureInfo.CurrentCulture' "The supplied index was less than zero ({0}). Only zero and positive index numbers are supported."' index)); " is 206.
Long Statement,Ploeh.AutoFixture,EnumerableList,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\EnumerableList.cs,SetItem,The length of the statement  "		throw new ArgumentOutOfRangeException (nameof (index)' string.Format (CultureInfo.CurrentCulture' "The supplied index ({0}) exceeds the addressable space of the current sequence. The length of the sequence is only {1}."' index' a.Length)); " is 239.
Long Statement,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,CreateAnonymous,The length of the statement  "			if (range.OperandType == typeof(byte) && Convert.ToInt32 (this.rangedValue' CultureInfo.CurrentCulture) > byte.MaxValue || range.OperandType == typeof(short) && Convert.ToInt32 (this.rangedValue' CultureInfo.CurrentCulture) > short.MaxValue) " is 241.
Long Statement,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,CreateAnonymous,The length of the statement  "		if (this.rangedValue != null && (minimum.CompareTo (this.rangedValue) <= 0 && maximum.CompareTo (this.rangedValue) > 0)) { " is 122.
Long Statement,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,CreateAnonymous,The length of the statement  "			this.rangedValue = Convert.ChangeType (RangedNumberGenerator.Add (this.rangedValue' Convert.ChangeType (1' range.OperandType' CultureInfo.CurrentCulture))' range.OperandType' CultureInfo.CurrentCulture); " is 203.
Long Statement,Ploeh.AutoFixture,SingletonSpecimenBuilderNodeStackAdapterCollection,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\SingletonSpecimenBuilderNodeStackAdapterCollection.cs,UpdateGraph,The length of the statement  "		throw new InvalidOperationException ("An ISpecimenBuilderTransformation returned a result which cannot be converted to an ISpecimenBuilderNode. To be used in the current context' all ISpecimenBuilderTransformation Transform methods must return an ISpecimenBuilderNode instance."); " is 280.
Long Statement,Ploeh.AutoFixture,MultipleCustomization,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MultipleCustomization.cs,Customize,The length of the statement  "	fixture.Customizations.Add (new FilteringSpecimenBuilder (new Postprocessor (new MethodInvoker (new ModestConstructorQuery ())' new DictionaryFiller ())' new DictionarySpecification ())); " is 187.
Long Statement,Ploeh.AutoFixture,MultipleCustomization,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MultipleCustomization.cs,Customize,The length of the statement  "	fixture.Customizations.Add (new FilteringSpecimenBuilder (new MethodInvoker (new ListFavoringConstructorQuery ())' new CollectionSpecification ())); " is 148.
Long Statement,Ploeh.AutoFixture,MultipleCustomization,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MultipleCustomization.cs,Customize,The length of the statement  "	fixture.Customizations.Add (new FilteringSpecimenBuilder (new MethodInvoker (new EnumerableFavoringConstructorQuery ())' new HashSetSpecification ())); " is 151.
Long Statement,Ploeh.AutoFixture,MultipleCustomization,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MultipleCustomization.cs,Customize,The length of the statement  "	fixture.Customizations.Add (new FilteringSpecimenBuilder (new MethodInvoker (new EnumerableFavoringConstructorQuery ())' new ListSpecification ())); " is 148.
Long Statement,Ploeh.AutoFixture,Fixture,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Fixture.cs,Build,The length of the statement  "	var g = this.graph.ReplaceNodes (with: n => new CompositeSpecimenBuilder (SpecimenBuilderNodeFactory.CreateComposer<T> ().WithAutoProperties (this.EnableAutoProperties)' n)' when: n => n is BehaviorRoot); " is 204.
Long Statement,Ploeh.AutoFixture,Fixture,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Fixture.cs,Customize,The length of the statement  "	var c = composerTransformation (SpecimenBuilderNodeFactory.CreateComposer<T> ().WithAutoProperties (this.EnableAutoProperties)); " is 128.
Long Statement,Ploeh.AutoFixture,Fixture,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Fixture.cs,UpdateBehaviors,The length of the statement  "	this.behaviors = new SingletonSpecimenBuilderNodeStackAdapterCollection (this.graph' n => n is BehaviorRoot' transformations); " is 126.
Long Statement,Ploeh.AutoFixture,SpecimenFactory,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\SpecimenFactory.cs,CreateMany,The length of the statement  "	return from s in (IEnumerable<object>)context.Resolve (new FiniteSequenceRequest (new SeededRequest (typeof(T)' seed)' count)) " is 126.
Long Statement,Ploeh.AutoFixture.Kernel,EnumeratorRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumeratorRelay.cs,Create,The length of the statement  "	var specimenBuilder = (ISpecimenBuilder)Activator.CreateInstance (typeof(EnumeratorRelay<>).MakeGenericType (typeArguments)); " is 125.
Long Statement,Ploeh.AutoFixture.Kernel,FieldTypeAndNameCriterion,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\FieldTypeAndNameCriterion.cs,Equals,The length of the statement  "	return object.Equals (this.TypeCriterion' other.TypeCriterion) && object.Equals (this.NameCriterion' other.NameCriterion); " is 122.
Long Statement,Ploeh.AutoFixture.Kernel,GenericMethod,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\GenericMethod.cs,InferMethodInfo,The length of the statement  "		var typeMap = arguments.Zip (methodInfo.GetParameters ()' (argument' parameter) => ResolveGenericType (GetType (argument)' parameter.ParameterType)).SelectMany (x => x).ToLookup (x => x.Item1' x => x.Item2); " is 207.
Long Statement,Ploeh.AutoFixture.Kernel,ParameterTypeAndNameCriterion,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ParameterTypeAndNameCriterion.cs,Equals,The length of the statement  "	return object.Equals (this.TypeCriterion' other.TypeCriterion) && object.Equals (this.NameCriterion' other.NameCriterion); " is 122.
Long Statement,Ploeh.AutoFixture.Kernel,PropertyTypeAndNameCriterion,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\PropertyTypeAndNameCriterion.cs,Equals,The length of the statement  "	return object.Equals (this.TypeCriterion' other.TypeCriterion) && object.Equals (this.NameCriterion' other.NameCriterion); " is 122.
Long Statement,Ploeh.AutoFixture.Kernel,TemplateMethodQuery,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TemplateMethodQuery.cs,SelectMethods,The length of the statement  "	where methodParameters.All (p => p.Position >= templateParameters.Length ? p.IsOptional || p.IsDefined (typeof(ParamArrayAttribute)' true) : Compare (p.ParameterType' templateParameters [p.Position].ParameterType)) " is 214.
Long Statement,Ploeh.AutoFixture.Kernel,TemplateMethodQuery,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TemplateMethodQuery.cs,Compare,The length of the statement  "		return templateParameterType.IsGenericParameter && parameterType.GenericParameterPosition == templateParameterType.GenericParameterPosition; " is 140.
Long Statement,Ploeh.AutoFixture.Kernel,MissingParametersSupplyingMethod,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MissingParametersSupplyingMethod.cs,GetHashCode,The length of the statement  "	return this.Method.GetHashCode () ^ this.Parameters.Aggregate (0' (current' parameter) => current + parameter.GetHashCode ()); " is 126.
Long Statement,Ploeh.AutoFixture.Kernel,TypeArgumentsCannotBeInferredException,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TypeArgumentsCannotBeInferredException.cs,GetFriendlyName,The length of the statement  "		return string.Format (CultureInfo.CurrentCulture' "{0}<{1}>"' type.Name.Split ('`') [0]' string.Join ("' "' type.GetGenericArguments ().Select (GetFriendlyName))); " is 163.
Long Statement,Ploeh.AutoFixture.Kernel,TerminatingWithPathSpecimenBuilder,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TerminatingWithPathSpecimenBuilder.cs,Create,The length of the statement  "			throw new ObjectCreationException (string.Format (CultureInfo.CurrentCulture' BuildCoreMessageTemplate (request)' request' Environment.NewLine' BuildRequestPathText (this.SpecimenRequests))); " is 191.
Long Statement,Ploeh.AutoFixture.Kernel,TerminatingWithPathSpecimenBuilder,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TerminatingWithPathSpecimenBuilder.cs,BuildCoreMessageTemplate,The length of the statement  "		return "AutoFixture was unable to create an instance from {0} " + "because it's an interface. There's no single' most " + "appropriate way to create an object implementing the " + "interface' but you can help AutoFixture figure it out." + "{1}" + "{1}" + "If you have a concrete class implementing the " + "interface' you can map the interface to that class:" + typeMappingOptionsHelp + "{1}" + "{1}" + "Request path:{1}{2}{1}"; " is 428.
Long Statement,Ploeh.AutoFixture.Kernel,TerminatingWithPathSpecimenBuilder,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TerminatingWithPathSpecimenBuilder.cs,BuildCoreMessageTemplate,The length of the statement  "		return "AutoFixture was unable to create an instance from {0} " + "because it's an abstract class. There's no single' " + "most appropriate way to create an object deriving from " + "that class' but you can help AutoFixture figure it out." + "{1}" + "{1}" + "If you have a concrete class deriving from the abstract " + "class' you can map the abstract class to that derived " + "class:" + typeMappingOptionsHelp + "{1}" + "{1}" + "Request path:{1}{2}{1}"; " is 455.
Long Statement,Ploeh.AutoFixture.Kernel,TerminatingWithPathSpecimenBuilder,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TerminatingWithPathSpecimenBuilder.cs,BuildCoreMessageTemplate,The length of the statement  "	return "AutoFixture was unable to create an instance from {0}' " + "most likely because it has no public constructor' is an " + "abstract or non-public type.{1}{1}Request path:{1}{2}"; " is 184.
Long Statement,Ploeh.AutoFixture.Kernel,TerminatingWithPathSpecimenBuilder,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TerminatingWithPathSpecimenBuilder.cs,BuildRequestPathText,The length of the statement  "	return recordedRequests.Where (r => r.GetType ().Assembly != thisAssembly).Select ((r' i) => string.Format (CultureInfo.CurrentCulture' "\t{0} {1}"' " ".PadLeft (i + 1)' r)).Aggregate ((s1' s2) => s1 + " --> " + Environment.NewLine + s2); " is 238.
Long Statement,Ploeh.AutoFixture.Kernel,PropertySpecification,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\PropertySpecification.cs,CreateDefaultTarget,The length of the statement  "	return new PropertyTypeAndNameCriterion (new Criterion<Type> (targetType' new DerivesFromTypeComparer ())' new Criterion<string> (targetName' EqualityComparer<string>.Default)); " is 177.
Long Statement,Ploeh.AutoFixture.Kernel,ParameterSpecification,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ParameterSpecification.cs,CreateDefaultTarget,The length of the statement  "	return new ParameterTypeAndNameCriterion (new Criterion<Type> (targetType' new DerivesFromTypeComparer ())' new Criterion<string> (targetName' EqualityComparer<string>.Default)); " is 178.
Long Statement,Ploeh.AutoFixture.Kernel,FieldSpecification,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\FieldSpecification.cs,CreateDefaultTarget,The length of the statement  "	return new FieldTypeAndNameCriterion (new Criterion<Type> (targetType' new DerivesFromTypeComparer ())' new Criterion<string> (targetName' EqualityComparer<string>.Default)); " is 174.
Long Statement,Ploeh.AutoFixture.Kernel,ThrowingRecursionHandler,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ThrowingRecursionHandler.cs,HandleRecursiveRequest,The length of the statement  "	throw new ObjectCreationException (string.Format (CultureInfo.InvariantCulture' @"AutoFixture was unable to create an instance of type {0} because the traversed object graph contains a circular reference. Information about the circular path follows below. This is the correct behavior when a Fixture is equipped with a ThrowingRecursionBehavior' which is the default. This ensures that you are being made aware of circular references in your code. Your first reaction should be to redesign your API in order to get rid of all circular references. However' if this is not possible (most likely because parts or all of the API is delivered by a third party)' you can replace this default behavior with a different behavior: on the Fixture instance' remove the ThrowingRecursionBehavior from Fixture.Behaviors' and instead add an instance of OmitOnRecursionBehavior:" is 863.
Long Statement,Ploeh.AutoFixture.Kernel,ThrowingRecursionHandler,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ThrowingRecursionHandler.cs,HandleRecursiveRequest,The length of the statement  "                " + "{2}\tPath:{2}{1}"' recordedRequests.Cast<object> ().First ().GetType ()' GetFlattenedRequests (request' recordedRequests)' Environment.NewLine)); " is 150.
Long Statement,Ploeh.AutoFixture.Kernel,MutableValueTypeWarningThrower,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MutableValueTypeWarningThrower.cs,Create,The length of the statement  "	throw new ObjectCreationException (string.Format (CultureInfo.CurrentCulture' @"AutoFixture was unwilling to create an instance from {0}' since it is a value type with no explicit' parameterized constructors. Are you attempting to create an instance of a mutable value type? If so' you should strongly consider changing the design of the value type. However' if you are unable to do so' you can add the {1} customizations to your Fixture instance:" is 447.
Long Statement,Ploeh.AutoFixture.Kernel,MutableValueTypeWarningThrower,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MutableValueTypeWarningThrower.cs,Create,The length of the statement  "For more information about mutable value types please refer to: http://tinyurl.com/pegtw57"' request' typeof(SupportMutableValueTypesCustomization).Name)); " is 155.
Long Statement,Ploeh.AutoFixture.Kernel,RangedNumberRequest,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\RangedNumberRequest.cs,Equals,The length of the statement  "	return this.OperandType == other.OperandType && object.Equals (this.Minimum' other.Minimum) && object.Equals (this.Maximum' other.Maximum); " is 139.
Long Statement,Ploeh.AutoFixture.Kernel,SpecimenBuilderNodeFactory,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SpecimenBuilderNodeFactory.cs,CreateComposer,The length of the statement  "	return new NodeComposer<T> (SpecimenBuilderNodeFactory.CreateTypedNode (typeof(T)' new MethodInvoker (new ModestConstructorQuery ()))); " is 135.
Long Statement,Ploeh.AutoFixture.Kernel,SpecimenBuilderNodeFactory,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SpecimenBuilderNodeFactory.cs,CreateTypedNode,The length of the statement  "	return new FilteringSpecimenBuilder (new CompositeSpecimenBuilder (new NoSpecimenOutputGuard (factory' new InverseRequestSpecification (new SeedRequestSpecification (targetType)))' new SeedIgnoringRelay ())' new OrRequestSpecification (new SeedRequestSpecification (targetType)' new ExactTypeSpecification (targetType))); " is 321.
Long Statement,Ploeh.AutoFixture.Kernel,ConstructorMethod,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ConstructorMethod.cs,Invoke,The length of the statement  "		throw new ObjectCreationException (string.Format (CultureInfo.CurrentCulture' @"AutoFixture was unable to create an instance of {0}' since it's an abstract class with a public constructor. Please consider changing the definition of {0}; while technically possible' an abstract class with a public constructor represents a design error. For more information please refer to: http://tinyurl.com/lg38t3g. If you are unable to modify the {0} class' you can customize AutoFixture by mapping the class to a concrete type. As an example' imagine that AbstractClassWithPublicConstructor is an abstract class with a public constructor' and that you can't change the definition of that class. In order to work around that issue' you can add a test-specific concrete class that derives from AbstractClassWithPublicConstructor: " is 815.
Long Statement,Ploeh.AutoFixture.Kernel,ConstructorMethod,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ConstructorMethod.cs,Invoke,The length of the statement  "This will cause AutoFixture to create an instance of TestDouble every time AbstractClassWithPublicConstructor is requested. However' please keep in mind that this is only a workaround for the case where you can't address the root cause' which is that an abstract class has a public constructor."' this.Constructor.DeclaringType.Name)); " is 335.
Long Statement,Ploeh.AutoFixture.Kernel,DelegateGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\DelegateGenerator.cs,CreateMethodSpecimenParameters,The length of the statement  "	var parameters = request.GetParameters ().Select (param => Expression.Parameter (param.ParameterType' String.Concat ("arg"' paramCount++))); " is 140.
Long Statement,Ploeh.AutoFixture.Kernel,StaticMethod,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\StaticMethod.cs,GetHashCode,The length of the statement  "	return this.Method.GetHashCode () ^ this.Parameters.Aggregate (0' (current' parameter) => current + parameter.GetHashCode ()); " is 126.
Long Statement,Ploeh.AutoFixture.Kernel,IntPtrGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\IntPtrGuard.cs,Create,The length of the statement  "	throw new IllegalRequestException ("A request for an IntPtr was detected. This is an unsafe resource that will crash the process if used' so the request is denied. A common source of IntPtr requests are requests for delegates such as Func<T> or Action<T>. If this is the case' the expected workaround is to Customize (Register or Inject) the offending type by specifying a proper creational strategy."); " is 403.
Long Statement,Ploeh.AutoFixture.Kernel,ExpressionReflector,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ExpressionReflector.cs,GetWritableMember,The length of the statement  "		throw new ArgumentException ("The expression's Body is not a MemberExpression. Most likely this is because it does not represent access to a property or field."' nameof (propertyPicker)); " is 187.
Long Statement,Ploeh.AutoFixture.Kernel,ExpressionReflector,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ExpressionReflector.cs,GetWritableMember,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.CurrentCulture' "The property \"{0}\" is read-only."' pi.Name)' nameof (propertyPicker)); " is 145.
Long Statement,Ploeh.AutoFixture.Kernel,NoSpecimenOutputGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\NoSpecimenOutputGuard.cs,Create,The length of the statement  "		throw new ObjectCreationException (string.Format (CultureInfo.CurrentCulture' "The decorated ISpecimenBuilder could not create a specimen based on the request: {0}. This can happen if the request represents an interface or abstract class; if this is the case' register an ISpecimenBuilder that can create specimens based on the request. If this happens in a strongly typed Build<T> expression' try supplying a factory using one of the IFactoryComposer<T> methods."' request)); " is 476.
Long Statement,Ploeh.AutoFixture.Kernel,Postprocessor,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\Postprocessor.cs,Create,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' "The specimen returned by the decorated ISpecimenBuilder is not compatible with {0}."' typeof(T))); " is 179.
Long Statement,Ploeh.AutoFixture.Kernel,BindingCommand,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\BindingCommand.cs,CreateAnonymousValue,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' "The specimen created for assignment is not compatible with {0}."' typeof(TProperty))); " is 167.
Long Statement,Ploeh.AutoFixture.Kernel,TerminatingSpecimenBuilder,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TerminatingSpecimenBuilder.cs,Create,The length of the statement  "	throw new ObjectCreationException (string.Format (CultureInfo.CurrentCulture' "AutoFixture was unable to create an instance from {0}' most likely because it has no public constructor' is an abstract or non-public type."' request)); " is 231.
Long Statement,Ploeh.AutoFixture.Kernel,ThrowingRecursionGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ThrowingRecursionGuard.cs,HandleRecursiveRequest,The length of the statement  "	throw new ObjectCreationException (string.Format (CultureInfo.InvariantCulture' @"AutoFixture was unable to create an instance of type {0} because the traversed object graph contains a circular reference. Information about the circular path follows below. This is the correct behavior when a Fixture is equipped with a ThrowingRecursionBehavior' which is the default. This ensures that you are being made aware of circular references in your code. Your first reaction should be to redesign your API in order to get rid of all circular references. However' if this is not possible (most likely because parts or all of the API is delivered by a third party)' you can replace this default behavior with a different behavior: on the Fixture instance' remove the ThrowingRecursionBehavior from Fixture.Behaviors' and instead add an instance of OmitOnRecursionBehavior: " is 863.
Long Statement,Ploeh.AutoFixture.Kernel,ThrowingRecursionGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ThrowingRecursionGuard.cs,HandleRecursiveRequest,The length of the statement  "                " + "{2}\tPath:{2}{1}"' this.RecordedRequests.Cast<object> ().First ().GetType ()' this.GetFlattenedRequests (request)' Environment.NewLine)); " is 142.
Long Statement,Ploeh.AutoFixture.DataAnnotations,Automaton,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\Automaton.cs,GetStates,The length of the statement  "		HashSet<Transition> tr = this.IsDebug ? new HashSet<Transition> (s.GetSortedTransitions (false)) : new HashSet<Transition> (s.Transitions); " is 139.
Long Statement,Ploeh.AutoFixture.DataAnnotations,BasicAutomata,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicAutomata.cs,MakeTotalDigits,The length of the statement  "	return Automaton.Minimize (new RegExp ("[ \t\n\r]*[-+]?0*([0-9]{0'" + i + "}|((([0-9]\\.*){0'" + i + "})&@\\.@)0*)[ \t\n\r]*").ToAutomaton ()); " is 143.
Long Statement,Ploeh.AutoFixture.DataAnnotations,ListEqualityComparer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\ListEqualityComparer.cs,GetHashCode,The length of the statement  "	// http://stackoverflow.com/questions/1079192/is-it-possible-to-combine-hash-codes-for-private-members-to-generate-a-new-hash " is 125.
Long Statement,Ploeh.AutoFixture.DataAnnotations,RangeAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangeAttributeRelay.cs,Create,The length of the statement  "	var rangeAttribute = customAttributeProvider.GetCustomAttributes (typeof(RangeAttribute)' inherit: true).Cast<RangeAttribute> ().SingleOrDefault (); " is 148.
Long Statement,Ploeh.AutoFixture.DataAnnotations,RangeAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangeAttributeRelay.cs,Create,The length of the statement  "	return new RangedNumberRequest (conversionType' Convert.ChangeType (rangeAttribute.Minimum' conversionType' CultureInfo.CurrentCulture)' Convert.ChangeType (rangeAttribute.Maximum' conversionType' CultureInfo.CurrentCulture)); " is 226.
Long Statement,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,MakeConcatenation,The length of the statement  "	if ((exp1.kind == Kind.RegexpChar || exp1.kind == Kind.RegexpString) && (exp2.kind == Kind.RegexpChar || exp2.kind == Kind.RegexpString)) { " is 139.
Long Statement,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,MakeConcatenation,The length of the statement  "	if (exp1.kind == Kind.RegexpConcatenation && (exp1.exp2.kind == Kind.RegexpChar || exp1.exp2.kind == Kind.RegexpString) && (exp2.kind == Kind.RegexpChar || exp2.kind == Kind.RegexpString)) { " is 190.
Long Statement,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,MakeConcatenation,The length of the statement  "	} else if ((exp1.kind == Kind.RegexpChar || exp1.kind == Kind.RegexpString) && exp2.kind == Kind.RegexpConcatenation && (exp2.exp1.kind == Kind.RegexpChar || exp2.exp1.kind == Kind.RegexpString)) { " is 197.
Long Statement,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,ToAutomaton,The length of the statement  "		a = exp1.ToAutomaton (automata' automatonProvider' minimize).Intersection (exp2.ToAutomaton (automata' automatonProvider' minimize)); " is 133.
Long Statement,Ploeh.AutoFixture.DataAnnotations,RegularExpressionAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegularExpressionAttributeRelay.cs,Create,The length of the statement  "	var regularExpressionAttribute = customAttributeProvider.GetCustomAttributes (typeof(RegularExpressionAttribute)' inherit: true).Cast<RegularExpressionAttribute> ().SingleOrDefault (); " is 184.
Long Statement,Ploeh.AutoFixture.DataAnnotations,StatePair,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StatePair.cs,Equals,The length of the statement  "	return object.Equals (other.S' S) && object.Equals (other.FirstState' this.FirstState) && object.Equals (other.SecondState' this.SecondState); " is 142.
Long Statement,Ploeh.AutoFixture.DataAnnotations,StringLengthAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StringLengthAttributeRelay.cs,Create,The length of the statement  "	var stringLengthAttribute = customAttributeProvider.GetCustomAttributes (typeof(StringLengthAttribute)' inherit: true).Cast<StringLengthAttribute> ().SingleOrDefault (); " is 169.
Long Statement,Ploeh.AutoFixture.DataAnnotations,StringLengthAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StringLengthAttributeRelay.cs,Create,The length of the statement  "	return context.Resolve (new ConstrainedStringRequest (stringLengthAttribute.MinimumLength' stringLengthAttribute.MaximumLength)); " is 129.
Long Statement,Ploeh.AutoFixture.Dsl,NodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\NodeComposer.cs,OmitAutoProperties,The length of the statement  "	return (NodeComposer<T>)this.ReplaceNodes (with: targetToRemove.Concat (p.Where (b => targetToRemove != b))' when: p.Equals); " is 125.
Long Statement,Ploeh.AutoFixture.Dsl,NodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\NodeComposer.cs,With,The length of the statement  "	return (NodeComposer<T>)this.ReplaceNodes (with: n => new Postprocessor<T> (n' new BindingCommand<T' TProperty> (propertyPicker)' CreateSpecification ())' when: targetToDecorate.Equals); " is 186.
Long Statement,Ploeh.AutoFixture.Dsl,NodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\NodeComposer.cs,With,The length of the statement  "		new Postprocessor<T> (CompositeSpecimenBuilder.ComposeIfMultiple (n)' new BindingCommand<T' TProperty> (propertyPicker' value)' CreateSpecification ())' " is 152.
Long Statement,Ploeh.AutoFixture.Dsl,NodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\NodeComposer.cs,With,The length of the statement  "		new Omitter (new EqualRequestSpecification (propertyPicker.GetWritableMember ().Member' new MemberInfoEqualityComparer ())) " is 123.
Long Statement,Ploeh.AutoFixture.Dsl,NodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\NodeComposer.cs,WithAutoProperties,The length of the statement  "		new Postprocessor<T> (CompositeSpecimenBuilder.ComposeIfMultiple (n)' new AutoPropertiesCommand<T> ()' CreateSpecification ())' " is 127.
Long Statement,Ploeh.AutoFixture.Dsl,NodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\NodeComposer.cs,WithoutSeedIgnoringRelay,The length of the statement  "	var g = this.ReplaceNodes (with: n => CompositeSpecimenBuilder.UnwrapIfSingle (n.Compose (n.Where (b => !(b is SeedIgnoringRelay))))' when: n => n.OfType<SeedIgnoringRelay> ().Any ()); " is 184.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,FromSeed,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).FromSeed (factory)' when: n => n is NodeComposer<T>); " is 154.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,FromFactory,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).FromFactory (factory)' when: n => n is NodeComposer<T>); " is 157.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,FromFactory,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).FromFactory (factory)' when: n => n is NodeComposer<T>); " is 157.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,FromFactory,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).FromFactory (factory)' when: n => n is NodeComposer<T>); " is 157.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,FromFactory,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).FromFactory (factory)' when: n => n is NodeComposer<T>); " is 157.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,FromFactory,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).FromFactory (factory)' when: n => n is NodeComposer<T>); " is 157.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,FromFactory,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).FromFactory (factory)' when: n => n is NodeComposer<T>); " is 157.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,Do,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).Do (action)' when: n => n is NodeComposer<T>); " is 147.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,OmitAutoProperties,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).OmitAutoProperties ()' when: n => n is NodeComposer<T>); " is 157.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,With,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).With (propertyPicker)' when: n => n is NodeComposer<T>); " is 157.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,With,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).With (propertyPicker' value)' when: n => n is NodeComposer<T>); " is 164.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,WithAutoProperties,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).WithAutoProperties ()' when: n => n is NodeComposer<T>); " is 157.
Long Statement,Ploeh.AutoFixture.Dsl,CompositeNodeComposer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Dsl\CompositeNodeComposer.cs,Without,The length of the statement  "	return (CompositeNodeComposer<T>)this.ReplaceNodes (with: n => (NodeComposer<T>)((NodeComposer<T>)n).Without (propertyPicker)' when: n => n is NodeComposer<T>); " is 160.
Complex Conditional,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,CreateAnonymous,The conditional expression  "range.OperandType == typeof(byte) && Convert.ToInt32 (this.rangedValue' CultureInfo.CurrentCulture) > byte.MaxValue || range.OperandType == typeof(short) && Convert.ToInt32 (this.rangedValue' CultureInfo.CurrentCulture) > short.MaxValue"  is complex.
Complex Conditional,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,MakeConcatenation,The conditional expression  "(exp1.kind == Kind.RegexpChar || exp1.kind == Kind.RegexpString) && (exp2.kind == Kind.RegexpChar || exp2.kind == Kind.RegexpString)"  is complex.
Complex Conditional,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,MakeConcatenation,The conditional expression  "exp1.kind == Kind.RegexpConcatenation && (exp1.exp2.kind == Kind.RegexpChar || exp1.exp2.kind == Kind.RegexpString) && (exp2.kind == Kind.RegexpChar || exp2.kind == Kind.RegexpString)"  is complex.
Complex Conditional,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,MakeConcatenation,The conditional expression  "(exp1.kind == Kind.RegexpChar || exp1.kind == Kind.RegexpString) && exp2.kind == Kind.RegexpConcatenation && (exp2.exp1.kind == Kind.RegexpChar || exp2.exp1.kind == Kind.RegexpString)"  is complex.
Complex Conditional,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,ParseConcatExp,The conditional expression  "this.More () && !this.Peek (")|") && (!this.Check (RegExpSyntaxOptions.Intersection) || !this.Peek ("&"))"  is complex.
Complex Conditional,Ploeh.AutoFixture.DataAnnotations,Transition,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\Transition.cs,AppendCharString,The conditional expression  "c >= 0x21 && c <= 0x7e && c != '\\' && c != '"'"  is complex.
Magic Number,Ploeh.AutoFixture,DomainNameGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DomainNameGenerator.cs,Create,The following statement contains a magic number: if (request == null || !typeof(DomainName).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,DomainNameGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DomainNameGenerator.cs,Create,The following statement contains a magic number: if (request == null || !typeof(DomainName).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,EmailAddressLocalPartGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\EmailAddressLocalPartGenerator.cs,Create,The following statement contains a magic number: if (request == null || !typeof(EmailAddressLocalPart).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,EmailAddressLocalPartGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\EmailAddressLocalPartGenerator.cs,Create,The following statement contains a magic number: if (request == null || !typeof(EmailAddressLocalPart).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,EmailAddressLocalPartGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\EmailAddressLocalPartGenerator.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty (localPart)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,EmailAddressLocalPartGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\EmailAddressLocalPartGenerator.cs,Create,The following statement contains a magic number: if (string.IsNullOrEmpty (localPart)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,LazyRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\LazyRelay.cs,Create,The following statement contains a magic number: if (t == null || !t.IsGenericType)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture,LazyRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\LazyRelay.cs,Create,The following statement contains a magic number: if (t.GetGenericTypeDefinition () != typeof(Lazy<>))  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture,RandomBooleanSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomBooleanSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(bool).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RandomBooleanSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomBooleanSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(bool).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,CharSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\CharSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(char).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,CharSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\CharSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(char).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,CharSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\CharSequenceGenerator.cs,Create,The following statement contains a magic number: lock (this.syncRoot) {  	if (c > 126) {  		c = '!';  	}  	return this.c++;  }  
Magic Number,Ploeh.AutoFixture,CharSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\CharSequenceGenerator.cs,Create,The following statement contains a magic number: if (c > 126) {  	c = '!';  }  
Magic Number,Ploeh.AutoFixture,ConstrainedStringGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\ConstrainedStringGenerator.cs,Create,The following statement contains a magic number: if (constrain == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,ConstrainedStringGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\ConstrainedStringGenerator.cs,Create,The following statement contains a magic number: if (constrain == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,CurrentDateTimeGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\CurrentDateTimeGenerator.cs,Create,The following statement contains a magic number: if (!typeof(DateTime).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,CurrentDateTimeGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\CurrentDateTimeGenerator.cs,Create,The following statement contains a magic number: if (!typeof(DateTime).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RandomCharSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomCharSequenceGenerator.cs,RandomCharSequenceGenerator,The following statement contains a magic number: this.randomPrintableCharNumbers = new RandomNumericSequenceGenerator (33' 126);  
Magic Number,Ploeh.AutoFixture,RandomCharSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomCharSequenceGenerator.cs,RandomCharSequenceGenerator,The following statement contains a magic number: this.randomPrintableCharNumbers = new RandomNumericSequenceGenerator (33' 126);  
Magic Number,Ploeh.AutoFixture,RandomCharSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomCharSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(char).Equals (request))  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture,RandomDateTimeSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomDateTimeSequenceGenerator.cs,Create,The following statement contains a magic number: return IsNotDateTimeRequest (request)   #pragma  ? new NoSpecimen (request)   #pragma  : this.CreateRandomDate (context);  
Magic Number,Ploeh.AutoFixture,RandomDateTimeSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomDateTimeSequenceGenerator.cs,Create,The following statement contains a magic number: return IsNotDateTimeRequest (request)   #pragma  ? new NoSpecimen (request)   #pragma  : this.CreateRandomDate (context);  
Magic Number,Ploeh.AutoFixture,RandomNumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomNumericSequenceGenerator.cs,RandomNumericSequenceGenerator,The following statement contains a magic number: if (limits.Length < 2) {  	throw new ArgumentException ("Limits must be at least two ascending numbers."' nameof (limits));  }  
Magic Number,Ploeh.AutoFixture,RandomNumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomNumericSequenceGenerator.cs,Create,The following statement contains a magic number: if (type == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RandomNumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomNumericSequenceGenerator.cs,Create,The following statement contains a magic number: if (type == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RandomNumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomNumericSequenceGenerator.cs,CreateRandom,The following statement contains a magic number: switch (Type.GetTypeCode (request)) {  case TypeCode.Byte:  	return (byte)this.GetNextRandom ();  case TypeCode.Decimal:  	return (decimal)this.GetNextRandom ();  case TypeCode.Double:  	return (double)this.GetNextRandom ();  case TypeCode.Int16:  	return (short)this.GetNextRandom ();  case TypeCode.Int32:  	return (int)this.GetNextRandom ();  case TypeCode.Int64:  	return this.GetNextRandom ();  case TypeCode.SByte:  	return (sbyte)this.GetNextRandom ();  case TypeCode.Single:  	return (float)this.GetNextRandom ();  case TypeCode.UInt16:  	return (ushort)this.GetNextRandom ();  case TypeCode.UInt32:  	return (uint)this.GetNextRandom ();  case TypeCode.UInt64:  	return (ulong)this.GetNextRandom ();  default:  	#pragma  	return new NoSpecimen (request);  #pragma  }  
Magic Number,Ploeh.AutoFixture,RandomNumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomNumericSequenceGenerator.cs,CreateRandom,The following statement contains a magic number: switch (Type.GetTypeCode (request)) {  case TypeCode.Byte:  	return (byte)this.GetNextRandom ();  case TypeCode.Decimal:  	return (decimal)this.GetNextRandom ();  case TypeCode.Double:  	return (double)this.GetNextRandom ();  case TypeCode.Int16:  	return (short)this.GetNextRandom ();  case TypeCode.Int32:  	return (int)this.GetNextRandom ();  case TypeCode.Int64:  	return this.GetNextRandom ();  case TypeCode.SByte:  	return (sbyte)this.GetNextRandom ();  case TypeCode.Single:  	return (float)this.GetNextRandom ();  case TypeCode.UInt16:  	return (ushort)this.GetNextRandom ();  case TypeCode.UInt32:  	return (uint)this.GetNextRandom ();  case TypeCode.UInt64:  	return (ulong)this.GetNextRandom ();  default:  	#pragma  	return new NoSpecimen (request);  #pragma  }  
Magic Number,Ploeh.AutoFixture,RandomRangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomRangedNumberGenerator.cs,Create,The following statement contains a magic number: if (rangedNumberRequest == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture,RandomRangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomRangedNumberGenerator.cs,Create,The following statement contains a magic number: try {  	return SelectGenerator (rangedNumberRequest).Create (rangedNumberRequest.OperandType' context);  } catch (ArgumentException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RandomRangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomRangedNumberGenerator.cs,Create,The following statement contains a magic number: try {  	return SelectGenerator (rangedNumberRequest).Create (rangedNumberRequest.OperandType' context);  } catch (ArgumentException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,Create,The following statement contains a magic number: if (range == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,Create,The following statement contains a magic number: if (range == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,Create,The following statement contains a magic number: if (value == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,Create,The following statement contains a magic number: if (value == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,Create,The following statement contains a magic number: try {  	this.CreateAnonymous (range' value);  } catch (InvalidOperationException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RangedNumberGenerator.cs,Create,The following statement contains a magic number: try {  	this.CreateAnonymous (range' value);  } catch (InvalidOperationException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RegularExpressionGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RegularExpressionGenerator.cs,Create,The following statement contains a magic number: if (regularExpressionRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RegularExpressionGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RegularExpressionGenerator.cs,Create,The following statement contains a magic number: if (regularExpressionRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RegularExpressionGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RegularExpressionGenerator.cs,CreateAnonymous,The following statement contains a magic number: try {  	string regex = new Xeger (pattern).Generate ();  	if (Regex.IsMatch (regex' pattern)) {  		return regex;  	}  } catch (InvalidOperationException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  } catch (ArgumentException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RegularExpressionGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RegularExpressionGenerator.cs,CreateAnonymous,The following statement contains a magic number: try {  	string regex = new Xeger (pattern).Generate ();  	if (Regex.IsMatch (regex' pattern)) {  		return regex;  	}  } catch (InvalidOperationException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  } catch (ArgumentException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RegularExpressionGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RegularExpressionGenerator.cs,CreateAnonymous,The following statement contains a magic number: try {  	string regex = new Xeger (pattern).Generate ();  	if (Regex.IsMatch (regex' pattern)) {  		return regex;  	}  } catch (InvalidOperationException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  } catch (ArgumentException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,RegularExpressionGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RegularExpressionGenerator.cs,CreateAnonymous,The following statement contains a magic number: try {  	string regex = new Xeger (pattern).Generate ();  	if (Regex.IsMatch (regex' pattern)) {  		return regex;  	}  } catch (InvalidOperationException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  } catch (ArgumentException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StrictlyMonotonicallyIncreasingDateTimeGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StrictlyMonotonicallyIncreasingDateTimeGenerator.cs,Create,The following statement contains a magic number: if (!typeof(DateTime).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StrictlyMonotonicallyIncreasingDateTimeGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StrictlyMonotonicallyIncreasingDateTimeGenerator.cs,Create,The following statement contains a magic number: if (!typeof(DateTime).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,DictionaryFiller,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DictionaryFiller.cs,Execute,The following statement contains a magic number: if (typeArguments.Length != 2)  	throw new ArgumentException ("The specimen must be an instance of IDictionary<TKey' TValue>."' nameof (specimen));  
Magic Number,Ploeh.AutoFixture,EnumGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\EnumGenerator.cs,Create,The following statement contains a magic number: if (!EnumGenerator.IsEnumType (t)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,EnumGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\EnumGenerator.cs,Create,The following statement contains a magic number: if (!EnumGenerator.IsEnumType (t)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,NumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\NumericSequenceGenerator.cs,Create,The following statement contains a magic number: if (type == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture,NumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\NumericSequenceGenerator.cs,CreateNumericSpecimen,The following statement contains a magic number: switch (typeCode) {  case TypeCode.Byte:  	return (byte)this.GetNextNumber ();  case TypeCode.Decimal:  	return (decimal)this.GetNextNumber ();  case TypeCode.Double:  	return (double)this.GetNextNumber ();  case TypeCode.Int16:  	return (short)this.GetNextNumber ();  case TypeCode.Int32:  	return (int)this.GetNextNumber ();  case TypeCode.Int64:  	return this.GetNextNumber ();  case TypeCode.SByte:  	return (sbyte)this.GetNextNumber ();  case TypeCode.Single:  	return (float)this.GetNextNumber ();  case TypeCode.UInt16:  	return (ushort)this.GetNextNumber ();  case TypeCode.UInt32:  	return (uint)this.GetNextNumber ();  case TypeCode.UInt64:  	return (ulong)this.GetNextNumber ();  default:  	#pragma  	return new NoSpecimen (request);  #pragma  }  
Magic Number,Ploeh.AutoFixture,NumericSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\NumericSequenceGenerator.cs,CreateNumericSpecimen,The following statement contains a magic number: switch (typeCode) {  case TypeCode.Byte:  	return (byte)this.GetNextNumber ();  case TypeCode.Decimal:  	return (decimal)this.GetNextNumber ();  case TypeCode.Double:  	return (double)this.GetNextNumber ();  case TypeCode.Int16:  	return (short)this.GetNextNumber ();  case TypeCode.Int32:  	return (int)this.GetNextNumber ();  case TypeCode.Int64:  	return this.GetNextNumber ();  case TypeCode.SByte:  	return (sbyte)this.GetNextNumber ();  case TypeCode.Single:  	return (float)this.GetNextNumber ();  case TypeCode.UInt16:  	return (ushort)this.GetNextNumber ();  case TypeCode.UInt32:  	return (uint)this.GetNextNumber ();  case TypeCode.UInt64:  	return (ulong)this.GetNextNumber ();  default:  	#pragma  	return new NoSpecimen (request);  #pragma  }  
Magic Number,Ploeh.AutoFixture,MutableValueTypeGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MutableValueTypeGenerator.cs,Create,The following statement contains a magic number: if (type == null || !valueTypeWithoutConstructorsSpecification.IsSatisfiedBy (type)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,MutableValueTypeGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MutableValueTypeGenerator.cs,Create,The following statement contains a magic number: if (type == null || !valueTypeWithoutConstructorsSpecification.IsSatisfiedBy (type)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,TaskGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\TaskGenerator.cs,Create,The following statement contains a magic number: if (type == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture,GuidGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\GuidGenerator.cs,Create,The following statement contains a magic number: if (!typeof(Guid).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,GuidGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\GuidGenerator.cs,Create,The following statement contains a magic number: if (!typeof(Guid).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StringSeedRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StringSeedRelay.cs,Create,The following statement contains a magic number: if (seededRequest == null || (!seededRequest.Request.Equals (typeof(string)))) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StringSeedRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StringSeedRelay.cs,Create,The following statement contains a magic number: if (seededRequest == null || (!seededRequest.Request.Equals (typeof(string)))) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StringSeedRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StringSeedRelay.cs,Create,The following statement contains a magic number: if (seed == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StringSeedRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StringSeedRelay.cs,Create,The following statement contains a magic number: if (seed == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,BooleanSwitch,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\BooleanSwitch.cs,Create,The following statement contains a magic number: if (!typeof(bool).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,BooleanSwitch,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\BooleanSwitch.cs,Create,The following statement contains a magic number: if (!typeof(bool).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,ByteSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\ByteSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(byte).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,ByteSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\ByteSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(byte).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,DecimalSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DecimalSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(decimal).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,DecimalSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DecimalSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(decimal).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,DoubleSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DoubleSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(double).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,DoubleSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DoubleSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(double).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,Int16SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Int16SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(short).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,Int16SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Int16SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(short).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,Int32SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Int32SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(int).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,Int32SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Int32SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(int).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,Int64SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Int64SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(long).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,Int64SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Int64SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(long).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,SByteSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\SByteSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(sbyte).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,SByteSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\SByteSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(sbyte).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,SingleSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\SingleSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(float).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,SingleSequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\SingleSequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(float).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StringGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StringGenerator.cs,Create,The following statement contains a magic number: if (!typeof(string).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StringGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StringGenerator.cs,Create,The following statement contains a magic number: if (!typeof(string).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StringGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StringGenerator.cs,Create,The following statement contains a magic number: if (specimen == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,StringGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\StringGenerator.cs,Create,The following statement contains a magic number: if (specimen == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UInt16SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UInt16SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(ushort).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UInt16SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UInt16SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(ushort).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UInt32SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UInt32SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(uint).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UInt32SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UInt32SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(uint).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UInt64SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UInt64SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(ulong).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UInt64SequenceGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UInt64SequenceGenerator.cs,Create,The following statement contains a magic number: if (!typeof(ulong).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UriGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UriGenerator.cs,Create,The following statement contains a magic number: if (!typeof(Uri).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UriGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UriGenerator.cs,Create,The following statement contains a magic number: if (!typeof(Uri).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UriGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UriGenerator.cs,Create,The following statement contains a magic number: if (scheme == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UriGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UriGenerator.cs,Create,The following statement contains a magic number: if (scheme == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UriGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UriGenerator.cs,Create,The following statement contains a magic number: if (authority == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UriGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UriGenerator.cs,Create,The following statement contains a magic number: if (authority == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UriSchemeGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UriSchemeGenerator.cs,Create,The following statement contains a magic number: if (!typeof(UriScheme).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,UriSchemeGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\UriSchemeGenerator.cs,Create,The following statement contains a magic number: if (!typeof(UriScheme).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,MailAddressGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MailAddressGenerator.cs,Create,The following statement contains a magic number: if (!typeof(MailAddress).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,MailAddressGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MailAddressGenerator.cs,Create,The following statement contains a magic number: if (!typeof(MailAddress).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,MailAddressGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MailAddressGenerator.cs,Create,The following statement contains a magic number: try {  	return TryCreateMailAddress (request' context);  } catch (FormatException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,MailAddressGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MailAddressGenerator.cs,Create,The following statement contains a magic number: try {  	return TryCreateMailAddress (request' context);  } catch (FormatException) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,MailAddressGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MailAddressGenerator.cs,TryCreateMailAddress,The following statement contains a magic number: if (localPart == null || domainName == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture,MailAddressGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\MailAddressGenerator.cs,TryCreateMailAddress,The following statement contains a magic number: if (localPart == null || domainName == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,EnumeratorRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumeratorRelay.cs,Create,The following statement contains a magic number: if (t == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,EnumeratorRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumeratorRelay.cs,Create,The following statement contains a magic number: if (typeArguments.Length != 1 || typeof(IEnumerator<>) != t.GetGenericTypeDefinition ())  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,EnumeratorRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumeratorRelay.cs,Create,The following statement contains a magic number: if (t == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,EnumeratorRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumeratorRelay.cs,Create,The following statement contains a magic number: if (t != typeof(IEnumerator<T>))  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,EnumeratorRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumeratorRelay.cs,Create,The following statement contains a magic number: if (enumerable == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,MultidimensionalArrayRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MultidimensionalArrayRelay.cs,Create,The following statement contains a magic number: if (arrayType == null || !IsMultidimensionalArray (arrayType))  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,OmitArrayParameterRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\OmitArrayParameterRequestRelay.cs,Create,The following statement contains a magic number: if (pi == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,OmitArrayParameterRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\OmitArrayParameterRequestRelay.cs,Create,The following statement contains a magic number: if (!pi.ParameterType.IsArray)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,OmitEnumerableParameterRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\OmitEnumerableParameterRequestRelay.cs,Create,The following statement contains a magic number: if (pi == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,OmitEnumerableParameterRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\OmitEnumerableParameterRequestRelay.cs,Create,The following statement contains a magic number: if (!pi.ParameterType.IsGenericType)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,OmitEnumerableParameterRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\OmitEnumerableParameterRequestRelay.cs,Create,The following statement contains a magic number: if (IsNotEnumerable (pi))  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,MultipleToEnumerableRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MultipleToEnumerableRelay.cs,Create,The following statement contains a magic number: if (multipleRequest == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,MultipleToEnumerableRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MultipleToEnumerableRelay.cs,Create,The following statement contains a magic number: if (itemType == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,TypeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TypeRelay.cs,Create,The following statement contains a magic number: if (t == null || t != this.from)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,ArrayRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ArrayRelay.cs,Create,The following statement contains a magic number: if (type == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,ArrayRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ArrayRelay.cs,Create,The following statement contains a magic number: if (!type.IsArray)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,ArrayRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ArrayRelay.cs,Create,The following statement contains a magic number: if (elements == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,DelegateGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\DelegateGenerator.cs,Create,The following statement contains a magic number: if (delegateType == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,DelegateGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\DelegateGenerator.cs,Create,The following statement contains a magic number: if (delegateType == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,DelegateGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\DelegateGenerator.cs,Create,The following statement contains a magic number: if (!typeof(Delegate).IsAssignableFrom (delegateType)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,DelegateGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\DelegateGenerator.cs,Create,The following statement contains a magic number: if (!typeof(Delegate).IsAssignableFrom (delegateType)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,DictionaryRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\DictionaryRelay.cs,Create,The following statement contains a magic number: if (typeArguments.Length != 2)  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,EnumerableRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumerableRelay.cs,Create,The following statement contains a magic number: if (type == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,EnumerableRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumerableRelay.cs,Create,The following statement contains a magic number: if (typeArgs.Length != 1)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,EnumerableRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumerableRelay.cs,Create,The following statement contains a magic number: if (type.GetGenericTypeDefinition () != typeof(IEnumerable<>))  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,EnumerableRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\EnumerableRelay.cs,Create,The following statement contains a magic number: if (enumerable == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,ListRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ListRelay.cs,Create,The following statement contains a magic number: if (t == null)  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,ListRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ListRelay.cs,Create,The following statement contains a magic number: if (typeArguments.Length != 1 || typeof(IList<>) != t.GetGenericTypeDefinition ())  	#pragma  	return new NoSpecimen (request);  
Magic Number,Ploeh.AutoFixture.Kernel,IntPtrGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\IntPtrGuard.cs,Create,The following statement contains a magic number: if (!typeof(IntPtr).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,IntPtrGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\IntPtrGuard.cs,Create,The following statement contains a magic number: if (!typeof(IntPtr).Equals (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,FieldRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\FieldRequestRelay.cs,Create,The following statement contains a magic number: if (fieldInfo == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,FieldRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\FieldRequestRelay.cs,Create,The following statement contains a magic number: if (fieldInfo == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,FilteringSpecimenBuilder,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\FilteringSpecimenBuilder.cs,Create,The following statement contains a magic number: if (!this.Specification.IsSatisfiedBy (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,FilteringSpecimenBuilder,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\FilteringSpecimenBuilder.cs,Create,The following statement contains a magic number: if (!this.Specification.IsSatisfiedBy (request)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,FiniteSequenceRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\FiniteSequenceRelay.cs,Create,The following statement contains a magic number: if (manyRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,FiniteSequenceRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\FiniteSequenceRelay.cs,Create,The following statement contains a magic number: if (manyRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,MultipleRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MultipleRelay.cs,MultipleRelay,The following statement contains a magic number: this.count = 3;  
Magic Number,Ploeh.AutoFixture.Kernel,MultipleRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MultipleRelay.cs,Create,The following statement contains a magic number: if (manyRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,MultipleRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\MultipleRelay.cs,Create,The following statement contains a magic number: if (manyRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,StableFiniteSequenceRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\StableFiniteSequenceRelay.cs,Create,The following statement contains a magic number: if (manyRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,StableFiniteSequenceRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\StableFiniteSequenceRelay.cs,Create,The following statement contains a magic number: if (manyRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,PropertyRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\PropertyRequestRelay.cs,Create,The following statement contains a magic number: if (propertyInfo == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,PropertyRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\PropertyRequestRelay.cs,Create,The following statement contains a magic number: if (propertyInfo == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,SeededFactory,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SeededFactory.cs,Create,The following statement contains a magic number: if (seededRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,SeededFactory,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SeededFactory.cs,Create,The following statement contains a magic number: if (seededRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,SeededFactory,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SeededFactory.cs,Create,The following statement contains a magic number: if (!seededRequest.Request.Equals (typeof(T))) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,SeededFactory,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SeededFactory.cs,Create,The following statement contains a magic number: if (!seededRequest.Request.Equals (typeof(T))) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,SeededFactory,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SeededFactory.cs,Create,The following statement contains a magic number: if ((seededRequest.Seed != null) && !(seededRequest.Seed is T)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,SeededFactory,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SeededFactory.cs,Create,The following statement contains a magic number: if ((seededRequest.Seed != null) && !(seededRequest.Seed is T)) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,TraceWriter,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TraceWriter.cs,TraceWriter,The following statement contains a magic number: this.TraceRequestFormatter = (tw' r' i) => tw.WriteLine (new string (' '' i * 2) + "Requested: " + r);  
Magic Number,Ploeh.AutoFixture.Kernel,TraceWriter,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\TraceWriter.cs,TraceWriter,The following statement contains a magic number: this.TraceSpecimenFormatter = (tw' r' i) => tw.WriteLine (new string (' '' i * 2) + "Created: " + r);  
Magic Number,Ploeh.AutoFixture.Kernel,ParameterRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ParameterRequestRelay.cs,Create,The following statement contains a magic number: if (paramInfo == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,ParameterRequestRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\ParameterRequestRelay.cs,Create,The following statement contains a magic number: if (paramInfo == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,SeedIgnoringRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SeedIgnoringRelay.cs,Create,The following statement contains a magic number: if (seededRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,SeedIgnoringRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\SeedIgnoringRelay.cs,Create,The following statement contains a magic number: if (seededRequest == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,RecursionGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\RecursionGuard.cs,Create,The following statement contains a magic number: if (requestsForCurrentThread.Count > 0) {  	// This is performance-sensitive code when used repeatedly over many requests.  	// See discussion at https://github.com/AutoFixture/AutoFixture/pull/218  	var requestsArray = requestsForCurrentThread.ToArray ();  	int numRequestsSameAsThisOne = 0;  	for (int i = 0; i < requestsArray.Length; i++) {  		var existingRequest = requestsArray [i];  		if (this.Comparer.Equals (existingRequest' request)) {  			numRequestsSameAsThisOne++;  		}  		if (numRequestsSameAsThisOne >= this.RecursionDepth) {  			#pragma  			return this.HandleRecursiveRequest (request);  			#pragma  		}  	}  }  
Magic Number,Ploeh.AutoFixture.Kernel,RecursionGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\RecursionGuard.cs,Create,The following statement contains a magic number: if (requestsForCurrentThread.Count > 0) {  	// This is performance-sensitive code when used repeatedly over many requests.  	// See discussion at https://github.com/AutoFixture/AutoFixture/pull/218  	var requestsArray = requestsForCurrentThread.ToArray ();  	int numRequestsSameAsThisOne = 0;  	for (int i = 0; i < requestsArray.Length; i++) {  		var existingRequest = requestsArray [i];  		if (this.Comparer.Equals (existingRequest' request)) {  			numRequestsSameAsThisOne++;  		}  		if (numRequestsSameAsThisOne >= this.RecursionDepth) {  			#pragma  			return this.HandleRecursiveRequest (request);  			#pragma  		}  	}  }  
Magic Number,Ploeh.AutoFixture.Kernel,RecursionGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\RecursionGuard.cs,Create,The following statement contains a magic number: for (int i = 0; i < requestsArray.Length; i++) {  	var existingRequest = requestsArray [i];  	if (this.Comparer.Equals (existingRequest' request)) {  		numRequestsSameAsThisOne++;  	}  	if (numRequestsSameAsThisOne >= this.RecursionDepth) {  		#pragma  		return this.HandleRecursiveRequest (request);  		#pragma  	}  }  
Magic Number,Ploeh.AutoFixture.Kernel,RecursionGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\RecursionGuard.cs,Create,The following statement contains a magic number: for (int i = 0; i < requestsArray.Length; i++) {  	var existingRequest = requestsArray [i];  	if (this.Comparer.Equals (existingRequest' request)) {  		numRequestsSameAsThisOne++;  	}  	if (numRequestsSameAsThisOne >= this.RecursionDepth) {  		#pragma  		return this.HandleRecursiveRequest (request);  		#pragma  	}  }  
Magic Number,Ploeh.AutoFixture.Kernel,RecursionGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\RecursionGuard.cs,Create,The following statement contains a magic number: if (numRequestsSameAsThisOne >= this.RecursionDepth) {  	#pragma  	return this.HandleRecursiveRequest (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.Kernel,RecursionGuard,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\Kernel\RecursionGuard.cs,Create,The following statement contains a magic number: if (numRequestsSameAsThisOne >= this.RecursionDepth) {  	#pragma  	return this.HandleRecursiveRequest (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,Automaton,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\Automaton.cs,RecomputeHashCode,The following statement contains a magic number: this.hashCode = (this.NumberOfStates * 3) + (this.NumberOfTransitions * 2);  
Magic Number,Ploeh.AutoFixture.DataAnnotations,Automaton,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\Automaton.cs,RecomputeHashCode,The following statement contains a magic number: this.hashCode = (this.NumberOfStates * 3) + (this.NumberOfTransitions * 2);  
Magic Number,Ploeh.AutoFixture.DataAnnotations,BasicAutomata,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicAutomata.cs,MakeStringMatcher,The following statement contains a magic number: for (int i = 0; i < s.Length; i++) {  	var done = new HashSet<char?> ();  	char c = s [i];  	states [i].Transitions.Add (new Transition (c' states [i + 1]));  	done.Add (c);  	for (int j = i; j >= 1; j--) {  		char d = s [j - 1];  		if (!done.Contains (d) && s.Substring (0' j - 1).Equals (s.Substring (i - j + 1' i - (i - j + 1)))) {  			states [i].Transitions.Add (new Transition (d' states [j]));  			done.Add (d);  		}  	}  	var da = new char[done.Count];  	int h = 0;  	foreach (char w in done) {  		da [h++] = w;  	}  	Array.Sort (da);  	int from = Char.MinValue;  	int k = 0;  	while (from <= Char.MaxValue) {  		while (k < da.Length && da [k] == from) {  			k++;  			from++;  		}  		if (from <= Char.MaxValue) {  			int to = Char.MaxValue;  			if (k < da.Length) {  				to = da [k] - 1;  				k++;  			}  			states [i].Transitions.Add (new Transition ((char)from' (char)to' states [0]));  			from = to + 2;  		}  	}  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,BasicAutomata,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicAutomata.cs,MakeStringMatcher,The following statement contains a magic number: while (from <= Char.MaxValue) {  	while (k < da.Length && da [k] == from) {  		k++;  		from++;  	}  	if (from <= Char.MaxValue) {  		int to = Char.MaxValue;  		if (k < da.Length) {  			to = da [k] - 1;  			k++;  		}  		states [i].Transitions.Add (new Transition ((char)from' (char)to' states [0]));  		from = to + 2;  	}  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,BasicAutomata,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicAutomata.cs,MakeStringMatcher,The following statement contains a magic number: if (from <= Char.MaxValue) {  	int to = Char.MaxValue;  	if (k < da.Length) {  		to = da [k] - 1;  		k++;  	}  	states [i].Transitions.Add (new Transition ((char)from' (char)to' states [0]));  	from = to + 2;  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,BasicAutomata,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\BasicAutomata.cs,MakeStringMatcher,The following statement contains a magic number: from = to + 2;  
Magic Number,Ploeh.AutoFixture.DataAnnotations,ListEqualityComparer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\ListEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Aggregate (17' (current' item) => (current * 31) + item.GetHashCode ());  
Magic Number,Ploeh.AutoFixture.DataAnnotations,ListEqualityComparer,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\ListEqualityComparer.cs,GetHashCode,The following statement contains a magic number: return obj.Aggregate (17' (current' item) => (current * 31) + item.GetHashCode ());  
Magic Number,Ploeh.AutoFixture.DataAnnotations,RangeAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangeAttributeRelay.cs,Create,The following statement contains a magic number: if (customAttributeProvider == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,RangeAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangeAttributeRelay.cs,Create,The following statement contains a magic number: if (customAttributeProvider == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,RangeAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangeAttributeRelay.cs,Create,The following statement contains a magic number: if (rangeAttribute == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,RangeAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RangeAttributeRelay.cs,Create,The following statement contains a magic number: if (rangeAttribute == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,RegularExpressionAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegularExpressionAttributeRelay.cs,Create,The following statement contains a magic number: if (customAttributeProvider == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,RegularExpressionAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegularExpressionAttributeRelay.cs,Create,The following statement contains a magic number: if (customAttributeProvider == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,RegularExpressionAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegularExpressionAttributeRelay.cs,Create,The following statement contains a magic number: if (regularExpressionAttribute == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,RegularExpressionAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegularExpressionAttributeRelay.cs,Create,The following statement contains a magic number: if (regularExpressionAttribute == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,State,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\State.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Id;  	result = (result * 397) ^ Accept.GetHashCode ();  	result = (result * 397) ^ Number;  	return result;  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,State,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\State.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Id;  	result = (result * 397) ^ Accept.GetHashCode ();  	result = (result * 397) ^ Number;  	return result;  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,State,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\State.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Accept.GetHashCode ();  
Magic Number,Ploeh.AutoFixture.DataAnnotations,State,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\State.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Number;  
Magic Number,Ploeh.AutoFixture.DataAnnotations,StatePair,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StatePair.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = (S != null ? S.GetHashCode () : 0);  	result = (result * 397) ^ (this.FirstState != null ? this.FirstState.GetHashCode () : 0);  	result = (result * 397) ^ (this.SecondState != null ? this.SecondState.GetHashCode () : 0);  	return result;  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,StatePair,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StatePair.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = (S != null ? S.GetHashCode () : 0);  	result = (result * 397) ^ (this.FirstState != null ? this.FirstState.GetHashCode () : 0);  	result = (result * 397) ^ (this.SecondState != null ? this.SecondState.GetHashCode () : 0);  	return result;  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,StatePair,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StatePair.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ (this.FirstState != null ? this.FirstState.GetHashCode () : 0);  
Magic Number,Ploeh.AutoFixture.DataAnnotations,StatePair,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StatePair.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ (this.SecondState != null ? this.SecondState.GetHashCode () : 0);  
Magic Number,Ploeh.AutoFixture.DataAnnotations,StringLengthAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StringLengthAttributeRelay.cs,Create,The following statement contains a magic number: if (customAttributeProvider == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,StringLengthAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StringLengthAttributeRelay.cs,Create,The following statement contains a magic number: if (customAttributeProvider == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,StringLengthAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StringLengthAttributeRelay.cs,Create,The following statement contains a magic number: if (stringLengthAttribute == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,StringLengthAttributeRelay,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\StringLengthAttributeRelay.cs,Create,The following statement contains a magic number: if (stringLengthAttribute == null) {  	#pragma  	return new NoSpecimen (request);  	#pragma  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,Transition,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\Transition.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Min.GetHashCode ();  	result = (result * 397) ^ Max.GetHashCode ();  	result = (result * 397) ^ (To != null ? To.GetHashCode () : 0);  	return result;  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,Transition,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\Transition.cs,GetHashCode,The following statement contains a magic number: unchecked {  	int result = Min.GetHashCode ();  	result = (result * 397) ^ Max.GetHashCode ();  	result = (result * 397) ^ (To != null ? To.GetHashCode () : 0);  	return result;  }  
Magic Number,Ploeh.AutoFixture.DataAnnotations,Transition,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\Transition.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ Max.GetHashCode ();  
Magic Number,Ploeh.AutoFixture.DataAnnotations,Transition,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\Transition.cs,GetHashCode,The following statement contains a magic number: result = (result * 397) ^ (To != null ? To.GetHashCode () : 0);  
Missing Default,Ploeh.AutoFixture,RandomRangedNumberGenerator,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\RandomRangedNumberGenerator.cs,ConvertLimit,The following switch statement is missing a default case: switch (GetTypeCode (limit)) {  case TypeCode.Byte:  	return (long)(byte)limit;  case TypeCode.Decimal:  	return (long)(decimal)limit;  case TypeCode.Double:  	return (long)(double)limit;  case TypeCode.Int16:  	return (long)(short)limit;  case TypeCode.Int32:  	return (long)(int)limit;  case TypeCode.Int64:  	return (long)limit;  case TypeCode.SByte:  	return (long)(sbyte)limit;  case TypeCode.Single:  	return (long)(float)limit;  case TypeCode.UInt16:  	return (long)(ushort)limit;  case TypeCode.UInt32:  	return (long)(uint)limit;  case TypeCode.UInt64:  	return (long)(ulong)limit;  }  
Missing Default,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,ToAutomaton,The following switch statement is missing a default case: switch (kind) {  case Kind.RegexpUnion:  	list = new List<Automaton> ();  	this.FindLeaves (exp1' Kind.RegexpUnion' list' automata' automatonProvider' minimize);  	this.FindLeaves (exp2' Kind.RegexpUnion' list' automata' automatonProvider' minimize);  	a = BasicOperations.Union (list);  	a.Minimize ();  	break;  case Kind.RegexpConcatenation:  	list = new List<Automaton> ();  	this.FindLeaves (exp1' Kind.RegexpConcatenation' list' automata' automatonProvider' minimize);  	this.FindLeaves (exp2' Kind.RegexpConcatenation' list' automata' automatonProvider' minimize);  	a = BasicOperations.Concatenate (list);  	a.Minimize ();  	break;  case Kind.RegexpIntersection:  	a = exp1.ToAutomaton (automata' automatonProvider' minimize).Intersection (exp2.ToAutomaton (automata' automatonProvider' minimize));  	a.Minimize ();  	break;  case Kind.RegexpOptional:  	a = exp1.ToAutomaton (automata' automatonProvider' minimize).Optional ();  	a.Minimize ();  	break;  case Kind.RegexpRepeat:  	a = exp1.ToAutomaton (automata' automatonProvider' minimize).Repeat ();  	a.Minimize ();  	break;  case Kind.RegexpRepeatMin:  	a = exp1.ToAutomaton (automata' automatonProvider' minimize).Repeat (min);  	a.Minimize ();  	break;  case Kind.RegexpRepeatMinMax:  	a = exp1.ToAutomaton (automata' automatonProvider' minimize).Repeat (min' max);  	a.Minimize ();  	break;  case Kind.RegexpComplement:  	a = exp1.ToAutomaton (automata' automatonProvider' minimize).Complement ();  	a.Minimize ();  	break;  case Kind.RegexpChar:  	a = BasicAutomata.MakeChar (c);  	break;  case Kind.RegexpCharRange:  	a = BasicAutomata.MakeCharRange (from' to);  	break;  case Kind.RegexpAnyChar:  	a = BasicAutomata.MakeAnyChar ();  	break;  case Kind.RegexpEmpty:  	a = BasicAutomata.MakeEmpty ();  	break;  case Kind.RegexpString:  	a = BasicAutomata.MakeString (s);  	break;  case Kind.RegexpAnyString:  	a = BasicAutomata.MakeAnyString ();  	break;  case Kind.RegexpAutomaton:  	Automaton aa = null;  	if (automata != null) {  		automata.TryGetValue (s' out aa);  	}  	if (aa == null && automatonProvider != null) {  		try {  			aa = automatonProvider.GetAutomaton (s);  		} catch (IOException e) {  			throw new ArgumentException (string.Empty' e);  		}  	}  	if (aa == null) {  		throw new ArgumentException ("'" + s + "' not found");  	}  	a = aa.Clone ();  	// Always clone here (ignore allowMutate).  	break;  case Kind.RegexpInterval:  	a = BasicAutomata.MakeInterval (min' max' digits);  	break;  }  
Missing Default,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,ToStringBuilder,The following switch statement is missing a default case: switch (kind) {  case Kind.RegexpUnion:  	sb.Append ("(");  	exp1.ToStringBuilder (sb);  	sb.Append ("|");  	exp2.ToStringBuilder (sb);  	sb.Append (")");  	break;  case Kind.RegexpConcatenation:  	exp1.ToStringBuilder (sb);  	exp2.ToStringBuilder (sb);  	break;  case Kind.RegexpIntersection:  	sb.Append ("(");  	exp1.ToStringBuilder (sb);  	sb.Append ("&");  	exp2.ToStringBuilder (sb);  	sb.Append (")");  	break;  case Kind.RegexpOptional:  	sb.Append ("(");  	exp1.ToStringBuilder (sb);  	sb.Append (")?");  	break;  case Kind.RegexpRepeat:  	sb.Append ("(");  	exp1.ToStringBuilder (sb);  	sb.Append (")*");  	break;  case Kind.RegexpRepeatMin:  	sb.Append ("(");  	exp1.ToStringBuilder (sb);  	sb.Append ("){").Append (min).Append ("'}");  	break;  case Kind.RegexpRepeatMinMax:  	sb.Append ("(");  	exp1.ToStringBuilder (sb);  	sb.Append ("){").Append (min).Append ("'").Append (max).Append ("}");  	break;  case Kind.RegexpComplement:  	sb.Append ("~(");  	exp1.ToStringBuilder (sb);  	sb.Append (")");  	break;  case Kind.RegexpChar:  	sb.Append ("\\").Append (c);  	break;  case Kind.RegexpCharRange:  	sb.Append ("[\\").Append (from).Append ("-\\").Append (to).Append ("]");  	break;  case Kind.RegexpAnyChar:  	sb.Append (".");  	break;  case Kind.RegexpEmpty:  	sb.Append ("#");  	break;  case Kind.RegexpString:  	sb.Append ("\"").Append (s).Append ("\"");  	break;  case Kind.RegexpAnyString:  	sb.Append ("@");  	break;  case Kind.RegexpAutomaton:  	sb.Append ("<").Append (s).Append (">");  	break;  case Kind.RegexpInterval:  	string s1 = Convert.ToDecimal (min).ToString (CultureInfo.CurrentCulture);  	string s2 = Convert.ToDecimal (max).ToString (CultureInfo.CurrentCulture);  	sb.Append ("<");  	if (digits > 0) {  		for (int i = s1.Length; i < digits; i++) {  			sb.Append ('0');  		}  	}  	sb.Append (s1).Append ("-");  	if (digits > 0) {  		for (int i = s2.Length; i < digits; i++) {  			sb.Append ('0');  		}  	}  	sb.Append (s2).Append (">");  	break;  }  
Missing Default,Ploeh.AutoFixture.DataAnnotations,RegExp,F:\newReposMay17\AutoFixture_AutoFixture\Src\AutoFixture\DataAnnotations\RegExp.cs,GetIdentifiers,The following switch statement is missing a default case: switch (kind) {  case Kind.RegexpUnion:  case Kind.RegexpConcatenation:  case Kind.RegexpIntersection:  	exp1.GetIdentifiers (set);  	exp2.GetIdentifiers (set);  	break;  case Kind.RegexpOptional:  case Kind.RegexpRepeat:  case Kind.RegexpRepeatMin:  case Kind.RegexpRepeatMinMax:  case Kind.RegexpComplement:  	exp1.GetIdentifiers (set);  	break;  case Kind.RegexpAutomaton:  	set.Add (s);  	break;  }  
