Implementation smell,Namespace,Class,File,Method,Description
Complex Method,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,Cyclomatic complexity of the method is 9
Long Parameter List,YoutubeExtractor,VideoInfo,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoInfo.cs,VideoInfo,The method has 7 parameters.
Long Statement,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The length of the statement  "	/* The previous algoritms used a.splice()' where the decipher used the method (.splice())' however it seems the new algoritm " is 124.
Long Statement,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The length of the statement  "             * renames the method to random but unique characters (example ab.dc() = splice). This code determines what each method code is'" is 127.
Long Statement,YoutubeExtractor,DownloadUrlResolver,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\DownloadUrlResolver.cs,ExtractDownloadUrls,The length of the statement  "			string fallbackHost = queries.ContainsKey ("fallback_host") ? "&fallback_host=" + queries ["fallback_host"] : String.Empty; " is 123.
Long Statement,YoutubeExtractor,DownloadUrlResolver,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\DownloadUrlResolver.cs,ThrowYoutubeParseException,The length of the statement  "	throw new YoutubeParseException ("Could not parse the Youtube page for URL " + videoUrl + "\n" + "This may be due to a change of the Youtube page structure.\n" + "Please report this bug at www.github.com/flagbug/YoutubeExtractor/issues"' innerException); " is 254.
Long Statement,YoutubeExtractor,HttpHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\HttpHelper.cs,DownloadString,The length of the statement  "	System.Threading.Tasks.Task<WebResponse> task = System.Threading.Tasks.Task.Factory.FromAsync (request.BeginGetResponse' asyncResult => request.EndGetResponse (asyncResult)' null); " is 180.
Long Statement,YoutubeExtractor,VideoInfo,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoInfo.cs,ToString,The length of the statement  "	return string.Format ("Full Title: {0}' Type: {1}' Resolution: {2}p"' this.Title + this.VideoExtension' this.VideoType' this.Resolution); " is 137.
Magic Number,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The following statement contains a magic number: foreach (var line in lines.Skip (1).Take (lines.Length - 2)) {  	string newVarName;  	//Previous algoritms used to be just "a." - now stores temp var name as its uneccessary  	int locOfDot' locOfBracket' functionIDLength;  	locOfDot = line.IndexOf (".");  	// NB.AC( - gets location of the dot.  	locOfBracket = line.IndexOf ("(");  	//NB.AC( - gets location of the bracet  	functionIDLength = locOfBracket - (locOfDot + 1);  	newVarName = line.Substring (0' locOfDot);  	functionIdentifier = line.Substring (locOfDot + 1' functionIDLength);  	//leaving us with the function AC  	//This is what the definitions currently look like' could be changed so the regex needs improving. Messy fix.  	string tempReverse = string.Format (@"{0}:\bfunction\b\(\w+\)"' functionIdentifier);  	//Reverse only one that doesnt have two parameters  	string tempSlice = string.Format (@"{0}:\bfunction\b\([a]'b\).(\breturn\b)?.?\w+\."' functionIdentifier);  	//Regex for slice (return or not)  	string tempCharSwap = string.Format (@"{0}:\bfunction\b\(\w+\'\w\).\bvar\b.\bc=a\b"' functionIdentifier);  	//Regex for the char swap.  	Match me;  	if ((me = Regex.Match (js' tempReverse)).Success) {  		id_Reverse = functionIdentifier;  	}  	//If def matched the regex for reverse then the current function is a defined as the reverse cipher  	if ((me = Regex.Match (js' tempSlice)).Success) {  		id_Slice = functionIdentifier;  	}  	//If def matched the regex for slice then the current function is defined as the slice cipher.  	if ((me = Regex.Match (js' tempCharSwap)).Success) {  		id_CharSwap = functionIdentifier;  	}  	//If def matched the regex for charSwap then the current function is defined as swap cipher.  }  
Magic Number,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The following statement contains a magic number: foreach (var line in lines.Skip (1).Take (lines.Length - 2)) {  	Match m;  	///DUPLICATE CODE! Improve.   	int locOfDot;  	int locOfBracket;  	int functionIDLength;  	locOfDot = line.IndexOf (".");  	locOfBracket = line.IndexOf ("(");  	functionIDLength = locOfBracket - (locOfDot + 1);  	functionIdentifier = line.Substring (locOfDot + 1' functionIDLength);  	//Just needed this (define it as a member?)  	string newSliceIDRegex = string.Format (@"(?<index>\d+)\)+"' functionIdentifier);  	if ((m = Regex.Match (line' @"\(\w+'(?<index>\d+)\)")).Success && functionIdentifier == id_CharSwap) {  		operations += "w" + m.Groups ["index"].Value + " ";  	}  	//Character swap regex appears to be the same as before  	if ((m = Regex.Match (line' @"\(\w+'(?<index>\d+)\)")).Success && functionIdentifier == id_Slice) {  		operations += "s" + m.Groups ["index"].Value + " ";  	}  	//Slice appears to have changed the index location???  	//Could be wrong and the regex needs improving' seems to work on the latest algorithm though.  	if (functionIdentifier == id_Reverse) {  		operations += "r ";  	}  	//Reverse operation' no regex required  }  
Magic Number,YoutubeExtractor,HttpHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\HttpHelper.cs,ParseQueryString,The following statement contains a magic number: foreach (string vp in Regex.Split (s' "&")) {  	string[] strings = Regex.Split (vp' "=");  	dictionary.Add (strings [0]' strings.Length == 2 ? UrlDecode (strings [1]) : string.Empty);  }  
Magic Number,YoutubeExtractor,HttpHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\HttpHelper.cs,ParseQueryString,The following statement contains a magic number: dictionary.Add (strings [0]' strings.Length == 2 ? UrlDecode (strings [1]) : string.Empty);  
