Implementation smell,Namespace,Class,File,Method,Description
Long Method,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The method has 129 lines of code.
Complex Method,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,Cyclomatic complexity of the method is 9
Complex Method,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,GetAudioWriter,Cyclomatic complexity of the method is 13
Complex Method,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,Cyclomatic complexity of the method is 20
Complex Method,YoutubeExtractor,VideoDownloader,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoDownloader.cs,Execute,Cyclomatic complexity of the method is 11
Long Parameter List,YoutubeExtractor,VideoInfo,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoInfo.cs,VideoInfo,The method has 7 parameters.
Long Statement,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The length of the statement  "	return (uint)value [startIndex] << 24 | (uint)value [startIndex + 1] << 16 | (uint)value [startIndex + 2] << 8 | value [startIndex + 3]; " is 136.
Long Statement,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The length of the statement  "	return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7]; " is 291.
Long Statement,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The length of the statement  "	/* The previous algoritms used a.splice()' where the decipher used the method (.splice())' however it seems the new algoritm " is 124.
Long Statement,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The length of the statement  "             * renames the method to random but unique characters (example ab.dc() = splice). This code determines what each method code is'" is 127.
Long Statement,YoutubeExtractor,DownloadUrlResolver,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\DownloadUrlResolver.cs,ExtractDownloadUrls,The length of the statement  "			string fallbackHost = queries.ContainsKey ("fallback_host") ? "&fallback_host=" + queries ["fallback_host"] : String.Empty; " is 123.
Long Statement,YoutubeExtractor,DownloadUrlResolver,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\DownloadUrlResolver.cs,ThrowYoutubeParseException,The length of the statement  "	throw new YoutubeParseException ("Could not parse the Youtube page for URL " + videoUrl + "\n" + "This may be due to a change of the Youtube page structure.\n" + "Please report this bug at www.github.com/flagbug/YoutubeExtractor/issues"' innerException); " is 254.
Long Statement,YoutubeExtractor,VideoInfo,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoInfo.cs,ToString,The length of the statement  "	return string.Format ("Full Title: {0}' Type: {1}' Resolution: {2}p"' this.Title + this.VideoExtension' this.VideoType' this.Resolution); " is 137.
Complex Conditional,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The conditional expression  "mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3"  is complex.
Empty Catch Block,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,CloseOutput,The method has an empty catch block.
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,AacAudioExtractor,The following statement contains a magic number: fileStream = new FileStream (path' FileMode.Create' FileAccess.Write' FileShare.Read' 64 * 1024);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,AacAudioExtractor,The following statement contains a magic number: fileStream = new FileStream (path' FileMode.Create' FileAccess.Write' FileShare.Read' 64 * 1024);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk [0] == 0) {  	// Header  	if (chunk.Length < 3) {  		return;  	}  	ulong bits = (ulong)BigEndianBitConverter.ToUInt16 (chunk' 1) << 48;  	aacProfile = BitHelper.Read (ref bits' 5) - 1;  	sampleRateIndex = BitHelper.Read (ref bits' 4);  	channelConfig = BitHelper.Read (ref bits' 4);  	if (aacProfile < 0 || aacProfile > 3)  		throw new AudioExtractionException ("Unsupported AAC profile.");  	if (sampleRateIndex > 12)  		throw new AudioExtractionException ("Invalid AAC sample rate index.");  	if (channelConfig > 6)  		throw new AudioExtractionException ("Invalid AAC channel configuration.");  }  else {  	// Audio data  	int dataSize = chunk.Length - 1;  	ulong bits = 0;  	// Reference: WriteADTSHeader from FAAC's bitstream.c  	BitHelper.Write (ref bits' 12' 0xFFF);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 2' 0);  	BitHelper.Write (ref bits' 1' 1);  	BitHelper.Write (ref bits' 2' aacProfile);  	BitHelper.Write (ref bits' 4' sampleRateIndex);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 3' channelConfig);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 1' 0);  	BitHelper.Write (ref bits' 13' 7 + dataSize);  	BitHelper.Write (ref bits' 11' 0x7FF);  	BitHelper.Write (ref bits' 2' 0);  	fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  	fileStream.Write (chunk' 1' dataSize);  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (chunk.Length < 3) {  	return;  }  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: aacProfile = BitHelper.Read (ref bits' 5) - 1;  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: sampleRateIndex = BitHelper.Read (ref bits' 4);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: channelConfig = BitHelper.Read (ref bits' 4);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (aacProfile < 0 || aacProfile > 3)  	throw new AudioExtractionException ("Unsupported AAC profile.");  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (sampleRateIndex > 12)  	throw new AudioExtractionException ("Invalid AAC sample rate index.");  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (channelConfig > 6)  	throw new AudioExtractionException ("Invalid AAC channel configuration.");  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: BitHelper.Write (ref bits' 12' 0xFFF);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: BitHelper.Write (ref bits' 2' 0);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: BitHelper.Write (ref bits' 2' aacProfile);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: BitHelper.Write (ref bits' 4' sampleRateIndex);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: BitHelper.Write (ref bits' 3' channelConfig);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: BitHelper.Write (ref bits' 13' 7 + dataSize);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: BitHelper.Write (ref bits' 13' 7 + dataSize);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: BitHelper.Write (ref bits' 11' 0x7FF);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: BitHelper.Write (ref bits' 2' 0);  
Magic Number,YoutubeExtractor,AacAudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\AacAudioExtractor.cs,WriteChunk,The following statement contains a magic number: fileStream.Write (BigEndianBitConverter.GetBytes (bits)' 1' 7);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [0] = (byte)(value >> 56);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [1] = (byte)(value >> 48);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [2] = (byte)(value >> 40);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [2] = (byte)(value >> 40);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [3] = (byte)(value >> 32);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [3] = (byte)(value >> 32);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [4] = (byte)(value >> 24);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [4] = (byte)(value >> 24);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [5] = (byte)(value >> 16);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [5] = (byte)(value >> 16);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [6] = (byte)(value >> 8);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [6] = (byte)(value >> 8);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [7] = (byte)(value);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [0] = (byte)(value >> 24);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [1] = (byte)(value >> 16);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [2] = (byte)(value >> 8);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [2] = (byte)(value >> 8);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [3] = (byte)(value);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,GetBytes,The following statement contains a magic number: buff [0] = (byte)(value >> 8);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt16,The following statement contains a magic number: return (ushort)(value [startIndex] << 8 | value [startIndex + 1]);  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return (uint)value [startIndex] << 24 | (uint)value [startIndex + 1] << 16 | (uint)value [startIndex + 2] << 8 | value [startIndex + 3];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return (uint)value [startIndex] << 24 | (uint)value [startIndex + 1] << 16 | (uint)value [startIndex + 2] << 8 | value [startIndex + 3];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return (uint)value [startIndex] << 24 | (uint)value [startIndex + 1] << 16 | (uint)value [startIndex + 2] << 8 | value [startIndex + 3];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return (uint)value [startIndex] << 24 | (uint)value [startIndex + 1] << 16 | (uint)value [startIndex + 2] << 8 | value [startIndex + 3];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt32,The following statement contains a magic number: return (uint)value [startIndex] << 24 | (uint)value [startIndex + 1] << 16 | (uint)value [startIndex + 2] << 8 | value [startIndex + 3];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BigEndianBitConverter,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BigEndianBitConverter.cs,ToUInt64,The following statement contains a magic number: return (ulong)value [startIndex] << 56 | (ulong)value [startIndex + 1] << 48 | (ulong)value [startIndex + 2] << 40 | (ulong)value [startIndex + 3] << 32 | (ulong)value [startIndex + 4] << 24 | (ulong)value [startIndex + 5] << 16 | (ulong)value [startIndex + 6] << 8 | value [startIndex + 7];  
Magic Number,YoutubeExtractor,BitHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BitHelper.cs,CopyBlock,The following statement contains a magic number: dst [dst.Length - 1] &= (byte)(0xFF << dst.Length * 8 - length);  
Magic Number,YoutubeExtractor,BitHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: for (int i = 0; i <= Math.Min (endByte - startByte' 7); i++) {  	bits |= (ulong)bytes [startByte + i] << 56 - i * 8;  }  
Magic Number,YoutubeExtractor,BitHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: for (int i = 0; i <= Math.Min (endByte - startByte' 7); i++) {  	bits |= (ulong)bytes [startByte + i] << 56 - i * 8;  }  
Magic Number,YoutubeExtractor,BitHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: for (int i = 0; i <= Math.Min (endByte - startByte' 7); i++) {  	bits |= (ulong)bytes [startByte + i] << 56 - i * 8;  }  
Magic Number,YoutubeExtractor,BitHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: bits |= (ulong)bytes [startByte + i] << 56 - i * 8;  
Magic Number,YoutubeExtractor,BitHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\BitHelper.cs,Read,The following statement contains a magic number: bits |= (ulong)bytes [startByte + i] << 56 - i * 8;  
Magic Number,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The following statement contains a magic number: foreach (var line in lines.Skip (1).Take (lines.Length - 2)) {  	string newVarName;  	//Previous algoritms used to be just "a." - now stores temp var name as its uneccessary  	int locOfDot' locOfBracket' functionIDLength;  	locOfDot = line.IndexOf (".");  	// NB.AC( - gets location of the dot.  	locOfBracket = line.IndexOf ("(");  	//NB.AC( - gets location of the bracet  	functionIDLength = locOfBracket - (locOfDot + 1);  	newVarName = line.Substring (0' locOfDot);  	functionIdentifier = line.Substring (locOfDot + 1' functionIDLength);  	//leaving us with the function AC  	//This is what the definitions currently look like' could be changed so the regex needs improving. Messy fix.  	string tempReverse = string.Format (@"{0}:\bfunction\b\(\w+\)"' functionIdentifier);  	//Reverse only one that doesnt have two parameters  	string tempSlice = string.Format (@"{0}:\bfunction\b\([a]'b\).(\breturn\b)?.?\w+\."' functionIdentifier);  	//Regex for slice (return or not)  	string tempCharSwap = string.Format (@"{0}:\bfunction\b\(\w+\'\w\).\bvar\b.\bc=a\b"' functionIdentifier);  	//Regex for the char swap.  	Match me;  	if ((me = Regex.Match (js' tempReverse)).Success) {  		id_Reverse = functionIdentifier;  	}  	//If def matched the regex for reverse then the current function is a defined as the reverse cipher  	if ((me = Regex.Match (js' tempSlice)).Success) {  		id_Slice = functionIdentifier;  	}  	//If def matched the regex for slice then the current function is defined as the slice cipher.  	if ((me = Regex.Match (js' tempCharSwap)).Success) {  		id_CharSwap = functionIdentifier;  	}  	//If def matched the regex for charSwap then the current function is defined as swap cipher.  }  
Magic Number,YoutubeExtractor,Decipherer,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Decipherer.cs,DecipherWithVersion,The following statement contains a magic number: foreach (var line in lines.Skip (1).Take (lines.Length - 2)) {  	Match m;  	///DUPLICATE CODE! Improve.   	int locOfDot;  	int locOfBracket;  	int functionIDLength;  	locOfDot = line.IndexOf (".");  	locOfBracket = line.IndexOf ("(");  	functionIDLength = locOfBracket - (locOfDot + 1);  	functionIdentifier = line.Substring (locOfDot + 1' functionIDLength);  	//Just needed this (define it as a member?)  	string newSliceIDRegex = string.Format (@"(?<index>\d+)\)+"' functionIdentifier);  	if ((m = Regex.Match (line' @"\(\w+'(?<index>\d+)\)")).Success && functionIdentifier == id_CharSwap) {  		operations += "w" + m.Groups ["index"].Value + " ";  	}  	//Character swap regex appears to be the same as before  	if ((m = Regex.Match (line' @"\(\w+'(?<index>\d+)\)")).Success && functionIdentifier == id_Slice) {  		operations += "s" + m.Groups ["index"].Value + " ";  	}  	//Slice appears to have changed the index location???  	//Could be wrong and the regex needs improving' seems to work on the latest algorithm though.  	if (functionIdentifier == id_Reverse) {  		operations += "r ";  	}  	//Reverse operation' no regex required  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,FlvFile,The following statement contains a magic number: this.fileStream = new FileStream (this.inputPath' FileMode.Open' FileAccess.Read' FileShare.Read' 64 * 1024);  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,FlvFile,The following statement contains a magic number: this.fileStream = new FileStream (this.inputPath' FileMode.Open' FileAccess.Read' FileShare.Read' 64 * 1024);  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,ExtractStreams,The following statement contains a magic number: while (fileOffset < fileLength) {  	if (!ReadTag ()) {  		break;  	}  	if (fileLength - fileOffset < 4) {  		break;  	}  	this.ReadUInt32 ();  	double progress = (this.fileOffset * 1.0 / this.fileLength) * 100;  	if (this.ConversionProgressChanged != null) {  		this.ConversionProgressChanged (this' new ProgressEventArgs (progress));  	}  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,ExtractStreams,The following statement contains a magic number: while (fileOffset < fileLength) {  	if (!ReadTag ()) {  		break;  	}  	if (fileLength - fileOffset < 4) {  		break;  	}  	this.ReadUInt32 ();  	double progress = (this.fileOffset * 1.0 / this.fileLength) * 100;  	if (this.ConversionProgressChanged != null) {  		this.ConversionProgressChanged (this' new ProgressEventArgs (progress));  	}  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,ExtractStreams,The following statement contains a magic number: if (fileLength - fileOffset < 4) {  	break;  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format) {  case 14:  case 2:  	return new Mp3AudioExtractor (this.outputPath);  case 10:  	return new AacAudioExtractor (this.outputPath);  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format) {  case 14:  case 2:  	return new Mp3AudioExtractor (this.outputPath);  case 10:  	return new AacAudioExtractor (this.outputPath);  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format) {  case 14:  case 2:  	return new Mp3AudioExtractor (this.outputPath);  case 10:  	return new AacAudioExtractor (this.outputPath);  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format) {  case 1:  	typeStr = "ADPCM";  	break;  case 6:  case 5:  case 4:  	typeStr = "Nellymoser";  	break;  default:  	typeStr = "format=" + format;  	break;  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format) {  case 1:  	typeStr = "ADPCM";  	break;  case 6:  case 5:  case 4:  	typeStr = "Nellymoser";  	break;  default:  	typeStr = "format=" + format;  	break;  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following statement contains a magic number: switch (format) {  case 1:  	typeStr = "ADPCM";  	break;  case 6:  case 5:  case 4:  	typeStr = "Nellymoser";  	break;  default:  	typeStr = "format=" + format;  	break;  }  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,ReadTag,The following statement contains a magic number: if (this.fileLength - this.fileOffset < 11)  	return false;  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,ReadTag,The following statement contains a magic number: timeStamp |= this.ReadUInt8 () << 24;  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,ReadUInt24,The following statement contains a magic number: this.fileStream.Read (x' 1' 3);  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,ReadUInt24,The following statement contains a magic number: this.fileOffset += 3;  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,ReadUInt32,The following statement contains a magic number: this.fileStream.Read (x' 0' 4);  
Magic Number,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,ReadUInt32,The following statement contains a magic number: this.fileOffset += 4;  
Magic Number,YoutubeExtractor,HttpHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\HttpHelper.cs,ParseQueryString,The following statement contains a magic number: foreach (string vp in Regex.Split (s' "&")) {  	string[] strings = Regex.Split (vp' "=");  	dictionary.Add (strings [0]' strings.Length == 2 ? UrlDecode (strings [1]) : string.Empty);  }  
Magic Number,YoutubeExtractor,HttpHelper,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\HttpHelper.cs,ParseQueryString,The following statement contains a magic number: dictionary.Add (strings [0]' strings.Length == 2 ? UrlDecode (strings [1]) : string.Empty);  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,Mp3AudioExtractor,The following statement contains a magic number: this.fileStream = new FileStream (path' FileMode.Create' FileAccess.Write' FileShare.Read' 64 * 1024);  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,Mp3AudioExtractor,The following statement contains a magic number: this.fileStream = new FileStream (path' FileMode.Create' FileAccess.Write' FileShare.Read' 64 * 1024);  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteChunk,The following statement contains a magic number: if (this.delayWrite && this.totalFrameLength >= 65536) {  	this.delayWrite = false;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ? (channelMode == 3 ? 17 : 32) : (channelMode == 3 ? 9 : 17));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ? (channelMode == 3 ? 17 : 32) : (channelMode == 3 ? 9 : 17));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ? (channelMode == 3 ? 17 : 32) : (channelMode == 3 ? 9 : 17));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ? (channelMode == 3 ? 17 : 32) : (channelMode == 3 ? 9 : 17));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ? (channelMode == 3 ? 17 : 32) : (channelMode == 3 ? 9 : 17));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ? (channelMode == 3 ? 17 : 32) : (channelMode == 3 ? 9 : 17));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ? (channelMode == 3 ? 17 : 32) : (channelMode == 3 ? 9 : 17));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameDataOffset,The following statement contains a magic number: return 4 + (mpegVersion == 3 ? (channelMode == 3 ? 17 : 32) : (channelMode == 3 ? 9 : 17));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameLength,The following statement contains a magic number: return (mpegVersion == 3 ? 144 : 72) * bitRate / sampleRate + padding;  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameLength,The following statement contains a magic number: return (mpegVersion == 3 ? 144 : 72) * bitRate / sampleRate + padding;  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,GetFrameLength,The following statement contains a magic number: return (mpegVersion == 3 ? 144 : 72) * bitRate / sampleRate + padding;  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: while (length >= 4) {  	int mpegVersion' sampleRate' channelMode;  	ulong header = (ulong)BigEndianBitConverter.ToUInt32 (buffer' offset) << 32;  	if (BitHelper.Read (ref header' 11) != 0x7FF) {  		break;  	}  	mpegVersion = BitHelper.Read (ref header' 2);  	int layer = BitHelper.Read (ref header' 2);  	BitHelper.Read (ref header' 1);  	int bitRate = BitHelper.Read (ref header' 4);  	sampleRate = BitHelper.Read (ref header' 2);  	int padding = BitHelper.Read (ref header' 1);  	BitHelper.Read (ref header' 1);  	channelMode = BitHelper.Read (ref header' 2);  	if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  		break;  	}  	bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  	switch (mpegVersion) {  	case 2:  		sampleRate = mpeg20SampleRate [sampleRate];  		break;  	case 3:  		sampleRate = mpeg1SampleRate [sampleRate];  		break;  	default:  		sampleRate = mpeg25SampleRate [sampleRate];  		break;  	}  	int frameLenght = GetFrameLength (mpegVersion' bitRate' sampleRate' padding);  	if (frameLenght > length) {  		break;  	}  	bool isVbrHeaderFrame = false;  	if (frameOffsets.Count == 0) {  		// Check for an existing VBR header just to be safe (I haven't seen any in FLVs)  		int o = offset + GetFrameDataOffset (mpegVersion' channelMode);  		if (BigEndianBitConverter.ToUInt32 (buffer' o) == 0x58696E67) {  			// "Xing"  			isVbrHeaderFrame = true;  			this.delayWrite = false;  			this.hasVbrHeader = true;  		}  	}  	if (!isVbrHeaderFrame) {  		if (this.firstBitRate == 0) {  			this.firstBitRate = bitRate;  			this.mpegVersion = mpegVersion;  			this.sampleRate = sampleRate;  			this.channelMode = channelMode;  			this.firstFrameHeader = BigEndianBitConverter.ToUInt32 (buffer' offset);  		}  		else if (!this.isVbr && bitRate != this.firstBitRate) {  			this.isVbr = true;  			if (!this.hasVbrHeader) {  				if (this.delayWrite) {  					this.WriteVbrHeader (true);  					this.writeVbrHeader = true;  					this.delayWrite = false;  				}  				else {  					this.warnings.Add ("Detected VBR too late' cannot add VBR header.");  				}  			}  		}  	}  	this.frameOffsets.Add (this.totalFrameLength + (uint)offset);  	offset += frameLenght;  	length -= frameLenght;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: if (BitHelper.Read (ref header' 11) != 0x7FF) {  	break;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: mpegVersion = BitHelper.Read (ref header' 2);  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: sampleRate = BitHelper.Read (ref header' 2);  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: channelMode = BitHelper.Read (ref header' 2);  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  	break;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: if (mpegVersion == 1 || layer != 1 || bitRate == 0 || bitRate == 15 || sampleRate == 3) {  	break;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: bitRate = (mpegVersion == 3 ? mpeg1BitRate [bitRate] : mpeg2XBitRate [bitRate]) * 1000;  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: switch (mpegVersion) {  case 2:  	sampleRate = mpeg20SampleRate [sampleRate];  	break;  case 3:  	sampleRate = mpeg1SampleRate [sampleRate];  	break;  default:  	sampleRate = mpeg25SampleRate [sampleRate];  	break;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,ParseMp3Frames,The following statement contains a magic number: switch (mpegVersion) {  case 2:  	sampleRate = mpeg20SampleRate [sampleRate];  	break;  case 3:  	sampleRate = mpeg1SampleRate [sampleRate];  	break;  default:  	sampleRate = mpeg25SampleRate [sampleRate];  	break;  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: if (!isPlaceholder) {  	uint header = this.firstFrameHeader;  	int dataOffset = GetFrameDataOffset (this.mpegVersion' this.channelMode);  	header &= 0xFFFE0DFF;  	// Clear CRC' bitrate' and padding fields  	header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  	// 64 kbit/sec  	BitHelper.CopyBytes (buffer' 0' BigEndianBitConverter.GetBytes (header));  	BitHelper.CopyBytes (buffer' dataOffset' BigEndianBitConverter.GetBytes (0x58696E67));  	// "Xing"  	BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  	// Flags  	BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  	// Frame count  	BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  	// File length  	for (int i = 0; i < 100; i++) {  		int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  		buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  	}  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: header |= (uint)(mpegVersion == 3 ? 5 : 8) << 12;  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: BitHelper.CopyBytes (buffer' dataOffset + 4' BigEndianBitConverter.GetBytes ((uint)0x7));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: BitHelper.CopyBytes (buffer' dataOffset + 8' BigEndianBitConverter.GetBytes ((uint)frameOffsets.Count));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: BitHelper.CopyBytes (buffer' dataOffset + 12' BigEndianBitConverter.GetBytes (totalFrameLength));  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  	int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  	buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  	int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  	buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  	int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  	buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: for (int i = 0; i < 100; i++) {  	int frameIndex = (int)((i / 100.0) * this.frameOffsets.Count);  	buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  }  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  
Magic Number,YoutubeExtractor,Mp3AudioExtractor,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\Mp3AudioExtractor.cs,WriteVbrHeader,The following statement contains a magic number: buffer [dataOffset + 16 + i] = (byte)(this.frameOffsets [frameIndex] / (double)this.totalFrameLength * 256.0);  
Magic Number,YoutubeExtractor,VideoDownloader,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoDownloader.cs,Execute,The following statement contains a magic number: using (WebResponse response = request.GetResponse ()) {  	using (Stream source = response.GetResponseStream ()) {  		using (FileStream target = File.Open (this.SavePath' FileMode.Create' FileAccess.Write)) {  			var buffer = new byte[1024];  			bool cancel = false;  			int bytes;  			int copiedBytes = 0;  			while (!cancel && (bytes = source.Read (buffer' 0' buffer.Length)) > 0) {  				target.Write (buffer' 0' bytes);  				copiedBytes += bytes;  				var eventArgs = new ProgressEventArgs ((copiedBytes * 1.0 / response.ContentLength) * 100);  				if (this.DownloadProgressChanged != null) {  					this.DownloadProgressChanged (this' eventArgs);  					if (eventArgs.Cancel) {  						cancel = true;  					}  				}  			}  		}  	}  }  
Magic Number,YoutubeExtractor,VideoDownloader,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoDownloader.cs,Execute,The following statement contains a magic number: using (WebResponse response = request.GetResponse ()) {  	using (Stream source = response.GetResponseStream ()) {  		using (FileStream target = File.Open (this.SavePath' FileMode.Create' FileAccess.Write)) {  			var buffer = new byte[1024];  			bool cancel = false;  			int bytes;  			int copiedBytes = 0;  			while (!cancel && (bytes = source.Read (buffer' 0' buffer.Length)) > 0) {  				target.Write (buffer' 0' bytes);  				copiedBytes += bytes;  				var eventArgs = new ProgressEventArgs ((copiedBytes * 1.0 / response.ContentLength) * 100);  				if (this.DownloadProgressChanged != null) {  					this.DownloadProgressChanged (this' eventArgs);  					if (eventArgs.Cancel) {  						cancel = true;  					}  				}  			}  		}  	}  }  
Magic Number,YoutubeExtractor,VideoDownloader,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoDownloader.cs,Execute,The following statement contains a magic number: using (Stream source = response.GetResponseStream ()) {  	using (FileStream target = File.Open (this.SavePath' FileMode.Create' FileAccess.Write)) {  		var buffer = new byte[1024];  		bool cancel = false;  		int bytes;  		int copiedBytes = 0;  		while (!cancel && (bytes = source.Read (buffer' 0' buffer.Length)) > 0) {  			target.Write (buffer' 0' bytes);  			copiedBytes += bytes;  			var eventArgs = new ProgressEventArgs ((copiedBytes * 1.0 / response.ContentLength) * 100);  			if (this.DownloadProgressChanged != null) {  				this.DownloadProgressChanged (this' eventArgs);  				if (eventArgs.Cancel) {  					cancel = true;  				}  			}  		}  	}  }  
Magic Number,YoutubeExtractor,VideoDownloader,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoDownloader.cs,Execute,The following statement contains a magic number: using (Stream source = response.GetResponseStream ()) {  	using (FileStream target = File.Open (this.SavePath' FileMode.Create' FileAccess.Write)) {  		var buffer = new byte[1024];  		bool cancel = false;  		int bytes;  		int copiedBytes = 0;  		while (!cancel && (bytes = source.Read (buffer' 0' buffer.Length)) > 0) {  			target.Write (buffer' 0' bytes);  			copiedBytes += bytes;  			var eventArgs = new ProgressEventArgs ((copiedBytes * 1.0 / response.ContentLength) * 100);  			if (this.DownloadProgressChanged != null) {  				this.DownloadProgressChanged (this' eventArgs);  				if (eventArgs.Cancel) {  					cancel = true;  				}  			}  		}  	}  }  
Magic Number,YoutubeExtractor,VideoDownloader,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoDownloader.cs,Execute,The following statement contains a magic number: using (FileStream target = File.Open (this.SavePath' FileMode.Create' FileAccess.Write)) {  	var buffer = new byte[1024];  	bool cancel = false;  	int bytes;  	int copiedBytes = 0;  	while (!cancel && (bytes = source.Read (buffer' 0' buffer.Length)) > 0) {  		target.Write (buffer' 0' bytes);  		copiedBytes += bytes;  		var eventArgs = new ProgressEventArgs ((copiedBytes * 1.0 / response.ContentLength) * 100);  		if (this.DownloadProgressChanged != null) {  			this.DownloadProgressChanged (this' eventArgs);  			if (eventArgs.Cancel) {  				cancel = true;  			}  		}  	}  }  
Magic Number,YoutubeExtractor,VideoDownloader,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoDownloader.cs,Execute,The following statement contains a magic number: using (FileStream target = File.Open (this.SavePath' FileMode.Create' FileAccess.Write)) {  	var buffer = new byte[1024];  	bool cancel = false;  	int bytes;  	int copiedBytes = 0;  	while (!cancel && (bytes = source.Read (buffer' 0' buffer.Length)) > 0) {  		target.Write (buffer' 0' bytes);  		copiedBytes += bytes;  		var eventArgs = new ProgressEventArgs ((copiedBytes * 1.0 / response.ContentLength) * 100);  		if (this.DownloadProgressChanged != null) {  			this.DownloadProgressChanged (this' eventArgs);  			if (eventArgs.Cancel) {  				cancel = true;  			}  		}  	}  }  
Magic Number,YoutubeExtractor,VideoDownloader,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\VideoDownloader.cs,Execute,The following statement contains a magic number: while (!cancel && (bytes = source.Read (buffer' 0' buffer.Length)) > 0) {  	target.Write (buffer' 0' bytes);  	copiedBytes += bytes;  	var eventArgs = new ProgressEventArgs ((copiedBytes * 1.0 / response.ContentLength) * 100);  	if (this.DownloadProgressChanged != null) {  		this.DownloadProgressChanged (this' eventArgs);  		if (eventArgs.Cancel) {  			cancel = true;  		}  	}  }  
Missing Default,YoutubeExtractor,FlvFile,C:\repos\phan-anh-tuan_DataAnalytic\YoutubeExtractor\FlvFile.cs,GetAudioWriter,The following switch statement is missing a default case: switch (format) {  case 14:  case 2:  	return new Mp3AudioExtractor (this.outputPath);  case 10:  	return new AacAudioExtractor (this.outputPath);  }  
