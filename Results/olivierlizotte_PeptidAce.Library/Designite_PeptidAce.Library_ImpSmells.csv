Implementation smell,Namespace,Class,File,Method,Description
Long Method,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The method has 114 lines of code.
Long Method,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,Load,The method has 156 lines of code.
Long Method,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The method has 125 lines of code.
Long Method,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The method has 135 lines of code.
Long Method,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The method has 168 lines of code.
Long Method,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The method has 139 lines of code.
Long Method,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The method has 116 lines of code.
Complex Method,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,Cyclomatic complexity of the method is 14
Complex Method,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,Cyclomatic complexity of the method is 33
Complex Method,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,GetVariableModificationPatterns,Cyclomatic complexity of the method is 9
Complex Method,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,Load,Cyclomatic complexity of the method is 143
Complex Method,PeptidAce,ProPheus,C:\repos\olivierlizotte_PeptidAce.Library\ProPheus.cs,ComputePSMs,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,ProPheus,C:\repos\olivierlizotte_PeptidAce.Library\ProPheus.cs,Search,Cyclomatic complexity of the method is 9
Complex Method,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,Cyclomatic complexity of the method is 20
Complex Method,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,Cyclomatic complexity of the method is 22
Complex Method,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,Cyclomatic complexity of the method is 16
Complex Method,PeptidAce,Cluster,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,OptimizedBestPsms,Cyclomatic complexity of the method is 12
Complex Method,PeptidAce,Cluster,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,ComputeBestPeptide,Cyclomatic complexity of the method is 14
Complex Method,PeptidAce,Cluster,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,OptimizedBestPrecursor,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Search,Cyclomatic complexity of the method is 9
Complex Method,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,Cyclomatic complexity of the method is 14
Complex Method,PeptidAce,PeptideMatch,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,BestPrecursorScore,Cyclomatic complexity of the method is 11
Complex Method,PeptidAce,PeptideMatch,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,BestPrecursorOptimizedScore,Cyclomatic complexity of the method is 11
Complex Method,PeptidAce,PeptideMatch,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,CumulPrecursorScore,Cyclomatic complexity of the method is 10
Complex Method,PeptidAce,PeptideMatch,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,CumulPrecursorOptimizedScore,Cyclomatic complexity of the method is 10
Complex Method,PeptidAce,PeptideSearcher,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,SearchAll,Cyclomatic complexity of the method is 17
Complex Method,PeptidAce,PeptideSearcher,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,SearchClusters,Cyclomatic complexity of the method is 18
Complex Method,PeptidAce,PeptideSearcher,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,Search,Cyclomatic complexity of the method is 17
Complex Method,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,ComputeAACoverage,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,GetProductMZs,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,Cyclomatic complexity of the method is 27
Complex Method,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,Cyclomatic complexity of the method is 14
Complex Method,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,Cyclomatic complexity of the method is 12
Complex Method,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,Cyclomatic complexity of the method is 13
Complex Method,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,Cyclomatic complexity of the method is 32
Complex Method,PeptidAce,Precursor,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Precursor.cs,OptimizedBestPsm,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AddMSMS,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,Cyclomatic complexity of the method is 22
Complex Method,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,Cyclomatic complexity of the method is 12
Complex Method,PeptidAce,Protease,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protease.cs,GetDigestionSiteIndices,Cyclomatic complexity of the method is 10
Complex Method,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,Digest,Cyclomatic complexity of the method is 9
Complex Method,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,Cyclomatic complexity of the method is 11
Complex Method,PeptidAce,FastGene,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,FastGene,Cyclomatic complexity of the method is 13
Complex Method,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteinChars,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,ProteinSearcher,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,SearchLatest,Cyclomatic complexity of the method is 17
Complex Method,PeptidAce,ProteinSearcher,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ProteinDigest,Cyclomatic complexity of the method is 14
Complex Method,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,Cyclomatic complexity of the method is 29
Complex Method,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetIsotopes,Cyclomatic complexity of the method is 9
Complex Method,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetOtherCharges,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce,Result,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Results.cs,WriteInfoToCsv,Cyclomatic complexity of the method is 14
Complex Method,PeptidAce,Result,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Results.cs,Export,Cyclomatic complexity of the method is 11
Complex Method,PeptidAce.Utilities,ElutionCurveMerger,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\ElutionCurveMaxFlow.cs,Merge,Cyclomatic complexity of the method is 11
Complex Method,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,GetTimePoints,Cyclomatic complexity of the method is 12
Complex Method,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,Cyclomatic complexity of the method is 30
Complex Method,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,Cyclomatic complexity of the method is 21
Complex Method,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,Cyclomatic complexity of the method is 21
Complex Method,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateHydrophobicity,Cyclomatic complexity of the method is 15
Complex Method,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculatePolarity,Cyclomatic complexity of the method is 15
Complex Method,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateNetCharge,Cyclomatic complexity of the method is 10
Complex Method,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,Cyclomatic complexity of the method is 25
Complex Method,PeptidAce.Utilities,vsCSVWriter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\vsCSVWriter.cs,WriteToFile,Cyclomatic complexity of the method is 9
Complex Method,PeptidAce.Utilities.Fasta,FastaRead,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Fasta\FastaRead.cs,GetSequences,Cyclomatic complexity of the method is 8
Complex Method,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,Cyclomatic complexity of the method is 20
Complex Method,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveMinimaStyle,Cyclomatic complexity of the method is 13
Complex Method,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveMaxFlowStyle,Cyclomatic complexity of the method is 25
Complex Method,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveMaxFlowStyle_bkp,Cyclomatic complexity of the method is 25
Complex Method,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,FCT,Cyclomatic complexity of the method is 8
Complex Method,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,Cyclomatic complexity of the method is 18
Long Parameter List,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,GetVariableModificationPatterns,The method has 5 parameters.
Long Parameter List,PeptidAce,Modification,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Modification.cs,Modification,The method has 8 parameters.
Long Parameter List,PeptidAce,Precursor,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Precursor.cs,Precursor,The method has 5 parameters.
Long Parameter List,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The method has 5 parameters.
Long Parameter List,PeptidAce,ProductSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\ProductSpectrum.cs,ProductSpectrum,The method has 11 parameters.
Long Parameter List,PeptidAce,MS1Spectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\MS1Spectrum.cs,MS1Spectrum,The method has 5 parameters.
Long Parameter List,PeptidAce,Ace,C:\repos\olivierlizotte_PeptidAce.Library\Ace.cs,Start,The method has 6 parameters.
Long Parameter List,PeptidAce,Protease,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protease.cs,Protease,The method has 5 parameters.
Long Parameter List,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,Digest,The method has 6 parameters.
Long Parameter List,PeptidAce,Query,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Query.cs,Query,The method has 5 parameters.
Long Parameter List,PeptidAce,Sample,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,Sample,The method has 7 parameters.
Long Parameter List,PeptidAce,Track,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Track.cs,Track,The method has 6 parameters.
Long Parameter List,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,AddTrack,The method has 6 parameters.
Long Parameter List,PeptidAce.Utilities,CurveFitter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\CurveFitter.cs,FitToSin2,The method has 6 parameters.
Long Parameter List,PeptidAce.Utilities,Gradior,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Gradior.cs,Minimize,The method has 6 parameters.
Long Parameter List,PeptidAce.Utilities,Gradior,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Gradior.cs,Gradient,The method has 7 parameters.
Long Parameter List,PeptidAce.Utilities,Gradior,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Gradior.cs,Optimize,The method has 6 parameters.
Long Parameter List,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveMinimaStyle,The method has 5 parameters.
Long Parameter List,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveFromGradientDescent,The method has 6 parameters.
Long Parameter List,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveMaxFlowStyle,The method has 6 parameters.
Long Parameter List,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveMaxFlowStyle_bkp,The method has 6 parameters.
Long Identifier,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The length of the parameter maximumVariableModificationIsoforms is 35.
Long Identifier,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the parameter nbTargetminMatchingProductScore is 31.
Long Identifier,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the parameter currentFDRminMatchingProductScore is 33.
Long Identifier,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the parameter nbTargetminMatchingProductFractionScore is 39.
Long Identifier,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the parameter currentFDRminMatchingProductFractionScore is 41.
Long Identifier,PeptidAce,ProteaseDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ProteaseDictionary.cs,ProteaseDictionary,The length of the parameter amino_acids_preventing_cleavage is 31.
Long Identifier,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,Digest,The length of the parameter peptide_without_initiator_methionine is 36.
Long Identifier,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The length of the parameter maximumVariableModificationIsoforms is 35.
Long Identifier,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The length of the parameter variable_modification_isoforms is 30.
Long Identifier,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The length of the parameter smallerInterpolatedIntensityCount is 33.
Long Statement,PeptidAce,Digestion,C:\repos\olivierlizotte_PeptidAce.Library\Digestion.cs,DigestProteomeOnTheFly,The length of the statement  "	//double minimumMonoisotopicPeakOffset = dbOptions.precursorMonoisotopicPeakCorrection ? dbOptions.minimumPrecursorMonoisotopicPeakOffset : 0; " is 142.
Long Statement,PeptidAce,Digestion,C:\repos\olivierlizotte_PeptidAce.Library\Digestion.cs,DigestProteomeOnTheFly,The length of the statement  "	//double maximumMonoisotopicPeakOffset = dbOptions.precursorMonoisotopicPeakCorrection ? dbOptions.maximumPrecursorMonoisotopicPeakOffset : 0; " is 142.
Long Statement,PeptidAce,Digestion,C:\repos\olivierlizotte_PeptidAce.Library\Digestion.cs,DigestProteomeOnTheFly,The length of the statement  "		//int firstIndex = AllQueries.BinarySearch(MassTolerance.MzFloor(peptide.MonoisotopicMass' options.precursorMassTolerance)); " is 124.
Long Statement,PeptidAce,Digestion,C:\repos\olivierlizotte_PeptidAce.Library\Digestion.cs,DigestProteomeOnTheFly,The length of the statement  "		foreach (Peptide modPeptide in peptide.GetVariablyModifiedPeptides (options.variableModifications' options.maximumVariableModificationIsoforms)) { " is 146.
Long Statement,PeptidAce,Digestion,C:\repos\olivierlizotte_PeptidAce.Library\Digestion.cs,DigestProteomeOnTheFly,The length of the statement  "			int firstIndex = AllQueries.BinarySearch (MassTolerance.MzFloor (modPeptide.MonoisotopicMass' options.precursorMassTolerance)); " is 127.
Long Statement,PeptidAce,Digestion,C:\repos\olivierlizotte_PeptidAce.Library\Digestion.cs,DigestProteomeOnTheFlyFast,The length of the statement  "		//int firstIndex = AllQueries.BinarySearch(MassTolerance.MzFloor(peptide.MonoisotopicMass' options.precursorMassTolerance)); " is 124.
Long Statement,PeptidAce,Digestion,C:\repos\olivierlizotte_PeptidAce.Library\Digestion.cs,DigestProteomeOnTheFlyFast,The length of the statement  "		foreach (Peptide modPeptide in peptide.GetVariablyModifiedPeptides (options.variableModifications' options.maximumVariableModificationIsoforms)) { " is 146.
Long Statement,PeptidAce,Digestion,C:\repos\olivierlizotte_PeptidAce.Library\Digestion.cs,DigestProteomeOnTheFlyFast,The length of the statement  "			int firstIndex = AllQueries.BinarySearch (MassTolerance.MzFloor (modPeptide.MonoisotopicMass' options.precursorMassTolerance)); " is 127.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The length of the statement  "		if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) { " is 236.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The length of the statement  "			if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) { " is 192.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The length of the statement  "		if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) { " is 182.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The length of the statement  "		cumulativeNTerminalMass [r] = cumulativeNTerminalMass [r - 1] + (productMassType == MassType.Average ? AminoAcidMasses.GetAverageMass (this [r - 1]) : AminoAcidMasses.GetMonoisotopicMass (this [r - 1])) + mass_shift; " is 216.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The length of the statement  "		cumulativeCTerminalMass [r] = cumulativeCTerminalMass [r - 1] + (productMassType == MassType.Average ? AminoAcidMasses.GetAverageMass (this [Length - r]) : AminoAcidMasses.GetMonoisotopicMass (this [Length - r])) + mass_shift; " is 226.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,CalculateProduct,The length of the statement  "		return new Product (productType' productNumber' cumulativeNTerminalMass [productNumber] + PRODUCT_CAPS [productType' productMassType]); " is 135.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,CalculateProduct,The length of the statement  "		return new Product (productType' productNumber' cumulativeCTerminalMass [productNumber] + PRODUCT_CAPS [productType' productMassType]); " is 135.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,GetVariableModificationPatterns,The length of the statement  "		foreach (Dictionary<int' Modification> dic in GetModificationDic (possibleVariableModifications' maxModPerPeptide' new Dictionary<int' Modification> ())) " is 153.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,GetVariableModificationPatterns,The length of the statement  "		//List<KeyValuePair<int' List<Modification>>> possible_variable_modifications = new List<KeyValuePair<int' List<Modification>>>(possibleVariableModifications); " is 159.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,GetVariableModificationPatterns,The length of the statement  "		//for (int variable_modifications = 0; variable_modifications <= possibleVariableModifications.Count; variable_modifications++) " is 127.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,GetVariableModificationPatterns,The length of the statement  "		//    foreach (int[] variable_modification_pattern in GetVariableModificationPatterns(possibleVariableModifications' possibleVariableModifications.Count - variable_modifications' base_variable_modification_pattern' 0' maxModPerPeptide)) " is 236.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,GetVariableModificationPatterns,The length of the statement  "		//     Dictionary<int' Modification> dic = GetVariableModificationPattern(variable_modification_pattern' possibleVariableModifications); " is 136.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,GetVariableModificationPatterns,The length of the statement  "			foreach (int[] new_variable_modification_pattern in GetVariableModificationPatterns (possibleVariableModifications' unmodifiedResiduesDesired - 1' variableModificationPattern' index + 1' maxModPerPeptide)) { " is 207.
Long Statement,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,GetVariableModificationPatterns,The length of the statement  "				foreach (int[] new_variable_modification_pattern in GetVariableModificationPatterns (possibleVariableModifications' unmodifiedResiduesDesired' variableModificationPattern' index + 1' maxModPerPeptide)) { " is 203.
Long Statement,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,Load,The length of the statement  "		//case "ToleratedMissedCleavages":                    options.ToleratedMissedCleavages = double.Parse(splits[1]); break;  " is 120.
Long Statement,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,Load,The length of the statement  "		//case "initiatorMethionineBehavior ":                    options.initiatorMethionineBehavior = double.Parse(splits[1]); break;  " is 127.
Long Statement,PeptidAce,ProPheus,C:\repos\olivierlizotte_PeptidAce.Library\ProPheus.cs,Search,The length of the statement  "	options.ConSole.WriteLine (nbAssignedQuery + " queries matched [" + nbAssignedPrecursor + " precursors] out of " + nbQueryConsidered + " psm computed"); " is 152.
Long Statement,PeptidAce,FullFragments,C:\repos\olivierlizotte_PeptidAce.Library\Fragment.cs,InitFullFrags,The length of the statement  "		AllFragments.Add (fg + "-H2O"' new FragmentGen (fg + "-H2O"' AllFragments [fg].IsReverse' AllFragments [fg].addOn - Constants.WATER_MONOISOTOPIC_MASS)); " is 152.
Long Statement,PeptidAce,FullFragments,C:\repos\olivierlizotte_PeptidAce.Library\Fragment.cs,InitFullFrags,The length of the statement  "		AllFragments.Add (fg + "-A"' new FragmentGen (fg + "-A"' AllFragments [fg].IsReverse' AllFragments [fg].addOn - Constants.AMONIA_MASS)); " is 136.
Long Statement,PeptidAce,Cluster,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Add,The length of the statement  "		conditions [precursor.sample.PROJECT.CONDITION - 1] = new clCondition (samples [precursor.sample.PROJECT.CONDITION].Count); " is 123.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The length of the statement  "		//double tmp = Math.Abs(MassTolerance.CalculateMassError(a.Track.MZ' b.Track.MZ' MassToleranceUnits.ppm) / options.MzTol); " is 122.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The length of the statement  "		double tmp = Math.Abs (Numerics.MzDifference (a.Track.MZ' b.Track.MZ' options.precursorMassTolerance.Units)) / options.precursorMassTolerance.Value; " is 148.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The length of the statement  "			tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds? " is 129.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Search,The length of the statement  "						//TODO Implement ProteoProfile Clustering algorithm' or anything on the litterature' as long as its backed by the scoring function " is 130.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Export,The length of the statement  "	writer.AddLine ("Index.Mz'Rt'Precursor Mz'Charge'Most Intense Charge'Precursor Mass'Peptide Mass'Sequence'Modified Sequence'Precursor Score'Product Score'Intensity Score'Final Score'Precursor Mass Error'Decoy?'Protein Score"); " is 226.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Export,The length of the statement  "		string line = precursor.INDEX + "'" + precursor.Track.RT + "'" + precursor.Track.MZ + "'" + precursor.Charge + "'" + precursor.GetMostIntenseCharge () + "'" + precursor.Mass + "'"; " is 180.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Export,The length of the statement  "			line += match.Peptide.MonoisotopicMass + "'" + match.Peptide.BaseSequence + "'" + match.Peptide.Sequence + "'" + match.PrecursorScore + "'" + match.ProductScore + "'" + match.IntensityScore + "'" + precursor.ProbabilityScore (match.Peptide) + "'" + match.PrecursorMzError + "'" + match.Decoy + "'" + match.ProteinScore; " is 319.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Export,The length of the statement  "	writer.AddLine ("Spectrum Precursor Mz'Rt'Charge'BaseSequence'Sequence'Nb Matched Fragments'Fragment Score'Precursor Score'Product Score'Intensity Score'Final Score'Precursor Mass Error'Decoy?'Protein Score"); " is 209.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Export,The length of the statement  "			line += match.Peptide.BaseSequence + "'" + match.Peptide.Sequence + "'" + match.MatchingProducts + "'" + match.FragmentScore + "'" + match.PrecursorScore + "'" + match.ProductScore + "'" + match.IntensityScore + "'" + query.ScoreFct (match.Peptide) + "'" + match.PrecursorMzError + "'" + match.Decoy + "'" + match.ProteinScore; " is 327.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Export,The length of the statement  "	writer.AddLine ("Mz'Rt'Charge'Sequence'Modifications'Precursor Score'Product Score'Intensity Score'Final Score'Precursor Mass Error'Decoy?'Protein Score"); " is 155.
Long Statement,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Export,The length of the statement  "		writer.AddLine (psm.Query.precursor.Track.MZ + "'" + psm.Query.spectrum.RetentionTimeInMin + "'" + psm.Query.precursor.Charge + "'" + psm.Peptide.BaseSequence + "'" + psm.Peptide.Sequence + "'" + psm.PrecursorScore + "'" + psm.ProductScore + "'" + psm.IntensityScore + "'" + psm.ProbabilityScore () + "'" + psm.PrecursorMzError + "'" + psm.Decoy + "'" + psm.ProteinScore); " is 372.
Long Statement,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,IsSamePeptide,The length of the statement  "					if (!peptide.VariableModifications.ContainsKey (key) || VariableModifications [key] != peptide.VariableModifications [key]) " is 123.
Long Statement,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The length of the statement  "		if (variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))) { " is 149.
Long Statement,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The length of the statement  "	foreach (Dictionary<int' Modification> kvp in GetVariableModificationPatterns (possible_modifications' maximumVariableModificationIsoforms)) { " is 142.
Long Statement,PeptidAce,PeptideMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideMatches.cs,CompareMatchingProducts,The length of the statement  "	return -left.BestPrecursor ().OptimizedBestPsm (left.peptide).MatchingProducts.CompareTo (right.BestPrecursor ().OptimizedBestPsm (right.peptide).MatchingProducts); " is 164.
Long Statement,PeptidAce,PeptideMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideMatches.cs,CompareMatchingProductsFraction,The length of the statement  "	return -left.BestPrecursor ().OptimizedBestPsm (left.peptide).MatchingProductsFraction.CompareTo (right.BestPrecursor ().OptimizedBestPsm (right.peptide).MatchingProductsFraction); " is 180.
Long Statement,PeptidAce,PeptideMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideMatches.cs,CompareMatchingIntensityFraction,The length of the statement  "	return -left.BestPrecursor ().OptimizedBestPsm (left.peptide).MatchingIntensityFraction.CompareTo (right.BestPrecursor ().OptimizedBestPsm (right.peptide).MatchingIntensityFraction); " is 182.
Long Statement,PeptidAce,PeptideMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideMatches.cs,CompareProductScore,The length of the statement  "	return -left.BestPrecursor ().OptimizedBestPsm (left.peptide).ProductScore.CompareTo (right.BestPrecursor ().OptimizedBestPsm (right.peptide).ProductScore); " is 156.
Long Statement,PeptidAce,PeptideSearcher,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,SearchAll,The length of the statement  "	options.ConSole.WriteLine (TotalList.Count + " distinct peptides (based on sequence" + (DiffByMod ? " and modifications)" : ")") + "    [" + nbClusterNewSeq + " added from clusters]"); " is 184.
Long Statement,PeptidAce,PeptideSearcher,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,SearchClusters,The length of the statement  "	options.ConSole.WriteLine (TotalList.Count + " distinct peptides (based on sequence" + (DiffByMod ? " and modifications)" : ")") + "    [" + nbClusterNewSeq + " not unmapped clusters]"); " is 186.
Long Statement,PeptidAce,PeptideSearcher,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,Search,The length of the statement  "	options.ConSole.WriteLine (TotalList.Count + " distinct peptides (based on sequence" + (DiffByMod ? " and modifications)" : ")") + "    [" + nbClusterNewSeq + " added from clusters]"); " is 184.
Long Statement,PeptidAce,PeptideSearcher,C:\repos\olivierlizotte_PeptidAce.Library\PeptideSearcher.cs,Export,The length of the statement  "		writer.AddLine (pm.peptide.BaseSequence + "'" + pm.peptide.Sequence + "'" + pm.ProbabilityScore () + "'" + pm.peptide.Decoy + "'" + pm.GetPrecursorMassError ()); " is 161.
Long Statement,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,ProbabilityScore,The length of the statement  "	double score = options.dIntensity * MatchingIntensity + options.dIntensityFraction * MatchingIntensityFraction + options.dProduct * ProductScore + options.dPrecursor * PrecursorScore + options.dMatchingProductFraction * MatchingProductsFraction + options.dMatchingProduct * MatchingWeightedProducts + options.dProtein * ProteinScore + options.dPeptideScore * PeptideScore + options.dFragmentScore * FragmentScore; " is 413.
Long Statement,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,UpdatePrecursor,The length of the statement  "	PrecursorMzError = Numerics.MzDifference (Numerics.MZFromMass (Peptide.MonoisotopicMass' Query.precursor.Charge)' Query.precursor.Track.MZ' options.precursorMassTolerance.Units); " is 178.
Long Statement,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,UpdatePrecursor,The length of the statement  "	PrecursorScore = (options.precursorMassTolerance.Value - Math.Abs (PrecursorMzError)) / options.precursorMassTolerance.Value; " is 125.
Long Statement,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,GetProductMZs,The length of the statement  "	foreach (ProductMatch matchTheo in options.fullFragment.ComputeFragments (Peptide.GetMasses ()' Query.precursor.Charge)) { " is 122.
Long Statement,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,GetProductMZs,The length of the statement  "                    foreach (int index in Query.spectrum.GetIndexOfMZInRange(matchTheo.theoMz + Numerics.IsotopicMassShift(1' matchTheo.charge)' options.productMassTolerance))" is 155.
Long Statement,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,GetProductMZs,The length of the statement  "                            //double diff = matchTheo.theoMz - peaks[index].MZ;// experimental_masses[index];//TODO DALTON ONLY : add product mass tolerance unit test" is 138.
Long Statement,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,GetProductMZs,The length of the statement  "                    if (secondIsoIntensity >= bestInt * 0.0107)//Second Isotope should be present... and should not account for less than 0.//*/{ " is 125.
Long Statement,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,GetProductMZs,The length of the statement  "				pMatch.normalizedIntensity = pMatch.obsIntensity / (Query.spectrum.InjectionTime * Query.spectrum.PrecursorIntensityPerMilliSecond); " is 132.
Long Statement,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,Initialize,The length of the statement  "	//List<double> theoretical_product_mz = Peptide.CalculateAllProductMz(PRODUCT_TYPES[Query.spectrum.FragmentationMethod]' Query.precursor); " is 138.
Long Statement,PeptidAce,PSMScoreThreshold,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,KeepPSM,The length of the statement  "	return psm.MatchingIntensity >= minIntensityScore && psm.MatchingIntensityFraction >= minIntensityFractionScore && psm.ProductScore >= minProductScore && psm.PrecursorScore >= minPrecursorScore && psm.MatchingProductsFraction >= minMatchingProductFractionScore && psm.MatchingProducts >= minMatchingProductScore && psm.ProteinScore >= minProteinScore && psm.PeptideScore >= minPeptideScore && psm.FragmentScore >= minFragmentScore && psm.ProbabilityScore () >= minProbabilityScore; " is 481.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the statement  "		double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy); " is 129.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the statement  "		double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy); " is 145.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the statement  "		double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy); " is 121.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the statement  "		if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) { " is 313.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the statement  "		else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) { " is 350.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the statement  "		else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) { " is 294.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the statement  "		else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) { " is 290.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The length of the statement  "		else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) { " is 302.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The length of the statement  "				for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) { " is 190.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The length of the statement  "	options.ConSole.WriteLine ("New score ratios   ----------------------------------------------------------------------- "); " is 122.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The length of the statement  "	options.ConSole.WriteLine ("    PeptideSpectrumMatch.dMatchingProductFraction:       " + options.dMatchingProductFraction); " is 123.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The length of the statement  "	options.ConSole.WriteLine ("------------------------------------------------------------------------------------------ "); " is 122.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The length of the statement  "					precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5); " is 140.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The length of the statement  "	Dictionary<string' Dictionary<PeptideSpectrumMatch' ProductMatch>> DicOfProducts = new Dictionary<string' Dictionary<PeptideSpectrumMatch' ProductMatch>> (); " is 157.
Long Statement,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The length of the statement  "							if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value) " is 167.
Long Statement,PeptidAce,Precursor,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Precursor.cs,OptimizedBestPsm,The length of the statement  "				if (peptide.IsSamePeptide (psms [i].Peptide' checkMods) && (psms [i].ProbabilityScore () > bestScore || (psms [i].ProbabilityScore () == bestScore && psms [i].Target)))//.ProteinScore > proteinScore))) " is 201.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The length of the statement  "		spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11]))); " is 275.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The length of the statement  "					//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value) " is 211.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The length of the statement  "					options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")"); " is 149.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The length of the statement  "					peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units)); " is 183.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The length of the statement  "                                ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);" is 173.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The length of the statement  "                        }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance); " is 127.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The length of the statement  "					ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime); " is 219.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStates,The length of the statement  "				if (Math.Abs (Numerics.CalculateMassError (peaks [j].MZ' peaks [i].MZ + Constants.C12_C13_MASS_DIFFERENCE / (double)c' isotopicMzTolerance.Units)) <= isotopicMzTolerance.Value) { " is 178.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesbkp,The length of the statement  "				if (Math.Abs (Numerics.CalculateMassError (peaks [j].MZ' peaks [i].MZ + Constants.C12_C13_MASS_DIFFERENCE / (double)c' isotopicMzTolerance.Units)) <= isotopicMzTolerance.Value) { " is 178.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The length of the statement  "						double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units)); " is 129.
Long Statement,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Deisotopebkp,The length of the statement  "					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units)); " is 129.
Long Statement,PeptidAce,ProductSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\ProductSpectrum.cs,ToString,The length of the statement  "	sb.AppendLine (ScanNumber + "'" + RetentionTimeInMin + "'" + FragmentationMethod + "'" + PrecursorMZ + "'" + PrecursorIntensity + "'" + PrecursorCharge + "'" + PrecursorMass + "'" + TotalIntensity + "'" + IsolationWindow + "'" + Peaks.Count + "'" + InjectionTime + "'" + Ms1InjectionTime); " is 289.
Long Statement,PeptidAce,Protease,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protease.cs,GetDigestionSiteIndices,The length of the statement  "				if ((CleavageTerminus != Terminus.N && aminoAcidPolymer [i] == c) || (CleavageTerminus == Terminus.N && i + 1 < aminoAcidPolymer.Length && aminoAcidPolymer [i + 1] == c)) { " is 172.
Long Statement,PeptidAce,Protease,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protease.cs,GetDigestionSiteIndices,The length of the statement  "						if ((CleavageTerminus != Terminus.N && i + 1 < aminoAcidPolymer.Length && aminoAcidPolymer [i + 1] == nc) || (CleavageTerminus == Terminus.N && i - 1 >= 0 && aminoAcidPolymer [i - 1] == nc)) { " is 192.
Long Statement,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,Digest,The length of the statement  "				if ((!minimumPeptideLength.HasValue || peptide.Length >= minimumPeptideLength.Value) && (!maximumPeptideLength.HasValue || peptide.Length <= maximumPeptideLength.Value)) { " is 171.
Long Statement,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,Digest,The length of the statement  "				Peptide peptide_without_initiator_methionine = new Peptide (this' indices [i] + 1 + 1' indices [i + missed_cleavages + 1]' missed_cleavages); " is 141.
Long Statement,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,Digest,The length of the statement  "				if ((!minimumPeptideLength.HasValue || peptide_without_initiator_methionine.Length >= minimumPeptideLength.Value) && (!maximumPeptideLength.HasValue || peptide_without_initiator_methionine.Length <= maximumPeptideLength.Value)) { " is 229.
Long Statement,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The length of the statement  "	foreach (Dictionary<int' Modification> kvp in GetVariableModificationPatterns (possible_modifications' maximumVariableModificationIsoforms)) { " is 142.
Long Statement,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The length of the statement  "					throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled"); " is 196.
Long Statement,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The length of the statement  "				Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true); " is 174.
Long Statement,PeptidAce,ProteinSearcher,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ProteinDigest,The length of the statement  "					if (options.initiatorMethionineBehavior != InitiatorMethionineBehavior.Cleave || indices [i] + 1 != 0 || protein [0] != 'M') { " is 126.
Long Statement,PeptidAce,ProteinSearcher,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ProteinDigest,The length of the statement  "					if (options.initiatorMethionineBehavior != InitiatorMethionineBehavior.Retain && indices [i] + 1 == 0 && protein [0] == 'M') { " is 126.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The length of the statement  "		foreach (Track track in tracks.GetTracksInMzRange (spectrum.PrecursorMZ' spectrum.IsolationWindow * dbOptions.EffectiveIsolationWindowRatio))//TODO Optimize this value " is 167.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The length of the statement  "				if (closestTrack == null || Math.Abs (track.MZ - spectrum.PrecursorMZ) < Math.Abs (closestTrack.MZ - spectrum.PrecursorMZ)) " is 123.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The length of the statement  "			/*if (closestTrack != null && Tracks.ContainsKey(closestTrack) && Math.Abs(Numerics.CalculateMassError(closestTrack.MZ' spectrum.PrecursorMZ' dbOptions.precursorMassTolerance.Units)) < dbOptions.precursorMassTolerance.Value)" is 224.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The length of the statement  "				closestTrack = new Track ((float)spectrum.PrecursorMZ' (float)spectrum.RetentionTimeInMin' spectrum.PrecursorIntensity' (float)(spectrum.RetentionTimeInMin - dbOptions.ComputedRetentionTimeDiff)' (float)(spectrum.RetentionTimeInMin + dbOptions.ComputedRetentionTimeDiff)' true); " is 278.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The length of the statement  "			//Remove precursors if estimated fragment intensities are too low (based on precursor intensity ratios and isolation window placement) " is 134.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The length of the statement  "				//if (q.precursor.Track.INTENSITY > intensityCumul * dbOptions.MinimumPrecursorIntensityRatioInIsolationWindow)//Need to be 5% of all intensity " is 143.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The length of the statement  "		if (query.precursor.Track.INTENSITY < DicOfSpectrumIntensities [query.spectrum] * dbOptions.MinimumPrecursorIntensityRatioInIsolationWindow) " is 140.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The length of the statement  "	dbOptions.ConSole.WriteLine (entry.sSDF + " :" + Precursors.Count + " precursors [" + Isotopes.Count + " isotopes] spreaded in " + Count + " queries [" + nbMissedTrack + " trackless precursors]"); " is 196.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The length of the statement  "	dbOptions.ConSole.WriteLine ("Average Precursors per Spectrum : " + averageNbPrecursorPerSpectrum / (double)nbSpectrumMatchedToTrack); " is 134.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetOtherCharges,The length of the statement  "					if (mzDiff < bestDeltaMz)//TODO Is the best isotope the most precise one or the closest in intensity?? Use a scoring function to get both! " is 138.
Long Statement,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetOtherCharges,The length of the statement  "				otherPrecursor.Add (new Precursor (bestTrack' charge' precursor.sample' 0' GetIsotopes (bestTrack' dbOptions' listTracks' entry))); " is 131.
Long Statement,PeptidAce,Result,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Results.cs,DescendingIntensityFractionComparison,The length of the statement  "	return -(left.OptimizedBestPsm ().MatchingIntensityFraction.CompareTo (right.OptimizedBestPsm ().MatchingIntensityFraction)); " is 125.
Long Statement,PeptidAce,Result,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Results.cs,WriteInfoToCsv,The length of the statement  "	dbOptions.ConSole.WriteLine ("  ---  Number of precursors          : " + target + " targets [" + matchedPrecursors.Count + "]" + "  ---  "); " is 140.
Long Statement,PeptidAce,Result,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Results.cs,WriteInfoToCsv,The length of the statement  "	dbOptions.ConSole.WriteLine ("  ---  Number of peptides            : " + target + " targets [" + peptides.Count + "]" + "  ---  "); " is 131.
Long Statement,PeptidAce,Result,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Results.cs,WriteInfoToCsv,The length of the statement  "	dbOptions.ConSole.WriteLine ("  ---  Number of peptide sequences   : " + target + " targets [" + peptideSequences.Count + "]" + "  ---  "); " is 139.
Long Statement,PeptidAce,Result,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Results.cs,WriteInfoToCsv,The length of the statement  "	dbOptions.ConSole.WriteLine ("  ---  Number of proteins            : " + target + " targets [" + proteins.Count + "]" + "  ---  "); " is 131.
Long Statement,PeptidAce,Result,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Results.cs,Export,The length of the statement  "                MSSearcher.Export(dbOptions.outputFolder + keyword + "Optimized_precursors.csv"' prec);//*///dbOptions.ConSole.WriteLine("Target Precursors : " ) " is 145.
Long Statement,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The length of the statement  "				// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf " is 127.
Long Statement,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The length of the statement  "			tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2])); " is 152.
Long Statement,PeptidAce.Utilities,CurveFitter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\CurveFitter.cs,AreaUnderTheCurve,The length of the statement  "	//MathNet.Numerics.Interpolation.IInterpolation interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(xTime' yIntensity); " is 142.
Long Statement,PeptidAce.Utilities,CurveFitter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\CurveFitter.cs,AreaUnderTheCurve,The length of the statement  "		MathNet.Numerics.Interpolation.IInterpolation interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (xTime' yIntensity); " is 134.
Long Statement,PeptidAce.Utilities,CurveFitter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\CurveFitter.cs,AreaUnderTheCurve,The length of the statement  "		//MathNet.Numerics.Interpolation.IInterpolation interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(xTime' yIntensity); " is 150.
Long Statement,PeptidAce.Utilities,CurveFitter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\CurveFitter.cs,AreaUnderTheCurve,The length of the statement  "	//MathNet.Numerics.Interpolation.IInterpolation interpole = MathNet.Numerics.Interpolation.Interpolate.(xTime' yIntensity); " is 123.
Long Statement,PeptidAce.Utilities,Gradior,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Gradior.cs,Gradient,The length of the statement  "	return x => Enumerable.Range (0' x.Count).Select (i => (f (x.Select ((y' j) => j == i ? y + Precision : y).ToList ()) - f (x.Select ((y' j) => j == i ? y - Precision : y).ToList ())) / (2 * Precision)).ToList (); " is 212.
Long Statement,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The length of the statement  "					//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount); " is 131.
Long Statement,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The length of the statement  "					//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount); " is 123.
Long Statement,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The length of the statement  "					//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount); " is 131.
Long Statement,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The length of the statement  "	foreach (char aa in sequence)//for (i = 0; i <= protein.length() - 1; ++i)              //  we are looking for charged amino acids " is 130.
Long Statement,PeptidAce.Utilities,vsCSV,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\vsCSV.cs,StartsWithNumberOrLetter,The length of the statement  "		return (line [0] >= '0' && line [0] <= '9') || (line [0] >= 'A' && line [0] <= 'Z') || (line [0] >= 'a' && line [0] <= 'z'); " is 124.
Long Statement,PeptidAce.Utilities,vsCSVWriter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\vsCSVWriter.cs,WriteToFile,The length of the statement  "			m_fileName = vsCSV.GetFolder (m_fileName) + vsCSV.GetFileName_NoExtension (m_fileName) + "_" + (new Random ()).Next () + ".csv"; " is 128.
Long Statement,PeptidAce.Utilities.Interfaces,Logger,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Interfaces\ConSolBasic.cs,UpdateLogFile,The length of the statement  "				string fileName = System.DateTime.Today.Day + "_" + System.DateTime.Today.Month + "_" + System.DateTime.Today.Year + ".txt"; " is 124.
Long Statement,PeptidAce.Utilities.Interfaces,Logger,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Interfaces\ConSolBasic.cs,UpdateLogFile,The length of the statement  "				System.IO.StreamWriter outFile = new System.IO.StreamWriter (FOLDER + System.IO.Path.DirectorySeparatorChar + fileName' true); " is 126.
Long Statement,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The length of the statement  "	PeptidAce.Utilities.vsCSVWriter writer = new vsCSVWriter (vsCSV.GetFolder (peptidesFile) + vsCSV.GetFileName_NoExtension (peptidesFile) + "_ERK_Motif.csv"); " is 156.
Long Statement,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The length of the statement  "	writer.AddLine (csvPep.LINES_LIST [0] + "'Start index in Protein'Index of Ph in protein'Motif Found'Index of Motif in protein'Motif sequence'Distance from peptide'SP Motif"); " is 174.
Long Statement,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The length of the statement  "				if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) { " is 171.
Long Statement,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The length of the statement  "											line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP; " is 197.
Complex Conditional,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The conditional expression  "fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))"  is complex.
Complex Conditional,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The conditional expression  "fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))"  is complex.
Complex Conditional,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The conditional expression  "fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))"  is complex.
Complex Conditional,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The conditional expression  "variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))"  is complex.
Complex Conditional,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The conditional expression  "nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore"  is complex.
Complex Conditional,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The conditional expression  "nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore"  is complex.
Complex Conditional,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The conditional expression  "nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore"  is complex.
Complex Conditional,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The conditional expression  "nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore"  is complex.
Complex Conditional,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The conditional expression  "nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore"  is complex.
Complex Conditional,PeptidAce,Precursor,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Precursor.cs,OptimizedBestPsm,The conditional expression  "peptide.IsSamePeptide (psms [i].Peptide' checkMods) && (psms [i].ProbabilityScore () > bestScore || (psms [i].ProbabilityScore () == bestScore && psms [i].Target))"  is complex.
Complex Conditional,PeptidAce,Protease,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protease.cs,GetDigestionSiteIndices,The conditional expression  "(CleavageTerminus != Terminus.N && aminoAcidPolymer [i] == c) || (CleavageTerminus == Terminus.N && i + 1 < aminoAcidPolymer.Length && aminoAcidPolymer [i + 1] == c)"  is complex.
Complex Conditional,PeptidAce,Protease,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protease.cs,GetDigestionSiteIndices,The conditional expression  "(CleavageTerminus != Terminus.N && i + 1 < aminoAcidPolymer.Length && aminoAcidPolymer [i + 1] == nc) || (CleavageTerminus == Terminus.N && i - 1 >= 0 && aminoAcidPolymer [i - 1] == nc)"  is complex.
Complex Conditional,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,Digest,The conditional expression  "(!minimumPeptideLength.HasValue || peptide.Length >= minimumPeptideLength.Value) && (!maximumPeptideLength.HasValue || peptide.Length <= maximumPeptideLength.Value)"  is complex.
Complex Conditional,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,Digest,The conditional expression  "(!minimumPeptideLength.HasValue || peptide_without_initiator_methionine.Length >= minimumPeptideLength.Value) && (!maximumPeptideLength.HasValue || peptide_without_initiator_methionine.Length <= maximumPeptideLength.Value)"  is complex.
Complex Conditional,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The conditional expression  "time != null && (time.Count > 8 || (time.Count >= 4 && type == CurveType.LINEAR))"  is complex.
Complex Conditional,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The conditional expression  "(!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))"  is complex.
Empty Catch Block,PeptidAce.Utilities.Interfaces,Logger,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Interfaces\ConSolBasic.cs,UpdateLogFile,The method has an empty catch block.
Magic Number,PeptidAce,AminoAcidMasses,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidMasses.cs,AminoAcidMasses,The following statement contains a magic number: try {  	List<char> aminoAcids = new List<char> ();  	using (StreamReader amino_acids = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "amino_acids.tsv"))) {  		string header = amino_acids.ReadLine ();  		while (amino_acids.Peek () != -1) {  			string line = amino_acids.ReadLine ();  			string[] fields = line.Split ('\t');  			char one_letter_code = char.Parse (fields [0]);  			double monoisotopic_mass = double.Parse (fields [1]);  			MONOISOTOPIC_AMINO_ACID_MASSES [one_letter_code - 'A'] = monoisotopic_mass;  			double average_mass = double.Parse (fields [2]);  			AVERAGE_AMINO_ACID_MASSES [one_letter_code - 'A'] = average_mass;  			aminoAcids.Add (one_letter_code);  		}  	}  	MONOISOTOPIC_AMINO_ACID_MASSES ['X' - 'A'] = 0.0;  	AVERAGE_AMINO_ACID_MASSES ['X' - 'A'] = 0.0;  	VALID_AMINO_ACIDS = aminoAcids.ToArray ();  	//aminoAcids.Add('X');   	AMINO_ACIDS = aminoAcids.ToArray ();  }  catch (Exception) {  	Console.WriteLine ("Could not load configuration file amino_acids.tsv");  }  
Magic Number,PeptidAce,AminoAcidMasses,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidMasses.cs,AminoAcidMasses,The following statement contains a magic number: using (StreamReader amino_acids = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "amino_acids.tsv"))) {  	string header = amino_acids.ReadLine ();  	while (amino_acids.Peek () != -1) {  		string line = amino_acids.ReadLine ();  		string[] fields = line.Split ('\t');  		char one_letter_code = char.Parse (fields [0]);  		double monoisotopic_mass = double.Parse (fields [1]);  		MONOISOTOPIC_AMINO_ACID_MASSES [one_letter_code - 'A'] = monoisotopic_mass;  		double average_mass = double.Parse (fields [2]);  		AVERAGE_AMINO_ACID_MASSES [one_letter_code - 'A'] = average_mass;  		aminoAcids.Add (one_letter_code);  	}  }  
Magic Number,PeptidAce,AminoAcidMasses,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidMasses.cs,AminoAcidMasses,The following statement contains a magic number: while (amino_acids.Peek () != -1) {  	string line = amino_acids.ReadLine ();  	string[] fields = line.Split ('\t');  	char one_letter_code = char.Parse (fields [0]);  	double monoisotopic_mass = double.Parse (fields [1]);  	MONOISOTOPIC_AMINO_ACID_MASSES [one_letter_code - 'A'] = monoisotopic_mass;  	double average_mass = double.Parse (fields [2]);  	AVERAGE_AMINO_ACID_MASSES [one_letter_code - 'A'] = average_mass;  	aminoAcids.Add (one_letter_code);  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,AminoAcidPolymer,The following statement contains a magic number: for (int i = 0; i < seqSplits.Length; i += 2)  	seq += seqSplits [i];  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,AminoAcidPolymer,The following statement contains a magic number: i += 2
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: this.fixedModifications = new Dictionary<int' List<Modification>> (Length + 4);  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: foreach (Modification fixed_modification in fixedModifications) {  	if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) {  		List<Modification> prot_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (0' out prot_n_term_fixed_mods)) {  			prot_n_term_fixed_mods = new List<Modification> ();  			prot_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (0' prot_n_term_fixed_mods);  		}  		else {  			prot_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (1' out pep_n_term_fixed_mods)) {  			pep_n_term_fixed_mods = new List<Modification> ();  			pep_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (1' pep_n_term_fixed_mods);  		}  		else {  			pep_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  			List<Modification> residue_fixed_mods;  			if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  				residue_fixed_mods = new List<Modification> ();  				residue_fixed_mods.Add (fixed_modification);  				this.fixedModifications.Add (r + 2' residue_fixed_mods);  			}  			else {  				residue_fixed_mods.Add (fixed_modification);  			}  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  			pep_c_term_fixed_mods = new List<Modification> ();  			pep_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  		}  		else {  			pep_c_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  		List<Modification> prot_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  			prot_c_term_fixed_mods = new List<Modification> ();  			prot_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  		}  		else {  			prot_c_term_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: foreach (Modification fixed_modification in fixedModifications) {  	if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) {  		List<Modification> prot_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (0' out prot_n_term_fixed_mods)) {  			prot_n_term_fixed_mods = new List<Modification> ();  			prot_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (0' prot_n_term_fixed_mods);  		}  		else {  			prot_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (1' out pep_n_term_fixed_mods)) {  			pep_n_term_fixed_mods = new List<Modification> ();  			pep_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (1' pep_n_term_fixed_mods);  		}  		else {  			pep_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  			List<Modification> residue_fixed_mods;  			if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  				residue_fixed_mods = new List<Modification> ();  				residue_fixed_mods.Add (fixed_modification);  				this.fixedModifications.Add (r + 2' residue_fixed_mods);  			}  			else {  				residue_fixed_mods.Add (fixed_modification);  			}  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  			pep_c_term_fixed_mods = new List<Modification> ();  			pep_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  		}  		else {  			pep_c_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  		List<Modification> prot_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  			prot_c_term_fixed_mods = new List<Modification> ();  			prot_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  		}  		else {  			prot_c_term_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: foreach (Modification fixed_modification in fixedModifications) {  	if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) {  		List<Modification> prot_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (0' out prot_n_term_fixed_mods)) {  			prot_n_term_fixed_mods = new List<Modification> ();  			prot_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (0' prot_n_term_fixed_mods);  		}  		else {  			prot_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (1' out pep_n_term_fixed_mods)) {  			pep_n_term_fixed_mods = new List<Modification> ();  			pep_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (1' pep_n_term_fixed_mods);  		}  		else {  			pep_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  			List<Modification> residue_fixed_mods;  			if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  				residue_fixed_mods = new List<Modification> ();  				residue_fixed_mods.Add (fixed_modification);  				this.fixedModifications.Add (r + 2' residue_fixed_mods);  			}  			else {  				residue_fixed_mods.Add (fixed_modification);  			}  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  			pep_c_term_fixed_mods = new List<Modification> ();  			pep_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  		}  		else {  			pep_c_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  		List<Modification> prot_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  			prot_c_term_fixed_mods = new List<Modification> ();  			prot_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  		}  		else {  			prot_c_term_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: foreach (Modification fixed_modification in fixedModifications) {  	if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) {  		List<Modification> prot_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (0' out prot_n_term_fixed_mods)) {  			prot_n_term_fixed_mods = new List<Modification> ();  			prot_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (0' prot_n_term_fixed_mods);  		}  		else {  			prot_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (1' out pep_n_term_fixed_mods)) {  			pep_n_term_fixed_mods = new List<Modification> ();  			pep_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (1' pep_n_term_fixed_mods);  		}  		else {  			pep_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  			List<Modification> residue_fixed_mods;  			if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  				residue_fixed_mods = new List<Modification> ();  				residue_fixed_mods.Add (fixed_modification);  				this.fixedModifications.Add (r + 2' residue_fixed_mods);  			}  			else {  				residue_fixed_mods.Add (fixed_modification);  			}  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  			pep_c_term_fixed_mods = new List<Modification> ();  			pep_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  		}  		else {  			pep_c_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  		List<Modification> prot_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  			prot_c_term_fixed_mods = new List<Modification> ();  			prot_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  		}  		else {  			prot_c_term_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: foreach (Modification fixed_modification in fixedModifications) {  	if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) {  		List<Modification> prot_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (0' out prot_n_term_fixed_mods)) {  			prot_n_term_fixed_mods = new List<Modification> ();  			prot_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (0' prot_n_term_fixed_mods);  		}  		else {  			prot_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (1' out pep_n_term_fixed_mods)) {  			pep_n_term_fixed_mods = new List<Modification> ();  			pep_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (1' pep_n_term_fixed_mods);  		}  		else {  			pep_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  			List<Modification> residue_fixed_mods;  			if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  				residue_fixed_mods = new List<Modification> ();  				residue_fixed_mods.Add (fixed_modification);  				this.fixedModifications.Add (r + 2' residue_fixed_mods);  			}  			else {  				residue_fixed_mods.Add (fixed_modification);  			}  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  			pep_c_term_fixed_mods = new List<Modification> ();  			pep_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  		}  		else {  			pep_c_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  		List<Modification> prot_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  			prot_c_term_fixed_mods = new List<Modification> ();  			prot_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  		}  		else {  			prot_c_term_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: foreach (Modification fixed_modification in fixedModifications) {  	if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) {  		List<Modification> prot_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (0' out prot_n_term_fixed_mods)) {  			prot_n_term_fixed_mods = new List<Modification> ();  			prot_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (0' prot_n_term_fixed_mods);  		}  		else {  			prot_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (1' out pep_n_term_fixed_mods)) {  			pep_n_term_fixed_mods = new List<Modification> ();  			pep_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (1' pep_n_term_fixed_mods);  		}  		else {  			pep_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  			List<Modification> residue_fixed_mods;  			if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  				residue_fixed_mods = new List<Modification> ();  				residue_fixed_mods.Add (fixed_modification);  				this.fixedModifications.Add (r + 2' residue_fixed_mods);  			}  			else {  				residue_fixed_mods.Add (fixed_modification);  			}  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  			pep_c_term_fixed_mods = new List<Modification> ();  			pep_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  		}  		else {  			pep_c_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  		List<Modification> prot_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  			prot_c_term_fixed_mods = new List<Modification> ();  			prot_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  		}  		else {  			prot_c_term_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: foreach (Modification fixed_modification in fixedModifications) {  	if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) {  		List<Modification> prot_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (0' out prot_n_term_fixed_mods)) {  			prot_n_term_fixed_mods = new List<Modification> ();  			prot_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (0' prot_n_term_fixed_mods);  		}  		else {  			prot_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (1' out pep_n_term_fixed_mods)) {  			pep_n_term_fixed_mods = new List<Modification> ();  			pep_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (1' pep_n_term_fixed_mods);  		}  		else {  			pep_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  			List<Modification> residue_fixed_mods;  			if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  				residue_fixed_mods = new List<Modification> ();  				residue_fixed_mods.Add (fixed_modification);  				this.fixedModifications.Add (r + 2' residue_fixed_mods);  			}  			else {  				residue_fixed_mods.Add (fixed_modification);  			}  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  			pep_c_term_fixed_mods = new List<Modification> ();  			pep_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  		}  		else {  			pep_c_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  		List<Modification> prot_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  			prot_c_term_fixed_mods = new List<Modification> ();  			prot_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  		}  		else {  			prot_c_term_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: foreach (Modification fixed_modification in fixedModifications) {  	if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) {  		List<Modification> prot_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (0' out prot_n_term_fixed_mods)) {  			prot_n_term_fixed_mods = new List<Modification> ();  			prot_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (0' prot_n_term_fixed_mods);  		}  		else {  			prot_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (1' out pep_n_term_fixed_mods)) {  			pep_n_term_fixed_mods = new List<Modification> ();  			pep_n_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (1' pep_n_term_fixed_mods);  		}  		else {  			pep_n_term_fixed_mods.Add (fixed_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  			List<Modification> residue_fixed_mods;  			if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  				residue_fixed_mods = new List<Modification> ();  				residue_fixed_mods.Add (fixed_modification);  				this.fixedModifications.Add (r + 2' residue_fixed_mods);  			}  			else {  				residue_fixed_mods.Add (fixed_modification);  			}  		}  	}  	if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  			pep_c_term_fixed_mods = new List<Modification> ();  			pep_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  		}  		else {  			pep_c_term_fixed_mods.Add (fixed_modification);  		}  	}  	if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  		List<Modification> prot_c_term_fixed_mods;  		if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  			prot_c_term_fixed_mods = new List<Modification> ();  			prot_c_term_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  		}  		else {  			prot_c_term_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (fixed_modification.Type == ModificationType.ProteinNTerminus && (this is Protein || (this is Peptide && (((Peptide)this).StartResidueNumber == 1 || (((Peptide)this).StartResidueNumber == 2 && ((Peptide)this).Parent [0] == 'M'))))) {  	List<Modification> prot_n_term_fixed_mods;  	if (!this.fixedModifications.TryGetValue (0' out prot_n_term_fixed_mods)) {  		prot_n_term_fixed_mods = new List<Modification> ();  		prot_n_term_fixed_mods.Add (fixed_modification);  		this.fixedModifications.Add (0' prot_n_term_fixed_mods);  	}  	else {  		prot_n_term_fixed_mods.Add (fixed_modification);  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: for (int r = 0; r < Length; r++) {  	if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  		List<Modification> residue_fixed_mods;  		if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  			residue_fixed_mods = new List<Modification> ();  			residue_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (r + 2' residue_fixed_mods);  		}  		else {  			residue_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: for (int r = 0; r < Length; r++) {  	if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  		List<Modification> residue_fixed_mods;  		if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  			residue_fixed_mods = new List<Modification> ();  			residue_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (r + 2' residue_fixed_mods);  		}  		else {  			residue_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: for (int r = 0; r < Length; r++) {  	if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  		List<Modification> residue_fixed_mods;  		if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  			residue_fixed_mods = new List<Modification> ();  			residue_fixed_mods.Add (fixed_modification);  			this.fixedModifications.Add (r + 2' residue_fixed_mods);  		}  		else {  			residue_fixed_mods.Add (fixed_modification);  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  	List<Modification> residue_fixed_mods;  	if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  		residue_fixed_mods = new List<Modification> ();  		residue_fixed_mods.Add (fixed_modification);  		this.fixedModifications.Add (r + 2' residue_fixed_mods);  	}  	else {  		residue_fixed_mods.Add (fixed_modification);  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  	List<Modification> residue_fixed_mods;  	if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  		residue_fixed_mods = new List<Modification> ();  		residue_fixed_mods.Add (fixed_modification);  		this.fixedModifications.Add (r + 2' residue_fixed_mods);  	}  	else {  		residue_fixed_mods.Add (fixed_modification);  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (fixed_modification.Type == ModificationType.AminoAcidResidue && this [r] == fixed_modification.AminoAcid && (variableModifications == null || !variableModifications.ContainsKey (r + 2))) {  	List<Modification> residue_fixed_mods;  	if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  		residue_fixed_mods = new List<Modification> ();  		residue_fixed_mods.Add (fixed_modification);  		this.fixedModifications.Add (r + 2' residue_fixed_mods);  	}  	else {  		residue_fixed_mods.Add (fixed_modification);  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  	residue_fixed_mods = new List<Modification> ();  	residue_fixed_mods.Add (fixed_modification);  	this.fixedModifications.Add (r + 2' residue_fixed_mods);  }  else {  	residue_fixed_mods.Add (fixed_modification);  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (!this.fixedModifications.TryGetValue (r + 2' out residue_fixed_mods)) {  	residue_fixed_mods = new List<Modification> ();  	residue_fixed_mods.Add (fixed_modification);  	this.fixedModifications.Add (r + 2' residue_fixed_mods);  }  else {  	residue_fixed_mods.Add (fixed_modification);  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: this.fixedModifications.Add (r + 2' residue_fixed_mods);  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  	List<Modification> pep_c_term_fixed_mods;  	if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  		pep_c_term_fixed_mods = new List<Modification> ();  		pep_c_term_fixed_mods.Add (fixed_modification);  		this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  	}  	else {  		pep_c_term_fixed_mods.Add (fixed_modification);  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (fixed_modification.Type == ModificationType.PeptideCTerminus) {  	List<Modification> pep_c_term_fixed_mods;  	if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  		pep_c_term_fixed_mods = new List<Modification> ();  		pep_c_term_fixed_mods.Add (fixed_modification);  		this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  	}  	else {  		pep_c_term_fixed_mods.Add (fixed_modification);  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  	pep_c_term_fixed_mods = new List<Modification> ();  	pep_c_term_fixed_mods.Add (fixed_modification);  	this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  }  else {  	pep_c_term_fixed_mods.Add (fixed_modification);  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (!this.fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  	pep_c_term_fixed_mods = new List<Modification> ();  	pep_c_term_fixed_mods.Add (fixed_modification);  	this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  }  else {  	pep_c_term_fixed_mods.Add (fixed_modification);  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: this.fixedModifications.Add (Length + 2' pep_c_term_fixed_mods);  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  	List<Modification> prot_c_term_fixed_mods;  	if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  		prot_c_term_fixed_mods = new List<Modification> ();  		prot_c_term_fixed_mods.Add (fixed_modification);  		this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  	}  	else {  		prot_c_term_fixed_mods.Add (fixed_modification);  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (fixed_modification.Type == ModificationType.ProteinCTerminus && (this is Protein || (this is Peptide && ((Peptide)this).EndResidueNumber == ((Peptide)this).Parent.Length - 1))) {  	List<Modification> prot_c_term_fixed_mods;  	if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  		prot_c_term_fixed_mods = new List<Modification> ();  		prot_c_term_fixed_mods.Add (fixed_modification);  		this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  	}  	else {  		prot_c_term_fixed_mods.Add (fixed_modification);  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  	prot_c_term_fixed_mods = new List<Modification> ();  	prot_c_term_fixed_mods.Add (fixed_modification);  	this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  }  else {  	prot_c_term_fixed_mods.Add (fixed_modification);  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: if (!this.fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  	prot_c_term_fixed_mods = new List<Modification> ();  	prot_c_term_fixed_mods.Add (fixed_modification);  	this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  }  else {  	prot_c_term_fixed_mods.Add (fixed_modification);  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,SetFixedModifications,The following statement contains a magic number: this.fixedModifications.Add (Length + 3' prot_c_term_fixed_mods);  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (fixedModifications != null) {  	List<Modification> prot_c_term_fixed_mods;  	if (fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  		foreach (Modification fixed_modification in prot_c_term_fixed_mods) {  			mass_shift += fixed_modification.MonoisotopicMassShift;  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (fixedModifications.TryGetValue (Length + 3' out prot_c_term_fixed_mods)) {  	foreach (Modification fixed_modification in prot_c_term_fixed_mods) {  		mass_shift += fixed_modification.MonoisotopicMassShift;  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (variableModifications != null) {  	Modification prot_c_term_variable_mod;  	if (variableModifications.TryGetValue (Length + 3' out prot_c_term_variable_mod)) {  		mass_shift += prot_c_term_variable_mod.MonoisotopicMassShift;  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (variableModifications.TryGetValue (Length + 3' out prot_c_term_variable_mod)) {  	mass_shift += prot_c_term_variable_mod.MonoisotopicMassShift;  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (fixedModifications != null) {  	List<Modification> pep_c_term_fixed_mods;  	if (fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  		foreach (Modification fixed_modification in pep_c_term_fixed_mods) {  			mass_shift += fixed_modification.MonoisotopicMassShift;  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (fixedModifications.TryGetValue (Length + 2' out pep_c_term_fixed_mods)) {  	foreach (Modification fixed_modification in pep_c_term_fixed_mods) {  		mass_shift += fixed_modification.MonoisotopicMassShift;  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (variableModifications != null) {  	Modification pep_c_term_variable_mod;  	if (variableModifications.TryGetValue (Length + 2' out pep_c_term_variable_mod)) {  		mass_shift += pep_c_term_variable_mod.MonoisotopicMassShift;  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (variableModifications.TryGetValue (Length + 2' out pep_c_term_variable_mod)) {  	mass_shift += pep_c_term_variable_mod.MonoisotopicMassShift;  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: for (int r = 1; r < Length; r++) {  	mass_shift = 0.0;  	// fixed modifications on this residue  	if (fixedModifications != null) {  		List<Modification> residue_fixed_mods;  		if (fixedModifications.TryGetValue (Length - r + 2' out residue_fixed_mods)) {  			foreach (Modification fixed_modification in residue_fixed_mods) {  				mass_shift += fixed_modification.MonoisotopicMassShift;  			}  		}  	}  	// variable modification on this residue  	if (variableModifications != null) {  		Modification residue_variable_mod;  		if (variableModifications.TryGetValue (Length - r + 2' out residue_variable_mod)) {  			mass_shift += residue_variable_mod.MonoisotopicMassShift;  		}  	}  	cumulativeCTerminalMass [r] = cumulativeCTerminalMass [r - 1] + (productMassType == MassType.Average ? AminoAcidMasses.GetAverageMass (this [Length - r]) : AminoAcidMasses.GetMonoisotopicMass (this [Length - r])) + mass_shift;  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: for (int r = 1; r < Length; r++) {  	mass_shift = 0.0;  	// fixed modifications on this residue  	if (fixedModifications != null) {  		List<Modification> residue_fixed_mods;  		if (fixedModifications.TryGetValue (Length - r + 2' out residue_fixed_mods)) {  			foreach (Modification fixed_modification in residue_fixed_mods) {  				mass_shift += fixed_modification.MonoisotopicMassShift;  			}  		}  	}  	// variable modification on this residue  	if (variableModifications != null) {  		Modification residue_variable_mod;  		if (variableModifications.TryGetValue (Length - r + 2' out residue_variable_mod)) {  			mass_shift += residue_variable_mod.MonoisotopicMassShift;  		}  	}  	cumulativeCTerminalMass [r] = cumulativeCTerminalMass [r - 1] + (productMassType == MassType.Average ? AminoAcidMasses.GetAverageMass (this [Length - r]) : AminoAcidMasses.GetMonoisotopicMass (this [Length - r])) + mass_shift;  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (fixedModifications != null) {  	List<Modification> residue_fixed_mods;  	if (fixedModifications.TryGetValue (Length - r + 2' out residue_fixed_mods)) {  		foreach (Modification fixed_modification in residue_fixed_mods) {  			mass_shift += fixed_modification.MonoisotopicMassShift;  		}  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (fixedModifications.TryGetValue (Length - r + 2' out residue_fixed_mods)) {  	foreach (Modification fixed_modification in residue_fixed_mods) {  		mass_shift += fixed_modification.MonoisotopicMassShift;  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (variableModifications != null) {  	Modification residue_variable_mod;  	if (variableModifications.TryGetValue (Length - r + 2' out residue_variable_mod)) {  		mass_shift += residue_variable_mod.MonoisotopicMassShift;  	}  }  
Magic Number,PeptidAce,AminoAcidPolymer,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\AminoAcidPolymer.cs,InitializeProductArrays,The following statement contains a magic number: if (variableModifications.TryGetValue (Length - r + 2' out residue_variable_mod)) {  	mass_shift += residue_variable_mod.MonoisotopicMassShift;  }  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,DBOptions,The following statement contains a magic number: this.MaximumPeptideMass = 10000;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,DBOptions,The following statement contains a magic number: this.ToleratedMissedCleavages = 100;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,DBOptions,The following statement contains a magic number: this.maximumVariableModificationIsoforms = 1024;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,DBOptions,The following statement contains a magic number: this.MaximumPrecursorChargeState = 4;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,DBOptions,The following statement contains a magic number: this.MaximumNumberOfFragmentsPerSpectrum = 400;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,DBOptions,The following statement contains a magic number: this.precursorMassTolerance = new MassTolerance (0.05' MassToleranceUnits.Da);  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,DBOptions,The following statement contains a magic number: this.productMassTolerance = new MassTolerance (0.05' MassToleranceUnits.Da);  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,DBOptions,The following statement contains a magic number: this.PSMFalseDiscoveryRate = 0.0504;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,DBOptions,The following statement contains a magic number: this.MinimumPSMScore = 0.0001;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dProduct = r.NextDouble () - 0.5;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dPrecursor = r.NextDouble () - 0.5;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dMatchingProductFraction = r.NextDouble () - 0.5;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dMatchingProduct = (r.NextDouble () - 0.5) * 0.01;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dMatchingProduct = (r.NextDouble () - 0.5) * 0.01;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dIntensityFraction = r.NextDouble () - 0.5;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dIntensity = (r.NextDouble () - 0.5) * 0.0001;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dIntensity = (r.NextDouble () - 0.5) * 0.0001;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dProtein = r.NextDouble () - 0.5;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dPeptideScore = r.NextDouble () - 0.5;  
Magic Number,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,RandomizeParams,The following statement contains a magic number: dFragmentScore = r.NextDouble () - 0.5;  
Magic Number,PeptidAce,FullFragments,C:\repos\olivierlizotte_PeptidAce.Library\Fragment.cs,InitFullFrags,The following statement contains a magic number: AllFragments.Add ("a"' new FragmentGen ("a"' false' -29.002741 + Constants.PROTON_MASS));  
Magic Number,PeptidAce,FullFragments,C:\repos\olivierlizotte_PeptidAce.Library\Fragment.cs,InitFullFrags,The following statement contains a magic number: AllFragments.Add ("c"' new FragmentGen ("c"' false' 17.02654915));  
Magic Number,PeptidAce,FullFragments,C:\repos\olivierlizotte_PeptidAce.Library\Fragment.cs,InitFullFrags,The following statement contains a magic number: AllFragments.Add ("x"' new FragmentGen ("x"' true' 43.9898346942));  
Magic Number,PeptidAce,FullFragments,C:\repos\olivierlizotte_PeptidAce.Library\Fragment.cs,InitFullFrags,The following statement contains a magic number: AllFragments.Add ("z"' new FragmentGen ("z"' true' 1.991840552567 - Constants.HYDROGEN_MASS));  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: using (StreamReader mods = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "fragments.tsv"))) {  	string header = mods.ReadLine ();  	while (mods.Peek () != -1) {  		string line = mods.ReadLine ();  		string[] fields = line.Split ('\t');  		string description = fields [0];  		ModificationType modification_type;  		switch (fields [1]) {  		case "fragment":  			modification_type = ModificationType.Fragment;  			break;  		case "amino acid residue":  			modification_type = ModificationType.AminoAcidResidue;  			break;  		case "peptide N-terminus":  			modification_type = ModificationType.PeptideNTerminus;  			break;  		case "peptide C-terminus":  			modification_type = ModificationType.PeptideCTerminus;  			break;  		default:  			modification_type = ModificationType.AminoAcidResidue;  			break;  		}  		char amino_acid = char.MinValue;  		if (fields [2].Length == 1)  			amino_acid = char.Parse (fields [2]);  		double monoisotopic_mass_shift = double.Parse (fields [3]);  		double probability = double.Parse (fields [4]);  		string default_mod = fields [5];  		bool default_fixed = default_mod.ToLower () == "fixed";  		bool default_variable = default_mod.ToLower () == "variable";  		bool automatic = default_mod.ToLower () == "auto";  		if (modification_type == ModificationType.Fragment) {  			Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  			monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  			Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		}  		else  			Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: using (StreamReader mods = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "fragments.tsv"))) {  	string header = mods.ReadLine ();  	while (mods.Peek () != -1) {  		string line = mods.ReadLine ();  		string[] fields = line.Split ('\t');  		string description = fields [0];  		ModificationType modification_type;  		switch (fields [1]) {  		case "fragment":  			modification_type = ModificationType.Fragment;  			break;  		case "amino acid residue":  			modification_type = ModificationType.AminoAcidResidue;  			break;  		case "peptide N-terminus":  			modification_type = ModificationType.PeptideNTerminus;  			break;  		case "peptide C-terminus":  			modification_type = ModificationType.PeptideCTerminus;  			break;  		default:  			modification_type = ModificationType.AminoAcidResidue;  			break;  		}  		char amino_acid = char.MinValue;  		if (fields [2].Length == 1)  			amino_acid = char.Parse (fields [2]);  		double monoisotopic_mass_shift = double.Parse (fields [3]);  		double probability = double.Parse (fields [4]);  		string default_mod = fields [5];  		bool default_fixed = default_mod.ToLower () == "fixed";  		bool default_variable = default_mod.ToLower () == "variable";  		bool automatic = default_mod.ToLower () == "auto";  		if (modification_type == ModificationType.Fragment) {  			Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  			monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  			Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		}  		else  			Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: using (StreamReader mods = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "fragments.tsv"))) {  	string header = mods.ReadLine ();  	while (mods.Peek () != -1) {  		string line = mods.ReadLine ();  		string[] fields = line.Split ('\t');  		string description = fields [0];  		ModificationType modification_type;  		switch (fields [1]) {  		case "fragment":  			modification_type = ModificationType.Fragment;  			break;  		case "amino acid residue":  			modification_type = ModificationType.AminoAcidResidue;  			break;  		case "peptide N-terminus":  			modification_type = ModificationType.PeptideNTerminus;  			break;  		case "peptide C-terminus":  			modification_type = ModificationType.PeptideCTerminus;  			break;  		default:  			modification_type = ModificationType.AminoAcidResidue;  			break;  		}  		char amino_acid = char.MinValue;  		if (fields [2].Length == 1)  			amino_acid = char.Parse (fields [2]);  		double monoisotopic_mass_shift = double.Parse (fields [3]);  		double probability = double.Parse (fields [4]);  		string default_mod = fields [5];  		bool default_fixed = default_mod.ToLower () == "fixed";  		bool default_variable = default_mod.ToLower () == "variable";  		bool automatic = default_mod.ToLower () == "auto";  		if (modification_type == ModificationType.Fragment) {  			Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  			monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  			Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		}  		else  			Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: using (StreamReader mods = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "fragments.tsv"))) {  	string header = mods.ReadLine ();  	while (mods.Peek () != -1) {  		string line = mods.ReadLine ();  		string[] fields = line.Split ('\t');  		string description = fields [0];  		ModificationType modification_type;  		switch (fields [1]) {  		case "fragment":  			modification_type = ModificationType.Fragment;  			break;  		case "amino acid residue":  			modification_type = ModificationType.AminoAcidResidue;  			break;  		case "peptide N-terminus":  			modification_type = ModificationType.PeptideNTerminus;  			break;  		case "peptide C-terminus":  			modification_type = ModificationType.PeptideCTerminus;  			break;  		default:  			modification_type = ModificationType.AminoAcidResidue;  			break;  		}  		char amino_acid = char.MinValue;  		if (fields [2].Length == 1)  			amino_acid = char.Parse (fields [2]);  		double monoisotopic_mass_shift = double.Parse (fields [3]);  		double probability = double.Parse (fields [4]);  		string default_mod = fields [5];  		bool default_fixed = default_mod.ToLower () == "fixed";  		bool default_variable = default_mod.ToLower () == "variable";  		bool automatic = default_mod.ToLower () == "auto";  		if (modification_type == ModificationType.Fragment) {  			Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  			monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  			Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		}  		else  			Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: using (StreamReader mods = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "fragments.tsv"))) {  	string header = mods.ReadLine ();  	while (mods.Peek () != -1) {  		string line = mods.ReadLine ();  		string[] fields = line.Split ('\t');  		string description = fields [0];  		ModificationType modification_type;  		switch (fields [1]) {  		case "fragment":  			modification_type = ModificationType.Fragment;  			break;  		case "amino acid residue":  			modification_type = ModificationType.AminoAcidResidue;  			break;  		case "peptide N-terminus":  			modification_type = ModificationType.PeptideNTerminus;  			break;  		case "peptide C-terminus":  			modification_type = ModificationType.PeptideCTerminus;  			break;  		default:  			modification_type = ModificationType.AminoAcidResidue;  			break;  		}  		char amino_acid = char.MinValue;  		if (fields [2].Length == 1)  			amino_acid = char.Parse (fields [2]);  		double monoisotopic_mass_shift = double.Parse (fields [3]);  		double probability = double.Parse (fields [4]);  		string default_mod = fields [5];  		bool default_fixed = default_mod.ToLower () == "fixed";  		bool default_variable = default_mod.ToLower () == "variable";  		bool automatic = default_mod.ToLower () == "auto";  		if (modification_type == ModificationType.Fragment) {  			Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  			monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  			Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		}  		else  			Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: while (mods.Peek () != -1) {  	string line = mods.ReadLine ();  	string[] fields = line.Split ('\t');  	string description = fields [0];  	ModificationType modification_type;  	switch (fields [1]) {  	case "fragment":  		modification_type = ModificationType.Fragment;  		break;  	case "amino acid residue":  		modification_type = ModificationType.AminoAcidResidue;  		break;  	case "peptide N-terminus":  		modification_type = ModificationType.PeptideNTerminus;  		break;  	case "peptide C-terminus":  		modification_type = ModificationType.PeptideCTerminus;  		break;  	default:  		modification_type = ModificationType.AminoAcidResidue;  		break;  	}  	char amino_acid = char.MinValue;  	if (fields [2].Length == 1)  		amino_acid = char.Parse (fields [2]);  	double monoisotopic_mass_shift = double.Parse (fields [3]);  	double probability = double.Parse (fields [4]);  	string default_mod = fields [5];  	bool default_fixed = default_mod.ToLower () == "fixed";  	bool default_variable = default_mod.ToLower () == "variable";  	bool automatic = default_mod.ToLower () == "auto";  	if (modification_type == ModificationType.Fragment) {  		Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  		Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  	else  		Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: while (mods.Peek () != -1) {  	string line = mods.ReadLine ();  	string[] fields = line.Split ('\t');  	string description = fields [0];  	ModificationType modification_type;  	switch (fields [1]) {  	case "fragment":  		modification_type = ModificationType.Fragment;  		break;  	case "amino acid residue":  		modification_type = ModificationType.AminoAcidResidue;  		break;  	case "peptide N-terminus":  		modification_type = ModificationType.PeptideNTerminus;  		break;  	case "peptide C-terminus":  		modification_type = ModificationType.PeptideCTerminus;  		break;  	default:  		modification_type = ModificationType.AminoAcidResidue;  		break;  	}  	char amino_acid = char.MinValue;  	if (fields [2].Length == 1)  		amino_acid = char.Parse (fields [2]);  	double monoisotopic_mass_shift = double.Parse (fields [3]);  	double probability = double.Parse (fields [4]);  	string default_mod = fields [5];  	bool default_fixed = default_mod.ToLower () == "fixed";  	bool default_variable = default_mod.ToLower () == "variable";  	bool automatic = default_mod.ToLower () == "auto";  	if (modification_type == ModificationType.Fragment) {  		Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  		Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  	else  		Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: while (mods.Peek () != -1) {  	string line = mods.ReadLine ();  	string[] fields = line.Split ('\t');  	string description = fields [0];  	ModificationType modification_type;  	switch (fields [1]) {  	case "fragment":  		modification_type = ModificationType.Fragment;  		break;  	case "amino acid residue":  		modification_type = ModificationType.AminoAcidResidue;  		break;  	case "peptide N-terminus":  		modification_type = ModificationType.PeptideNTerminus;  		break;  	case "peptide C-terminus":  		modification_type = ModificationType.PeptideCTerminus;  		break;  	default:  		modification_type = ModificationType.AminoAcidResidue;  		break;  	}  	char amino_acid = char.MinValue;  	if (fields [2].Length == 1)  		amino_acid = char.Parse (fields [2]);  	double monoisotopic_mass_shift = double.Parse (fields [3]);  	double probability = double.Parse (fields [4]);  	string default_mod = fields [5];  	bool default_fixed = default_mod.ToLower () == "fixed";  	bool default_variable = default_mod.ToLower () == "variable";  	bool automatic = default_mod.ToLower () == "auto";  	if (modification_type == ModificationType.Fragment) {  		Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  		Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  	else  		Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: while (mods.Peek () != -1) {  	string line = mods.ReadLine ();  	string[] fields = line.Split ('\t');  	string description = fields [0];  	ModificationType modification_type;  	switch (fields [1]) {  	case "fragment":  		modification_type = ModificationType.Fragment;  		break;  	case "amino acid residue":  		modification_type = ModificationType.AminoAcidResidue;  		break;  	case "peptide N-terminus":  		modification_type = ModificationType.PeptideNTerminus;  		break;  	case "peptide C-terminus":  		modification_type = ModificationType.PeptideCTerminus;  		break;  	default:  		modification_type = ModificationType.AminoAcidResidue;  		break;  	}  	char amino_acid = char.MinValue;  	if (fields [2].Length == 1)  		amino_acid = char.Parse (fields [2]);  	double monoisotopic_mass_shift = double.Parse (fields [3]);  	double probability = double.Parse (fields [4]);  	string default_mod = fields [5];  	bool default_fixed = default_mod.ToLower () == "fixed";  	bool default_variable = default_mod.ToLower () == "variable";  	bool automatic = default_mod.ToLower () == "auto";  	if (modification_type == ModificationType.Fragment) {  		Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  		Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  	else  		Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: while (mods.Peek () != -1) {  	string line = mods.ReadLine ();  	string[] fields = line.Split ('\t');  	string description = fields [0];  	ModificationType modification_type;  	switch (fields [1]) {  	case "fragment":  		modification_type = ModificationType.Fragment;  		break;  	case "amino acid residue":  		modification_type = ModificationType.AminoAcidResidue;  		break;  	case "peptide N-terminus":  		modification_type = ModificationType.PeptideNTerminus;  		break;  	case "peptide C-terminus":  		modification_type = ModificationType.PeptideCTerminus;  		break;  	default:  		modification_type = ModificationType.AminoAcidResidue;  		break;  	}  	char amino_acid = char.MinValue;  	if (fields [2].Length == 1)  		amino_acid = char.Parse (fields [2]);  	double monoisotopic_mass_shift = double.Parse (fields [3]);  	double probability = double.Parse (fields [4]);  	string default_mod = fields [5];  	bool default_fixed = default_mod.ToLower () == "fixed";  	bool default_variable = default_mod.ToLower () == "variable";  	bool automatic = default_mod.ToLower () == "auto";  	if (modification_type == ModificationType.Fragment) {  		Add (new Modification ("Loss : " + description' ModificationType.AminoAcidResidue' amino_acid' -monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  		monoisotopic_mass_shift = Numerics.MZFromMass (monoisotopic_mass_shift' 1);  		Add (new Modification ("Fragment : " + description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  	}  	else  		Add (new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' probability' default_fixed' default_variable' automatic));  }  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: if (fields [2].Length == 1)  	amino_acid = char.Parse (fields [2]);  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: if (fields [2].Length == 1)  	amino_acid = char.Parse (fields [2]);  
Magic Number,PeptidAce,FragmentDictionary,C:\repos\olivierlizotte_PeptidAce.Library\FragmentDictionary.cs,FragmentDictionary,The following statement contains a magic number: amino_acid = char.Parse (fields [2]);  
Magic Number,PeptidAce,MassTolerance,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\MassTolerance.cs,MzTop,The following statement contains a magic number: if (right.Units == MassToleranceUnits.Da)  	return left + right.Value;  else  	return left + left * right.Value / 1e6;  
Magic Number,PeptidAce,MassTolerance,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\MassTolerance.cs,MzTop,The following statement contains a magic number: return left + left * right.Value / 1e6;  
Magic Number,PeptidAce,MassTolerance,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\MassTolerance.cs,MzFloor,The following statement contains a magic number: if (right.Units == MassToleranceUnits.Da)  	return left - right.Value;  else  	return left - left * right.Value / 1e6;  
Magic Number,PeptidAce,MassTolerance,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\MassTolerance.cs,MzFloor,The following statement contains a magic number: return left - left * right.Value / 1e6;  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: using (StreamReader mods = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "modifications.tsv"))) {  	string header = mods.ReadLine ();  	while (mods.Peek () != -1) {  		string line = mods.ReadLine ();  		string[] fields = line.Split ('\t');  		string description = fields [0];  		ModificationType modification_type;  		switch (fields [1]) {  		case "amino acid residue":  			modification_type = ModificationType.AminoAcidResidue;  			break;  		case "protein N-terminus":  			modification_type = ModificationType.ProteinNTerminus;  			break;  		case "protein C-terminus":  			modification_type = ModificationType.ProteinCTerminus;  			break;  		case "peptide N-terminus":  			modification_type = ModificationType.PeptideNTerminus;  			break;  		case "peptide C-terminus":  			modification_type = ModificationType.PeptideCTerminus;  			break;  		default:  			modification_type = ModificationType.AminoAcidResidue;  			break;  		}  		char amino_acid = char.MinValue;  		if (modification_type == ModificationType.AminoAcidResidue) {  			amino_acid = char.Parse (fields [2]);  		}  		double monoisotopic_mass_shift = double.Parse (fields [3]);  		double average_mass_shift = double.Parse (fields [4]);  		string default_mod = fields [5];  		bool default_fixed = default_mod.ToLower () == "fixed";  		bool default_variable = default_mod.ToLower () == "variable";  		bool automatic = default_mod.ToLower () == "auto";  		Modification modification = new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' average_mass_shift' default_fixed' default_variable' automatic);  		Add (modification);  	}  }  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: using (StreamReader mods = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "modifications.tsv"))) {  	string header = mods.ReadLine ();  	while (mods.Peek () != -1) {  		string line = mods.ReadLine ();  		string[] fields = line.Split ('\t');  		string description = fields [0];  		ModificationType modification_type;  		switch (fields [1]) {  		case "amino acid residue":  			modification_type = ModificationType.AminoAcidResidue;  			break;  		case "protein N-terminus":  			modification_type = ModificationType.ProteinNTerminus;  			break;  		case "protein C-terminus":  			modification_type = ModificationType.ProteinCTerminus;  			break;  		case "peptide N-terminus":  			modification_type = ModificationType.PeptideNTerminus;  			break;  		case "peptide C-terminus":  			modification_type = ModificationType.PeptideCTerminus;  			break;  		default:  			modification_type = ModificationType.AminoAcidResidue;  			break;  		}  		char amino_acid = char.MinValue;  		if (modification_type == ModificationType.AminoAcidResidue) {  			amino_acid = char.Parse (fields [2]);  		}  		double monoisotopic_mass_shift = double.Parse (fields [3]);  		double average_mass_shift = double.Parse (fields [4]);  		string default_mod = fields [5];  		bool default_fixed = default_mod.ToLower () == "fixed";  		bool default_variable = default_mod.ToLower () == "variable";  		bool automatic = default_mod.ToLower () == "auto";  		Modification modification = new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' average_mass_shift' default_fixed' default_variable' automatic);  		Add (modification);  	}  }  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: using (StreamReader mods = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "modifications.tsv"))) {  	string header = mods.ReadLine ();  	while (mods.Peek () != -1) {  		string line = mods.ReadLine ();  		string[] fields = line.Split ('\t');  		string description = fields [0];  		ModificationType modification_type;  		switch (fields [1]) {  		case "amino acid residue":  			modification_type = ModificationType.AminoAcidResidue;  			break;  		case "protein N-terminus":  			modification_type = ModificationType.ProteinNTerminus;  			break;  		case "protein C-terminus":  			modification_type = ModificationType.ProteinCTerminus;  			break;  		case "peptide N-terminus":  			modification_type = ModificationType.PeptideNTerminus;  			break;  		case "peptide C-terminus":  			modification_type = ModificationType.PeptideCTerminus;  			break;  		default:  			modification_type = ModificationType.AminoAcidResidue;  			break;  		}  		char amino_acid = char.MinValue;  		if (modification_type == ModificationType.AminoAcidResidue) {  			amino_acid = char.Parse (fields [2]);  		}  		double monoisotopic_mass_shift = double.Parse (fields [3]);  		double average_mass_shift = double.Parse (fields [4]);  		string default_mod = fields [5];  		bool default_fixed = default_mod.ToLower () == "fixed";  		bool default_variable = default_mod.ToLower () == "variable";  		bool automatic = default_mod.ToLower () == "auto";  		Modification modification = new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' average_mass_shift' default_fixed' default_variable' automatic);  		Add (modification);  	}  }  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: using (StreamReader mods = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "modifications.tsv"))) {  	string header = mods.ReadLine ();  	while (mods.Peek () != -1) {  		string line = mods.ReadLine ();  		string[] fields = line.Split ('\t');  		string description = fields [0];  		ModificationType modification_type;  		switch (fields [1]) {  		case "amino acid residue":  			modification_type = ModificationType.AminoAcidResidue;  			break;  		case "protein N-terminus":  			modification_type = ModificationType.ProteinNTerminus;  			break;  		case "protein C-terminus":  			modification_type = ModificationType.ProteinCTerminus;  			break;  		case "peptide N-terminus":  			modification_type = ModificationType.PeptideNTerminus;  			break;  		case "peptide C-terminus":  			modification_type = ModificationType.PeptideCTerminus;  			break;  		default:  			modification_type = ModificationType.AminoAcidResidue;  			break;  		}  		char amino_acid = char.MinValue;  		if (modification_type == ModificationType.AminoAcidResidue) {  			amino_acid = char.Parse (fields [2]);  		}  		double monoisotopic_mass_shift = double.Parse (fields [3]);  		double average_mass_shift = double.Parse (fields [4]);  		string default_mod = fields [5];  		bool default_fixed = default_mod.ToLower () == "fixed";  		bool default_variable = default_mod.ToLower () == "variable";  		bool automatic = default_mod.ToLower () == "auto";  		Modification modification = new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' average_mass_shift' default_fixed' default_variable' automatic);  		Add (modification);  	}  }  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: while (mods.Peek () != -1) {  	string line = mods.ReadLine ();  	string[] fields = line.Split ('\t');  	string description = fields [0];  	ModificationType modification_type;  	switch (fields [1]) {  	case "amino acid residue":  		modification_type = ModificationType.AminoAcidResidue;  		break;  	case "protein N-terminus":  		modification_type = ModificationType.ProteinNTerminus;  		break;  	case "protein C-terminus":  		modification_type = ModificationType.ProteinCTerminus;  		break;  	case "peptide N-terminus":  		modification_type = ModificationType.PeptideNTerminus;  		break;  	case "peptide C-terminus":  		modification_type = ModificationType.PeptideCTerminus;  		break;  	default:  		modification_type = ModificationType.AminoAcidResidue;  		break;  	}  	char amino_acid = char.MinValue;  	if (modification_type == ModificationType.AminoAcidResidue) {  		amino_acid = char.Parse (fields [2]);  	}  	double monoisotopic_mass_shift = double.Parse (fields [3]);  	double average_mass_shift = double.Parse (fields [4]);  	string default_mod = fields [5];  	bool default_fixed = default_mod.ToLower () == "fixed";  	bool default_variable = default_mod.ToLower () == "variable";  	bool automatic = default_mod.ToLower () == "auto";  	Modification modification = new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' average_mass_shift' default_fixed' default_variable' automatic);  	Add (modification);  }  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: while (mods.Peek () != -1) {  	string line = mods.ReadLine ();  	string[] fields = line.Split ('\t');  	string description = fields [0];  	ModificationType modification_type;  	switch (fields [1]) {  	case "amino acid residue":  		modification_type = ModificationType.AminoAcidResidue;  		break;  	case "protein N-terminus":  		modification_type = ModificationType.ProteinNTerminus;  		break;  	case "protein C-terminus":  		modification_type = ModificationType.ProteinCTerminus;  		break;  	case "peptide N-terminus":  		modification_type = ModificationType.PeptideNTerminus;  		break;  	case "peptide C-terminus":  		modification_type = ModificationType.PeptideCTerminus;  		break;  	default:  		modification_type = ModificationType.AminoAcidResidue;  		break;  	}  	char amino_acid = char.MinValue;  	if (modification_type == ModificationType.AminoAcidResidue) {  		amino_acid = char.Parse (fields [2]);  	}  	double monoisotopic_mass_shift = double.Parse (fields [3]);  	double average_mass_shift = double.Parse (fields [4]);  	string default_mod = fields [5];  	bool default_fixed = default_mod.ToLower () == "fixed";  	bool default_variable = default_mod.ToLower () == "variable";  	bool automatic = default_mod.ToLower () == "auto";  	Modification modification = new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' average_mass_shift' default_fixed' default_variable' automatic);  	Add (modification);  }  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: while (mods.Peek () != -1) {  	string line = mods.ReadLine ();  	string[] fields = line.Split ('\t');  	string description = fields [0];  	ModificationType modification_type;  	switch (fields [1]) {  	case "amino acid residue":  		modification_type = ModificationType.AminoAcidResidue;  		break;  	case "protein N-terminus":  		modification_type = ModificationType.ProteinNTerminus;  		break;  	case "protein C-terminus":  		modification_type = ModificationType.ProteinCTerminus;  		break;  	case "peptide N-terminus":  		modification_type = ModificationType.PeptideNTerminus;  		break;  	case "peptide C-terminus":  		modification_type = ModificationType.PeptideCTerminus;  		break;  	default:  		modification_type = ModificationType.AminoAcidResidue;  		break;  	}  	char amino_acid = char.MinValue;  	if (modification_type == ModificationType.AminoAcidResidue) {  		amino_acid = char.Parse (fields [2]);  	}  	double monoisotopic_mass_shift = double.Parse (fields [3]);  	double average_mass_shift = double.Parse (fields [4]);  	string default_mod = fields [5];  	bool default_fixed = default_mod.ToLower () == "fixed";  	bool default_variable = default_mod.ToLower () == "variable";  	bool automatic = default_mod.ToLower () == "auto";  	Modification modification = new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' average_mass_shift' default_fixed' default_variable' automatic);  	Add (modification);  }  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: while (mods.Peek () != -1) {  	string line = mods.ReadLine ();  	string[] fields = line.Split ('\t');  	string description = fields [0];  	ModificationType modification_type;  	switch (fields [1]) {  	case "amino acid residue":  		modification_type = ModificationType.AminoAcidResidue;  		break;  	case "protein N-terminus":  		modification_type = ModificationType.ProteinNTerminus;  		break;  	case "protein C-terminus":  		modification_type = ModificationType.ProteinCTerminus;  		break;  	case "peptide N-terminus":  		modification_type = ModificationType.PeptideNTerminus;  		break;  	case "peptide C-terminus":  		modification_type = ModificationType.PeptideCTerminus;  		break;  	default:  		modification_type = ModificationType.AminoAcidResidue;  		break;  	}  	char amino_acid = char.MinValue;  	if (modification_type == ModificationType.AminoAcidResidue) {  		amino_acid = char.Parse (fields [2]);  	}  	double monoisotopic_mass_shift = double.Parse (fields [3]);  	double average_mass_shift = double.Parse (fields [4]);  	string default_mod = fields [5];  	bool default_fixed = default_mod.ToLower () == "fixed";  	bool default_variable = default_mod.ToLower () == "variable";  	bool automatic = default_mod.ToLower () == "auto";  	Modification modification = new Modification (description' modification_type' amino_acid' monoisotopic_mass_shift' average_mass_shift' default_fixed' default_variable' automatic);  	Add (modification);  }  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: if (modification_type == ModificationType.AminoAcidResidue) {  	amino_acid = char.Parse (fields [2]);  }  
Magic Number,PeptidAce,ModificationDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ModificationDictionary.cs,ModificationDictionary,The following statement contains a magic number: amino_acid = char.Parse (fields [2]);  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: for (int i = 0; i < peaks.Length; i++) {  	peaks [i] = new double[2];  	peaks [i] [0] = spectrum.Peaks [i].MZ;  	peaks [i] [1] = spectrum.Peaks [i].Intensity;  }  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: peaks [i] = new double[2];  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: if (peptide.FixedModifications != null)  	foreach (int position in peptide.FixedModifications.Keys) {  		if (position == 1)  			foreach (Modification mod in peptide.FixedModifications [position])  				ntermMod += mod.MonoisotopicMassShift;  		else if (position == sequence.Length + 2)  			foreach (Modification mod in peptide.FixedModifications [position])  				ctermMod += mod.MonoisotopicMassShift;  		else  			foreach (Modification mod in peptide.FixedModifications [position])  				fixedMods.Add (new AnnotatedSpectrumModification (mod.AminoAcid' mod.MonoisotopicMassShift' position - 1));  	}  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: foreach (int position in peptide.FixedModifications.Keys) {  	if (position == 1)  		foreach (Modification mod in peptide.FixedModifications [position])  			ntermMod += mod.MonoisotopicMassShift;  	else if (position == sequence.Length + 2)  		foreach (Modification mod in peptide.FixedModifications [position])  			ctermMod += mod.MonoisotopicMassShift;  	else  		foreach (Modification mod in peptide.FixedModifications [position])  			fixedMods.Add (new AnnotatedSpectrumModification (mod.AminoAcid' mod.MonoisotopicMassShift' position - 1));  }  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: if (position == 1)  	foreach (Modification mod in peptide.FixedModifications [position])  		ntermMod += mod.MonoisotopicMassShift;  else if (position == sequence.Length + 2)  	foreach (Modification mod in peptide.FixedModifications [position])  		ctermMod += mod.MonoisotopicMassShift;  else  	foreach (Modification mod in peptide.FixedModifications [position])  		fixedMods.Add (new AnnotatedSpectrumModification (mod.AminoAcid' mod.MonoisotopicMassShift' position - 1));  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: if (position == sequence.Length + 2)  	foreach (Modification mod in peptide.FixedModifications [position])  		ctermMod += mod.MonoisotopicMassShift;  else  	foreach (Modification mod in peptide.FixedModifications [position])  		fixedMods.Add (new AnnotatedSpectrumModification (mod.AminoAcid' mod.MonoisotopicMassShift' position - 1));  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: if (peptide.VariableModifications != null)  	foreach (int position in peptide.VariableModifications.Keys) {  		if (position == 1)  			ntermMod += peptide.VariableModifications [position].MonoisotopicMassShift;  		else if (position == sequence.Length + 2)  			ctermMod += peptide.VariableModifications [position].MonoisotopicMassShift;  		else  			varMods.Add (new AnnotatedSpectrumModification (peptide.VariableModifications [position].AminoAcid' peptide.VariableModifications [position].MonoisotopicMassShift' position - 1));  	}  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: foreach (int position in peptide.VariableModifications.Keys) {  	if (position == 1)  		ntermMod += peptide.VariableModifications [position].MonoisotopicMassShift;  	else if (position == sequence.Length + 2)  		ctermMod += peptide.VariableModifications [position].MonoisotopicMassShift;  	else  		varMods.Add (new AnnotatedSpectrumModification (peptide.VariableModifications [position].AminoAcid' peptide.VariableModifications [position].MonoisotopicMassShift' position - 1));  }  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: if (position == 1)  	ntermMod += peptide.VariableModifications [position].MonoisotopicMassShift;  else if (position == sequence.Length + 2)  	ctermMod += peptide.VariableModifications [position].MonoisotopicMassShift;  else  	varMods.Add (new AnnotatedSpectrumModification (peptide.VariableModifications [position].AminoAcid' peptide.VariableModifications [position].MonoisotopicMassShift' position - 1));  
Magic Number,PeptidAce,AnnotatedSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\AnnotatedSpectrum.cs,AnnotatedSpectrum,The following statement contains a magic number: if (position == sequence.Length + 2)  	ctermMod += peptide.VariableModifications [position].MonoisotopicMassShift;  else  	varMods.Add (new AnnotatedSpectrumModification (peptide.VariableModifications [position].AminoAcid' peptide.VariableModifications [position].MonoisotopicMassShift' position - 1));  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The following statement contains a magic number: if (a.sample != b.sample && NbCommonSequences (a' b) > 0) {  	//Zero based score  	//double tmp = Math.Abs(MassTolerance.CalculateMassError(a.Track.MZ' b.Track.MZ' MassToleranceUnits.ppm) / options.MzTol);  	double tmp = Math.Abs (Numerics.MzDifference (a.Track.MZ' b.Track.MZ' options.precursorMassTolerance.Units)) / options.precursorMassTolerance.Value;  	if (tmp < 1) {  		tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds?  		(a.Charge == b.Charge ? 0 : 1) + 0.1 * Math.Abs (Math.Log10 (a.Track.INTENSITY) - Math.Log10 (b.Track.INTENSITY)));  		if (tmp < 1)  			return 1 - tmp;  	}  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The following statement contains a magic number: if (a.sample != b.sample && NbCommonSequences (a' b) > 0) {  	//Zero based score  	//double tmp = Math.Abs(MassTolerance.CalculateMassError(a.Track.MZ' b.Track.MZ' MassToleranceUnits.ppm) / options.MzTol);  	double tmp = Math.Abs (Numerics.MzDifference (a.Track.MZ' b.Track.MZ' options.precursorMassTolerance.Units)) / options.precursorMassTolerance.Value;  	if (tmp < 1) {  		tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds?  		(a.Charge == b.Charge ? 0 : 1) + 0.1 * Math.Abs (Math.Log10 (a.Track.INTENSITY) - Math.Log10 (b.Track.INTENSITY)));  		if (tmp < 1)  			return 1 - tmp;  	}  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The following statement contains a magic number: if (a.sample != b.sample && NbCommonSequences (a' b) > 0) {  	//Zero based score  	//double tmp = Math.Abs(MassTolerance.CalculateMassError(a.Track.MZ' b.Track.MZ' MassToleranceUnits.ppm) / options.MzTol);  	double tmp = Math.Abs (Numerics.MzDifference (a.Track.MZ' b.Track.MZ' options.precursorMassTolerance.Units)) / options.precursorMassTolerance.Value;  	if (tmp < 1) {  		tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds?  		(a.Charge == b.Charge ? 0 : 1) + 0.1 * Math.Abs (Math.Log10 (a.Track.INTENSITY) - Math.Log10 (b.Track.INTENSITY)));  		if (tmp < 1)  			return 1 - tmp;  	}  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The following statement contains a magic number: if (tmp < 1) {  	tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds?  	(a.Charge == b.Charge ? 0 : 1) + 0.1 * Math.Abs (Math.Log10 (a.Track.INTENSITY) - Math.Log10 (b.Track.INTENSITY)));  	if (tmp < 1)  		return 1 - tmp;  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The following statement contains a magic number: if (tmp < 1) {  	tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds?  	(a.Charge == b.Charge ? 0 : 1) + 0.1 * Math.Abs (Math.Log10 (a.Track.INTENSITY) - Math.Log10 (b.Track.INTENSITY)));  	if (tmp < 1)  		return 1 - tmp;  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The following statement contains a magic number: if (tmp < 1) {  	tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds?  	(a.Charge == b.Charge ? 0 : 1) + 0.1 * Math.Abs (Math.Log10 (a.Track.INTENSITY) - Math.Log10 (b.Track.INTENSITY)));  	if (tmp < 1)  		return 1 - tmp;  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The following statement contains a magic number: tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds?  (a.Charge == b.Charge ? 0 : 1) + 0.1 * Math.Abs (Math.Log10 (a.Track.INTENSITY) - Math.Log10 (b.Track.INTENSITY)));  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The following statement contains a magic number: tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds?  (a.Charge == b.Charge ? 0 : 1) + 0.1 * Math.Abs (Math.Log10 (a.Track.INTENSITY) - Math.Log10 (b.Track.INTENSITY)));  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Score,The following statement contains a magic number: tmp = 0.2 * (2 * tmp + Math.Abs (a.Track.RT - b.Track.RT) / options.ComputedRetentionTimeDiff + //TODO check if it is in seconds?  (a.Charge == b.Charge ? 0 : 1) + 0.1 * Math.Abs (Math.Log10 (a.Track.INTENSITY) - Math.Log10 (b.Track.INTENSITY)));  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Search,The following statement contains a magic number: for (int i = 0; i < precursors.Count; i++) {  	if (!done [i]) {  		Cluster group = new Cluster (samples);  		group.Add (precursors [i]);  		if (runCluster) {  			for (int j = i + 1; j < precursors.Count; j++) {  				if (!done [j] && precursors [i].sample != precursors [j].sample) {  					double score = Score (precursors [i]' precursors [j]);  					//TODO Implement ProteoProfile Clustering algorithm' or anything on the litterature' as long as its backed by the scoring function  					if (score > 0.75)//TODO Should we put a threshold here? Can it be computed dynamically?  					 {  						group.Add (precursors [j]);  						done [j] = true;  					}  				}  			}  		}  		clusters.Add (group);  	}  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Search,The following statement contains a magic number: if (!done [i]) {  	Cluster group = new Cluster (samples);  	group.Add (precursors [i]);  	if (runCluster) {  		for (int j = i + 1; j < precursors.Count; j++) {  			if (!done [j] && precursors [i].sample != precursors [j].sample) {  				double score = Score (precursors [i]' precursors [j]);  				//TODO Implement ProteoProfile Clustering algorithm' or anything on the litterature' as long as its backed by the scoring function  				if (score > 0.75)//TODO Should we put a threshold here? Can it be computed dynamically?  				 {  					group.Add (precursors [j]);  					done [j] = true;  				}  			}  		}  	}  	clusters.Add (group);  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Search,The following statement contains a magic number: if (runCluster) {  	for (int j = i + 1; j < precursors.Count; j++) {  		if (!done [j] && precursors [i].sample != precursors [j].sample) {  			double score = Score (precursors [i]' precursors [j]);  			//TODO Implement ProteoProfile Clustering algorithm' or anything on the litterature' as long as its backed by the scoring function  			if (score > 0.75)//TODO Should we put a threshold here? Can it be computed dynamically?  			 {  				group.Add (precursors [j]);  				done [j] = true;  			}  		}  	}  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Search,The following statement contains a magic number: for (int j = i + 1; j < precursors.Count; j++) {  	if (!done [j] && precursors [i].sample != precursors [j].sample) {  		double score = Score (precursors [i]' precursors [j]);  		//TODO Implement ProteoProfile Clustering algorithm' or anything on the litterature' as long as its backed by the scoring function  		if (score > 0.75)//TODO Should we put a threshold here? Can it be computed dynamically?  		 {  			group.Add (precursors [j]);  			done [j] = true;  		}  	}  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Search,The following statement contains a magic number: if (!done [j] && precursors [i].sample != precursors [j].sample) {  	double score = Score (precursors [i]' precursors [j]);  	//TODO Implement ProteoProfile Clustering algorithm' or anything on the litterature' as long as its backed by the scoring function  	if (score > 0.75)//TODO Should we put a threshold here? Can it be computed dynamically?  	 {  		group.Add (precursors [j]);  		done [j] = true;  	}  }  
Magic Number,PeptidAce,MSSearcher,C:\repos\olivierlizotte_PeptidAce.Library\MSSearcher.cs,Search,The following statement contains a magic number: if (score > 0.75)//TODO Should we put a threshold here? Can it be computed dynamically?   {  	group.Add (precursors [j]);  	done [j] = true;  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (1' out pep_n_term_variable_mods)) {  			pep_n_term_variable_mods = new List<Modification> ();  			pep_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (1' pep_n_term_variable_mods);  		}  		else {  			pep_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  			pep_c_term_variable_mods = new List<Modification> ();  			pep_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  		}  		else {  			pep_c_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus && (EndResidueNumber == Parent.Length - 1)) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (1' out pep_n_term_variable_mods)) {  			pep_n_term_variable_mods = new List<Modification> ();  			pep_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (1' pep_n_term_variable_mods);  		}  		else {  			pep_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  			pep_c_term_variable_mods = new List<Modification> ();  			pep_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  		}  		else {  			pep_c_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus && (EndResidueNumber == Parent.Length - 1)) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (1' out pep_n_term_variable_mods)) {  			pep_n_term_variable_mods = new List<Modification> ();  			pep_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (1' pep_n_term_variable_mods);  		}  		else {  			pep_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  			pep_c_term_variable_mods = new List<Modification> ();  			pep_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  		}  		else {  			pep_c_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus && (EndResidueNumber == Parent.Length - 1)) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (1' out pep_n_term_variable_mods)) {  			pep_n_term_variable_mods = new List<Modification> ();  			pep_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (1' pep_n_term_variable_mods);  		}  		else {  			pep_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  			pep_c_term_variable_mods = new List<Modification> ();  			pep_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  		}  		else {  			pep_c_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus && (EndResidueNumber == Parent.Length - 1)) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (1' out pep_n_term_variable_mods)) {  			pep_n_term_variable_mods = new List<Modification> ();  			pep_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (1' pep_n_term_variable_mods);  		}  		else {  			pep_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  			pep_c_term_variable_mods = new List<Modification> ();  			pep_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  		}  		else {  			pep_c_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus && (EndResidueNumber == Parent.Length - 1)) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (1' out pep_n_term_variable_mods)) {  			pep_n_term_variable_mods = new List<Modification> ();  			pep_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (1' pep_n_term_variable_mods);  		}  		else {  			pep_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  			pep_c_term_variable_mods = new List<Modification> ();  			pep_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  		}  		else {  			pep_c_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus && (EndResidueNumber == Parent.Length - 1)) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.PeptideNTerminus) {  		List<Modification> pep_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (1' out pep_n_term_variable_mods)) {  			pep_n_term_variable_mods = new List<Modification> ();  			pep_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (1' pep_n_term_variable_mods);  		}  		else {  			pep_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.PeptideCTerminus) {  		List<Modification> pep_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  			pep_c_term_variable_mods = new List<Modification> ();  			pep_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  		}  		else {  			pep_c_term_variable_mods.Add (variable_modification);  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus && (EndResidueNumber == Parent.Length - 1)) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (variable_modification.Type == ModificationType.ProteinNTerminus && (StartResidueNumber == 1 || (StartResidueNumber == 2 && Parent [0] == 'M'))) {  	List<Modification> prot_n_term_variable_mods;  	if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  		prot_n_term_variable_mods = new List<Modification> ();  		prot_n_term_variable_mods.Add (variable_modification);  		possible_modifications.Add (0' prot_n_term_variable_mods);  	}  	else {  		prot_n_term_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: for (int r = 0; r < Length; r++) {  	if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  		List<Modification> residue_variable_mods;  		if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  			residue_variable_mods = new List<Modification> ();  			residue_variable_mods.Add (variable_modification);  			possible_modifications.Add (r + 2' residue_variable_mods);  		}  		else {  			residue_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: for (int r = 0; r < Length; r++) {  	if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  		List<Modification> residue_variable_mods;  		if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  			residue_variable_mods = new List<Modification> ();  			residue_variable_mods.Add (variable_modification);  			possible_modifications.Add (r + 2' residue_variable_mods);  		}  		else {  			residue_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  	List<Modification> residue_variable_mods;  	if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  		residue_variable_mods = new List<Modification> ();  		residue_variable_mods.Add (variable_modification);  		possible_modifications.Add (r + 2' residue_variable_mods);  	}  	else {  		residue_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  	List<Modification> residue_variable_mods;  	if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  		residue_variable_mods = new List<Modification> ();  		residue_variable_mods.Add (variable_modification);  		possible_modifications.Add (r + 2' residue_variable_mods);  	}  	else {  		residue_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  	residue_variable_mods = new List<Modification> ();  	residue_variable_mods.Add (variable_modification);  	possible_modifications.Add (r + 2' residue_variable_mods);  }  else {  	residue_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  	residue_variable_mods = new List<Modification> ();  	residue_variable_mods.Add (variable_modification);  	possible_modifications.Add (r + 2' residue_variable_mods);  }  else {  	residue_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: possible_modifications.Add (r + 2' residue_variable_mods);  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (variable_modification.Type == ModificationType.PeptideCTerminus) {  	List<Modification> pep_c_term_variable_mods;  	if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  		pep_c_term_variable_mods = new List<Modification> ();  		pep_c_term_variable_mods.Add (variable_modification);  		possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  	}  	else {  		pep_c_term_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (variable_modification.Type == ModificationType.PeptideCTerminus) {  	List<Modification> pep_c_term_variable_mods;  	if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  		pep_c_term_variable_mods = new List<Modification> ();  		pep_c_term_variable_mods.Add (variable_modification);  		possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  	}  	else {  		pep_c_term_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  	pep_c_term_variable_mods = new List<Modification> ();  	pep_c_term_variable_mods.Add (variable_modification);  	possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  }  else {  	pep_c_term_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (!possible_modifications.TryGetValue (Length + 2' out pep_c_term_variable_mods)) {  	pep_c_term_variable_mods = new List<Modification> ();  	pep_c_term_variable_mods.Add (variable_modification);  	possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  }  else {  	pep_c_term_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: possible_modifications.Add (Length + 2' pep_c_term_variable_mods);  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (variable_modification.Type == ModificationType.ProteinCTerminus && (EndResidueNumber == Parent.Length - 1)) {  	List<Modification> prot_c_term_variable_mods;  	if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  		prot_c_term_variable_mods = new List<Modification> ();  		prot_c_term_variable_mods.Add (variable_modification);  		possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  	}  	else {  		prot_c_term_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (variable_modification.Type == ModificationType.ProteinCTerminus && (EndResidueNumber == Parent.Length - 1)) {  	List<Modification> prot_c_term_variable_mods;  	if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  		prot_c_term_variable_mods = new List<Modification> ();  		prot_c_term_variable_mods.Add (variable_modification);  		possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  	}  	else {  		prot_c_term_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  	prot_c_term_variable_mods = new List<Modification> ();  	prot_c_term_variable_mods.Add (variable_modification);  	possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  }  else {  	prot_c_term_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  	prot_c_term_variable_mods = new List<Modification> ();  	prot_c_term_variable_mods.Add (variable_modification);  	possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  }  else {  	prot_c_term_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Peptide,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Peptide.cs,GetVariablyModifiedPeptides,The following statement contains a magic number: possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  
Magic Number,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,ComputeFragmentScore,The following statement contains a magic number: for (int i = 0; i < aaScoreArray.Length; i++)  	if (aaScoreArray [i] <= 1)  		score += aaScoreArray [i];  	else if (aaScoreArray [i] < 2)  		score += 2 - aaScoreArray [i];  
Magic Number,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,ComputeFragmentScore,The following statement contains a magic number: for (int i = 0; i < aaScoreArray.Length; i++)  	if (aaScoreArray [i] <= 1)  		score += aaScoreArray [i];  	else if (aaScoreArray [i] < 2)  		score += 2 - aaScoreArray [i];  
Magic Number,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,ComputeFragmentScore,The following statement contains a magic number: if (aaScoreArray [i] <= 1)  	score += aaScoreArray [i];  else if (aaScoreArray [i] < 2)  	score += 2 - aaScoreArray [i];  
Magic Number,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,ComputeFragmentScore,The following statement contains a magic number: if (aaScoreArray [i] <= 1)  	score += aaScoreArray [i];  else if (aaScoreArray [i] < 2)  	score += 2 - aaScoreArray [i];  
Magic Number,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,ComputeFragmentScore,The following statement contains a magic number: if (aaScoreArray [i] < 2)  	score += 2 - aaScoreArray [i];  
Magic Number,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,ComputeFragmentScore,The following statement contains a magic number: if (aaScoreArray [i] < 2)  	score += 2 - aaScoreArray [i];  
Magic Number,PeptidAce,PeptideSpectrumMatch,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatch.cs,ComputeFragmentScore,The following statement contains a magic number: score += 2 - aaScoreArray [i];  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: do {  	double previousVal = localMinimas.minMatchingProductScore;  	localMinimas.minMatchingProductScore *= iterSize;  	long nbTargetminMatchingProductScore = 0;  	double currentFDRminMatchingProductScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  		nbTargetminMatchingProductScore = 0;  	localMinimas.minMatchingProductScore = previousVal;  	previousVal = localMinimas.minMatchingProductFractionScore;  	localMinimas.minMatchingProductFractionScore *= iterSize;  	long nbTargetminMatchingProductFractionScore = 0;  	double currentFDRminMatchingProductFractionScore = localMinimas.ComputeFDR (this' out nbTargetminMatchingProductFractionScore' out nbCumulDecoy);  	if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  		nbTargetminMatchingProductFractionScore = 0;  	localMinimas.minMatchingProductFractionScore = previousVal;  	previousVal = localMinimas.minIntensityScore;  	localMinimas.minIntensityScore *= iterSize;  	long nbTargetminIntensityScore = 0;  	double currentFDRminIntensityScore = localMinimas.ComputeFDR (this' out nbTargetminIntensityScore' out nbCumulDecoy);  	if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  		nbTargetminIntensityScore = 0;  	localMinimas.minIntensityScore = previousVal;  	previousVal = localMinimas.minFragmentScore;  	localMinimas.minFragmentScore *= iterSize;  	long nbTargetminFragmentScore = 0;  	double currentFDRminFragmentScore = localMinimas.ComputeFDR (this' out nbTargetminFragmentScore' out nbCumulDecoy);  	if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  		nbTargetminFragmentScore = 0;  	localMinimas.minFragmentScore = previousVal;  	previousVal = localMinimas.minProbabilityScore;  	localMinimas.minProbabilityScore *= iterSize;  	long nbTargetminProbabilityScore = 0;  	double currentFDRminProbabilityScore = localMinimas.ComputeFDR (this' out nbTargetminProbabilityScore' out nbCumulDecoy);  	if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  		nbTargetminProbabilityScore = 0;  	localMinimas.minProbabilityScore = previousVal;  	if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductScore *= iterSize;  	}  	else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minMatchingProductFractionScore *= iterSize;  	}  	else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minIntensityScore *= iterSize;  	}  	else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  		iterSize = 0.95;  		localMinimas.minFragmentScore *= iterSize;  	}  	else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  		iterSize = 0.95;  		localMinimas.minProbabilityScore *= iterSize;  	}  	else  		iterSize -= 0.05;  	currentFDR = localMinimas.ComputeFDR (this' out nbCumulTarget' out nbCumulDecoy);  }  while (iterSize > 0.01);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (currentFDRminMatchingProductScore > fdr || localMinimas.minMatchingProductScore < 0.001)  	nbTargetminMatchingProductScore = 0;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (currentFDRminMatchingProductFractionScore > fdr || localMinimas.minMatchingProductFractionScore < 0.001)  	nbTargetminMatchingProductFractionScore = 0;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (currentFDRminIntensityScore > fdr || localMinimas.minIntensityScore < 0.001)  	nbTargetminIntensityScore = 0;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (currentFDRminFragmentScore > fdr || localMinimas.minFragmentScore < 0.001)  	nbTargetminFragmentScore = 0;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (currentFDRminProbabilityScore > fdr || localMinimas.minProbabilityScore < 0.001)  	nbTargetminProbabilityScore = 0;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductScore *= iterSize;  }  else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductScore *= iterSize;  }  else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductScore *= iterSize;  }  else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductScore *= iterSize;  }  else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductScore *= iterSize;  }  else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductScore > 0 && nbTargetminMatchingProductScore >= nbTargetminMatchingProductFractionScore && nbTargetminMatchingProductScore >= nbTargetminIntensityScore && nbTargetminMatchingProductScore >= nbTargetminFragmentScore && nbTargetminMatchingProductScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductScore *= iterSize;  }  else if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: iterSize = 0.95;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminMatchingProductFractionScore > 0 && nbTargetminMatchingProductFractionScore >= nbTargetminMatchingProductScore && nbTargetminMatchingProductFractionScore >= nbTargetminIntensityScore && nbTargetminMatchingProductFractionScore >= nbTargetminFragmentScore && nbTargetminMatchingProductFractionScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minMatchingProductFractionScore *= iterSize;  }  else if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: iterSize = 0.95;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminIntensityScore > 0 && nbTargetminIntensityScore >= nbTargetminMatchingProductFractionScore && nbTargetminIntensityScore >= nbTargetminMatchingProductScore && nbTargetminIntensityScore >= nbTargetminFragmentScore && nbTargetminIntensityScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minIntensityScore *= iterSize;  }  else if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: iterSize = 0.95;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminFragmentScore > 0 && nbTargetminFragmentScore >= nbTargetminMatchingProductFractionScore && nbTargetminFragmentScore >= nbTargetminIntensityScore && nbTargetminFragmentScore >= nbTargetminMatchingProductScore && nbTargetminFragmentScore >= nbTargetminProbabilityScore) {  	iterSize = 0.95;  	localMinimas.minFragmentScore *= iterSize;  }  else if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: iterSize = 0.95;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: if (nbTargetminProbabilityScore > 0 && nbTargetminProbabilityScore >= nbTargetminMatchingProductFractionScore && nbTargetminProbabilityScore >= nbTargetminIntensityScore && nbTargetminProbabilityScore >= nbTargetminMatchingProductScore && nbTargetminProbabilityScore >= nbTargetminFragmentScore) {  	iterSize = 0.95;  	localMinimas.minProbabilityScore *= iterSize;  }  else  	iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: iterSize = 0.95;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeScoreThreshold,The following statement contains a magic number: iterSize -= 0.05;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dProtein = 0.1; options.dProtein < 0.3; options.dProtein += incr)  	for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  		for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  			for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  				double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  				for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  					if (cumul + options.dIntensityFraction == 1) {  						long nbTargets = 0;  						foreach (Precursor precursor in results.matchedPrecursors)  							if (precursor.Target)  								nbTargets++;  						if (nbTargets > bestNbTargets) {  							bestNbTargets = nbTargets;  							bestProtein = options.dProtein;  							bestPeptide = options.dPeptideScore;  							bestPrecursor = options.dPrecursor;  							bestIntensities = options.dIntensityFraction;  							bestFragments = options.dMatchingProductFraction;  						}  					}  				}  			}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dProtein = 0.1; options.dProtein < 0.3; options.dProtein += incr)  	for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  		for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  			for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  				double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  				for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  					if (cumul + options.dIntensityFraction == 1) {  						long nbTargets = 0;  						foreach (Precursor precursor in results.matchedPrecursors)  							if (precursor.Target)  								nbTargets++;  						if (nbTargets > bestNbTargets) {  							bestNbTargets = nbTargets;  							bestProtein = options.dProtein;  							bestPeptide = options.dPeptideScore;  							bestPrecursor = options.dPrecursor;  							bestIntensities = options.dIntensityFraction;  							bestFragments = options.dMatchingProductFraction;  						}  					}  				}  			}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dProtein = 0.1; options.dProtein < 0.3; options.dProtein += incr)  	for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  		for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  			for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  				double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  				for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  					if (cumul + options.dIntensityFraction == 1) {  						long nbTargets = 0;  						foreach (Precursor precursor in results.matchedPrecursors)  							if (precursor.Target)  								nbTargets++;  						if (nbTargets > bestNbTargets) {  							bestNbTargets = nbTargets;  							bestProtein = options.dProtein;  							bestPeptide = options.dPeptideScore;  							bestPrecursor = options.dPrecursor;  							bestIntensities = options.dIntensityFraction;  							bestFragments = options.dMatchingProductFraction;  						}  					}  				}  			}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dProtein = 0.1; options.dProtein < 0.3; options.dProtein += incr)  	for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  		for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  			for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  				double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  				for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  					if (cumul + options.dIntensityFraction == 1) {  						long nbTargets = 0;  						foreach (Precursor precursor in results.matchedPrecursors)  							if (precursor.Target)  								nbTargets++;  						if (nbTargets > bestNbTargets) {  							bestNbTargets = nbTargets;  							bestProtein = options.dProtein;  							bestPeptide = options.dPeptideScore;  							bestPrecursor = options.dPrecursor;  							bestIntensities = options.dIntensityFraction;  							bestFragments = options.dMatchingProductFraction;  						}  					}  				}  			}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dProtein = 0.1; options.dProtein < 0.3; options.dProtein += incr)  	for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  		for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  			for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  				double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  				for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  					if (cumul + options.dIntensityFraction == 1) {  						long nbTargets = 0;  						foreach (Precursor precursor in results.matchedPrecursors)  							if (precursor.Target)  								nbTargets++;  						if (nbTargets > bestNbTargets) {  							bestNbTargets = nbTargets;  							bestProtein = options.dProtein;  							bestPeptide = options.dPeptideScore;  							bestPrecursor = options.dPrecursor;  							bestIntensities = options.dIntensityFraction;  							bestFragments = options.dMatchingProductFraction;  						}  					}  				}  			}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dProtein = 0.1; options.dProtein < 0.3; options.dProtein += incr)  	for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  		for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  			for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  				double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  				for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  					if (cumul + options.dIntensityFraction == 1) {  						long nbTargets = 0;  						foreach (Precursor precursor in results.matchedPrecursors)  							if (precursor.Target)  								nbTargets++;  						if (nbTargets > bestNbTargets) {  							bestNbTargets = nbTargets;  							bestProtein = options.dProtein;  							bestPeptide = options.dPeptideScore;  							bestPrecursor = options.dPrecursor;  							bestIntensities = options.dIntensityFraction;  							bestFragments = options.dMatchingProductFraction;  						}  					}  				}  			}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dProtein = 0.1; options.dProtein < 0.3; options.dProtein += incr)  	for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  		for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  			for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  				double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  				for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  					if (cumul + options.dIntensityFraction == 1) {  						long nbTargets = 0;  						foreach (Precursor precursor in results.matchedPrecursors)  							if (precursor.Target)  								nbTargets++;  						if (nbTargets > bestNbTargets) {  							bestNbTargets = nbTargets;  							bestProtein = options.dProtein;  							bestPeptide = options.dPeptideScore;  							bestPrecursor = options.dPrecursor;  							bestIntensities = options.dIntensityFraction;  							bestFragments = options.dMatchingProductFraction;  						}  					}  				}  			}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dProtein = 0.1; options.dProtein < 0.3; options.dProtein += incr)  	for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  		for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  			for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  				double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  				for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  					if (cumul + options.dIntensityFraction == 1) {  						long nbTargets = 0;  						foreach (Precursor precursor in results.matchedPrecursors)  							if (precursor.Target)  								nbTargets++;  						if (nbTargets > bestNbTargets) {  							bestNbTargets = nbTargets;  							bestProtein = options.dProtein;  							bestPeptide = options.dPeptideScore;  							bestPrecursor = options.dPrecursor;  							bestIntensities = options.dIntensityFraction;  							bestFragments = options.dMatchingProductFraction;  						}  					}  				}  			}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: options.dProtein = 0.1
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  	for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  		for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  			double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  			for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  				if (cumul + options.dIntensityFraction == 1) {  					long nbTargets = 0;  					foreach (Precursor precursor in results.matchedPrecursors)  						if (precursor.Target)  							nbTargets++;  					if (nbTargets > bestNbTargets) {  						bestNbTargets = nbTargets;  						bestProtein = options.dProtein;  						bestPeptide = options.dPeptideScore;  						bestPrecursor = options.dPrecursor;  						bestIntensities = options.dIntensityFraction;  						bestFragments = options.dMatchingProductFraction;  					}  				}  			}  		}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  	for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  		for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  			double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  			for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  				if (cumul + options.dIntensityFraction == 1) {  					long nbTargets = 0;  					foreach (Precursor precursor in results.matchedPrecursors)  						if (precursor.Target)  							nbTargets++;  					if (nbTargets > bestNbTargets) {  						bestNbTargets = nbTargets;  						bestProtein = options.dProtein;  						bestPeptide = options.dPeptideScore;  						bestPrecursor = options.dPrecursor;  						bestIntensities = options.dIntensityFraction;  						bestFragments = options.dMatchingProductFraction;  					}  				}  			}  		}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  	for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  		for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  			double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  			for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  				if (cumul + options.dIntensityFraction == 1) {  					long nbTargets = 0;  					foreach (Precursor precursor in results.matchedPrecursors)  						if (precursor.Target)  							nbTargets++;  					if (nbTargets > bestNbTargets) {  						bestNbTargets = nbTargets;  						bestProtein = options.dProtein;  						bestPeptide = options.dPeptideScore;  						bestPrecursor = options.dPrecursor;  						bestIntensities = options.dIntensityFraction;  						bestFragments = options.dMatchingProductFraction;  					}  				}  			}  		}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  	for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  		for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  			double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  			for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  				if (cumul + options.dIntensityFraction == 1) {  					long nbTargets = 0;  					foreach (Precursor precursor in results.matchedPrecursors)  						if (precursor.Target)  							nbTargets++;  					if (nbTargets > bestNbTargets) {  						bestNbTargets = nbTargets;  						bestProtein = options.dProtein;  						bestPeptide = options.dPeptideScore;  						bestPrecursor = options.dPrecursor;  						bestIntensities = options.dIntensityFraction;  						bestFragments = options.dMatchingProductFraction;  					}  				}  			}  		}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  	for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  		for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  			double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  			for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  				if (cumul + options.dIntensityFraction == 1) {  					long nbTargets = 0;  					foreach (Precursor precursor in results.matchedPrecursors)  						if (precursor.Target)  							nbTargets++;  					if (nbTargets > bestNbTargets) {  						bestNbTargets = nbTargets;  						bestProtein = options.dProtein;  						bestPeptide = options.dPeptideScore;  						bestPrecursor = options.dPrecursor;  						bestIntensities = options.dIntensityFraction;  						bestFragments = options.dMatchingProductFraction;  					}  				}  			}  		}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPeptideScore = 0.1; options.dPeptideScore < 0.4; options.dPeptideScore += incr)  	for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  		for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  			double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  			for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  				if (cumul + options.dIntensityFraction == 1) {  					long nbTargets = 0;  					foreach (Precursor precursor in results.matchedPrecursors)  						if (precursor.Target)  							nbTargets++;  					if (nbTargets > bestNbTargets) {  						bestNbTargets = nbTargets;  						bestProtein = options.dProtein;  						bestPeptide = options.dPeptideScore;  						bestPrecursor = options.dPrecursor;  						bestIntensities = options.dIntensityFraction;  						bestFragments = options.dMatchingProductFraction;  					}  				}  			}  		}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: options.dPeptideScore = 0.1
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  	for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  		double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  		for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  			if (cumul + options.dIntensityFraction == 1) {  				long nbTargets = 0;  				foreach (Precursor precursor in results.matchedPrecursors)  					if (precursor.Target)  						nbTargets++;  				if (nbTargets > bestNbTargets) {  					bestNbTargets = nbTargets;  					bestProtein = options.dProtein;  					bestPeptide = options.dPeptideScore;  					bestPrecursor = options.dPrecursor;  					bestIntensities = options.dIntensityFraction;  					bestFragments = options.dMatchingProductFraction;  				}  			}  		}  	}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  	for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  		double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  		for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  			if (cumul + options.dIntensityFraction == 1) {  				long nbTargets = 0;  				foreach (Precursor precursor in results.matchedPrecursors)  					if (precursor.Target)  						nbTargets++;  				if (nbTargets > bestNbTargets) {  					bestNbTargets = nbTargets;  					bestProtein = options.dProtein;  					bestPeptide = options.dPeptideScore;  					bestPrecursor = options.dPrecursor;  					bestIntensities = options.dIntensityFraction;  					bestFragments = options.dMatchingProductFraction;  				}  			}  		}  	}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  	for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  		double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  		for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  			if (cumul + options.dIntensityFraction == 1) {  				long nbTargets = 0;  				foreach (Precursor precursor in results.matchedPrecursors)  					if (precursor.Target)  						nbTargets++;  				if (nbTargets > bestNbTargets) {  					bestNbTargets = nbTargets;  					bestProtein = options.dProtein;  					bestPeptide = options.dPeptideScore;  					bestPrecursor = options.dPrecursor;  					bestIntensities = options.dIntensityFraction;  					bestFragments = options.dMatchingProductFraction;  				}  			}  		}  	}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dPrecursor = 0.1; options.dPrecursor < 0.5; options.dPrecursor += incr)  	for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  		double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  		for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  			if (cumul + options.dIntensityFraction == 1) {  				long nbTargets = 0;  				foreach (Precursor precursor in results.matchedPrecursors)  					if (precursor.Target)  						nbTargets++;  				if (nbTargets > bestNbTargets) {  					bestNbTargets = nbTargets;  					bestProtein = options.dProtein;  					bestPeptide = options.dPeptideScore;  					bestPrecursor = options.dPrecursor;  					bestIntensities = options.dIntensityFraction;  					bestFragments = options.dMatchingProductFraction;  				}  			}  		}  	}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: options.dPrecursor = 0.1
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  	double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  	for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  		if (cumul + options.dIntensityFraction == 1) {  			long nbTargets = 0;  			foreach (Precursor precursor in results.matchedPrecursors)  				if (precursor.Target)  					nbTargets++;  			if (nbTargets > bestNbTargets) {  				bestNbTargets = nbTargets;  				bestProtein = options.dProtein;  				bestPeptide = options.dPeptideScore;  				bestPrecursor = options.dPrecursor;  				bestIntensities = options.dIntensityFraction;  				bestFragments = options.dMatchingProductFraction;  			}  		}  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dMatchingProductFraction = 0.1; options.dMatchingProductFraction < 1 - options.dPrecursor - options.dPeptideScore - options.dProtein; options.dMatchingProductFraction += incr) {  	double cumul = options.dPrecursor + options.dPeptideScore + options.dProtein + options.dMatchingProductFraction;  	for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  		if (cumul + options.dIntensityFraction == 1) {  			long nbTargets = 0;  			foreach (Precursor precursor in results.matchedPrecursors)  				if (precursor.Target)  					nbTargets++;  			if (nbTargets > bestNbTargets) {  				bestNbTargets = nbTargets;  				bestProtein = options.dProtein;  				bestPeptide = options.dPeptideScore;  				bestPrecursor = options.dPrecursor;  				bestIntensities = options.dIntensityFraction;  				bestFragments = options.dMatchingProductFraction;  			}  		}  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: options.dMatchingProductFraction = 0.1
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: for (options.dIntensityFraction = 0.1; options.dIntensityFraction < 1 - cumul; options.dIntensityFraction += incr) {  	if (cumul + options.dIntensityFraction == 1) {  		long nbTargets = 0;  		foreach (Precursor precursor in results.matchedPrecursors)  			if (precursor.Target)  				nbTargets++;  		if (nbTargets > bestNbTargets) {  			bestNbTargets = nbTargets;  			bestProtein = options.dProtein;  			bestPeptide = options.dPeptideScore;  			bestPrecursor = options.dPrecursor;  			bestIntensities = options.dIntensityFraction;  			bestFragments = options.dMatchingProductFraction;  		}  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,OptimizePSMScoreRatios,The following statement contains a magic number: options.dIntensityFraction = 0.1
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in this) {  	if (psm.Query.spectrum.Ms1InjectionTime > 0) {  		if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  			timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  			precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensityPerMilliSecond);  		}  		lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensityPerMilliSecond;  		lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in this) {  	if (psm.Query.spectrum.Ms1InjectionTime > 0) {  		if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  			timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  			precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensityPerMilliSecond);  		}  		lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensityPerMilliSecond;  		lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: if (psm.Query.spectrum.Ms1InjectionTime > 0) {  	if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  		timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  		precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensityPerMilliSecond);  	}  	lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensityPerMilliSecond;  	lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: if (psm.Query.spectrum.Ms1InjectionTime > 0) {  	if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  		timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  		precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensityPerMilliSecond);  	}  	lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensityPerMilliSecond;  	lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  	timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  	precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensityPerMilliSecond);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  	timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  	precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensityPerMilliSecond);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: if (smooth) {  	List<double> timeGapSmooth = new List<double> ();  	List<double> precursorIntensitiesSmoothed = new List<double> ();  	for (int i = 0; i < timeGap.Count; i++) {  		double cumulIntensity = 0;  		int nbItems = 0;  		for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  			nbItems++;  			cumulIntensity += precursorIntensities [k];  		}  		if (nbItems > 0) {  			timeGapSmooth.Add (timeGap [0]);  			precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  		}  	}  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGapSmooth.Count; i++)  		fragSpectrumArea += timeGapSmooth [i] * precursorIntensitiesSmoothed [i];  	return fragSpectrumArea;  }  else {  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGap.Count; i++)  		fragSpectrumArea += timeGap [i] * precursorIntensities [i];  	return fragSpectrumArea;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: if (smooth) {  	List<double> timeGapSmooth = new List<double> ();  	List<double> precursorIntensitiesSmoothed = new List<double> ();  	for (int i = 0; i < timeGap.Count; i++) {  		double cumulIntensity = 0;  		int nbItems = 0;  		for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  			nbItems++;  			cumulIntensity += precursorIntensities [k];  		}  		if (nbItems > 0) {  			timeGapSmooth.Add (timeGap [0]);  			precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  		}  	}  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGapSmooth.Count; i++)  		fragSpectrumArea += timeGapSmooth [i] * precursorIntensitiesSmoothed [i];  	return fragSpectrumArea;  }  else {  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGap.Count; i++)  		fragSpectrumArea += timeGap [i] * precursorIntensities [i];  	return fragSpectrumArea;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: if (smooth) {  	List<double> timeGapSmooth = new List<double> ();  	List<double> precursorIntensitiesSmoothed = new List<double> ();  	for (int i = 0; i < timeGap.Count; i++) {  		double cumulIntensity = 0;  		int nbItems = 0;  		for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  			nbItems++;  			cumulIntensity += precursorIntensities [k];  		}  		if (nbItems > 0) {  			timeGapSmooth.Add (timeGap [0]);  			precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  		}  	}  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGapSmooth.Count; i++)  		fragSpectrumArea += timeGapSmooth [i] * precursorIntensitiesSmoothed [i];  	return fragSpectrumArea;  }  else {  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGap.Count; i++)  		fragSpectrumArea += timeGap [i] * precursorIntensities [i];  	return fragSpectrumArea;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: for (int i = 0; i < timeGap.Count; i++) {  	double cumulIntensity = 0;  	int nbItems = 0;  	for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  		nbItems++;  		cumulIntensity += precursorIntensities [k];  	}  	if (nbItems > 0) {  		timeGapSmooth.Add (timeGap [0]);  		precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: for (int i = 0; i < timeGap.Count; i++) {  	double cumulIntensity = 0;  	int nbItems = 0;  	for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  		nbItems++;  		cumulIntensity += precursorIntensities [k];  	}  	if (nbItems > 0) {  		timeGapSmooth.Add (timeGap [0]);  		precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: for (int i = 0; i < timeGap.Count; i++) {  	double cumulIntensity = 0;  	int nbItems = 0;  	for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  		nbItems++;  		cumulIntensity += precursorIntensities [k];  	}  	if (nbItems > 0) {  		timeGapSmooth.Add (timeGap [0]);  		precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  	nbItems++;  	cumulIntensity += precursorIntensities [k];  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  	nbItems++;  	cumulIntensity += precursorIntensities [k];  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorArea,The following statement contains a magic number: for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  	nbItems++;  	cumulIntensity += precursorIntensities [k];  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in this) {  	if (psm.Query.spectrum.Ms1InjectionTime > 0) {  		if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  			timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  			if (lastIntensityPerUnitOfTime > 0)  				precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  			else  				precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  		}  		lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime;  		lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in this) {  	if (psm.Query.spectrum.Ms1InjectionTime > 0) {  		if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  			timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  			if (lastIntensityPerUnitOfTime > 0)  				precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  			else  				precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  		}  		lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime;  		lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in this) {  	if (psm.Query.spectrum.Ms1InjectionTime > 0) {  		if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  			timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  			if (lastIntensityPerUnitOfTime > 0)  				precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  			else  				precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  		}  		lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime;  		lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (psm.Query.spectrum.Ms1InjectionTime > 0) {  	if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  		timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  		if (lastIntensityPerUnitOfTime > 0)  			precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  		else  			precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  	}  	lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime;  	lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (psm.Query.spectrum.Ms1InjectionTime > 0) {  	if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  		timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  		if (lastIntensityPerUnitOfTime > 0)  			precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  		else  			precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  	}  	lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime;  	lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (psm.Query.spectrum.Ms1InjectionTime > 0) {  	if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  		timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  		if (lastIntensityPerUnitOfTime > 0)  			precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  		else  			precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  	}  	lastIntensityPerUnitOfTime = psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime;  	lastTimeStamp = psm.Query.spectrum.RetentionTimeInMin;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  	timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  	if (lastIntensityPerUnitOfTime > 0)  		precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  	else  		precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  	timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  	if (lastIntensityPerUnitOfTime > 0)  		precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  	else  		precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (psm.Query.spectrum.PrecursorIntensity > 0 && lastTimeStamp > 0) {  	timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  	if (lastIntensityPerUnitOfTime > 0)  		precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  	else  		precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: timeGap.Add ((psm.Query.spectrum.RetentionTimeInMin - lastTimeStamp) * 60.0 * 1000.0);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (lastIntensityPerUnitOfTime > 0)  	precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  else  	precursorIntensities.Add (psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: precursorIntensities.Add ((psm.Query.spectrum.PrecursorIntensity / psm.Query.spectrum.Ms1InjectionTime + lastIntensityPerUnitOfTime) * 0.5);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (smooth) {  	List<double> timeGapSmooth = new List<double> ();  	List<double> precursorIntensitiesSmoothed = new List<double> ();  	for (int i = 0; i < timeGap.Count; i++) {  		double cumulIntensity = 0;  		int nbItems = 0;  		for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  			nbItems++;  			cumulIntensity += precursorIntensities [k];  		}  		if (nbItems > 0) {  			timeGapSmooth.Add (timeGap [0]);  			precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  		}  	}  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGapSmooth.Count; i++)  		fragSpectrumArea += timeGapSmooth [i] * precursorIntensitiesSmoothed [i];  	return fragSpectrumArea;  }  else {  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGap.Count; i++)  		fragSpectrumArea += timeGap [i] * precursorIntensities [i];  	return fragSpectrumArea;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (smooth) {  	List<double> timeGapSmooth = new List<double> ();  	List<double> precursorIntensitiesSmoothed = new List<double> ();  	for (int i = 0; i < timeGap.Count; i++) {  		double cumulIntensity = 0;  		int nbItems = 0;  		for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  			nbItems++;  			cumulIntensity += precursorIntensities [k];  		}  		if (nbItems > 0) {  			timeGapSmooth.Add (timeGap [0]);  			precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  		}  	}  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGapSmooth.Count; i++)  		fragSpectrumArea += timeGapSmooth [i] * precursorIntensitiesSmoothed [i];  	return fragSpectrumArea;  }  else {  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGap.Count; i++)  		fragSpectrumArea += timeGap [i] * precursorIntensities [i];  	return fragSpectrumArea;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: if (smooth) {  	List<double> timeGapSmooth = new List<double> ();  	List<double> precursorIntensitiesSmoothed = new List<double> ();  	for (int i = 0; i < timeGap.Count; i++) {  		double cumulIntensity = 0;  		int nbItems = 0;  		for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  			nbItems++;  			cumulIntensity += precursorIntensities [k];  		}  		if (nbItems > 0) {  			timeGapSmooth.Add (timeGap [0]);  			precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  		}  	}  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGapSmooth.Count; i++)  		fragSpectrumArea += timeGapSmooth [i] * precursorIntensitiesSmoothed [i];  	return fragSpectrumArea;  }  else {  	double fragSpectrumArea = 0;  	for (int i = 0; i < timeGap.Count; i++)  		fragSpectrumArea += timeGap [i] * precursorIntensities [i];  	return fragSpectrumArea;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: for (int i = 0; i < timeGap.Count; i++) {  	double cumulIntensity = 0;  	int nbItems = 0;  	for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  		nbItems++;  		cumulIntensity += precursorIntensities [k];  	}  	if (nbItems > 0) {  		timeGapSmooth.Add (timeGap [0]);  		precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: for (int i = 0; i < timeGap.Count; i++) {  	double cumulIntensity = 0;  	int nbItems = 0;  	for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  		nbItems++;  		cumulIntensity += precursorIntensities [k];  	}  	if (nbItems > 0) {  		timeGapSmooth.Add (timeGap [0]);  		precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: for (int i = 0; i < timeGap.Count; i++) {  	double cumulIntensity = 0;  	int nbItems = 0;  	for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  		nbItems++;  		cumulIntensity += precursorIntensities [k];  	}  	if (nbItems > 0) {  		timeGapSmooth.Add (timeGap [0]);  		precursorIntensitiesSmoothed.Add (cumulIntensity / (double)nbItems);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  	nbItems++;  	cumulIntensity += precursorIntensities [k];  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  	nbItems++;  	cumulIntensity += precursorIntensities [k];  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputePrecursorAreaBKP,The following statement contains a magic number: for (int k = (i - 2 < 0 ? 0 : i - 2); k < timeGap.Count - 2; k++) {  	nbItems++;  	cumulIntensity += precursorIntensities [k];  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeMsMsNormalizationFactors,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in this) {  	if (psm.Query.spectrum.PrecursorIntensity > 0) {  		double intensityFactor = 0;  		if (psm.Query.spectrum.InjectionTime >= 119.999997317791)  			//TODO Find instrument/method specific default or max injection time  			lastIntensity = psm.Query.spectrum.PrecursorIntensity;  		else {  			double predictedIntensity = (lastIntensity);  			// + psm.Query.spectrum.PrecursorIntensity) * 0.5;  			intensityFactor = (psm.Query.spectrum.PrecursorIntensity - predictedIntensity) / predictedIntensity;  			// psm.Query.spectrum.PrecursorIntensity;  		}  		fragRatio.Add (psm' intensityFactor);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeMsMsNormalizationFactors,The following statement contains a magic number: if (psm.Query.spectrum.PrecursorIntensity > 0) {  	double intensityFactor = 0;  	if (psm.Query.spectrum.InjectionTime >= 119.999997317791)  		//TODO Find instrument/method specific default or max injection time  		lastIntensity = psm.Query.spectrum.PrecursorIntensity;  	else {  		double predictedIntensity = (lastIntensity);  		// + psm.Query.spectrum.PrecursorIntensity) * 0.5;  		intensityFactor = (psm.Query.spectrum.PrecursorIntensity - predictedIntensity) / predictedIntensity;  		// psm.Query.spectrum.PrecursorIntensity;  	}  	fragRatio.Add (psm' intensityFactor);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,ComputeMsMsNormalizationFactors,The following statement contains a magic number: if (psm.Query.spectrum.InjectionTime >= 119.999997317791)  	//TODO Find instrument/method specific default or max injection time  	lastIntensity = psm.Query.spectrum.PrecursorIntensity;  else {  	double predictedIntensity = (lastIntensity);  	// + psm.Query.spectrum.PrecursorIntensity) * 0.5;  	intensityFactor = (psm.Query.spectrum.PrecursorIntensity - predictedIntensity) / predictedIntensity;  	// psm.Query.spectrum.PrecursorIntensity;  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: avgProbability -= avgProbability * 0.5;  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: foreach (Dictionary<PeptideSpectrumMatch' ProductMatch> matchList in DicOfProducts.Values) {  	List<ProductMatch> newPMList = new List<ProductMatch> ();  	if (matchList.Count > 0) {  		double sumPsmFactor = 0;  		foreach (PeptideSpectrumMatch psm in matchList.Keys) {  			if (psm.ProbabilityScore () > avgProbability)//Keep only above average spectrum  			 {  				ProductMatch pm = matchList [psm];  				//if (newPM == null)  				//{  				//    newPM = new ProductMatch(pm);  				//    newPM.obsIntensity = 0;  				//    newPM.normalizedIntensity = 0;  				//}  				ProductMatch newPM = new ProductMatch (pm);  				newPM.obsIntensity = pm.obsIntensity * DicOfPsmFactor [psm];  				// +pm.obsIntensity * DicOfProductMsMsFactor[pm];  				//newPM.obsIntensity += pm.obsIntensity + pm.obsIntensity * DicOfProductMsMsFactor[pm];  				newPM.normalizedIntensity = pm.normalizedIntensity * DicOfPsmFactor [psm];  				newPMList.Add (newPM);  				sumPsmFactor += DicOfPsmFactor [psm];  			}  		}  		if (sumPsmFactor > 0 && newPMList.Count > 4) {  			double[] nIArray = new double[newPMList.Count];  			for (int i = 0; i < nIArray.Length; i++)  				nIArray [i] = newPMList [i].normalizedIntensity;  			double variance = Numerics.Variance (nIArray);  			double stDev = MathNet.Numerics.Statistics.ArrayStatistics.StandardDeviation (nIArray);  			double mean = MathNet.Numerics.Statistics.ArrayStatistics.Mean (nIArray);  			if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  				ProductMatch newPM = new ProductMatch (newPMList [0]);  				newPM.weight = 0.0;  				newPM.obsIntensity = 0.0;  				newPM.normalizedIntensity = 0.0;  				for (int i = 0; i < newPMList.Count; i++) {  					newPM.obsIntensity += newPMList [i].obsIntensity;  					newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  					if (newPMList [i].normalizedIntensity > 0.0)  						newPM.weight++;  				}  				newPM.obsIntensity /= sumPsmFactor;  				newPM.normalizedIntensity /= sumPsmFactor;  				//newPM.weight = matchList.Count * newPM.normalizedIntensity;  				newPM.weight *= newPM.normalizedIntensity;  				avgNormedInt += newPM.normalizedIntensity;  				products.Add (newPM);  			}  			else  				unstableMasses.Add (newPMList [0].theoMz);  		}  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: foreach (Dictionary<PeptideSpectrumMatch' ProductMatch> matchList in DicOfProducts.Values) {  	List<ProductMatch> newPMList = new List<ProductMatch> ();  	if (matchList.Count > 0) {  		double sumPsmFactor = 0;  		foreach (PeptideSpectrumMatch psm in matchList.Keys) {  			if (psm.ProbabilityScore () > avgProbability)//Keep only above average spectrum  			 {  				ProductMatch pm = matchList [psm];  				//if (newPM == null)  				//{  				//    newPM = new ProductMatch(pm);  				//    newPM.obsIntensity = 0;  				//    newPM.normalizedIntensity = 0;  				//}  				ProductMatch newPM = new ProductMatch (pm);  				newPM.obsIntensity = pm.obsIntensity * DicOfPsmFactor [psm];  				// +pm.obsIntensity * DicOfProductMsMsFactor[pm];  				//newPM.obsIntensity += pm.obsIntensity + pm.obsIntensity * DicOfProductMsMsFactor[pm];  				newPM.normalizedIntensity = pm.normalizedIntensity * DicOfPsmFactor [psm];  				newPMList.Add (newPM);  				sumPsmFactor += DicOfPsmFactor [psm];  			}  		}  		if (sumPsmFactor > 0 && newPMList.Count > 4) {  			double[] nIArray = new double[newPMList.Count];  			for (int i = 0; i < nIArray.Length; i++)  				nIArray [i] = newPMList [i].normalizedIntensity;  			double variance = Numerics.Variance (nIArray);  			double stDev = MathNet.Numerics.Statistics.ArrayStatistics.StandardDeviation (nIArray);  			double mean = MathNet.Numerics.Statistics.ArrayStatistics.Mean (nIArray);  			if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  				ProductMatch newPM = new ProductMatch (newPMList [0]);  				newPM.weight = 0.0;  				newPM.obsIntensity = 0.0;  				newPM.normalizedIntensity = 0.0;  				for (int i = 0; i < newPMList.Count; i++) {  					newPM.obsIntensity += newPMList [i].obsIntensity;  					newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  					if (newPMList [i].normalizedIntensity > 0.0)  						newPM.weight++;  				}  				newPM.obsIntensity /= sumPsmFactor;  				newPM.normalizedIntensity /= sumPsmFactor;  				//newPM.weight = matchList.Count * newPM.normalizedIntensity;  				newPM.weight *= newPM.normalizedIntensity;  				avgNormedInt += newPM.normalizedIntensity;  				products.Add (newPM);  			}  			else  				unstableMasses.Add (newPMList [0].theoMz);  		}  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: foreach (Dictionary<PeptideSpectrumMatch' ProductMatch> matchList in DicOfProducts.Values) {  	List<ProductMatch> newPMList = new List<ProductMatch> ();  	if (matchList.Count > 0) {  		double sumPsmFactor = 0;  		foreach (PeptideSpectrumMatch psm in matchList.Keys) {  			if (psm.ProbabilityScore () > avgProbability)//Keep only above average spectrum  			 {  				ProductMatch pm = matchList [psm];  				//if (newPM == null)  				//{  				//    newPM = new ProductMatch(pm);  				//    newPM.obsIntensity = 0;  				//    newPM.normalizedIntensity = 0;  				//}  				ProductMatch newPM = new ProductMatch (pm);  				newPM.obsIntensity = pm.obsIntensity * DicOfPsmFactor [psm];  				// +pm.obsIntensity * DicOfProductMsMsFactor[pm];  				//newPM.obsIntensity += pm.obsIntensity + pm.obsIntensity * DicOfProductMsMsFactor[pm];  				newPM.normalizedIntensity = pm.normalizedIntensity * DicOfPsmFactor [psm];  				newPMList.Add (newPM);  				sumPsmFactor += DicOfPsmFactor [psm];  			}  		}  		if (sumPsmFactor > 0 && newPMList.Count > 4) {  			double[] nIArray = new double[newPMList.Count];  			for (int i = 0; i < nIArray.Length; i++)  				nIArray [i] = newPMList [i].normalizedIntensity;  			double variance = Numerics.Variance (nIArray);  			double stDev = MathNet.Numerics.Statistics.ArrayStatistics.StandardDeviation (nIArray);  			double mean = MathNet.Numerics.Statistics.ArrayStatistics.Mean (nIArray);  			if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  				ProductMatch newPM = new ProductMatch (newPMList [0]);  				newPM.weight = 0.0;  				newPM.obsIntensity = 0.0;  				newPM.normalizedIntensity = 0.0;  				for (int i = 0; i < newPMList.Count; i++) {  					newPM.obsIntensity += newPMList [i].obsIntensity;  					newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  					if (newPMList [i].normalizedIntensity > 0.0)  						newPM.weight++;  				}  				newPM.obsIntensity /= sumPsmFactor;  				newPM.normalizedIntensity /= sumPsmFactor;  				//newPM.weight = matchList.Count * newPM.normalizedIntensity;  				newPM.weight *= newPM.normalizedIntensity;  				avgNormedInt += newPM.normalizedIntensity;  				products.Add (newPM);  			}  			else  				unstableMasses.Add (newPMList [0].theoMz);  		}  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (matchList.Count > 0) {  	double sumPsmFactor = 0;  	foreach (PeptideSpectrumMatch psm in matchList.Keys) {  		if (psm.ProbabilityScore () > avgProbability)//Keep only above average spectrum  		 {  			ProductMatch pm = matchList [psm];  			//if (newPM == null)  			//{  			//    newPM = new ProductMatch(pm);  			//    newPM.obsIntensity = 0;  			//    newPM.normalizedIntensity = 0;  			//}  			ProductMatch newPM = new ProductMatch (pm);  			newPM.obsIntensity = pm.obsIntensity * DicOfPsmFactor [psm];  			// +pm.obsIntensity * DicOfProductMsMsFactor[pm];  			//newPM.obsIntensity += pm.obsIntensity + pm.obsIntensity * DicOfProductMsMsFactor[pm];  			newPM.normalizedIntensity = pm.normalizedIntensity * DicOfPsmFactor [psm];  			newPMList.Add (newPM);  			sumPsmFactor += DicOfPsmFactor [psm];  		}  	}  	if (sumPsmFactor > 0 && newPMList.Count > 4) {  		double[] nIArray = new double[newPMList.Count];  		for (int i = 0; i < nIArray.Length; i++)  			nIArray [i] = newPMList [i].normalizedIntensity;  		double variance = Numerics.Variance (nIArray);  		double stDev = MathNet.Numerics.Statistics.ArrayStatistics.StandardDeviation (nIArray);  		double mean = MathNet.Numerics.Statistics.ArrayStatistics.Mean (nIArray);  		if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  			ProductMatch newPM = new ProductMatch (newPMList [0]);  			newPM.weight = 0.0;  			newPM.obsIntensity = 0.0;  			newPM.normalizedIntensity = 0.0;  			for (int i = 0; i < newPMList.Count; i++) {  				newPM.obsIntensity += newPMList [i].obsIntensity;  				newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  				if (newPMList [i].normalizedIntensity > 0.0)  					newPM.weight++;  			}  			newPM.obsIntensity /= sumPsmFactor;  			newPM.normalizedIntensity /= sumPsmFactor;  			//newPM.weight = matchList.Count * newPM.normalizedIntensity;  			newPM.weight *= newPM.normalizedIntensity;  			avgNormedInt += newPM.normalizedIntensity;  			products.Add (newPM);  		}  		else  			unstableMasses.Add (newPMList [0].theoMz);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (matchList.Count > 0) {  	double sumPsmFactor = 0;  	foreach (PeptideSpectrumMatch psm in matchList.Keys) {  		if (psm.ProbabilityScore () > avgProbability)//Keep only above average spectrum  		 {  			ProductMatch pm = matchList [psm];  			//if (newPM == null)  			//{  			//    newPM = new ProductMatch(pm);  			//    newPM.obsIntensity = 0;  			//    newPM.normalizedIntensity = 0;  			//}  			ProductMatch newPM = new ProductMatch (pm);  			newPM.obsIntensity = pm.obsIntensity * DicOfPsmFactor [psm];  			// +pm.obsIntensity * DicOfProductMsMsFactor[pm];  			//newPM.obsIntensity += pm.obsIntensity + pm.obsIntensity * DicOfProductMsMsFactor[pm];  			newPM.normalizedIntensity = pm.normalizedIntensity * DicOfPsmFactor [psm];  			newPMList.Add (newPM);  			sumPsmFactor += DicOfPsmFactor [psm];  		}  	}  	if (sumPsmFactor > 0 && newPMList.Count > 4) {  		double[] nIArray = new double[newPMList.Count];  		for (int i = 0; i < nIArray.Length; i++)  			nIArray [i] = newPMList [i].normalizedIntensity;  		double variance = Numerics.Variance (nIArray);  		double stDev = MathNet.Numerics.Statistics.ArrayStatistics.StandardDeviation (nIArray);  		double mean = MathNet.Numerics.Statistics.ArrayStatistics.Mean (nIArray);  		if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  			ProductMatch newPM = new ProductMatch (newPMList [0]);  			newPM.weight = 0.0;  			newPM.obsIntensity = 0.0;  			newPM.normalizedIntensity = 0.0;  			for (int i = 0; i < newPMList.Count; i++) {  				newPM.obsIntensity += newPMList [i].obsIntensity;  				newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  				if (newPMList [i].normalizedIntensity > 0.0)  					newPM.weight++;  			}  			newPM.obsIntensity /= sumPsmFactor;  			newPM.normalizedIntensity /= sumPsmFactor;  			//newPM.weight = matchList.Count * newPM.normalizedIntensity;  			newPM.weight *= newPM.normalizedIntensity;  			avgNormedInt += newPM.normalizedIntensity;  			products.Add (newPM);  		}  		else  			unstableMasses.Add (newPMList [0].theoMz);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (matchList.Count > 0) {  	double sumPsmFactor = 0;  	foreach (PeptideSpectrumMatch psm in matchList.Keys) {  		if (psm.ProbabilityScore () > avgProbability)//Keep only above average spectrum  		 {  			ProductMatch pm = matchList [psm];  			//if (newPM == null)  			//{  			//    newPM = new ProductMatch(pm);  			//    newPM.obsIntensity = 0;  			//    newPM.normalizedIntensity = 0;  			//}  			ProductMatch newPM = new ProductMatch (pm);  			newPM.obsIntensity = pm.obsIntensity * DicOfPsmFactor [psm];  			// +pm.obsIntensity * DicOfProductMsMsFactor[pm];  			//newPM.obsIntensity += pm.obsIntensity + pm.obsIntensity * DicOfProductMsMsFactor[pm];  			newPM.normalizedIntensity = pm.normalizedIntensity * DicOfPsmFactor [psm];  			newPMList.Add (newPM);  			sumPsmFactor += DicOfPsmFactor [psm];  		}  	}  	if (sumPsmFactor > 0 && newPMList.Count > 4) {  		double[] nIArray = new double[newPMList.Count];  		for (int i = 0; i < nIArray.Length; i++)  			nIArray [i] = newPMList [i].normalizedIntensity;  		double variance = Numerics.Variance (nIArray);  		double stDev = MathNet.Numerics.Statistics.ArrayStatistics.StandardDeviation (nIArray);  		double mean = MathNet.Numerics.Statistics.ArrayStatistics.Mean (nIArray);  		if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  			ProductMatch newPM = new ProductMatch (newPMList [0]);  			newPM.weight = 0.0;  			newPM.obsIntensity = 0.0;  			newPM.normalizedIntensity = 0.0;  			for (int i = 0; i < newPMList.Count; i++) {  				newPM.obsIntensity += newPMList [i].obsIntensity;  				newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  				if (newPMList [i].normalizedIntensity > 0.0)  					newPM.weight++;  			}  			newPM.obsIntensity /= sumPsmFactor;  			newPM.normalizedIntensity /= sumPsmFactor;  			//newPM.weight = matchList.Count * newPM.normalizedIntensity;  			newPM.weight *= newPM.normalizedIntensity;  			avgNormedInt += newPM.normalizedIntensity;  			products.Add (newPM);  		}  		else  			unstableMasses.Add (newPMList [0].theoMz);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (sumPsmFactor > 0 && newPMList.Count > 4) {  	double[] nIArray = new double[newPMList.Count];  	for (int i = 0; i < nIArray.Length; i++)  		nIArray [i] = newPMList [i].normalizedIntensity;  	double variance = Numerics.Variance (nIArray);  	double stDev = MathNet.Numerics.Statistics.ArrayStatistics.StandardDeviation (nIArray);  	double mean = MathNet.Numerics.Statistics.ArrayStatistics.Mean (nIArray);  	if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  		ProductMatch newPM = new ProductMatch (newPMList [0]);  		newPM.weight = 0.0;  		newPM.obsIntensity = 0.0;  		newPM.normalizedIntensity = 0.0;  		for (int i = 0; i < newPMList.Count; i++) {  			newPM.obsIntensity += newPMList [i].obsIntensity;  			newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  			if (newPMList [i].normalizedIntensity > 0.0)  				newPM.weight++;  		}  		newPM.obsIntensity /= sumPsmFactor;  		newPM.normalizedIntensity /= sumPsmFactor;  		//newPM.weight = matchList.Count * newPM.normalizedIntensity;  		newPM.weight *= newPM.normalizedIntensity;  		avgNormedInt += newPM.normalizedIntensity;  		products.Add (newPM);  	}  	else  		unstableMasses.Add (newPMList [0].theoMz);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (sumPsmFactor > 0 && newPMList.Count > 4) {  	double[] nIArray = new double[newPMList.Count];  	for (int i = 0; i < nIArray.Length; i++)  		nIArray [i] = newPMList [i].normalizedIntensity;  	double variance = Numerics.Variance (nIArray);  	double stDev = MathNet.Numerics.Statistics.ArrayStatistics.StandardDeviation (nIArray);  	double mean = MathNet.Numerics.Statistics.ArrayStatistics.Mean (nIArray);  	if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  		ProductMatch newPM = new ProductMatch (newPMList [0]);  		newPM.weight = 0.0;  		newPM.obsIntensity = 0.0;  		newPM.normalizedIntensity = 0.0;  		for (int i = 0; i < newPMList.Count; i++) {  			newPM.obsIntensity += newPMList [i].obsIntensity;  			newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  			if (newPMList [i].normalizedIntensity > 0.0)  				newPM.weight++;  		}  		newPM.obsIntensity /= sumPsmFactor;  		newPM.normalizedIntensity /= sumPsmFactor;  		//newPM.weight = matchList.Count * newPM.normalizedIntensity;  		newPM.weight *= newPM.normalizedIntensity;  		avgNormedInt += newPM.normalizedIntensity;  		products.Add (newPM);  	}  	else  		unstableMasses.Add (newPMList [0].theoMz);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (sumPsmFactor > 0 && newPMList.Count > 4) {  	double[] nIArray = new double[newPMList.Count];  	for (int i = 0; i < nIArray.Length; i++)  		nIArray [i] = newPMList [i].normalizedIntensity;  	double variance = Numerics.Variance (nIArray);  	double stDev = MathNet.Numerics.Statistics.ArrayStatistics.StandardDeviation (nIArray);  	double mean = MathNet.Numerics.Statistics.ArrayStatistics.Mean (nIArray);  	if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  		ProductMatch newPM = new ProductMatch (newPMList [0]);  		newPM.weight = 0.0;  		newPM.obsIntensity = 0.0;  		newPM.normalizedIntensity = 0.0;  		for (int i = 0; i < newPMList.Count; i++) {  			newPM.obsIntensity += newPMList [i].obsIntensity;  			newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  			if (newPMList [i].normalizedIntensity > 0.0)  				newPM.weight++;  		}  		newPM.obsIntensity /= sumPsmFactor;  		newPM.normalizedIntensity /= sumPsmFactor;  		//newPM.weight = matchList.Count * newPM.normalizedIntensity;  		newPM.weight *= newPM.normalizedIntensity;  		avgNormedInt += newPM.normalizedIntensity;  		products.Add (newPM);  	}  	else  		unstableMasses.Add (newPMList [0].theoMz);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  	ProductMatch newPM = new ProductMatch (newPMList [0]);  	newPM.weight = 0.0;  	newPM.obsIntensity = 0.0;  	newPM.normalizedIntensity = 0.0;  	for (int i = 0; i < newPMList.Count; i++) {  		newPM.obsIntensity += newPMList [i].obsIntensity;  		newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  		if (newPMList [i].normalizedIntensity > 0.0)  			newPM.weight++;  	}  	newPM.obsIntensity /= sumPsmFactor;  	newPM.normalizedIntensity /= sumPsmFactor;  	//newPM.weight = matchList.Count * newPM.normalizedIntensity;  	newPM.weight *= newPM.normalizedIntensity;  	avgNormedInt += newPM.normalizedIntensity;  	products.Add (newPM);  }  else  	unstableMasses.Add (newPMList [0].theoMz);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (mean - stDev > mean * 0.5 || variance < mean * 0.5) {  	ProductMatch newPM = new ProductMatch (newPMList [0]);  	newPM.weight = 0.0;  	newPM.obsIntensity = 0.0;  	newPM.normalizedIntensity = 0.0;  	for (int i = 0; i < newPMList.Count; i++) {  		newPM.obsIntensity += newPMList [i].obsIntensity;  		newPM.normalizedIntensity += newPMList [i].normalizedIntensity;  		if (newPMList [i].normalizedIntensity > 0.0)  			newPM.weight++;  	}  	newPM.obsIntensity /= sumPsmFactor;  	newPM.normalizedIntensity /= sumPsmFactor;  	//newPM.weight = matchList.Count * newPM.normalizedIntensity;  	newPM.weight *= newPM.normalizedIntensity;  	avgNormedInt += newPM.normalizedIntensity;  	products.Add (newPM);  }  else  	unstableMasses.Add (newPMList [0].theoMz);  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (DicOfCommonPM != null) {  	foreach (double mz in DicOfCommonPM.Keys) {  		bool found = false;  		foreach (ProductMatch match in products)  			if (match.theoMz == mz)  				found = true;  		if (!found) {  			double sumPsmFactor = 0;  			ProductMatch newMatch = new ProductMatch ();  			newMatch.theoMz = mz;  			newMatch.weight = 0;  			newMatch.obsIntensity = 0;  			newMatch.normalizedIntensity = 0;  			foreach (PeptideSpectrumMatch psm in DicOfPsmFactor.Keys) {  				double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  				double intensityInCTrap = eCurvePerMs.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime);  				double peakIntensity = 0.0;  				foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  					if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  						peakIntensity += peak.Intensity;  				}  				if (peakIntensity > 0) {  					newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  					//MixedPrecursor.GetLocalArea  					newMatch.normalizedIntensity += (peakIntensity / intensityInCTrap) * DicOfPsmFactor [psm];  					sumPsmFactor += DicOfPsmFactor [psm];  					newMatch.weight++;  				}  			}  			if (newMatch.weight > 0) {  				newMatch.obsIntensity /= sumPsmFactor;  				newMatch.normalizedIntensity /= sumPsmFactor;  			}  			newMatch.weight *= newMatch.normalizedIntensity;  			products.Add (newMatch);  		}  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (DicOfCommonPM != null) {  	foreach (double mz in DicOfCommonPM.Keys) {  		bool found = false;  		foreach (ProductMatch match in products)  			if (match.theoMz == mz)  				found = true;  		if (!found) {  			double sumPsmFactor = 0;  			ProductMatch newMatch = new ProductMatch ();  			newMatch.theoMz = mz;  			newMatch.weight = 0;  			newMatch.obsIntensity = 0;  			newMatch.normalizedIntensity = 0;  			foreach (PeptideSpectrumMatch psm in DicOfPsmFactor.Keys) {  				double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  				double intensityInCTrap = eCurvePerMs.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime);  				double peakIntensity = 0.0;  				foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  					if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  						peakIntensity += peak.Intensity;  				}  				if (peakIntensity > 0) {  					newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  					//MixedPrecursor.GetLocalArea  					newMatch.normalizedIntensity += (peakIntensity / intensityInCTrap) * DicOfPsmFactor [psm];  					sumPsmFactor += DicOfPsmFactor [psm];  					newMatch.weight++;  				}  			}  			if (newMatch.weight > 0) {  				newMatch.obsIntensity /= sumPsmFactor;  				newMatch.normalizedIntensity /= sumPsmFactor;  			}  			newMatch.weight *= newMatch.normalizedIntensity;  			products.Add (newMatch);  		}  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: foreach (double mz in DicOfCommonPM.Keys) {  	bool found = false;  	foreach (ProductMatch match in products)  		if (match.theoMz == mz)  			found = true;  	if (!found) {  		double sumPsmFactor = 0;  		ProductMatch newMatch = new ProductMatch ();  		newMatch.theoMz = mz;  		newMatch.weight = 0;  		newMatch.obsIntensity = 0;  		newMatch.normalizedIntensity = 0;  		foreach (PeptideSpectrumMatch psm in DicOfPsmFactor.Keys) {  			double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  			double intensityInCTrap = eCurvePerMs.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime);  			double peakIntensity = 0.0;  			foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  				if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  					peakIntensity += peak.Intensity;  			}  			if (peakIntensity > 0) {  				newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  				//MixedPrecursor.GetLocalArea  				newMatch.normalizedIntensity += (peakIntensity / intensityInCTrap) * DicOfPsmFactor [psm];  				sumPsmFactor += DicOfPsmFactor [psm];  				newMatch.weight++;  			}  		}  		if (newMatch.weight > 0) {  			newMatch.obsIntensity /= sumPsmFactor;  			newMatch.normalizedIntensity /= sumPsmFactor;  		}  		newMatch.weight *= newMatch.normalizedIntensity;  		products.Add (newMatch);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: foreach (double mz in DicOfCommonPM.Keys) {  	bool found = false;  	foreach (ProductMatch match in products)  		if (match.theoMz == mz)  			found = true;  	if (!found) {  		double sumPsmFactor = 0;  		ProductMatch newMatch = new ProductMatch ();  		newMatch.theoMz = mz;  		newMatch.weight = 0;  		newMatch.obsIntensity = 0;  		newMatch.normalizedIntensity = 0;  		foreach (PeptideSpectrumMatch psm in DicOfPsmFactor.Keys) {  			double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  			double intensityInCTrap = eCurvePerMs.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime);  			double peakIntensity = 0.0;  			foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  				if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  					peakIntensity += peak.Intensity;  			}  			if (peakIntensity > 0) {  				newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  				//MixedPrecursor.GetLocalArea  				newMatch.normalizedIntensity += (peakIntensity / intensityInCTrap) * DicOfPsmFactor [psm];  				sumPsmFactor += DicOfPsmFactor [psm];  				newMatch.weight++;  			}  		}  		if (newMatch.weight > 0) {  			newMatch.obsIntensity /= sumPsmFactor;  			newMatch.normalizedIntensity /= sumPsmFactor;  		}  		newMatch.weight *= newMatch.normalizedIntensity;  		products.Add (newMatch);  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (!found) {  	double sumPsmFactor = 0;  	ProductMatch newMatch = new ProductMatch ();  	newMatch.theoMz = mz;  	newMatch.weight = 0;  	newMatch.obsIntensity = 0;  	newMatch.normalizedIntensity = 0;  	foreach (PeptideSpectrumMatch psm in DicOfPsmFactor.Keys) {  		double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  		double intensityInCTrap = eCurvePerMs.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime);  		double peakIntensity = 0.0;  		foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  			if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  				peakIntensity += peak.Intensity;  		}  		if (peakIntensity > 0) {  			newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  			//MixedPrecursor.GetLocalArea  			newMatch.normalizedIntensity += (peakIntensity / intensityInCTrap) * DicOfPsmFactor [psm];  			sumPsmFactor += DicOfPsmFactor [psm];  			newMatch.weight++;  		}  	}  	if (newMatch.weight > 0) {  		newMatch.obsIntensity /= sumPsmFactor;  		newMatch.normalizedIntensity /= sumPsmFactor;  	}  	newMatch.weight *= newMatch.normalizedIntensity;  	products.Add (newMatch);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (!found) {  	double sumPsmFactor = 0;  	ProductMatch newMatch = new ProductMatch ();  	newMatch.theoMz = mz;  	newMatch.weight = 0;  	newMatch.obsIntensity = 0;  	newMatch.normalizedIntensity = 0;  	foreach (PeptideSpectrumMatch psm in DicOfPsmFactor.Keys) {  		double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  		double intensityInCTrap = eCurvePerMs.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime);  		double peakIntensity = 0.0;  		foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  			if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  				peakIntensity += peak.Intensity;  		}  		if (peakIntensity > 0) {  			newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  			//MixedPrecursor.GetLocalArea  			newMatch.normalizedIntensity += (peakIntensity / intensityInCTrap) * DicOfPsmFactor [psm];  			sumPsmFactor += DicOfPsmFactor [psm];  			newMatch.weight++;  		}  	}  	if (newMatch.weight > 0) {  		newMatch.obsIntensity /= sumPsmFactor;  		newMatch.normalizedIntensity /= sumPsmFactor;  	}  	newMatch.weight *= newMatch.normalizedIntensity;  	products.Add (newMatch);  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in DicOfPsmFactor.Keys) {  	double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  	double intensityInCTrap = eCurvePerMs.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime);  	double peakIntensity = 0.0;  	foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  		if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  			peakIntensity += peak.Intensity;  	}  	if (peakIntensity > 0) {  		newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  		//MixedPrecursor.GetLocalArea  		newMatch.normalizedIntensity += (peakIntensity / intensityInCTrap) * DicOfPsmFactor [psm];  		sumPsmFactor += DicOfPsmFactor [psm];  		newMatch.weight++;  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: foreach (PeptideSpectrumMatch psm in DicOfPsmFactor.Keys) {  	double timePoint = psm.Query.spectrum.RetentionTimeInMin * 1000.0 * 60.0;  	double intensityInCTrap = eCurvePerMs.GetLocalArea (timePoint' timePoint + psm.Query.spectrum.InjectionTime);  	double peakIntensity = 0.0;  	foreach (MsMsPeak peak in psm.Query.spectrum.Peaks) {  		if (peak.Intensity > 0 && Math.Abs (Utilities.Numerics.CalculateMassError (peak.MZ' mz' dbOptions.productMassTolerance.Units)) <= dbOptions.productMassTolerance.Value)  			peakIntensity += peak.Intensity;  	}  	if (peakIntensity > 0) {  		newMatch.obsIntensity += peakIntensity * DicOfPsmFactor [psm];  		//MixedPrecursor.GetLocalArea  		newMatch.normalizedIntensity += (peakIntensity / intensityInCTrap) * DicOfPsmFactor [psm];  		sumPsmFactor += DicOfPsmFactor [psm];  		newMatch.weight++;  	}  }  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: foreach (ProductMatch pm in products)  	if (pm.normalizedIntensity < avgNormedInt * 0.1)//0.05  	 {  		pm.normalizedIntensity = 0;  		pm.obsIntensity = 0;  	}  
Magic Number,PeptidAce,PeptideSpectrumMatches,C:\repos\olivierlizotte_PeptidAce.Library\Structures\PeptideSpectrumMatches.cs,GetCombinedSpectrum,The following statement contains a magic number: if (pm.normalizedIntensity < avgNormedInt * 0.1)//0.05   {  	pm.normalizedIntensity = 0;  	pm.obsIntensity = 0;  }  
Magic Number,PeptidAce,ProductCaps,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ProductCaps.cs,ProductCaps,The following statement contains a magic number: using (StreamReader product_caps = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "product_caps.tsv"))) {  	string header = product_caps.ReadLine ();  	while (product_caps.Peek () != -1) {  		string line = product_caps.ReadLine ();  		string[] fields = line.Split ('\t');  		ProductType product_type = (ProductType)Enum.Parse (typeof(ProductType)' fields [0]' true);  		double cap_monoisotopic_mass = double.Parse (fields [1]);  		PRODUCT_CAP_MASSES [(int)product_type' (int)MassType.Monoisotopic] = cap_monoisotopic_mass;  		double cap_average_mass = double.Parse (fields [2]);  		PRODUCT_CAP_MASSES [(int)product_type' (int)MassType.Average] = cap_average_mass;  	}  }  
Magic Number,PeptidAce,ProductCaps,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ProductCaps.cs,ProductCaps,The following statement contains a magic number: while (product_caps.Peek () != -1) {  	string line = product_caps.ReadLine ();  	string[] fields = line.Split ('\t');  	ProductType product_type = (ProductType)Enum.Parse (typeof(ProductType)' fields [0]' true);  	double cap_monoisotopic_mass = double.Parse (fields [1]);  	PRODUCT_CAP_MASSES [(int)product_type' (int)MassType.Monoisotopic] = cap_monoisotopic_mass;  	double cap_average_mass = double.Parse (fields [2]);  	PRODUCT_CAP_MASSES [(int)product_type' (int)MassType.Average] = cap_average_mass;  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	double mz = double.Parse (splits [3]);  	int charge = int.Parse (splits [5]);  	int nbPeaks = int.Parse (splits [9]);  	List<MsMsPeak> peaks = new List<MsMsPeak> (nbPeaks);  	i++;  	for (int j = 0; j < nbPeaks; i++' j++) {  		try {  			string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  			if (splitPeaks.Length > 2)  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  			else  				peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  		}  		catch (Exception) {  			dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  		}  	}  	spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int j = 0; j < nbPeaks; i++' j++) {  	try {  		string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  		if (splitPeaks.Length > 2)  			peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  		else  			peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  	}  	catch (Exception) {  		dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: for (int j = 0; j < nbPeaks; i++' j++) {  	try {  		string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  		if (splitPeaks.Length > 2)  			peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  		else  			peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  	}  	catch (Exception) {  		dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: try {  	string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  	if (splitPeaks.Length > 2)  		peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  	else  		peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  }  catch (Exception) {  	dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: try {  	string[] splitPeaks = csv.LINES_LIST [i].Split ('\t');  	if (splitPeaks.Length > 2)  		peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  	else  		peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  }  catch (Exception) {  	dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: if (splitPeaks.Length > 2)  	peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  else  	peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: if (splitPeaks.Length > 2)  	peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  else  	peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' 0));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: peaks.Add (new MsMsPeak (double.Parse (splitPeaks [0])' double.Parse (splitPeaks [1])' int.Parse (splitPeaks [2])));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Import,The following statement contains a magic number: spectra.AddMSMS (new ProductSpectrum (int.Parse (splits [0])' double.Parse (splits [1])' splits [2]' mz' double.Parse (splits [4])' charge' Utilities.Numerics.MassFromMZ (mz' charge)' peaks' double.Parse (splits [8])' double.Parse (splits [10])' double.Parse (splits [11])));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: try {  	//TODO DONT forget to remove the limiter  	//int maxNbMSMS = 10;  	double LastMs1InjectionTime = 0;  	for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!  	 {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  		if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			//List precursors and their intensities  			double precursor_mz = 0;  			//Is there a value for the time a scan took to complete?  			int charge = 2;  			double precursor_intensity = 0;  			string fragmentation_method = "unknown";  			double isolationWindow = 1.0;  			double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (injectionTime <= 0.0)  				injectionTime = 120;  			foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  				fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  				if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  					if (precursor.activation.cvParams.Count > 0)  						fragmentation_method = precursor.activation.cvParams [0].name;  				isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  				//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  				//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  				//else if (precursor.isolationWindow.cvParams.Count > 2)  				//    options.ConSole.WriteLine("Weird Isolation Window");  				if (isolationWindow <= 0) {  					double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  					double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  					isolationWindow = lower + upper;  					//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  					if (isolationWindow <= 0)  						isolationWindow = 2;  				}  				foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  					//Cycle through MS to get real precursor intensities  					precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  					//.MS_isolation_width).value  					charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  					precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  					if (precursor_intensity <= 0) {  						precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  						//precursor_mz = ion.cvParams[0].value;  						//charge = (int)ion.cvParams[1].value;  						//precursor_intensity = ion.cvParams[2].value;  					}  				}  			}  			int scan_index = i;  			int scan_number = scan_index + 1;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			int num_peaks = mz.data.Count;  			if (num_peaks != intensity.data.Count) {  				options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  				if (intensity.data.Count < num_peaks)  					num_peaks = intensity.data.Count;  			}  			List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  			for (int k = 0; k < num_peaks; k++) {  				if (intensity.data [k] > 0) {  					MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  					peaks.Add (peak);  				}  			}  			mz.Dispose ();  			mz = null;  			intensity.Dispose ();  			intensity = null;  			peaks.Sort (MsMsPeak.AscendingMzComparison);  			if (filterMS2) {  				//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  				peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  				//TODO Add Contaminant removal   				//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  				//Can sometime be sorted by intensity after this call  				//peaks = FilterPeaksV2(peaks);  				peaks.Sort (MsMsPeak.AscendingMzComparison);  			}  			/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  				/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  				double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  				ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  				spectra.AddMSMS (spectrum);  				//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  			//if (spectra.Count >= maxNbMSMS)  			//    i = 10000000;  			}  		}  		else//Is an MS  		 {  			LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (loadMS) {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  				if (previousMS1 != null) {  					previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  					spectra.MS1s.Add (previousMS1);  				}  				previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  				//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  				//Trail.RemoveFinished(ref trails' spectra' 1);  			}  		}  		spec.Dispose ();  		spec = null;  		Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  	}  	if (previousMS1 != null)  		spectra.MS1s.Add (previousMS1);  	if (spectra.MS1s.Count > 0)  		spectra.tracks = new Tracks ();  	//TODO ReImplement Precursor finding routine (from MassSense?)  	else  		spectra.tracks = new Tracks ();  	spectra.tracks.Sort (Tracks.AscendingPrecursorMassComparison);  	Console.Write ("\r{0}%   "' 100);  	//ContaminantMasses.DisplayContaminants();  }  catch (Exception ex) {  	options.ConSole.WriteLine (ex.StackTrace);  	options.ConSole.WriteLine (ex.Message);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: try {  	//TODO DONT forget to remove the limiter  	//int maxNbMSMS = 10;  	double LastMs1InjectionTime = 0;  	for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!  	 {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  		if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			//List precursors and their intensities  			double precursor_mz = 0;  			//Is there a value for the time a scan took to complete?  			int charge = 2;  			double precursor_intensity = 0;  			string fragmentation_method = "unknown";  			double isolationWindow = 1.0;  			double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (injectionTime <= 0.0)  				injectionTime = 120;  			foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  				fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  				if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  					if (precursor.activation.cvParams.Count > 0)  						fragmentation_method = precursor.activation.cvParams [0].name;  				isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  				//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  				//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  				//else if (precursor.isolationWindow.cvParams.Count > 2)  				//    options.ConSole.WriteLine("Weird Isolation Window");  				if (isolationWindow <= 0) {  					double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  					double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  					isolationWindow = lower + upper;  					//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  					if (isolationWindow <= 0)  						isolationWindow = 2;  				}  				foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  					//Cycle through MS to get real precursor intensities  					precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  					//.MS_isolation_width).value  					charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  					precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  					if (precursor_intensity <= 0) {  						precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  						//precursor_mz = ion.cvParams[0].value;  						//charge = (int)ion.cvParams[1].value;  						//precursor_intensity = ion.cvParams[2].value;  					}  				}  			}  			int scan_index = i;  			int scan_number = scan_index + 1;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			int num_peaks = mz.data.Count;  			if (num_peaks != intensity.data.Count) {  				options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  				if (intensity.data.Count < num_peaks)  					num_peaks = intensity.data.Count;  			}  			List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  			for (int k = 0; k < num_peaks; k++) {  				if (intensity.data [k] > 0) {  					MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  					peaks.Add (peak);  				}  			}  			mz.Dispose ();  			mz = null;  			intensity.Dispose ();  			intensity = null;  			peaks.Sort (MsMsPeak.AscendingMzComparison);  			if (filterMS2) {  				//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  				peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  				//TODO Add Contaminant removal   				//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  				//Can sometime be sorted by intensity after this call  				//peaks = FilterPeaksV2(peaks);  				peaks.Sort (MsMsPeak.AscendingMzComparison);  			}  			/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  				/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  				double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  				ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  				spectra.AddMSMS (spectrum);  				//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  			//if (spectra.Count >= maxNbMSMS)  			//    i = 10000000;  			}  		}  		else//Is an MS  		 {  			LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (loadMS) {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  				if (previousMS1 != null) {  					previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  					spectra.MS1s.Add (previousMS1);  				}  				previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  				//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  				//Trail.RemoveFinished(ref trails' spectra' 1);  			}  		}  		spec.Dispose ();  		spec = null;  		Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  	}  	if (previousMS1 != null)  		spectra.MS1s.Add (previousMS1);  	if (spectra.MS1s.Count > 0)  		spectra.tracks = new Tracks ();  	//TODO ReImplement Precursor finding routine (from MassSense?)  	else  		spectra.tracks = new Tracks ();  	spectra.tracks.Sort (Tracks.AscendingPrecursorMassComparison);  	Console.Write ("\r{0}%   "' 100);  	//ContaminantMasses.DisplayContaminants();  }  catch (Exception ex) {  	options.ConSole.WriteLine (ex.StackTrace);  	options.ConSole.WriteLine (ex.Message);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: try {  	//TODO DONT forget to remove the limiter  	//int maxNbMSMS = 10;  	double LastMs1InjectionTime = 0;  	for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!  	 {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  		if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			//List precursors and their intensities  			double precursor_mz = 0;  			//Is there a value for the time a scan took to complete?  			int charge = 2;  			double precursor_intensity = 0;  			string fragmentation_method = "unknown";  			double isolationWindow = 1.0;  			double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (injectionTime <= 0.0)  				injectionTime = 120;  			foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  				fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  				if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  					if (precursor.activation.cvParams.Count > 0)  						fragmentation_method = precursor.activation.cvParams [0].name;  				isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  				//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  				//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  				//else if (precursor.isolationWindow.cvParams.Count > 2)  				//    options.ConSole.WriteLine("Weird Isolation Window");  				if (isolationWindow <= 0) {  					double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  					double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  					isolationWindow = lower + upper;  					//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  					if (isolationWindow <= 0)  						isolationWindow = 2;  				}  				foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  					//Cycle through MS to get real precursor intensities  					precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  					//.MS_isolation_width).value  					charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  					precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  					if (precursor_intensity <= 0) {  						precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  						//precursor_mz = ion.cvParams[0].value;  						//charge = (int)ion.cvParams[1].value;  						//precursor_intensity = ion.cvParams[2].value;  					}  				}  			}  			int scan_index = i;  			int scan_number = scan_index + 1;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			int num_peaks = mz.data.Count;  			if (num_peaks != intensity.data.Count) {  				options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  				if (intensity.data.Count < num_peaks)  					num_peaks = intensity.data.Count;  			}  			List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  			for (int k = 0; k < num_peaks; k++) {  				if (intensity.data [k] > 0) {  					MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  					peaks.Add (peak);  				}  			}  			mz.Dispose ();  			mz = null;  			intensity.Dispose ();  			intensity = null;  			peaks.Sort (MsMsPeak.AscendingMzComparison);  			if (filterMS2) {  				//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  				peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  				//TODO Add Contaminant removal   				//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  				//Can sometime be sorted by intensity after this call  				//peaks = FilterPeaksV2(peaks);  				peaks.Sort (MsMsPeak.AscendingMzComparison);  			}  			/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  				/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  				double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  				ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  				spectra.AddMSMS (spectrum);  				//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  			//if (spectra.Count >= maxNbMSMS)  			//    i = 10000000;  			}  		}  		else//Is an MS  		 {  			LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (loadMS) {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  				if (previousMS1 != null) {  					previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  					spectra.MS1s.Add (previousMS1);  				}  				previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  				//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  				//Trail.RemoveFinished(ref trails' spectra' 1);  			}  		}  		spec.Dispose ();  		spec = null;  		Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  	}  	if (previousMS1 != null)  		spectra.MS1s.Add (previousMS1);  	if (spectra.MS1s.Count > 0)  		spectra.tracks = new Tracks ();  	//TODO ReImplement Precursor finding routine (from MassSense?)  	else  		spectra.tracks = new Tracks ();  	spectra.tracks.Sort (Tracks.AscendingPrecursorMassComparison);  	Console.Write ("\r{0}%   "' 100);  	//ContaminantMasses.DisplayContaminants();  }  catch (Exception ex) {  	options.ConSole.WriteLine (ex.StackTrace);  	options.ConSole.WriteLine (ex.Message);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: try {  	//TODO DONT forget to remove the limiter  	//int maxNbMSMS = 10;  	double LastMs1InjectionTime = 0;  	for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!  	 {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  		if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			//List precursors and their intensities  			double precursor_mz = 0;  			//Is there a value for the time a scan took to complete?  			int charge = 2;  			double precursor_intensity = 0;  			string fragmentation_method = "unknown";  			double isolationWindow = 1.0;  			double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (injectionTime <= 0.0)  				injectionTime = 120;  			foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  				fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  				if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  					if (precursor.activation.cvParams.Count > 0)  						fragmentation_method = precursor.activation.cvParams [0].name;  				isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  				//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  				//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  				//else if (precursor.isolationWindow.cvParams.Count > 2)  				//    options.ConSole.WriteLine("Weird Isolation Window");  				if (isolationWindow <= 0) {  					double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  					double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  					isolationWindow = lower + upper;  					//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  					if (isolationWindow <= 0)  						isolationWindow = 2;  				}  				foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  					//Cycle through MS to get real precursor intensities  					precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  					//.MS_isolation_width).value  					charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  					precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  					if (precursor_intensity <= 0) {  						precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  						//precursor_mz = ion.cvParams[0].value;  						//charge = (int)ion.cvParams[1].value;  						//precursor_intensity = ion.cvParams[2].value;  					}  				}  			}  			int scan_index = i;  			int scan_number = scan_index + 1;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			int num_peaks = mz.data.Count;  			if (num_peaks != intensity.data.Count) {  				options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  				if (intensity.data.Count < num_peaks)  					num_peaks = intensity.data.Count;  			}  			List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  			for (int k = 0; k < num_peaks; k++) {  				if (intensity.data [k] > 0) {  					MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  					peaks.Add (peak);  				}  			}  			mz.Dispose ();  			mz = null;  			intensity.Dispose ();  			intensity = null;  			peaks.Sort (MsMsPeak.AscendingMzComparison);  			if (filterMS2) {  				//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  				peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  				//TODO Add Contaminant removal   				//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  				//Can sometime be sorted by intensity after this call  				//peaks = FilterPeaksV2(peaks);  				peaks.Sort (MsMsPeak.AscendingMzComparison);  			}  			/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  				/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  				double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  				ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  				spectra.AddMSMS (spectrum);  				//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  			//if (spectra.Count >= maxNbMSMS)  			//    i = 10000000;  			}  		}  		else//Is an MS  		 {  			LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (loadMS) {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  				if (previousMS1 != null) {  					previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  					spectra.MS1s.Add (previousMS1);  				}  				previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  				//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  				//Trail.RemoveFinished(ref trails' spectra' 1);  			}  		}  		spec.Dispose ();  		spec = null;  		Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  	}  	if (previousMS1 != null)  		spectra.MS1s.Add (previousMS1);  	if (spectra.MS1s.Count > 0)  		spectra.tracks = new Tracks ();  	//TODO ReImplement Precursor finding routine (from MassSense?)  	else  		spectra.tracks = new Tracks ();  	spectra.tracks.Sort (Tracks.AscendingPrecursorMassComparison);  	Console.Write ("\r{0}%   "' 100);  	//ContaminantMasses.DisplayContaminants();  }  catch (Exception ex) {  	options.ConSole.WriteLine (ex.StackTrace);  	options.ConSole.WriteLine (ex.Message);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: try {  	//TODO DONT forget to remove the limiter  	//int maxNbMSMS = 10;  	double LastMs1InjectionTime = 0;  	for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!  	 {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  		if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			//List precursors and their intensities  			double precursor_mz = 0;  			//Is there a value for the time a scan took to complete?  			int charge = 2;  			double precursor_intensity = 0;  			string fragmentation_method = "unknown";  			double isolationWindow = 1.0;  			double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (injectionTime <= 0.0)  				injectionTime = 120;  			foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  				fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  				if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  					if (precursor.activation.cvParams.Count > 0)  						fragmentation_method = precursor.activation.cvParams [0].name;  				isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  				//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  				//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  				//else if (precursor.isolationWindow.cvParams.Count > 2)  				//    options.ConSole.WriteLine("Weird Isolation Window");  				if (isolationWindow <= 0) {  					double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  					double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  					isolationWindow = lower + upper;  					//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  					if (isolationWindow <= 0)  						isolationWindow = 2;  				}  				foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  					//Cycle through MS to get real precursor intensities  					precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  					//.MS_isolation_width).value  					charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  					precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  					if (precursor_intensity <= 0) {  						precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  						//precursor_mz = ion.cvParams[0].value;  						//charge = (int)ion.cvParams[1].value;  						//precursor_intensity = ion.cvParams[2].value;  					}  				}  			}  			int scan_index = i;  			int scan_number = scan_index + 1;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			int num_peaks = mz.data.Count;  			if (num_peaks != intensity.data.Count) {  				options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  				if (intensity.data.Count < num_peaks)  					num_peaks = intensity.data.Count;  			}  			List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  			for (int k = 0; k < num_peaks; k++) {  				if (intensity.data [k] > 0) {  					MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  					peaks.Add (peak);  				}  			}  			mz.Dispose ();  			mz = null;  			intensity.Dispose ();  			intensity = null;  			peaks.Sort (MsMsPeak.AscendingMzComparison);  			if (filterMS2) {  				//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  				peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  				//TODO Add Contaminant removal   				//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  				//Can sometime be sorted by intensity after this call  				//peaks = FilterPeaksV2(peaks);  				peaks.Sort (MsMsPeak.AscendingMzComparison);  			}  			/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  				/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  				double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  				ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  				spectra.AddMSMS (spectrum);  				//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  			//if (spectra.Count >= maxNbMSMS)  			//    i = 10000000;  			}  		}  		else//Is an MS  		 {  			LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (loadMS) {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  				if (previousMS1 != null) {  					previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  					spectra.MS1s.Add (previousMS1);  				}  				previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  				//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  				//Trail.RemoveFinished(ref trails' spectra' 1);  			}  		}  		spec.Dispose ();  		spec = null;  		Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  	}  	if (previousMS1 != null)  		spectra.MS1s.Add (previousMS1);  	if (spectra.MS1s.Count > 0)  		spectra.tracks = new Tracks ();  	//TODO ReImplement Precursor finding routine (from MassSense?)  	else  		spectra.tracks = new Tracks ();  	spectra.tracks.Sort (Tracks.AscendingPrecursorMassComparison);  	Console.Write ("\r{0}%   "' 100);  	//ContaminantMasses.DisplayContaminants();  }  catch (Exception ex) {  	options.ConSole.WriteLine (ex.StackTrace);  	options.ConSole.WriteLine (ex.Message);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: try {  	//TODO DONT forget to remove the limiter  	//int maxNbMSMS = 10;  	double LastMs1InjectionTime = 0;  	for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!  	 {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  		if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			//List precursors and their intensities  			double precursor_mz = 0;  			//Is there a value for the time a scan took to complete?  			int charge = 2;  			double precursor_intensity = 0;  			string fragmentation_method = "unknown";  			double isolationWindow = 1.0;  			double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (injectionTime <= 0.0)  				injectionTime = 120;  			foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  				fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  				if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  					if (precursor.activation.cvParams.Count > 0)  						fragmentation_method = precursor.activation.cvParams [0].name;  				isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  				//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  				//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  				//else if (precursor.isolationWindow.cvParams.Count > 2)  				//    options.ConSole.WriteLine("Weird Isolation Window");  				if (isolationWindow <= 0) {  					double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  					double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  					isolationWindow = lower + upper;  					//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  					if (isolationWindow <= 0)  						isolationWindow = 2;  				}  				foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  					//Cycle through MS to get real precursor intensities  					precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  					//.MS_isolation_width).value  					charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  					precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  					if (precursor_intensity <= 0) {  						precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  						//precursor_mz = ion.cvParams[0].value;  						//charge = (int)ion.cvParams[1].value;  						//precursor_intensity = ion.cvParams[2].value;  					}  				}  			}  			int scan_index = i;  			int scan_number = scan_index + 1;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			int num_peaks = mz.data.Count;  			if (num_peaks != intensity.data.Count) {  				options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  				if (intensity.data.Count < num_peaks)  					num_peaks = intensity.data.Count;  			}  			List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  			for (int k = 0; k < num_peaks; k++) {  				if (intensity.data [k] > 0) {  					MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  					peaks.Add (peak);  				}  			}  			mz.Dispose ();  			mz = null;  			intensity.Dispose ();  			intensity = null;  			peaks.Sort (MsMsPeak.AscendingMzComparison);  			if (filterMS2) {  				//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  				peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  				//TODO Add Contaminant removal   				//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  				//Can sometime be sorted by intensity after this call  				//peaks = FilterPeaksV2(peaks);  				peaks.Sort (MsMsPeak.AscendingMzComparison);  			}  			/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  				/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  				double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  				ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  				spectra.AddMSMS (spectrum);  				//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  			//if (spectra.Count >= maxNbMSMS)  			//    i = 10000000;  			}  		}  		else//Is an MS  		 {  			LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (loadMS) {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  				if (previousMS1 != null) {  					previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  					spectra.MS1s.Add (previousMS1);  				}  				previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  				//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  				//Trail.RemoveFinished(ref trails' spectra' 1);  			}  		}  		spec.Dispose ();  		spec = null;  		Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  	}  	if (previousMS1 != null)  		spectra.MS1s.Add (previousMS1);  	if (spectra.MS1s.Count > 0)  		spectra.tracks = new Tracks ();  	//TODO ReImplement Precursor finding routine (from MassSense?)  	else  		spectra.tracks = new Tracks ();  	spectra.tracks.Sort (Tracks.AscendingPrecursorMassComparison);  	Console.Write ("\r{0}%   "' 100);  	//ContaminantMasses.DisplayContaminants();  }  catch (Exception ex) {  	options.ConSole.WriteLine (ex.StackTrace);  	options.ConSole.WriteLine (ex.Message);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: try {  	//TODO DONT forget to remove the limiter  	//int maxNbMSMS = 10;  	double LastMs1InjectionTime = 0;  	for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!  	 {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  		if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			//List precursors and their intensities  			double precursor_mz = 0;  			//Is there a value for the time a scan took to complete?  			int charge = 2;  			double precursor_intensity = 0;  			string fragmentation_method = "unknown";  			double isolationWindow = 1.0;  			double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (injectionTime <= 0.0)  				injectionTime = 120;  			foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  				fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  				if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  					if (precursor.activation.cvParams.Count > 0)  						fragmentation_method = precursor.activation.cvParams [0].name;  				isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  				//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  				//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  				//else if (precursor.isolationWindow.cvParams.Count > 2)  				//    options.ConSole.WriteLine("Weird Isolation Window");  				if (isolationWindow <= 0) {  					double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  					double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  					isolationWindow = lower + upper;  					//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  					if (isolationWindow <= 0)  						isolationWindow = 2;  				}  				foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  					//Cycle through MS to get real precursor intensities  					precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  					//.MS_isolation_width).value  					charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  					precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  					if (precursor_intensity <= 0) {  						precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  						//precursor_mz = ion.cvParams[0].value;  						//charge = (int)ion.cvParams[1].value;  						//precursor_intensity = ion.cvParams[2].value;  					}  				}  			}  			int scan_index = i;  			int scan_number = scan_index + 1;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			int num_peaks = mz.data.Count;  			if (num_peaks != intensity.data.Count) {  				options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  				if (intensity.data.Count < num_peaks)  					num_peaks = intensity.data.Count;  			}  			List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  			for (int k = 0; k < num_peaks; k++) {  				if (intensity.data [k] > 0) {  					MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  					peaks.Add (peak);  				}  			}  			mz.Dispose ();  			mz = null;  			intensity.Dispose ();  			intensity = null;  			peaks.Sort (MsMsPeak.AscendingMzComparison);  			if (filterMS2) {  				//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  				peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  				//TODO Add Contaminant removal   				//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  				//Can sometime be sorted by intensity after this call  				//peaks = FilterPeaksV2(peaks);  				peaks.Sort (MsMsPeak.AscendingMzComparison);  			}  			/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  				/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  				double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  				ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  				spectra.AddMSMS (spectrum);  				//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  			//if (spectra.Count >= maxNbMSMS)  			//    i = 10000000;  			}  		}  		else//Is an MS  		 {  			LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (loadMS) {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  				if (previousMS1 != null) {  					previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  					spectra.MS1s.Add (previousMS1);  				}  				previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  				//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  				//Trail.RemoveFinished(ref trails' spectra' 1);  			}  		}  		spec.Dispose ();  		spec = null;  		Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  	}  	if (previousMS1 != null)  		spectra.MS1s.Add (previousMS1);  	if (spectra.MS1s.Count > 0)  		spectra.tracks = new Tracks ();  	//TODO ReImplement Precursor finding routine (from MassSense?)  	else  		spectra.tracks = new Tracks ();  	spectra.tracks.Sort (Tracks.AscendingPrecursorMassComparison);  	Console.Write ("\r{0}%   "' 100);  	//ContaminantMasses.DisplayContaminants();  }  catch (Exception ex) {  	options.ConSole.WriteLine (ex.StackTrace);  	options.ConSole.WriteLine (ex.Message);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: try {  	//TODO DONT forget to remove the limiter  	//int maxNbMSMS = 10;  	double LastMs1InjectionTime = 0;  	for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!  	 {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  		if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			//List precursors and their intensities  			double precursor_mz = 0;  			//Is there a value for the time a scan took to complete?  			int charge = 2;  			double precursor_intensity = 0;  			string fragmentation_method = "unknown";  			double isolationWindow = 1.0;  			double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (injectionTime <= 0.0)  				injectionTime = 120;  			foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  				fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  				if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  					if (precursor.activation.cvParams.Count > 0)  						fragmentation_method = precursor.activation.cvParams [0].name;  				isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  				//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  				//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  				//else if (precursor.isolationWindow.cvParams.Count > 2)  				//    options.ConSole.WriteLine("Weird Isolation Window");  				if (isolationWindow <= 0) {  					double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  					double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  					isolationWindow = lower + upper;  					//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  					if (isolationWindow <= 0)  						isolationWindow = 2;  				}  				foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  					//Cycle through MS to get real precursor intensities  					precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  					//.MS_isolation_width).value  					charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  					precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  					if (precursor_intensity <= 0) {  						precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  						//precursor_mz = ion.cvParams[0].value;  						//charge = (int)ion.cvParams[1].value;  						//precursor_intensity = ion.cvParams[2].value;  					}  				}  			}  			int scan_index = i;  			int scan_number = scan_index + 1;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			int num_peaks = mz.data.Count;  			if (num_peaks != intensity.data.Count) {  				options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  				if (intensity.data.Count < num_peaks)  					num_peaks = intensity.data.Count;  			}  			List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  			for (int k = 0; k < num_peaks; k++) {  				if (intensity.data [k] > 0) {  					MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  					peaks.Add (peak);  				}  			}  			mz.Dispose ();  			mz = null;  			intensity.Dispose ();  			intensity = null;  			peaks.Sort (MsMsPeak.AscendingMzComparison);  			if (filterMS2) {  				//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  				peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  				peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  				//TODO Add Contaminant removal   				//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  				//Can sometime be sorted by intensity after this call  				//peaks = FilterPeaksV2(peaks);  				peaks.Sort (MsMsPeak.AscendingMzComparison);  			}  			/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  				/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  				double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  				ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  				spectra.AddMSMS (spectrum);  				//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  			//if (spectra.Count >= maxNbMSMS)  			//    i = 10000000;  			}  		}  		else//Is an MS  		 {  			LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  			if (loadMS) {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  				if (previousMS1 != null) {  					previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  					spectra.MS1s.Add (previousMS1);  				}  				previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  				//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  				//Trail.RemoveFinished(ref trails' spectra' 1);  			}  		}  		spec.Dispose ();  		spec = null;  		Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  	}  	if (previousMS1 != null)  		spectra.MS1s.Add (previousMS1);  	if (spectra.MS1s.Count > 0)  		spectra.tracks = new Tracks ();  	//TODO ReImplement Precursor finding routine (from MassSense?)  	else  		spectra.tracks = new Tracks ();  	spectra.tracks.Sort (Tracks.AscendingPrecursorMassComparison);  	Console.Write ("\r{0}%   "' 100);  	//ContaminantMasses.DisplayContaminants();  }  catch (Exception ex) {  	options.ConSole.WriteLine (ex.StackTrace);  	options.ConSole.WriteLine (ex.Message);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!   {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  	if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		//List precursors and their intensities  		double precursor_mz = 0;  		//Is there a value for the time a scan took to complete?  		int charge = 2;  		double precursor_intensity = 0;  		string fragmentation_method = "unknown";  		double isolationWindow = 1.0;  		double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (injectionTime <= 0.0)  			injectionTime = 120;  		foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  			fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  			if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  				if (precursor.activation.cvParams.Count > 0)  					fragmentation_method = precursor.activation.cvParams [0].name;  			isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  			//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  			//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  			//else if (precursor.isolationWindow.cvParams.Count > 2)  			//    options.ConSole.WriteLine("Weird Isolation Window");  			if (isolationWindow <= 0) {  				double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  				double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  				isolationWindow = lower + upper;  				//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  				if (isolationWindow <= 0)  					isolationWindow = 2;  			}  			foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  				//Cycle through MS to get real precursor intensities  				precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  				//.MS_isolation_width).value  				charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  				precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  				if (precursor_intensity <= 0) {  					precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  					//precursor_mz = ion.cvParams[0].value;  					//charge = (int)ion.cvParams[1].value;  					//precursor_intensity = ion.cvParams[2].value;  				}  			}  		}  		int scan_index = i;  		int scan_number = scan_index + 1;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		int num_peaks = mz.data.Count;  		if (num_peaks != intensity.data.Count) {  			options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  			if (intensity.data.Count < num_peaks)  				num_peaks = intensity.data.Count;  		}  		List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  		for (int k = 0; k < num_peaks; k++) {  			if (intensity.data [k] > 0) {  				MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  				peaks.Add (peak);  			}  		}  		mz.Dispose ();  		mz = null;  		intensity.Dispose ();  		intensity = null;  		peaks.Sort (MsMsPeak.AscendingMzComparison);  		if (filterMS2) {  			//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  			peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  			//TODO Add Contaminant removal   			//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  			//Can sometime be sorted by intensity after this call  			//peaks = FilterPeaksV2(peaks);  			peaks.Sort (MsMsPeak.AscendingMzComparison);  		}  		/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  			/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  			double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  			ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  			spectra.AddMSMS (spectrum);  			//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  		//if (spectra.Count >= maxNbMSMS)  		//    i = 10000000;  		}  	}  	else//Is an MS  	 {  		LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (loadMS) {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			if (previousMS1 != null) {  				previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  				spectra.MS1s.Add (previousMS1);  			}  			previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  			//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  			//Trail.RemoveFinished(ref trails' spectra' 1);  		}  	}  	spec.Dispose ();  	spec = null;  	Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!   {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  	if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		//List precursors and their intensities  		double precursor_mz = 0;  		//Is there a value for the time a scan took to complete?  		int charge = 2;  		double precursor_intensity = 0;  		string fragmentation_method = "unknown";  		double isolationWindow = 1.0;  		double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (injectionTime <= 0.0)  			injectionTime = 120;  		foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  			fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  			if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  				if (precursor.activation.cvParams.Count > 0)  					fragmentation_method = precursor.activation.cvParams [0].name;  			isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  			//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  			//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  			//else if (precursor.isolationWindow.cvParams.Count > 2)  			//    options.ConSole.WriteLine("Weird Isolation Window");  			if (isolationWindow <= 0) {  				double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  				double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  				isolationWindow = lower + upper;  				//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  				if (isolationWindow <= 0)  					isolationWindow = 2;  			}  			foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  				//Cycle through MS to get real precursor intensities  				precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  				//.MS_isolation_width).value  				charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  				precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  				if (precursor_intensity <= 0) {  					precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  					//precursor_mz = ion.cvParams[0].value;  					//charge = (int)ion.cvParams[1].value;  					//precursor_intensity = ion.cvParams[2].value;  				}  			}  		}  		int scan_index = i;  		int scan_number = scan_index + 1;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		int num_peaks = mz.data.Count;  		if (num_peaks != intensity.data.Count) {  			options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  			if (intensity.data.Count < num_peaks)  				num_peaks = intensity.data.Count;  		}  		List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  		for (int k = 0; k < num_peaks; k++) {  			if (intensity.data [k] > 0) {  				MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  				peaks.Add (peak);  			}  		}  		mz.Dispose ();  		mz = null;  		intensity.Dispose ();  		intensity = null;  		peaks.Sort (MsMsPeak.AscendingMzComparison);  		if (filterMS2) {  			//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  			peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  			//TODO Add Contaminant removal   			//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  			//Can sometime be sorted by intensity after this call  			//peaks = FilterPeaksV2(peaks);  			peaks.Sort (MsMsPeak.AscendingMzComparison);  		}  		/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  			/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  			double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  			ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  			spectra.AddMSMS (spectrum);  			//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  		//if (spectra.Count >= maxNbMSMS)  		//    i = 10000000;  		}  	}  	else//Is an MS  	 {  		LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (loadMS) {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			if (previousMS1 != null) {  				previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  				spectra.MS1s.Add (previousMS1);  			}  			previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  			//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  			//Trail.RemoveFinished(ref trails' spectra' 1);  		}  	}  	spec.Dispose ();  	spec = null;  	Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!   {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  	if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		//List precursors and their intensities  		double precursor_mz = 0;  		//Is there a value for the time a scan took to complete?  		int charge = 2;  		double precursor_intensity = 0;  		string fragmentation_method = "unknown";  		double isolationWindow = 1.0;  		double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (injectionTime <= 0.0)  			injectionTime = 120;  		foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  			fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  			if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  				if (precursor.activation.cvParams.Count > 0)  					fragmentation_method = precursor.activation.cvParams [0].name;  			isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  			//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  			//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  			//else if (precursor.isolationWindow.cvParams.Count > 2)  			//    options.ConSole.WriteLine("Weird Isolation Window");  			if (isolationWindow <= 0) {  				double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  				double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  				isolationWindow = lower + upper;  				//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  				if (isolationWindow <= 0)  					isolationWindow = 2;  			}  			foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  				//Cycle through MS to get real precursor intensities  				precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  				//.MS_isolation_width).value  				charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  				precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  				if (precursor_intensity <= 0) {  					precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  					//precursor_mz = ion.cvParams[0].value;  					//charge = (int)ion.cvParams[1].value;  					//precursor_intensity = ion.cvParams[2].value;  				}  			}  		}  		int scan_index = i;  		int scan_number = scan_index + 1;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		int num_peaks = mz.data.Count;  		if (num_peaks != intensity.data.Count) {  			options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  			if (intensity.data.Count < num_peaks)  				num_peaks = intensity.data.Count;  		}  		List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  		for (int k = 0; k < num_peaks; k++) {  			if (intensity.data [k] > 0) {  				MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  				peaks.Add (peak);  			}  		}  		mz.Dispose ();  		mz = null;  		intensity.Dispose ();  		intensity = null;  		peaks.Sort (MsMsPeak.AscendingMzComparison);  		if (filterMS2) {  			//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  			peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  			//TODO Add Contaminant removal   			//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  			//Can sometime be sorted by intensity after this call  			//peaks = FilterPeaksV2(peaks);  			peaks.Sort (MsMsPeak.AscendingMzComparison);  		}  		/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  			/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  			double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  			ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  			spectra.AddMSMS (spectrum);  			//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  		//if (spectra.Count >= maxNbMSMS)  		//    i = 10000000;  		}  	}  	else//Is an MS  	 {  		LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (loadMS) {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			if (previousMS1 != null) {  				previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  				spectra.MS1s.Add (previousMS1);  			}  			previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  			//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  			//Trail.RemoveFinished(ref trails' spectra' 1);  		}  	}  	spec.Dispose ();  	spec = null;  	Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!   {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  	if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		//List precursors and their intensities  		double precursor_mz = 0;  		//Is there a value for the time a scan took to complete?  		int charge = 2;  		double precursor_intensity = 0;  		string fragmentation_method = "unknown";  		double isolationWindow = 1.0;  		double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (injectionTime <= 0.0)  			injectionTime = 120;  		foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  			fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  			if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  				if (precursor.activation.cvParams.Count > 0)  					fragmentation_method = precursor.activation.cvParams [0].name;  			isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  			//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  			//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  			//else if (precursor.isolationWindow.cvParams.Count > 2)  			//    options.ConSole.WriteLine("Weird Isolation Window");  			if (isolationWindow <= 0) {  				double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  				double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  				isolationWindow = lower + upper;  				//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  				if (isolationWindow <= 0)  					isolationWindow = 2;  			}  			foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  				//Cycle through MS to get real precursor intensities  				precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  				//.MS_isolation_width).value  				charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  				precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  				if (precursor_intensity <= 0) {  					precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  					//precursor_mz = ion.cvParams[0].value;  					//charge = (int)ion.cvParams[1].value;  					//precursor_intensity = ion.cvParams[2].value;  				}  			}  		}  		int scan_index = i;  		int scan_number = scan_index + 1;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		int num_peaks = mz.data.Count;  		if (num_peaks != intensity.data.Count) {  			options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  			if (intensity.data.Count < num_peaks)  				num_peaks = intensity.data.Count;  		}  		List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  		for (int k = 0; k < num_peaks; k++) {  			if (intensity.data [k] > 0) {  				MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  				peaks.Add (peak);  			}  		}  		mz.Dispose ();  		mz = null;  		intensity.Dispose ();  		intensity = null;  		peaks.Sort (MsMsPeak.AscendingMzComparison);  		if (filterMS2) {  			//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  			peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  			//TODO Add Contaminant removal   			//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  			//Can sometime be sorted by intensity after this call  			//peaks = FilterPeaksV2(peaks);  			peaks.Sort (MsMsPeak.AscendingMzComparison);  		}  		/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  			/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  			double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  			ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  			spectra.AddMSMS (spectrum);  			//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  		//if (spectra.Count >= maxNbMSMS)  		//    i = 10000000;  		}  	}  	else//Is an MS  	 {  		LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (loadMS) {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			if (previousMS1 != null) {  				previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  				spectra.MS1s.Add (previousMS1);  			}  			previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  			//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  			//Trail.RemoveFinished(ref trails' spectra' 1);  		}  	}  	spec.Dispose ();  	spec = null;  	Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!   {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  	if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		//List precursors and their intensities  		double precursor_mz = 0;  		//Is there a value for the time a scan took to complete?  		int charge = 2;  		double precursor_intensity = 0;  		string fragmentation_method = "unknown";  		double isolationWindow = 1.0;  		double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (injectionTime <= 0.0)  			injectionTime = 120;  		foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  			fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  			if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  				if (precursor.activation.cvParams.Count > 0)  					fragmentation_method = precursor.activation.cvParams [0].name;  			isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  			//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  			//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  			//else if (precursor.isolationWindow.cvParams.Count > 2)  			//    options.ConSole.WriteLine("Weird Isolation Window");  			if (isolationWindow <= 0) {  				double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  				double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  				isolationWindow = lower + upper;  				//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  				if (isolationWindow <= 0)  					isolationWindow = 2;  			}  			foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  				//Cycle through MS to get real precursor intensities  				precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  				//.MS_isolation_width).value  				charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  				precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  				if (precursor_intensity <= 0) {  					precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  					//precursor_mz = ion.cvParams[0].value;  					//charge = (int)ion.cvParams[1].value;  					//precursor_intensity = ion.cvParams[2].value;  				}  			}  		}  		int scan_index = i;  		int scan_number = scan_index + 1;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		int num_peaks = mz.data.Count;  		if (num_peaks != intensity.data.Count) {  			options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  			if (intensity.data.Count < num_peaks)  				num_peaks = intensity.data.Count;  		}  		List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  		for (int k = 0; k < num_peaks; k++) {  			if (intensity.data [k] > 0) {  				MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  				peaks.Add (peak);  			}  		}  		mz.Dispose ();  		mz = null;  		intensity.Dispose ();  		intensity = null;  		peaks.Sort (MsMsPeak.AscendingMzComparison);  		if (filterMS2) {  			//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  			peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  			//TODO Add Contaminant removal   			//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  			//Can sometime be sorted by intensity after this call  			//peaks = FilterPeaksV2(peaks);  			peaks.Sort (MsMsPeak.AscendingMzComparison);  		}  		/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  			/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  			double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  			ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  			spectra.AddMSMS (spectrum);  			//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  		//if (spectra.Count >= maxNbMSMS)  		//    i = 10000000;  		}  	}  	else//Is an MS  	 {  		LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (loadMS) {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			if (previousMS1 != null) {  				previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  				spectra.MS1s.Add (previousMS1);  			}  			previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  			//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  			//Trail.RemoveFinished(ref trails' spectra' 1);  		}  	}  	spec.Dispose ();  	spec = null;  	Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!   {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  	if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		//List precursors and their intensities  		double precursor_mz = 0;  		//Is there a value for the time a scan took to complete?  		int charge = 2;  		double precursor_intensity = 0;  		string fragmentation_method = "unknown";  		double isolationWindow = 1.0;  		double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (injectionTime <= 0.0)  			injectionTime = 120;  		foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  			fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  			if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  				if (precursor.activation.cvParams.Count > 0)  					fragmentation_method = precursor.activation.cvParams [0].name;  			isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  			//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  			//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  			//else if (precursor.isolationWindow.cvParams.Count > 2)  			//    options.ConSole.WriteLine("Weird Isolation Window");  			if (isolationWindow <= 0) {  				double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  				double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  				isolationWindow = lower + upper;  				//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  				if (isolationWindow <= 0)  					isolationWindow = 2;  			}  			foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  				//Cycle through MS to get real precursor intensities  				precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  				//.MS_isolation_width).value  				charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  				precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  				if (precursor_intensity <= 0) {  					precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  					//precursor_mz = ion.cvParams[0].value;  					//charge = (int)ion.cvParams[1].value;  					//precursor_intensity = ion.cvParams[2].value;  				}  			}  		}  		int scan_index = i;  		int scan_number = scan_index + 1;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		int num_peaks = mz.data.Count;  		if (num_peaks != intensity.data.Count) {  			options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  			if (intensity.data.Count < num_peaks)  				num_peaks = intensity.data.Count;  		}  		List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  		for (int k = 0; k < num_peaks; k++) {  			if (intensity.data [k] > 0) {  				MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  				peaks.Add (peak);  			}  		}  		mz.Dispose ();  		mz = null;  		intensity.Dispose ();  		intensity = null;  		peaks.Sort (MsMsPeak.AscendingMzComparison);  		if (filterMS2) {  			//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  			peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  			//TODO Add Contaminant removal   			//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  			//Can sometime be sorted by intensity after this call  			//peaks = FilterPeaksV2(peaks);  			peaks.Sort (MsMsPeak.AscendingMzComparison);  		}  		/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  			/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  			double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  			ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  			spectra.AddMSMS (spectrum);  			//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  		//if (spectra.Count >= maxNbMSMS)  		//    i = 10000000;  		}  	}  	else//Is an MS  	 {  		LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (loadMS) {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			if (previousMS1 != null) {  				previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  				spectra.MS1s.Add (previousMS1);  			}  			previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  			//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  			//Trail.RemoveFinished(ref trails' spectra' 1);  		}  	}  	spec.Dispose ();  	spec = null;  	Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: for (int i = 0; i < num_spectra/* && i < 200*/; i++)//TODO Fix that later!   {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  	if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		//List precursors and their intensities  		double precursor_mz = 0;  		//Is there a value for the time a scan took to complete?  		int charge = 2;  		double precursor_intensity = 0;  		string fragmentation_method = "unknown";  		double isolationWindow = 1.0;  		double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (injectionTime <= 0.0)  			injectionTime = 120;  		foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  			fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  			if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  				if (precursor.activation.cvParams.Count > 0)  					fragmentation_method = precursor.activation.cvParams [0].name;  			isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  			//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  			//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  			//else if (precursor.isolationWindow.cvParams.Count > 2)  			//    options.ConSole.WriteLine("Weird Isolation Window");  			if (isolationWindow <= 0) {  				double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  				double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  				isolationWindow = lower + upper;  				//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  				if (isolationWindow <= 0)  					isolationWindow = 2;  			}  			foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  				//Cycle through MS to get real precursor intensities  				precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  				//.MS_isolation_width).value  				charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  				precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  				if (precursor_intensity <= 0) {  					precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  					//precursor_mz = ion.cvParams[0].value;  					//charge = (int)ion.cvParams[1].value;  					//precursor_intensity = ion.cvParams[2].value;  				}  			}  		}  		int scan_index = i;  		int scan_number = scan_index + 1;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		int num_peaks = mz.data.Count;  		if (num_peaks != intensity.data.Count) {  			options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  			if (intensity.data.Count < num_peaks)  				num_peaks = intensity.data.Count;  		}  		List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  		for (int k = 0; k < num_peaks; k++) {  			if (intensity.data [k] > 0) {  				MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  				peaks.Add (peak);  			}  		}  		mz.Dispose ();  		mz = null;  		intensity.Dispose ();  		intensity = null;  		peaks.Sort (MsMsPeak.AscendingMzComparison);  		if (filterMS2) {  			//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  			peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  			peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  			//TODO Add Contaminant removal   			//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  			//Can sometime be sorted by intensity after this call  			//peaks = FilterPeaksV2(peaks);  			peaks.Sort (MsMsPeak.AscendingMzComparison);  		}  		/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  			/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  			double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  			ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  			spectra.AddMSMS (spectrum);  			//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  		//if (spectra.Count >= maxNbMSMS)  		//    i = 10000000;  		}  	}  	else//Is an MS  	 {  		LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  		if (loadMS) {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  			if (previousMS1 != null) {  				previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  				spectra.MS1s.Add (previousMS1);  			}  			previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  			//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  			//Trail.RemoveFinished(ref trails' spectra' 1);  		}  	}  	spec.Dispose ();  	spec = null;  	Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS   {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	//List precursors and their intensities  	double precursor_mz = 0;  	//Is there a value for the time a scan took to complete?  	int charge = 2;  	double precursor_intensity = 0;  	string fragmentation_method = "unknown";  	double isolationWindow = 1.0;  	double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (injectionTime <= 0.0)  		injectionTime = 120;  	foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  		fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  		if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  			if (precursor.activation.cvParams.Count > 0)  				fragmentation_method = precursor.activation.cvParams [0].name;  		isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  		//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  		//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  		//else if (precursor.isolationWindow.cvParams.Count > 2)  		//    options.ConSole.WriteLine("Weird Isolation Window");  		if (isolationWindow <= 0) {  			double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  			double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  			isolationWindow = lower + upper;  			//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  			if (isolationWindow <= 0)  				isolationWindow = 2;  		}  		foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  			//Cycle through MS to get real precursor intensities  			precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  			//.MS_isolation_width).value  			charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  			precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  			if (precursor_intensity <= 0) {  				precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  				//precursor_mz = ion.cvParams[0].value;  				//charge = (int)ion.cvParams[1].value;  				//precursor_intensity = ion.cvParams[2].value;  			}  		}  	}  	int scan_index = i;  	int scan_number = scan_index + 1;  	pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  	int num_peaks = mz.data.Count;  	if (num_peaks != intensity.data.Count) {  		options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  		if (intensity.data.Count < num_peaks)  			num_peaks = intensity.data.Count;  	}  	List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  	for (int k = 0; k < num_peaks; k++) {  		if (intensity.data [k] > 0) {  			MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  			peaks.Add (peak);  		}  	}  	mz.Dispose ();  	mz = null;  	intensity.Dispose ();  	intensity = null;  	peaks.Sort (MsMsPeak.AscendingMzComparison);  	if (filterMS2) {  		//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  		peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  		//TODO Add Contaminant removal   		//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  		//Can sometime be sorted by intensity after this call  		//peaks = FilterPeaksV2(peaks);  		peaks.Sort (MsMsPeak.AscendingMzComparison);  	}  	/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  		/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  		double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  		ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  		spectra.AddMSMS (spectrum);  		//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  	//if (spectra.Count >= maxNbMSMS)  	//    i = 10000000;  	}  }  else//Is an MS   {  	LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (loadMS) {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		if (previousMS1 != null) {  			previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  			spectra.MS1s.Add (previousMS1);  		}  		previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  		//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  		//Trail.RemoveFinished(ref trails' spectra' 1);  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS   {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	//List precursors and their intensities  	double precursor_mz = 0;  	//Is there a value for the time a scan took to complete?  	int charge = 2;  	double precursor_intensity = 0;  	string fragmentation_method = "unknown";  	double isolationWindow = 1.0;  	double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (injectionTime <= 0.0)  		injectionTime = 120;  	foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  		fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  		if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  			if (precursor.activation.cvParams.Count > 0)  				fragmentation_method = precursor.activation.cvParams [0].name;  		isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  		//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  		//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  		//else if (precursor.isolationWindow.cvParams.Count > 2)  		//    options.ConSole.WriteLine("Weird Isolation Window");  		if (isolationWindow <= 0) {  			double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  			double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  			isolationWindow = lower + upper;  			//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  			if (isolationWindow <= 0)  				isolationWindow = 2;  		}  		foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  			//Cycle through MS to get real precursor intensities  			precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  			//.MS_isolation_width).value  			charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  			precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  			if (precursor_intensity <= 0) {  				precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  				//precursor_mz = ion.cvParams[0].value;  				//charge = (int)ion.cvParams[1].value;  				//precursor_intensity = ion.cvParams[2].value;  			}  		}  	}  	int scan_index = i;  	int scan_number = scan_index + 1;  	pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  	int num_peaks = mz.data.Count;  	if (num_peaks != intensity.data.Count) {  		options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  		if (intensity.data.Count < num_peaks)  			num_peaks = intensity.data.Count;  	}  	List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  	for (int k = 0; k < num_peaks; k++) {  		if (intensity.data [k] > 0) {  			MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  			peaks.Add (peak);  		}  	}  	mz.Dispose ();  	mz = null;  	intensity.Dispose ();  	intensity = null;  	peaks.Sort (MsMsPeak.AscendingMzComparison);  	if (filterMS2) {  		//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  		peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  		//TODO Add Contaminant removal   		//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  		//Can sometime be sorted by intensity after this call  		//peaks = FilterPeaksV2(peaks);  		peaks.Sort (MsMsPeak.AscendingMzComparison);  	}  	/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  		/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  		double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  		ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  		spectra.AddMSMS (spectrum);  		//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  	//if (spectra.Count >= maxNbMSMS)  	//    i = 10000000;  	}  }  else//Is an MS   {  	LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (loadMS) {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		if (previousMS1 != null) {  			previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  			spectra.MS1s.Add (previousMS1);  		}  		previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  		//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  		//Trail.RemoveFinished(ref trails' spectra' 1);  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS   {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	//List precursors and their intensities  	double precursor_mz = 0;  	//Is there a value for the time a scan took to complete?  	int charge = 2;  	double precursor_intensity = 0;  	string fragmentation_method = "unknown";  	double isolationWindow = 1.0;  	double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (injectionTime <= 0.0)  		injectionTime = 120;  	foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  		fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  		if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  			if (precursor.activation.cvParams.Count > 0)  				fragmentation_method = precursor.activation.cvParams [0].name;  		isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  		//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  		//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  		//else if (precursor.isolationWindow.cvParams.Count > 2)  		//    options.ConSole.WriteLine("Weird Isolation Window");  		if (isolationWindow <= 0) {  			double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  			double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  			isolationWindow = lower + upper;  			//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  			if (isolationWindow <= 0)  				isolationWindow = 2;  		}  		foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  			//Cycle through MS to get real precursor intensities  			precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  			//.MS_isolation_width).value  			charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  			precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  			if (precursor_intensity <= 0) {  				precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  				//precursor_mz = ion.cvParams[0].value;  				//charge = (int)ion.cvParams[1].value;  				//precursor_intensity = ion.cvParams[2].value;  			}  		}  	}  	int scan_index = i;  	int scan_number = scan_index + 1;  	pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  	int num_peaks = mz.data.Count;  	if (num_peaks != intensity.data.Count) {  		options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  		if (intensity.data.Count < num_peaks)  			num_peaks = intensity.data.Count;  	}  	List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  	for (int k = 0; k < num_peaks; k++) {  		if (intensity.data [k] > 0) {  			MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  			peaks.Add (peak);  		}  	}  	mz.Dispose ();  	mz = null;  	intensity.Dispose ();  	intensity = null;  	peaks.Sort (MsMsPeak.AscendingMzComparison);  	if (filterMS2) {  		//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  		peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  		//TODO Add Contaminant removal   		//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  		//Can sometime be sorted by intensity after this call  		//peaks = FilterPeaksV2(peaks);  		peaks.Sort (MsMsPeak.AscendingMzComparison);  	}  	/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  		/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  		double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  		ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  		spectra.AddMSMS (spectrum);  		//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  	//if (spectra.Count >= maxNbMSMS)  	//    i = 10000000;  	}  }  else//Is an MS   {  	LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (loadMS) {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		if (previousMS1 != null) {  			previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  			spectra.MS1s.Add (previousMS1);  		}  		previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  		//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  		//Trail.RemoveFinished(ref trails' spectra' 1);  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS   {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	//List precursors and their intensities  	double precursor_mz = 0;  	//Is there a value for the time a scan took to complete?  	int charge = 2;  	double precursor_intensity = 0;  	string fragmentation_method = "unknown";  	double isolationWindow = 1.0;  	double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (injectionTime <= 0.0)  		injectionTime = 120;  	foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  		fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  		if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  			if (precursor.activation.cvParams.Count > 0)  				fragmentation_method = precursor.activation.cvParams [0].name;  		isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  		//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  		//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  		//else if (precursor.isolationWindow.cvParams.Count > 2)  		//    options.ConSole.WriteLine("Weird Isolation Window");  		if (isolationWindow <= 0) {  			double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  			double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  			isolationWindow = lower + upper;  			//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  			if (isolationWindow <= 0)  				isolationWindow = 2;  		}  		foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  			//Cycle through MS to get real precursor intensities  			precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  			//.MS_isolation_width).value  			charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  			precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  			if (precursor_intensity <= 0) {  				precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  				//precursor_mz = ion.cvParams[0].value;  				//charge = (int)ion.cvParams[1].value;  				//precursor_intensity = ion.cvParams[2].value;  			}  		}  	}  	int scan_index = i;  	int scan_number = scan_index + 1;  	pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  	int num_peaks = mz.data.Count;  	if (num_peaks != intensity.data.Count) {  		options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  		if (intensity.data.Count < num_peaks)  			num_peaks = intensity.data.Count;  	}  	List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  	for (int k = 0; k < num_peaks; k++) {  		if (intensity.data [k] > 0) {  			MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  			peaks.Add (peak);  		}  	}  	mz.Dispose ();  	mz = null;  	intensity.Dispose ();  	intensity = null;  	peaks.Sort (MsMsPeak.AscendingMzComparison);  	if (filterMS2) {  		//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  		peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  		//TODO Add Contaminant removal   		//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  		//Can sometime be sorted by intensity after this call  		//peaks = FilterPeaksV2(peaks);  		peaks.Sort (MsMsPeak.AscendingMzComparison);  	}  	/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  		/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  		double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  		ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  		spectra.AddMSMS (spectrum);  		//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  	//if (spectra.Count >= maxNbMSMS)  	//    i = 10000000;  	}  }  else//Is an MS   {  	LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (loadMS) {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		if (previousMS1 != null) {  			previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  			spectra.MS1s.Add (previousMS1);  		}  		previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  		//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  		//Trail.RemoveFinished(ref trails' spectra' 1);  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS   {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	//List precursors and their intensities  	double precursor_mz = 0;  	//Is there a value for the time a scan took to complete?  	int charge = 2;  	double precursor_intensity = 0;  	string fragmentation_method = "unknown";  	double isolationWindow = 1.0;  	double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (injectionTime <= 0.0)  		injectionTime = 120;  	foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  		fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  		if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  			if (precursor.activation.cvParams.Count > 0)  				fragmentation_method = precursor.activation.cvParams [0].name;  		isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  		//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  		//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  		//else if (precursor.isolationWindow.cvParams.Count > 2)  		//    options.ConSole.WriteLine("Weird Isolation Window");  		if (isolationWindow <= 0) {  			double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  			double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  			isolationWindow = lower + upper;  			//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  			if (isolationWindow <= 0)  				isolationWindow = 2;  		}  		foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  			//Cycle through MS to get real precursor intensities  			precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  			//.MS_isolation_width).value  			charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  			precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  			if (precursor_intensity <= 0) {  				precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  				//precursor_mz = ion.cvParams[0].value;  				//charge = (int)ion.cvParams[1].value;  				//precursor_intensity = ion.cvParams[2].value;  			}  		}  	}  	int scan_index = i;  	int scan_number = scan_index + 1;  	pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  	int num_peaks = mz.data.Count;  	if (num_peaks != intensity.data.Count) {  		options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  		if (intensity.data.Count < num_peaks)  			num_peaks = intensity.data.Count;  	}  	List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  	for (int k = 0; k < num_peaks; k++) {  		if (intensity.data [k] > 0) {  			MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  			peaks.Add (peak);  		}  	}  	mz.Dispose ();  	mz = null;  	intensity.Dispose ();  	intensity = null;  	peaks.Sort (MsMsPeak.AscendingMzComparison);  	if (filterMS2) {  		//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  		peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  		//TODO Add Contaminant removal   		//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  		//Can sometime be sorted by intensity after this call  		//peaks = FilterPeaksV2(peaks);  		peaks.Sort (MsMsPeak.AscendingMzComparison);  	}  	/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  		/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  		double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  		ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  		spectra.AddMSMS (spectrum);  		//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  	//if (spectra.Count >= maxNbMSMS)  	//    i = 10000000;  	}  }  else//Is an MS   {  	LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (loadMS) {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		if (previousMS1 != null) {  			previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  			spectra.MS1s.Add (previousMS1);  		}  		previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  		//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  		//Trail.RemoveFinished(ref trails' spectra' 1);  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1)//is an MSMS   {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	//List precursors and their intensities  	double precursor_mz = 0;  	//Is there a value for the time a scan took to complete?  	int charge = 2;  	double precursor_intensity = 0;  	string fragmentation_method = "unknown";  	double isolationWindow = 1.0;  	double injectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (injectionTime <= 0.0)  		injectionTime = 120;  	foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  		fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  		if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  			if (precursor.activation.cvParams.Count > 0)  				fragmentation_method = precursor.activation.cvParams [0].name;  		isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  		//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  		//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  		//else if (precursor.isolationWindow.cvParams.Count > 2)  		//    options.ConSole.WriteLine("Weird Isolation Window");  		if (isolationWindow <= 0) {  			double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  			double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  			isolationWindow = lower + upper;  			//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  			if (isolationWindow <= 0)  				isolationWindow = 2;  		}  		foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  			//Cycle through MS to get real precursor intensities  			precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  			//.MS_isolation_width).value  			charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  			precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  			if (precursor_intensity <= 0) {  				precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  				//precursor_mz = ion.cvParams[0].value;  				//charge = (int)ion.cvParams[1].value;  				//precursor_intensity = ion.cvParams[2].value;  			}  		}  	}  	int scan_index = i;  	int scan_number = scan_index + 1;  	pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  	int num_peaks = mz.data.Count;  	if (num_peaks != intensity.data.Count) {  		options.ConSole.WriteLine ("PreoteWizard reports peaks arrays (mz/intensity) of different sizes : (" + num_peaks + "/" + intensity.data.Count + ")");  		if (intensity.data.Count < num_peaks)  			num_peaks = intensity.data.Count;  	}  	List<MsMsPeak> peaks = new List<MsMsPeak> (num_peaks);  	for (int k = 0; k < num_peaks; k++) {  		if (intensity.data [k] > 0) {  			MsMsPeak peak = new MsMsPeak (mz.data [k]' intensity.data [k]' 0);  			peaks.Add (peak);  		}  	}  	mz.Dispose ();  	mz = null;  	intensity.Dispose ();  	intensity = null;  	peaks.Sort (MsMsPeak.AscendingMzComparison);  	if (filterMS2) {  		//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  		peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  		peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  		//TODO Add Contaminant removal   		//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  		//Can sometime be sorted by intensity after this call  		//peaks = FilterPeaksV2(peaks);  		peaks.Sort (MsMsPeak.AscendingMzComparison);  	}  	/*//TODO Validate that in most cases' next steps can calculate missing charge                         if (charge == 0)                         {                             for (int c = options.minimumAssumedPrecursorChargeState; c <= options.maximumAssumedPrecursorChargeState; c++)                             {                                 if (options.assignChargeStates)                                 {                                     peaks = AssignChargeStates(peaks' c' options.productMassTolerance);                                     if (options.deisotope)                                     {                                         peaks = Deisotope(peaks' c' options.productMassTolerance);                                     }                                 }                                  double precursor_mass = Utilities.MassFromMZ(precursor_mz' c);                                  ProductSpectrum spectrum = new ProductSpectrum(mzMlFilepath' scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' c' precursor_mass' peaks);                                 spectra.Add(spectrum);                             }                         }                         else//*/{  		/*                         if (options.assignChargeStates)                         {                             peaks = AssignChargeStatesbkp(peaks' charge' options.productMassTolerance);                             if (options.deisotope)                             {                                 peaks = Deisotopebkp(peaks' charge' options.productMassTolerance);                             }                         }//*///peaks = AssignChargeStatesAndDeisotope(peaks' options.maximumAssumedPrecursorChargeState' options.productMassTolerance);  		double precursor_mass = Numerics.MassFromMZ (precursor_mz' charge);  		ProductSpectrum spectrum = new ProductSpectrum (scan_number' retention_time' fragmentation_method' precursor_mz' precursor_intensity' charge' precursor_mass' peaks' isolationWindow' injectionTime' LastMs1InjectionTime);  		spectra.AddMSMS (spectrum);  		//zones.Add(new Zone(precursor_mz - isolationWindow' precursor_mz + isolationWindow' retention_time));  	//if (spectra.Count >= maxNbMSMS)  	//    i = 10000000;  	}  }  else//Is an MS   {  	LastMs1InjectionTime = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_ion_injection_time).value;  	if (loadMS) {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  		if (previousMS1 != null) {  			previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  			spectra.MS1s.Add (previousMS1);  		}  		previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  		//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  		//Trail.RemoveFinished(ref trails' spectra' 1);  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (injectionTime <= 0.0)  	injectionTime = 120;  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: injectionTime = 120;  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: foreach (pwiz.CLI.msdata.Precursor precursor in spec.precursors) {  	fragmentation_method = precursor.activation.cvParam (pwiz.CLI.cv.CVID.MS_fragmentation_information).name;  	if (string.IsNullOrEmpty (fragmentation_method) || fragmentation_method.Contains ("nknown"))  		if (precursor.activation.cvParams.Count > 0)  			fragmentation_method = precursor.activation.cvParams [0].name;  	isolationWindow = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_width).value;  	//if (precursor.isolationWindow.cvParam(pwiz.CLI.cv.CVID.MS_isolation_width).value > 0)//s.Count > 2 && (double)precursor.isolationWindow.cvParams[1].value == (double)precursor.isolationWindow.cvParams[2].value)  	//    isolationWindow = precursor.isolationWindow.cvParams[1].value;  	//else if (precursor.isolationWindow.cvParams.Count > 2)  	//    options.ConSole.WriteLine("Weird Isolation Window");  	if (isolationWindow <= 0) {  		double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  		double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  		isolationWindow = lower + upper;  		//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  		if (isolationWindow <= 0)  			isolationWindow = 2;  	}  	foreach (pwiz.CLI.msdata.SelectedIon ion in precursor.selectedIons) {  		//Cycle through MS to get real precursor intensities  		precursor_mz = ion.cvParam (pwiz.CLI.cv.CVID.MS_selected_ion_m_z).value;  		//.MS_isolation_width).value  		charge = (int)ion.cvParam (pwiz.CLI.cv.CVID.MS_charge_state).value;  		precursor_intensity = ion.cvParam (pwiz.CLI.cv.CVID.MS_peak_intensity).value;  		if (precursor_intensity <= 0) {  			precursor_intensity = precursor.cvParam (pwiz.CLI.cv.CVID.MS_intensity_of_precursor_ion).value;  			//precursor_mz = ion.cvParams[0].value;  			//charge = (int)ion.cvParams[1].value;  			//precursor_intensity = ion.cvParams[2].value;  		}  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (isolationWindow <= 0) {  	double lower = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_lower_offset).value;  	double upper = precursor.isolationWindow.cvParam (pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset).value;  	isolationWindow = lower + upper;  	//pwiz.CLI.cv.CVID.MS_isolation_window_upper_offset  	if (isolationWindow <= 0)  		isolationWindow = 2;  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (isolationWindow <= 0)  	isolationWindow = 2;  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: isolationWindow = 2;  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (filterMS2) {  	//peaks = AssignChargeStates(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  	//peaks = Deisotopebkp(peaks' options.maximumAssumedPrecursorChargeState' options.precursorMassTolerance);  	peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  	peaks = FilterPeaks (peaks' options.MaximumNumberOfFragmentsPerSpectrum);  	//TODO Add Contaminant removal   	//peaks = ContaminantMasses.RemoveContaminantsFromMzSortedList(peaks' options.productMassTolerance);  	//Can sometime be sorted by intensity after this call  	//peaks = FilterPeaksV2(peaks);  	peaks.Sort (MsMsPeak.AscendingMzComparison);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: peaks = AssignChargeStatesAndDeisotope (peaks' options.MaximumPrecursorChargeState' new MassTolerance (options.productMassTolerance.Value * 0.25' options.productMassTolerance.Units));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: if (loadMS) {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensity = spec.getIntensityArray ();  	if (previousMS1 != null) {  		previousMS1.ScanDuration = retention_time - previousMS1.RetentionTimeInMin;  		spectra.MS1s.Add (previousMS1);  	}  	previousMS1 = new MS1Spectrum (i' retention_time' intensity.data' mz.data' 1);  	//Trail.Follow(mz.data' intensity.data' retention_time' ref trails' options);  	//Trail.RemoveFinished(ref trails' spectra' 1);  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: Console.Write ("\r{0}%   "' ((100 * i) / num_spectra));  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,Load,The following statement contains a magic number: Console.Write ("\r{0}%   "' 100);  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int lowMassIndex = 0; lowMassIndex < new_peaks.Count - 1; lowMassIndex++) {  	double bestChargeScore = 0;  	int bestCharge = 0;  	bestIsotopes [0] = 0;  	bestIsotopes [1] = 0;  	bestIsotopes [2] = 0;  	bestIsotopes [3] = 0;  	for (int charge = maxCharge; charge > 0; charge--) {  		currentIsotopes [0] = 0;  		currentIsotopes [1] = 0;  		currentIsotopes [2] = 0;  		currentIsotopes [3] = 0;  		double score = 0;  		int potentialIsotopeIndex = lowMassIndex + 1;  		for (int isotope = 1; isotope <= 4; isotope++) {  			double bestMassError = isotopicMzTolerance.Value;  			double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  			while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  				if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  					double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  					if (massError < bestMassError) {  						bestMassError = massError;  						currentIsotopes [isotope - 1] = potentialIsotopeIndex;  					}  				}  				potentialIsotopeIndex++;  			}  			score += isotopicMzTolerance.Value - bestMassError;  			if (score == 0)  				break;  			;  		}  		if (score > bestChargeScore) {  			bestIsotopes [0] = currentIsotopes [0];  			bestIsotopes [1] = currentIsotopes [1];  			bestIsotopes [2] = currentIsotopes [2];  			bestIsotopes [3] = currentIsotopes [3];  			bestChargeScore = score;  			bestCharge = charge;  		}  	}  	new_peaks [lowMassIndex].Charge = bestCharge;  	for (int i = 3; i >= 0; i--)  		if (bestIsotopes [i] > 0) {  			new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  			new_peaks.RemoveAt (bestIsotopes [i]);  		}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: bestIsotopes [2] = 0;  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: bestIsotopes [3] = 0;  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int charge = maxCharge; charge > 0; charge--) {  	currentIsotopes [0] = 0;  	currentIsotopes [1] = 0;  	currentIsotopes [2] = 0;  	currentIsotopes [3] = 0;  	double score = 0;  	int potentialIsotopeIndex = lowMassIndex + 1;  	for (int isotope = 1; isotope <= 4; isotope++) {  		double bestMassError = isotopicMzTolerance.Value;  		double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  		while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  			if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  				double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  				if (massError < bestMassError) {  					bestMassError = massError;  					currentIsotopes [isotope - 1] = potentialIsotopeIndex;  				}  			}  			potentialIsotopeIndex++;  		}  		score += isotopicMzTolerance.Value - bestMassError;  		if (score == 0)  			break;  		;  	}  	if (score > bestChargeScore) {  		bestIsotopes [0] = currentIsotopes [0];  		bestIsotopes [1] = currentIsotopes [1];  		bestIsotopes [2] = currentIsotopes [2];  		bestIsotopes [3] = currentIsotopes [3];  		bestChargeScore = score;  		bestCharge = charge;  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int charge = maxCharge; charge > 0; charge--) {  	currentIsotopes [0] = 0;  	currentIsotopes [1] = 0;  	currentIsotopes [2] = 0;  	currentIsotopes [3] = 0;  	double score = 0;  	int potentialIsotopeIndex = lowMassIndex + 1;  	for (int isotope = 1; isotope <= 4; isotope++) {  		double bestMassError = isotopicMzTolerance.Value;  		double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  		while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  			if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  				double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  				if (massError < bestMassError) {  					bestMassError = massError;  					currentIsotopes [isotope - 1] = potentialIsotopeIndex;  				}  			}  			potentialIsotopeIndex++;  		}  		score += isotopicMzTolerance.Value - bestMassError;  		if (score == 0)  			break;  		;  	}  	if (score > bestChargeScore) {  		bestIsotopes [0] = currentIsotopes [0];  		bestIsotopes [1] = currentIsotopes [1];  		bestIsotopes [2] = currentIsotopes [2];  		bestIsotopes [3] = currentIsotopes [3];  		bestChargeScore = score;  		bestCharge = charge;  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int charge = maxCharge; charge > 0; charge--) {  	currentIsotopes [0] = 0;  	currentIsotopes [1] = 0;  	currentIsotopes [2] = 0;  	currentIsotopes [3] = 0;  	double score = 0;  	int potentialIsotopeIndex = lowMassIndex + 1;  	for (int isotope = 1; isotope <= 4; isotope++) {  		double bestMassError = isotopicMzTolerance.Value;  		double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  		while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  			if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  				double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  				if (massError < bestMassError) {  					bestMassError = massError;  					currentIsotopes [isotope - 1] = potentialIsotopeIndex;  				}  			}  			potentialIsotopeIndex++;  		}  		score += isotopicMzTolerance.Value - bestMassError;  		if (score == 0)  			break;  		;  	}  	if (score > bestChargeScore) {  		bestIsotopes [0] = currentIsotopes [0];  		bestIsotopes [1] = currentIsotopes [1];  		bestIsotopes [2] = currentIsotopes [2];  		bestIsotopes [3] = currentIsotopes [3];  		bestChargeScore = score;  		bestCharge = charge;  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int charge = maxCharge; charge > 0; charge--) {  	currentIsotopes [0] = 0;  	currentIsotopes [1] = 0;  	currentIsotopes [2] = 0;  	currentIsotopes [3] = 0;  	double score = 0;  	int potentialIsotopeIndex = lowMassIndex + 1;  	for (int isotope = 1; isotope <= 4; isotope++) {  		double bestMassError = isotopicMzTolerance.Value;  		double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  		while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  			if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  				double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  				if (massError < bestMassError) {  					bestMassError = massError;  					currentIsotopes [isotope - 1] = potentialIsotopeIndex;  				}  			}  			potentialIsotopeIndex++;  		}  		score += isotopicMzTolerance.Value - bestMassError;  		if (score == 0)  			break;  		;  	}  	if (score > bestChargeScore) {  		bestIsotopes [0] = currentIsotopes [0];  		bestIsotopes [1] = currentIsotopes [1];  		bestIsotopes [2] = currentIsotopes [2];  		bestIsotopes [3] = currentIsotopes [3];  		bestChargeScore = score;  		bestCharge = charge;  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int charge = maxCharge; charge > 0; charge--) {  	currentIsotopes [0] = 0;  	currentIsotopes [1] = 0;  	currentIsotopes [2] = 0;  	currentIsotopes [3] = 0;  	double score = 0;  	int potentialIsotopeIndex = lowMassIndex + 1;  	for (int isotope = 1; isotope <= 4; isotope++) {  		double bestMassError = isotopicMzTolerance.Value;  		double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  		while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  			if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  				double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  				if (massError < bestMassError) {  					bestMassError = massError;  					currentIsotopes [isotope - 1] = potentialIsotopeIndex;  				}  			}  			potentialIsotopeIndex++;  		}  		score += isotopicMzTolerance.Value - bestMassError;  		if (score == 0)  			break;  		;  	}  	if (score > bestChargeScore) {  		bestIsotopes [0] = currentIsotopes [0];  		bestIsotopes [1] = currentIsotopes [1];  		bestIsotopes [2] = currentIsotopes [2];  		bestIsotopes [3] = currentIsotopes [3];  		bestChargeScore = score;  		bestCharge = charge;  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int charge = maxCharge; charge > 0; charge--) {  	currentIsotopes [0] = 0;  	currentIsotopes [1] = 0;  	currentIsotopes [2] = 0;  	currentIsotopes [3] = 0;  	double score = 0;  	int potentialIsotopeIndex = lowMassIndex + 1;  	for (int isotope = 1; isotope <= 4; isotope++) {  		double bestMassError = isotopicMzTolerance.Value;  		double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  		while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  			if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  				double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  				if (massError < bestMassError) {  					bestMassError = massError;  					currentIsotopes [isotope - 1] = potentialIsotopeIndex;  				}  			}  			potentialIsotopeIndex++;  		}  		score += isotopicMzTolerance.Value - bestMassError;  		if (score == 0)  			break;  		;  	}  	if (score > bestChargeScore) {  		bestIsotopes [0] = currentIsotopes [0];  		bestIsotopes [1] = currentIsotopes [1];  		bestIsotopes [2] = currentIsotopes [2];  		bestIsotopes [3] = currentIsotopes [3];  		bestChargeScore = score;  		bestCharge = charge;  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int charge = maxCharge; charge > 0; charge--) {  	currentIsotopes [0] = 0;  	currentIsotopes [1] = 0;  	currentIsotopes [2] = 0;  	currentIsotopes [3] = 0;  	double score = 0;  	int potentialIsotopeIndex = lowMassIndex + 1;  	for (int isotope = 1; isotope <= 4; isotope++) {  		double bestMassError = isotopicMzTolerance.Value;  		double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  		while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  			if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  				double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  				if (massError < bestMassError) {  					bestMassError = massError;  					currentIsotopes [isotope - 1] = potentialIsotopeIndex;  				}  			}  			potentialIsotopeIndex++;  		}  		score += isotopicMzTolerance.Value - bestMassError;  		if (score == 0)  			break;  		;  	}  	if (score > bestChargeScore) {  		bestIsotopes [0] = currentIsotopes [0];  		bestIsotopes [1] = currentIsotopes [1];  		bestIsotopes [2] = currentIsotopes [2];  		bestIsotopes [3] = currentIsotopes [3];  		bestChargeScore = score;  		bestCharge = charge;  	}  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: currentIsotopes [2] = 0;  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: currentIsotopes [3] = 0;  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int isotope = 1; isotope <= 4; isotope++) {  	double bestMassError = isotopicMzTolerance.Value;  	double aim = Numerics.IsotopicMassShift (isotope' charge) + new_peaks [lowMassIndex].MZ;  	while (potentialIsotopeIndex < new_peaks.Count && new_peaks [potentialIsotopeIndex].MZ < aim + bestMassError) {  		if (new_peaks [lowMassIndex].Intensity > new_peaks [potentialIsotopeIndex].Intensity) {  			double massError = Math.Abs (Numerics.CalculateMassError (new_peaks [potentialIsotopeIndex].MZ' aim' isotopicMzTolerance.Units));  			if (massError < bestMassError) {  				bestMassError = massError;  				currentIsotopes [isotope - 1] = potentialIsotopeIndex;  			}  		}  		potentialIsotopeIndex++;  	}  	score += isotopicMzTolerance.Value - bestMassError;  	if (score == 0)  		break;  	;  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: if (score > bestChargeScore) {  	bestIsotopes [0] = currentIsotopes [0];  	bestIsotopes [1] = currentIsotopes [1];  	bestIsotopes [2] = currentIsotopes [2];  	bestIsotopes [3] = currentIsotopes [3];  	bestChargeScore = score;  	bestCharge = charge;  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: if (score > bestChargeScore) {  	bestIsotopes [0] = currentIsotopes [0];  	bestIsotopes [1] = currentIsotopes [1];  	bestIsotopes [2] = currentIsotopes [2];  	bestIsotopes [3] = currentIsotopes [3];  	bestChargeScore = score;  	bestCharge = charge;  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: if (score > bestChargeScore) {  	bestIsotopes [0] = currentIsotopes [0];  	bestIsotopes [1] = currentIsotopes [1];  	bestIsotopes [2] = currentIsotopes [2];  	bestIsotopes [3] = currentIsotopes [3];  	bestChargeScore = score;  	bestCharge = charge;  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: if (score > bestChargeScore) {  	bestIsotopes [0] = currentIsotopes [0];  	bestIsotopes [1] = currentIsotopes [1];  	bestIsotopes [2] = currentIsotopes [2];  	bestIsotopes [3] = currentIsotopes [3];  	bestChargeScore = score;  	bestCharge = charge;  }  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: bestIsotopes [2] = currentIsotopes [2];  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: bestIsotopes [2] = currentIsotopes [2];  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: bestIsotopes [3] = currentIsotopes [3];  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: bestIsotopes [3] = currentIsotopes [3];  
Magic Number,PeptidAce,Spectra,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Spectra.cs,AssignChargeStatesAndDeisotope,The following statement contains a magic number: for (int i = 3; i >= 0; i--)  	if (bestIsotopes [i] > 0) {  		new_peaks [lowMassIndex].Intensity += new_peaks [bestIsotopes [i]].Intensity;  		new_peaks.RemoveAt (bestIsotopes [i]);  	}  
Magic Number,PeptidAce,ProductSpectrum,C:\repos\olivierlizotte_PeptidAce.Library\Structures\ProductSpectrum.cs,BinarySearchMz,The following statement contains a magic number: while (low_index <= high_index) {  	int mid_index = low_index + ((high_index - low_index) / 2);  	int comparison = Peaks [mid_index].MZ.CompareTo (theoMz);  	if (comparison == 0) {  		return mid_index;  	}  	if (comparison < 0) {  		low_index = mid_index + 1;  	}  	else {  		high_index = mid_index - 1;  	}  }  
Magic Number,PeptidAce,ProteaseDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ProteaseDictionary.cs,ProteaseDictionary,The following statement contains a magic number: using (StreamReader proteases = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "proteases.tsv"))) {  	string header = proteases.ReadLine ();  	while (proteases.Peek () != -1) {  		string line = proteases.ReadLine ();  		string[] fields = line.Split ('\t');  		string name = fields [0];  		string amino_acids_inducing_cleavage = fields [1];  		string amino_acids_preventing_cleavage = fields [2];  		Terminus cleavage_terminus = (Terminus)Enum.Parse (typeof(Terminus)' fields [3]);  		CleavageSpecificity cleavage_specificity = (CleavageSpecificity)Enum.Parse (typeof(CleavageSpecificity)' fields [4]);  		Protease protease = new Protease (name' amino_acids_inducing_cleavage' amino_acids_preventing_cleavage' cleavage_terminus' cleavage_specificity);  		Add (protease);  	}  }  
Magic Number,PeptidAce,ProteaseDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ProteaseDictionary.cs,ProteaseDictionary,The following statement contains a magic number: using (StreamReader proteases = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "proteases.tsv"))) {  	string header = proteases.ReadLine ();  	while (proteases.Peek () != -1) {  		string line = proteases.ReadLine ();  		string[] fields = line.Split ('\t');  		string name = fields [0];  		string amino_acids_inducing_cleavage = fields [1];  		string amino_acids_preventing_cleavage = fields [2];  		Terminus cleavage_terminus = (Terminus)Enum.Parse (typeof(Terminus)' fields [3]);  		CleavageSpecificity cleavage_specificity = (CleavageSpecificity)Enum.Parse (typeof(CleavageSpecificity)' fields [4]);  		Protease protease = new Protease (name' amino_acids_inducing_cleavage' amino_acids_preventing_cleavage' cleavage_terminus' cleavage_specificity);  		Add (protease);  	}  }  
Magic Number,PeptidAce,ProteaseDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ProteaseDictionary.cs,ProteaseDictionary,The following statement contains a magic number: using (StreamReader proteases = new StreamReader (Path.Combine (Path.GetDirectoryName (Environment.GetCommandLineArgs () [0])' "Configuration"' "proteases.tsv"))) {  	string header = proteases.ReadLine ();  	while (proteases.Peek () != -1) {  		string line = proteases.ReadLine ();  		string[] fields = line.Split ('\t');  		string name = fields [0];  		string amino_acids_inducing_cleavage = fields [1];  		string amino_acids_preventing_cleavage = fields [2];  		Terminus cleavage_terminus = (Terminus)Enum.Parse (typeof(Terminus)' fields [3]);  		CleavageSpecificity cleavage_specificity = (CleavageSpecificity)Enum.Parse (typeof(CleavageSpecificity)' fields [4]);  		Protease protease = new Protease (name' amino_acids_inducing_cleavage' amino_acids_preventing_cleavage' cleavage_terminus' cleavage_specificity);  		Add (protease);  	}  }  
Magic Number,PeptidAce,ProteaseDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ProteaseDictionary.cs,ProteaseDictionary,The following statement contains a magic number: while (proteases.Peek () != -1) {  	string line = proteases.ReadLine ();  	string[] fields = line.Split ('\t');  	string name = fields [0];  	string amino_acids_inducing_cleavage = fields [1];  	string amino_acids_preventing_cleavage = fields [2];  	Terminus cleavage_terminus = (Terminus)Enum.Parse (typeof(Terminus)' fields [3]);  	CleavageSpecificity cleavage_specificity = (CleavageSpecificity)Enum.Parse (typeof(CleavageSpecificity)' fields [4]);  	Protease protease = new Protease (name' amino_acids_inducing_cleavage' amino_acids_preventing_cleavage' cleavage_terminus' cleavage_specificity);  	Add (protease);  }  
Magic Number,PeptidAce,ProteaseDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ProteaseDictionary.cs,ProteaseDictionary,The following statement contains a magic number: while (proteases.Peek () != -1) {  	string line = proteases.ReadLine ();  	string[] fields = line.Split ('\t');  	string name = fields [0];  	string amino_acids_inducing_cleavage = fields [1];  	string amino_acids_preventing_cleavage = fields [2];  	Terminus cleavage_terminus = (Terminus)Enum.Parse (typeof(Terminus)' fields [3]);  	CleavageSpecificity cleavage_specificity = (CleavageSpecificity)Enum.Parse (typeof(CleavageSpecificity)' fields [4]);  	Protease protease = new Protease (name' amino_acids_inducing_cleavage' amino_acids_preventing_cleavage' cleavage_terminus' cleavage_specificity);  	Add (protease);  }  
Magic Number,PeptidAce,ProteaseDictionary,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\ProteaseDictionary.cs,ProteaseDictionary,The following statement contains a magic number: while (proteases.Peek () != -1) {  	string line = proteases.ReadLine ();  	string[] fields = line.Split ('\t');  	string name = fields [0];  	string amino_acids_inducing_cleavage = fields [1];  	string amino_acids_preventing_cleavage = fields [2];  	Terminus cleavage_terminus = (Terminus)Enum.Parse (typeof(Terminus)' fields [3]);  	CleavageSpecificity cleavage_specificity = (CleavageSpecificity)Enum.Parse (typeof(CleavageSpecificity)' fields [4]);  	Protease protease = new Protease (name' amino_acids_inducing_cleavage' amino_acids_preventing_cleavage' cleavage_terminus' cleavage_specificity);  	Add (protease);  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: foreach (Modification variable_modification in variableModifications) {  	if (variable_modification.Type == ModificationType.ProteinNTerminus) {  		List<Modification> prot_n_term_variable_mods;  		if (!possible_modifications.TryGetValue (0' out prot_n_term_variable_mods)) {  			prot_n_term_variable_mods = new List<Modification> ();  			prot_n_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (0' prot_n_term_variable_mods);  		}  		else {  			prot_n_term_variable_mods.Add (variable_modification);  		}  	}  	for (int r = 0; r < Length; r++) {  		if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  			List<Modification> residue_variable_mods;  			if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  				residue_variable_mods = new List<Modification> ();  				residue_variable_mods.Add (variable_modification);  				possible_modifications.Add (r + 2' residue_variable_mods);  			}  			else {  				residue_variable_mods.Add (variable_modification);  			}  		}  	}  	if (variable_modification.Type == ModificationType.ProteinCTerminus) {  		List<Modification> prot_c_term_variable_mods;  		if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  			prot_c_term_variable_mods = new List<Modification> ();  			prot_c_term_variable_mods.Add (variable_modification);  			possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  		}  		else {  			prot_c_term_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: for (int r = 0; r < Length; r++) {  	if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  		List<Modification> residue_variable_mods;  		if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  			residue_variable_mods = new List<Modification> ();  			residue_variable_mods.Add (variable_modification);  			possible_modifications.Add (r + 2' residue_variable_mods);  		}  		else {  			residue_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: for (int r = 0; r < Length; r++) {  	if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  		List<Modification> residue_variable_mods;  		if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  			residue_variable_mods = new List<Modification> ();  			residue_variable_mods.Add (variable_modification);  			possible_modifications.Add (r + 2' residue_variable_mods);  		}  		else {  			residue_variable_mods.Add (variable_modification);  		}  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  	List<Modification> residue_variable_mods;  	if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  		residue_variable_mods = new List<Modification> ();  		residue_variable_mods.Add (variable_modification);  		possible_modifications.Add (r + 2' residue_variable_mods);  	}  	else {  		residue_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: if (variable_modification.Type == ModificationType.AminoAcidResidue && this [r] == variable_modification.AminoAcid) {  	List<Modification> residue_variable_mods;  	if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  		residue_variable_mods = new List<Modification> ();  		residue_variable_mods.Add (variable_modification);  		possible_modifications.Add (r + 2' residue_variable_mods);  	}  	else {  		residue_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  	residue_variable_mods = new List<Modification> ();  	residue_variable_mods.Add (variable_modification);  	possible_modifications.Add (r + 2' residue_variable_mods);  }  else {  	residue_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: if (!possible_modifications.TryGetValue (r + 2' out residue_variable_mods)) {  	residue_variable_mods = new List<Modification> ();  	residue_variable_mods.Add (variable_modification);  	possible_modifications.Add (r + 2' residue_variable_mods);  }  else {  	residue_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: possible_modifications.Add (r + 2' residue_variable_mods);  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: if (variable_modification.Type == ModificationType.ProteinCTerminus) {  	List<Modification> prot_c_term_variable_mods;  	if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  		prot_c_term_variable_mods = new List<Modification> ();  		prot_c_term_variable_mods.Add (variable_modification);  		possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  	}  	else {  		prot_c_term_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: if (variable_modification.Type == ModificationType.ProteinCTerminus) {  	List<Modification> prot_c_term_variable_mods;  	if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  		prot_c_term_variable_mods = new List<Modification> ();  		prot_c_term_variable_mods.Add (variable_modification);  		possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  	}  	else {  		prot_c_term_variable_mods.Add (variable_modification);  	}  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  	prot_c_term_variable_mods = new List<Modification> ();  	prot_c_term_variable_mods.Add (variable_modification);  	possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  }  else {  	prot_c_term_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: if (!possible_modifications.TryGetValue (Length + 3' out prot_c_term_variable_mods)) {  	prot_c_term_variable_mods = new List<Modification> ();  	prot_c_term_variable_mods.Add (variable_modification);  	possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  }  else {  	prot_c_term_variable_mods.Add (variable_modification);  }  
Magic Number,PeptidAce,Protein,C:\repos\olivierlizotte_PeptidAce.Library\Morpheus\Protein.cs,GetVariablyModifiedProteins,The following statement contains a magic number: possible_modifications.Add (Length + 3' prot_c_term_variable_mods);  
Magic Number,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The following statement contains a magic number: while (true) {  	string line = fasta.ReadLine ();  	if (line.StartsWith (">")) {  		description = line.Substring (1);  	}  	else {  		sequence += line.Trim ();  	}  	if (fasta.Peek () == '>' || fasta.Peek () == -1) {  		Protein protein = new Protein (sequence' description' false);  		yield return protein;  		if (onTheFlyDecoys) {  			if (protein.Decoy) {  				throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled");  			}  			char[] sequence_array = sequence.ToCharArray ();  			if (sequence.StartsWith ("M")) {  				Array.Reverse (sequence_array' 1' sequence.Length - 1);  			}  			else {  				Array.Reverse (sequence_array);  			}  			string reversed_sequence = new string (sequence_array);  			Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true);  			yield return decoy_protein;  			//*/  		}  		description = null;  		sequence = null;  		if (fasta.Peek () == -1) {  			break;  		}  	}  }  
Magic Number,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The following statement contains a magic number: while (true) {  	string line = fasta.ReadLine ();  	if (line.StartsWith (">")) {  		description = line.Substring (1);  	}  	else {  		sequence += line.Trim ();  	}  	if (fasta.Peek () == '>' || fasta.Peek () == -1) {  		Protein protein = new Protein (sequence' description' false);  		yield return protein;  		if (onTheFlyDecoys) {  			if (protein.Decoy) {  				throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled");  			}  			char[] sequence_array = sequence.ToCharArray ();  			if (sequence.StartsWith ("M")) {  				Array.Reverse (sequence_array' 1' sequence.Length - 1);  			}  			else {  				Array.Reverse (sequence_array);  			}  			string reversed_sequence = new string (sequence_array);  			Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true);  			yield return decoy_protein;  			//*/  		}  		description = null;  		sequence = null;  		if (fasta.Peek () == -1) {  			break;  		}  	}  }  
Magic Number,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The following statement contains a magic number: while (true) {  	string line = fasta.ReadLine ();  	if (line.StartsWith (">")) {  		description = line.Substring (1);  	}  	else {  		sequence += line.Trim ();  	}  	if (fasta.Peek () == '>' || fasta.Peek () == -1) {  		Protein protein = new Protein (sequence' description' false);  		yield return protein;  		if (onTheFlyDecoys) {  			if (protein.Decoy) {  				throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled");  			}  			char[] sequence_array = sequence.ToCharArray ();  			if (sequence.StartsWith ("M")) {  				Array.Reverse (sequence_array' 1' sequence.Length - 1);  			}  			else {  				Array.Reverse (sequence_array);  			}  			string reversed_sequence = new string (sequence_array);  			Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true);  			yield return decoy_protein;  			//*/  		}  		description = null;  		sequence = null;  		if (fasta.Peek () == -1) {  			break;  		}  	}  }  
Magic Number,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The following statement contains a magic number: if (fasta.Peek () == '>' || fasta.Peek () == -1) {  	Protein protein = new Protein (sequence' description' false);  	yield return protein;  	if (onTheFlyDecoys) {  		if (protein.Decoy) {  			throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled");  		}  		char[] sequence_array = sequence.ToCharArray ();  		if (sequence.StartsWith ("M")) {  			Array.Reverse (sequence_array' 1' sequence.Length - 1);  		}  		else {  			Array.Reverse (sequence_array);  		}  		string reversed_sequence = new string (sequence_array);  		Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true);  		yield return decoy_protein;  		//*/  	}  	description = null;  	sequence = null;  	if (fasta.Peek () == -1) {  		break;  	}  }  
Magic Number,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The following statement contains a magic number: if (fasta.Peek () == '>' || fasta.Peek () == -1) {  	Protein protein = new Protein (sequence' description' false);  	yield return protein;  	if (onTheFlyDecoys) {  		if (protein.Decoy) {  			throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled");  		}  		char[] sequence_array = sequence.ToCharArray ();  		if (sequence.StartsWith ("M")) {  			Array.Reverse (sequence_array' 1' sequence.Length - 1);  		}  		else {  			Array.Reverse (sequence_array);  		}  		string reversed_sequence = new string (sequence_array);  		Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true);  		yield return decoy_protein;  		//*/  	}  	description = null;  	sequence = null;  	if (fasta.Peek () == -1) {  		break;  	}  }  
Magic Number,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The following statement contains a magic number: if (fasta.Peek () == '>' || fasta.Peek () == -1) {  	Protein protein = new Protein (sequence' description' false);  	yield return protein;  	if (onTheFlyDecoys) {  		if (protein.Decoy) {  			throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled");  		}  		char[] sequence_array = sequence.ToCharArray ();  		if (sequence.StartsWith ("M")) {  			Array.Reverse (sequence_array' 1' sequence.Length - 1);  		}  		else {  			Array.Reverse (sequence_array);  		}  		string reversed_sequence = new string (sequence_array);  		Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true);  		yield return decoy_protein;  		//*/  	}  	description = null;  	sequence = null;  	if (fasta.Peek () == -1) {  		break;  	}  }  
Magic Number,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The following statement contains a magic number: if (onTheFlyDecoys) {  	if (protein.Decoy) {  		throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled");  	}  	char[] sequence_array = sequence.ToCharArray ();  	if (sequence.StartsWith ("M")) {  		Array.Reverse (sequence_array' 1' sequence.Length - 1);  	}  	else {  		Array.Reverse (sequence_array);  	}  	string reversed_sequence = new string (sequence_array);  	Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true);  	yield return decoy_protein;  	//*/  }  
Magic Number,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The following statement contains a magic number: if (onTheFlyDecoys) {  	if (protein.Decoy) {  		throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled");  	}  	char[] sequence_array = sequence.ToCharArray ();  	if (sequence.StartsWith ("M")) {  		Array.Reverse (sequence_array' 1' sequence.Length - 1);  	}  	else {  		Array.Reverse (sequence_array);  	}  	string reversed_sequence = new string (sequence_array);  	Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true);  	yield return decoy_protein;  	//*/  }  
Magic Number,PeptidAce,ProteinFastaReader,C:\repos\olivierlizotte_PeptidAce.Library\ProteinFastaReader.cs,ReadProteins,The following statement contains a magic number: if (onTheFlyDecoys) {  	if (protein.Decoy) {  		throw new ArgumentException (proteinFastaDatabase.Name + " contains decoy proteins; database should not contain decoy proteins when \"create target–decoy database on the fly\" option is enabled");  	}  	char[] sequence_array = sequence.ToCharArray ();  	if (sequence.StartsWith ("M")) {  		Array.Reverse (sequence_array' 1' sequence.Length - 1);  	}  	else {  		Array.Reverse (sequence_array);  	}  	string reversed_sequence = new string (sequence_array);  	Protein decoy_protein = new Protein (reversed_sequence' (description.Length > 2 && description [2] == '|') ? description.Insert (3' "DECOY_") : "DECOY_" + description' true);  	yield return decoy_protein;  	//*/  }  
Magic Number,PeptidAce,ProteinGroupMatch,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ToString,The following statement contains a magic number: if (Proteins.Count > 0) {  	foreach (Protein protein in this.Proteins) {  		description.Append (protein.Description.Replace ('''' ' ') + " / ");  		sequence.Append (protein.Sequence + '/');  		length.Append (protein.Sequence.Length.ToString () + '/');  	}  	description = description.Remove (description.Length - 3' 3);  	sequence = sequence.Remove (sequence.Length - 1' 1);  	length = length.Remove (length.Length - 1' 1);  }  
Magic Number,PeptidAce,ProteinGroupMatch,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ToString,The following statement contains a magic number: if (Proteins.Count > 0) {  	foreach (Protein protein in this.Proteins) {  		description.Append (protein.Description.Replace ('''' ' ') + " / ");  		sequence.Append (protein.Sequence + '/');  		length.Append (protein.Sequence.Length.ToString () + '/');  	}  	description = description.Remove (description.Length - 3' 3);  	sequence = sequence.Remove (sequence.Length - 1' 1);  	length = length.Remove (length.Length - 1' 1);  }  
Magic Number,PeptidAce,ProteinGroupMatch,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ToString,The following statement contains a magic number: description = description.Remove (description.Length - 3' 3);  
Magic Number,PeptidAce,ProteinGroupMatch,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ToString,The following statement contains a magic number: description = description.Remove (description.Length - 3' 3);  
Magic Number,PeptidAce,ProteinGroupMatch,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ToString,The following statement contains a magic number: if (Proteins.Count > 0) {  	foreach (Protein protein in this.Proteins)  		sequence_coverage.Append ((CalculateSequenceCoverage (PeptideMatches' protein) * 100.0).ToString () + '/');  	sequence_coverage = sequence_coverage.Remove (sequence_coverage.Length - 1' 1);  }  
Magic Number,PeptidAce,ProteinGroupMatch,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ToString,The following statement contains a magic number: foreach (Protein protein in this.Proteins)  	sequence_coverage.Append ((CalculateSequenceCoverage (PeptideMatches' protein) * 100.0).ToString () + '/');  
Magic Number,PeptidAce,ProteinGroupMatch,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ToString,The following statement contains a magic number: sequence_coverage.Append ((CalculateSequenceCoverage (PeptideMatches' protein) * 100.0).ToString () + '/');  
Magic Number,PeptidAce,ProteinSearcher,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ProteinDigest,The following statement contains a magic number: foreach (Protein protein in Proteins) {  	nbProteins++;  	if (tooLong)  		break;  	List<int> indices = options.DigestionEnzyme.GetDigestionSiteIndices (protein);  	indices.Insert (0' -1);  	indices.Add (protein.Length - 1);  	for (int missed_cleavages = 0; missed_cleavages <= options.ToleratedMissedCleavages; missed_cleavages++) {  		for (int i = 0; i < indices.Count - missed_cleavages - 1; i++) {  			if (indices [i + missed_cleavages + 1] + 1 - (indices [i] + 1 + 1) + 1 >= options.MinimumPeptideLength) {  				if (options.initiatorMethionineBehavior != InitiatorMethionineBehavior.Cleave || indices [i] + 1 != 0 || protein [0] != 'M') {  					Peptide newPep = new Peptide (protein' indices [i] + 1' indices [i + missed_cleavages + 1]' missed_cleavages);  					yield return newPep;  					if (allowSNP)  						foreach (Peptide possibleSnp in newPep.GetSNPsdPeptides ())  							yield return possibleSnp;  				}  				if (options.initiatorMethionineBehavior != InitiatorMethionineBehavior.Retain && indices [i] + 1 == 0 && protein [0] == 'M') {  					Peptide newPep = new Peptide (protein' indices [i] + 1 + 1' indices [i + missed_cleavages + 1]' missed_cleavages);  					yield return newPep;  					if (allowSNP)  						foreach (Peptide possibleSnp in newPep.GetSNPsdPeptides ())  							yield return possibleSnp;  				}  			}  		}  	}  	Console.Write ("\r{0}%   "' ((100 * nbProteins) / Proteins.Count));  }  
Magic Number,PeptidAce,ProteinSearcher,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ProteinDigest,The following statement contains a magic number: Console.Write ("\r{0}%   "' ((100 * nbProteins) / Proteins.Count));  
Magic Number,PeptidAce,ProteinSearcher,C:\repos\olivierlizotte_PeptidAce.Library\ProteinSearcher.cs,ProteinDigest,The following statement contains a magic number: Console.Write ("\r{0}%   "' 100);  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The following statement contains a magic number: foreach (ProductSpectrum spectrum in spectra) {  	NbSpectrum++;  	double intensityCumul = 0.0;  	bool foundCharge = false;  	Track closestTrack = null;  	List<Query> newQueries = new List<Query> ();  	//TODO No threshold on sdf files' and preferably a C# routine that does what MassSense do  	foreach (Track track in tracks.GetTracksInMzRange (spectrum.PrecursorMZ' spectrum.IsolationWindow * dbOptions.EffectiveIsolationWindowRatio))//TODO Optimize this value  	 {  		Precursor prec = null;  		if (track.RT_Min <= spectrum.RetentionTimeInMin && track.RT_Max >= spectrum.RetentionTimeInMin) {  			if (closestTrack == null || Math.Abs (track.MZ - spectrum.PrecursorMZ) < Math.Abs (closestTrack.MZ - spectrum.PrecursorMZ))  				closestTrack = track;  			if (Isotopes.ContainsKey (track))  				break;  			if (Tracks.ContainsKey (track))  				prec = Tracks [track];  			else {  				List<Precursor> isotopes = GetIsotopes (track' dbOptions' tracks' entry);  				if (isotopes.Count > 0) {  					prec = new Precursor (track' isotopes [0].Charge' entry' 0.0' isotopes);  					Tracks.Add (track' prec);  					prec.OtherCharges = GetOtherCharges (prec' dbOptions' tracks' entry);  					foreach (Precursor isotope in prec.Isotopes)  						if (!Isotopes.ContainsKey (isotope.Track))  							Isotopes.Add (isotope.Track' isotope);  				}  			}  			if (prec != null) {  				intensityCumul += track.INTENSITY;  				newQueries.Add (new Query (dbOptions' entry' spectrum' prec' NbSpectrum));  				if (prec.Charge == spectrum.PrecursorCharge)  					foundCharge = true;  			}  		}  	}  	if (!foundCharge) {  		/*if (closestTrack != null && Tracks.ContainsKey(closestTrack) && Math.Abs(Numerics.CalculateMassError(closestTrack.MZ' spectrum.PrecursorMZ' dbOptions.precursorMassTolerance.Units)) < dbOptions.precursorMassTolerance.Value)                     {                         if(closestTrack.RT_Min > (float)(spectrum.RetentionTimeInMin - dbOptions.ComputedRetentionTimeDiff))                             closestTrack.RT_Min = (float)(spectrum.RetentionTimeInMin - dbOptions.ComputedRetentionTimeDiff);                         if (closestTrack.RT_Max < (float)(spectrum.RetentionTimeInMin + dbOptions.ComputedRetentionTimeDiff))                             closestTrack.RT_Max = (float)(spectrum.RetentionTimeInMin + dbOptions.ComputedRetentionTimeDiff);                         if (closestTrack.INTENSITY < spectrum.PrecursorIntensity)                             closestTrack.INTENSITY = spectrum.PrecursorIntensity;                          Precursor prec = Tracks[closestTrack];                         if (prec.Charge == spectrum.PrecursorCharge)                         {                             Add(new Query(dbOptions' entry' spectrum' prec' NbSpectrum));                         }                         else                         {                             Precursor newPrec = new Precursor(closestTrack' spectrum.PrecursorCharge' entry);                             Add(new Query(dbOptions' entry' spectrum' newPrec' NbSpectrum));                         }                     }                     else//*/{  			nbMissedTrack++;  			closestTrack = new Track ((float)spectrum.PrecursorMZ' (float)spectrum.RetentionTimeInMin' spectrum.PrecursorIntensity' (float)(spectrum.RetentionTimeInMin - dbOptions.ComputedRetentionTimeDiff)' (float)(spectrum.RetentionTimeInMin + dbOptions.ComputedRetentionTimeDiff)' true);  			Precursor prec = new Precursor (closestTrack' spectrum.PrecursorCharge' entry);  			Tracks.Add (closestTrack' prec);  			Add (new Query (dbOptions' entry' spectrum' prec' NbSpectrum));  		}  	}  	//*/  	if (newQueries.Count > 0) {  		//Remove precursors if estimated fragment intensities are too low (based on precursor intensity ratios and isolation window placement)  		foreach (Query q in newQueries) {  			//if (q.precursor.Track.INTENSITY > intensityCumul * dbOptions.MinimumPrecursorIntensityRatioInIsolationWindow)//Need to be 5% of all intensity  			//{  			this.Add (q);  			//}  		}  	}  	Console.Write ("\r{0}%   "' ((100 * NbSpectrum) / spectra.Count));  }  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The following statement contains a magic number: Console.Write ("\r{0}%   "' ((100 * NbSpectrum) / spectra.Count));  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GenerateQueries,The following statement contains a magic number: Console.Write ("\r{0}%   "' 100);  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetIsotopes,The following statement contains a magic number: if (dbOptions.precursorMassTolerance.Units == MassToleranceUnits.ppm)  	isotopicMzTolerance = (isotopicMzTolerance / 1e6) * track.MZ;  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetIsotopes,The following statement contains a magic number: isotopicMzTolerance = (isotopicMzTolerance / 1e6) * track.MZ;  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetIsotopes,The following statement contains a magic number: for (int charge = dbOptions.MaximumPrecursorChargeState; charge >= dbOptions.MinimumPrecursorChargeState; charge--) {  	List<Precursor> isotopes = new List<Precursor> ();  	for (int nbIsotope = 1; nbIsotope < 5; nbIsotope++) {  		double bestDeltaMz = isotopicMzTolerance;  		Track bestTrack = null;  		double massShift = Numerics.IsotopicMassShift (nbIsotope' charge);  		double mzIsotope = track.MZ + massShift;  		foreach (Track trackToTest in listTracks.GetTracksInMzRange (mzIsotope' isotopicMzTolerance)) {  			if (trackToTest.RT >= track.RT_Min && trackToTest.RT <= track.RT_Max) {  				double mzDiff = Math.Abs (mzIsotope - trackToTest.MZ);  				if (mzDiff < bestDeltaMz)//TODO Is the best isotope the most precise one or the most intense?? Use a scoring function!  				 {  					bestDeltaMz = mzDiff;  					bestTrack = trackToTest;  				}  			}  		}  		if (bestTrack != null)  			isotopes.Add (new Precursor (bestTrack' charge' entry' Constants.C12_C13_MASS_DIFFERENCE * nbIsotope' null));  		else  			break;  	}  	if (isotopes.Count > bestIsotopes.Count)  		//TODO Best way to compare isotope potentials? Number of isotopes? Delta Mass? Intensity ratios?  		bestIsotopes = isotopes;  }  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetIsotopes,The following statement contains a magic number: for (int nbIsotope = 1; nbIsotope < 5; nbIsotope++) {  	double bestDeltaMz = isotopicMzTolerance;  	Track bestTrack = null;  	double massShift = Numerics.IsotopicMassShift (nbIsotope' charge);  	double mzIsotope = track.MZ + massShift;  	foreach (Track trackToTest in listTracks.GetTracksInMzRange (mzIsotope' isotopicMzTolerance)) {  		if (trackToTest.RT >= track.RT_Min && trackToTest.RT <= track.RT_Max) {  			double mzDiff = Math.Abs (mzIsotope - trackToTest.MZ);  			if (mzDiff < bestDeltaMz)//TODO Is the best isotope the most precise one or the most intense?? Use a scoring function!  			 {  				bestDeltaMz = mzDiff;  				bestTrack = trackToTest;  			}  		}  	}  	if (bestTrack != null)  		isotopes.Add (new Precursor (bestTrack' charge' entry' Constants.C12_C13_MASS_DIFFERENCE * nbIsotope' null));  	else  		break;  }  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetOtherCharges,The following statement contains a magic number: for (int charge = dbOptions.MaximumPrecursorChargeState; charge >= 1; charge--) {  	if (charge != precursor.Charge) {  		double aimedMZ = Numerics.MZFromMass (precursor.Mass' charge);  		double chargeMzTolerance = dbOptions.precursorMassTolerance.Value * 0.5;  		if (dbOptions.precursorMassTolerance.Units == MassToleranceUnits.ppm)  			chargeMzTolerance = (chargeMzTolerance / 1e6) * aimedMZ;  		double bestDeltaMz = chargeMzTolerance;  		Track bestTrack = null;  		foreach (Track trackToTest in listTracks.GetTracksInMzRange (aimedMZ' chargeMzTolerance)) {  			if (trackToTest.RT >= precursor.Track.RT_Min && trackToTest.RT <= precursor.Track.RT_Max) {  				double mzDiff = Math.Abs (aimedMZ - trackToTest.MZ);  				if (mzDiff < bestDeltaMz)//TODO Is the best isotope the most precise one or the closest in intensity?? Use a scoring function to get both!  				 {  					bestDeltaMz = mzDiff;  					bestTrack = trackToTest;  				}  			}  		}  		if (bestTrack != null)  			otherPrecursor.Add (new Precursor (bestTrack' charge' precursor.sample' 0' GetIsotopes (bestTrack' dbOptions' listTracks' entry)));  	}  }  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetOtherCharges,The following statement contains a magic number: for (int charge = dbOptions.MaximumPrecursorChargeState; charge >= 1; charge--) {  	if (charge != precursor.Charge) {  		double aimedMZ = Numerics.MZFromMass (precursor.Mass' charge);  		double chargeMzTolerance = dbOptions.precursorMassTolerance.Value * 0.5;  		if (dbOptions.precursorMassTolerance.Units == MassToleranceUnits.ppm)  			chargeMzTolerance = (chargeMzTolerance / 1e6) * aimedMZ;  		double bestDeltaMz = chargeMzTolerance;  		Track bestTrack = null;  		foreach (Track trackToTest in listTracks.GetTracksInMzRange (aimedMZ' chargeMzTolerance)) {  			if (trackToTest.RT >= precursor.Track.RT_Min && trackToTest.RT <= precursor.Track.RT_Max) {  				double mzDiff = Math.Abs (aimedMZ - trackToTest.MZ);  				if (mzDiff < bestDeltaMz)//TODO Is the best isotope the most precise one or the closest in intensity?? Use a scoring function to get both!  				 {  					bestDeltaMz = mzDiff;  					bestTrack = trackToTest;  				}  			}  		}  		if (bestTrack != null)  			otherPrecursor.Add (new Precursor (bestTrack' charge' precursor.sample' 0' GetIsotopes (bestTrack' dbOptions' listTracks' entry)));  	}  }  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetOtherCharges,The following statement contains a magic number: if (charge != precursor.Charge) {  	double aimedMZ = Numerics.MZFromMass (precursor.Mass' charge);  	double chargeMzTolerance = dbOptions.precursorMassTolerance.Value * 0.5;  	if (dbOptions.precursorMassTolerance.Units == MassToleranceUnits.ppm)  		chargeMzTolerance = (chargeMzTolerance / 1e6) * aimedMZ;  	double bestDeltaMz = chargeMzTolerance;  	Track bestTrack = null;  	foreach (Track trackToTest in listTracks.GetTracksInMzRange (aimedMZ' chargeMzTolerance)) {  		if (trackToTest.RT >= precursor.Track.RT_Min && trackToTest.RT <= precursor.Track.RT_Max) {  			double mzDiff = Math.Abs (aimedMZ - trackToTest.MZ);  			if (mzDiff < bestDeltaMz)//TODO Is the best isotope the most precise one or the closest in intensity?? Use a scoring function to get both!  			 {  				bestDeltaMz = mzDiff;  				bestTrack = trackToTest;  			}  		}  	}  	if (bestTrack != null)  		otherPrecursor.Add (new Precursor (bestTrack' charge' precursor.sample' 0' GetIsotopes (bestTrack' dbOptions' listTracks' entry)));  }  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetOtherCharges,The following statement contains a magic number: if (charge != precursor.Charge) {  	double aimedMZ = Numerics.MZFromMass (precursor.Mass' charge);  	double chargeMzTolerance = dbOptions.precursorMassTolerance.Value * 0.5;  	if (dbOptions.precursorMassTolerance.Units == MassToleranceUnits.ppm)  		chargeMzTolerance = (chargeMzTolerance / 1e6) * aimedMZ;  	double bestDeltaMz = chargeMzTolerance;  	Track bestTrack = null;  	foreach (Track trackToTest in listTracks.GetTracksInMzRange (aimedMZ' chargeMzTolerance)) {  		if (trackToTest.RT >= precursor.Track.RT_Min && trackToTest.RT <= precursor.Track.RT_Max) {  			double mzDiff = Math.Abs (aimedMZ - trackToTest.MZ);  			if (mzDiff < bestDeltaMz)//TODO Is the best isotope the most precise one or the closest in intensity?? Use a scoring function to get both!  			 {  				bestDeltaMz = mzDiff;  				bestTrack = trackToTest;  			}  		}  	}  	if (bestTrack != null)  		otherPrecursor.Add (new Precursor (bestTrack' charge' precursor.sample' 0' GetIsotopes (bestTrack' dbOptions' listTracks' entry)));  }  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetOtherCharges,The following statement contains a magic number: if (dbOptions.precursorMassTolerance.Units == MassToleranceUnits.ppm)  	chargeMzTolerance = (chargeMzTolerance / 1e6) * aimedMZ;  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,GetOtherCharges,The following statement contains a magic number: chargeMzTolerance = (chargeMzTolerance / 1e6) * aimedMZ;  
Magic Number,PeptidAce,Queries,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Queries.cs,BinarySearch,The following statement contains a magic number: while (low_index <= high_index) {  	int mid_index = low_index + ((high_index - low_index) / 2);  	int comparison = this [mid_index].precursor.Mass.CompareTo (lowestPrecursorMass);  	if (comparison == 0) {  		while (mid_index > low_index && this [mid_index - 1].precursor.Mass.CompareTo (lowestPrecursorMass) == 0)  			mid_index--;  		return mid_index;  	}  	if (comparison < 0)  		low_index = mid_index + 1;  	else  		high_index = mid_index - 1;  }  
Magic Number,PeptidAce,Result,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Results.cs,Export,The following statement contains a magic number: dbOptions.ConSole.WriteLine ("Exporting at " + (fdr * 100) + "% FDR (Decoy/Target)...");  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	this.Clear ();  	// project csv file is comma delimited  	char[] splitter =  {  		'''  	};  	vsCSV csvProject = new vsCSV (project_file);  	for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  		try {  			string line = csvProject.LINES_LIST [i];  			lineNum++;  			string[] lineParts = line.Split (splitter);  			// skip header line  			if (lineNum == 1) {  				continue;  			}  			// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  			// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  			int condition = int.Parse (lineParts [0]);  			int replicate = int.Parse (lineParts [1]);  			int fraction = int.Parse (lineParts [2]);  			string peptideMap = lineParts [3];  			string sdf = lineParts [4];  			string nameCol = "";  			if (lineParts.Length >= 6)  				nameCol = lineParts [5];  			// KE Aug 7 2008 - lower case  			//OLI Why lower case? Files does not exist under linux!  			this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  		}  		catch (System.Exception ex) {  			dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  		}  	}  }  catch (Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4u34 : " + ex.Message + "  \n  " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	this.Clear ();  	// project csv file is comma delimited  	char[] splitter =  {  		'''  	};  	vsCSV csvProject = new vsCSV (project_file);  	for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  		try {  			string line = csvProject.LINES_LIST [i];  			lineNum++;  			string[] lineParts = line.Split (splitter);  			// skip header line  			if (lineNum == 1) {  				continue;  			}  			// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  			// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  			int condition = int.Parse (lineParts [0]);  			int replicate = int.Parse (lineParts [1]);  			int fraction = int.Parse (lineParts [2]);  			string peptideMap = lineParts [3];  			string sdf = lineParts [4];  			string nameCol = "";  			if (lineParts.Length >= 6)  				nameCol = lineParts [5];  			// KE Aug 7 2008 - lower case  			//OLI Why lower case? Files does not exist under linux!  			this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  		}  		catch (System.Exception ex) {  			dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  		}  	}  }  catch (Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4u34 : " + ex.Message + "  \n  " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	this.Clear ();  	// project csv file is comma delimited  	char[] splitter =  {  		'''  	};  	vsCSV csvProject = new vsCSV (project_file);  	for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  		try {  			string line = csvProject.LINES_LIST [i];  			lineNum++;  			string[] lineParts = line.Split (splitter);  			// skip header line  			if (lineNum == 1) {  				continue;  			}  			// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  			// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  			int condition = int.Parse (lineParts [0]);  			int replicate = int.Parse (lineParts [1]);  			int fraction = int.Parse (lineParts [2]);  			string peptideMap = lineParts [3];  			string sdf = lineParts [4];  			string nameCol = "";  			if (lineParts.Length >= 6)  				nameCol = lineParts [5];  			// KE Aug 7 2008 - lower case  			//OLI Why lower case? Files does not exist under linux!  			this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  		}  		catch (System.Exception ex) {  			dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  		}  	}  }  catch (Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4u34 : " + ex.Message + "  \n  " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	this.Clear ();  	// project csv file is comma delimited  	char[] splitter =  {  		'''  	};  	vsCSV csvProject = new vsCSV (project_file);  	for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  		try {  			string line = csvProject.LINES_LIST [i];  			lineNum++;  			string[] lineParts = line.Split (splitter);  			// skip header line  			if (lineNum == 1) {  				continue;  			}  			// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  			// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  			int condition = int.Parse (lineParts [0]);  			int replicate = int.Parse (lineParts [1]);  			int fraction = int.Parse (lineParts [2]);  			string peptideMap = lineParts [3];  			string sdf = lineParts [4];  			string nameCol = "";  			if (lineParts.Length >= 6)  				nameCol = lineParts [5];  			// KE Aug 7 2008 - lower case  			//OLI Why lower case? Files does not exist under linux!  			this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  		}  		catch (System.Exception ex) {  			dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  		}  	}  }  catch (Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4u34 : " + ex.Message + "  \n  " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	this.Clear ();  	// project csv file is comma delimited  	char[] splitter =  {  		'''  	};  	vsCSV csvProject = new vsCSV (project_file);  	for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  		try {  			string line = csvProject.LINES_LIST [i];  			lineNum++;  			string[] lineParts = line.Split (splitter);  			// skip header line  			if (lineNum == 1) {  				continue;  			}  			// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  			// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  			int condition = int.Parse (lineParts [0]);  			int replicate = int.Parse (lineParts [1]);  			int fraction = int.Parse (lineParts [2]);  			string peptideMap = lineParts [3];  			string sdf = lineParts [4];  			string nameCol = "";  			if (lineParts.Length >= 6)  				nameCol = lineParts [5];  			// KE Aug 7 2008 - lower case  			//OLI Why lower case? Files does not exist under linux!  			this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  		}  		catch (System.Exception ex) {  			dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  		}  	}  }  catch (Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4u34 : " + ex.Message + "  \n  " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  	try {  		string line = csvProject.LINES_LIST [i];  		lineNum++;  		string[] lineParts = line.Split (splitter);  		// skip header line  		if (lineNum == 1) {  			continue;  		}  		// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  		// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  		int condition = int.Parse (lineParts [0]);  		int replicate = int.Parse (lineParts [1]);  		int fraction = int.Parse (lineParts [2]);  		string peptideMap = lineParts [3];  		string sdf = lineParts [4];  		string nameCol = "";  		if (lineParts.Length >= 6)  			nameCol = lineParts [5];  		// KE Aug 7 2008 - lower case  		//OLI Why lower case? Files does not exist under linux!  		this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  	}  	catch (System.Exception ex) {  		dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  	}  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  	try {  		string line = csvProject.LINES_LIST [i];  		lineNum++;  		string[] lineParts = line.Split (splitter);  		// skip header line  		if (lineNum == 1) {  			continue;  		}  		// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  		// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  		int condition = int.Parse (lineParts [0]);  		int replicate = int.Parse (lineParts [1]);  		int fraction = int.Parse (lineParts [2]);  		string peptideMap = lineParts [3];  		string sdf = lineParts [4];  		string nameCol = "";  		if (lineParts.Length >= 6)  			nameCol = lineParts [5];  		// KE Aug 7 2008 - lower case  		//OLI Why lower case? Files does not exist under linux!  		this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  	}  	catch (System.Exception ex) {  		dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  	}  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  	try {  		string line = csvProject.LINES_LIST [i];  		lineNum++;  		string[] lineParts = line.Split (splitter);  		// skip header line  		if (lineNum == 1) {  			continue;  		}  		// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  		// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  		int condition = int.Parse (lineParts [0]);  		int replicate = int.Parse (lineParts [1]);  		int fraction = int.Parse (lineParts [2]);  		string peptideMap = lineParts [3];  		string sdf = lineParts [4];  		string nameCol = "";  		if (lineParts.Length >= 6)  			nameCol = lineParts [5];  		// KE Aug 7 2008 - lower case  		//OLI Why lower case? Files does not exist under linux!  		this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  	}  	catch (System.Exception ex) {  		dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  	}  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  	try {  		string line = csvProject.LINES_LIST [i];  		lineNum++;  		string[] lineParts = line.Split (splitter);  		// skip header line  		if (lineNum == 1) {  			continue;  		}  		// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  		// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  		int condition = int.Parse (lineParts [0]);  		int replicate = int.Parse (lineParts [1]);  		int fraction = int.Parse (lineParts [2]);  		string peptideMap = lineParts [3];  		string sdf = lineParts [4];  		string nameCol = "";  		if (lineParts.Length >= 6)  			nameCol = lineParts [5];  		// KE Aug 7 2008 - lower case  		//OLI Why lower case? Files does not exist under linux!  		this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  	}  	catch (System.Exception ex) {  		dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  	}  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: for (int i = 0; i < csvProject.LINES_LIST.Count; i++) {  	try {  		string line = csvProject.LINES_LIST [i];  		lineNum++;  		string[] lineParts = line.Split (splitter);  		// skip header line  		if (lineNum == 1) {  			continue;  		}  		// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  		// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  		int condition = int.Parse (lineParts [0]);  		int replicate = int.Parse (lineParts [1]);  		int fraction = int.Parse (lineParts [2]);  		string peptideMap = lineParts [3];  		string sdf = lineParts [4];  		string nameCol = "";  		if (lineParts.Length >= 6)  			nameCol = lineParts [5];  		// KE Aug 7 2008 - lower case  		//OLI Why lower case? Files does not exist under linux!  		this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  	}  	catch (System.Exception ex) {  		dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  	}  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	string line = csvProject.LINES_LIST [i];  	lineNum++;  	string[] lineParts = line.Split (splitter);  	// skip header line  	if (lineNum == 1) {  		continue;  	}  	// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  	// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  	int condition = int.Parse (lineParts [0]);  	int replicate = int.Parse (lineParts [1]);  	int fraction = int.Parse (lineParts [2]);  	string peptideMap = lineParts [3];  	string sdf = lineParts [4];  	string nameCol = "";  	if (lineParts.Length >= 6)  		nameCol = lineParts [5];  	// KE Aug 7 2008 - lower case  	//OLI Why lower case? Files does not exist under linux!  	this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  }  catch (System.Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	string line = csvProject.LINES_LIST [i];  	lineNum++;  	string[] lineParts = line.Split (splitter);  	// skip header line  	if (lineNum == 1) {  		continue;  	}  	// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  	// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  	int condition = int.Parse (lineParts [0]);  	int replicate = int.Parse (lineParts [1]);  	int fraction = int.Parse (lineParts [2]);  	string peptideMap = lineParts [3];  	string sdf = lineParts [4];  	string nameCol = "";  	if (lineParts.Length >= 6)  		nameCol = lineParts [5];  	// KE Aug 7 2008 - lower case  	//OLI Why lower case? Files does not exist under linux!  	this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  }  catch (System.Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	string line = csvProject.LINES_LIST [i];  	lineNum++;  	string[] lineParts = line.Split (splitter);  	// skip header line  	if (lineNum == 1) {  		continue;  	}  	// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  	// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  	int condition = int.Parse (lineParts [0]);  	int replicate = int.Parse (lineParts [1]);  	int fraction = int.Parse (lineParts [2]);  	string peptideMap = lineParts [3];  	string sdf = lineParts [4];  	string nameCol = "";  	if (lineParts.Length >= 6)  		nameCol = lineParts [5];  	// KE Aug 7 2008 - lower case  	//OLI Why lower case? Files does not exist under linux!  	this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  }  catch (System.Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	string line = csvProject.LINES_LIST [i];  	lineNum++;  	string[] lineParts = line.Split (splitter);  	// skip header line  	if (lineNum == 1) {  		continue;  	}  	// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  	// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  	int condition = int.Parse (lineParts [0]);  	int replicate = int.Parse (lineParts [1]);  	int fraction = int.Parse (lineParts [2]);  	string peptideMap = lineParts [3];  	string sdf = lineParts [4];  	string nameCol = "";  	if (lineParts.Length >= 6)  		nameCol = lineParts [5];  	// KE Aug 7 2008 - lower case  	//OLI Why lower case? Files does not exist under linux!  	this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  }  catch (System.Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: try {  	string line = csvProject.LINES_LIST [i];  	lineNum++;  	string[] lineParts = line.Split (splitter);  	// skip header line  	if (lineNum == 1) {  		continue;  	}  	// project csv file format: REPLICATE'REPLICATE'FRACTION'peptide map location' sdf file location  	// ex. 1'1'1'c:\work\adhoc\Promix_070706\Promix_10_070706_Out_peptides.csv'c:\work\adhoc\Promix_070706\Promix_10_070706_Out.sdf  	int condition = int.Parse (lineParts [0]);  	int replicate = int.Parse (lineParts [1]);  	int fraction = int.Parse (lineParts [2]);  	string peptideMap = lineParts [3];  	string sdf = lineParts [4];  	string nameCol = "";  	if (lineParts.Length >= 6)  		nameCol = lineParts [5];  	// KE Aug 7 2008 - lower case  	//OLI Why lower case? Files does not exist under linux!  	this.Add (new Sample (condition' replicate' fraction' peptideMap' sdf' maxFractionSpreading' nameCol));  }  catch (System.Exception ex) {  	dbOptions.ConSole.WriteLine ("Error sfj4aau34 : LineNum = " + lineNum + "   " + ex.Message + "    " + ex.StackTrace);  }  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: if (lineParts.Length >= 6)  	nameCol = lineParts [5];  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: if (lineParts.Length >= 6)  	nameCol = lineParts [5];  
Magic Number,PeptidAce,Samples,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Sample.cs,loadProjectFile,The following statement contains a magic number: nameCol = lineParts [5];  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	try {  		string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  		tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2]));  	}  	catch (Exception) {  		dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  	}  }  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	try {  		string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  		tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2]));  	}  	catch (Exception) {  		dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  	}  }  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The following statement contains a magic number: for (int i = 1; i < csv.LINES_LIST.Count; i++) {  	try {  		string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  		tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2]));  	}  	catch (Exception) {  		dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  	}  }  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The following statement contains a magic number: try {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2]));  }  catch (Exception) {  	dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  }  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The following statement contains a magic number: try {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2]));  }  catch (Exception) {  	dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  }  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The following statement contains a magic number: try {  	string[] splits = csv.LINES_LIST [i].Split (vsCSV._Generic_Separator);  	tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2]));  }  catch (Exception) {  	dbOptions.ConSole.WriteLine ("Error parsing line : " + csv.LINES_LIST [i]);  }  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The following statement contains a magic number: tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2]));  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The following statement contains a magic number: tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2]));  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,Import,The following statement contains a magic number: tracks.AddTrack (double.Parse (splits [0])' double.Parse (splits [1])' double.Parse (splits [3])' double.Parse (splits [4])' double.Parse (splits [2]));  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,BinarySearchMZ,The following statement contains a magic number: while (low_index <= high_index) {  	int mid_index = low_index + ((high_index - low_index) / 2);  	int comparison = this [mid_index].MZ.CompareTo (lowestPrecursorMz);  	if (comparison == 0) {  		while (mid_index > low_index && this [mid_index - 1].MZ.CompareTo (lowestPrecursorMz) == 0)  			mid_index--;  		return mid_index;  	}  	if (comparison < 0)  		low_index = mid_index + 1;  	else  		high_index = mid_index - 1;  }  
Magic Number,PeptidAce,Tracks,C:\repos\olivierlizotte_PeptidAce.Library\Structures\Tracks.cs,BinarySearchRT,The following statement contains a magic number: while (low_index <= high_index) {  	int mid_index = low_index + ((high_index - low_index) / 2);  	int comparison = this [mid_index].RT.CompareTo (lowestPrecursorRt);  	if (comparison == 0) {  		while (mid_index > low_index && this [mid_index - 1].RT.CompareTo (lowestPrecursorRt) == 0)  			mid_index--;  		return mid_index;  	}  	if (comparison < 0)  		low_index = mid_index + 1;  	else  		high_index = mid_index - 1;  }  
Magic Number,PeptidAce.Utilities,CurveFitter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\CurveFitter.cs,FitToSin2,The following statement contains a magic number: c = p [2];  
Magic Number,PeptidAce.Utilities,CurveFitter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\CurveFitter.cs,AreaUnderTheCurve,The following statement contains a magic number: if (timeStop > xTimeStart) {  	double iterSize = (timeStop - xTimeStart) / 100.0;  	for (double timePoint = xTimeStart; timePoint <= timeStop; timePoint += iterSize) {  		double localIntensity = Evaluate.Polynomial (timePoint' coefficients);  		if (localIntensity > 0)  			cumul += localIntensity * iterSize;  		//else  		//    break;  	}  }  
Magic Number,PeptidAce.Utilities,CurveFitter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\CurveFitter.cs,FitToPolynomial,The following statement contains a magic number: coeff = Fit.Polynomial (xdata' ydata' 2);  
Magic Number,PeptidAce.Utilities,ElutionCurveMerger,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\ElutionCurveMaxFlow.cs,Merge,The following statement contains a magic number: if (Curves.Count > 1) {  	double sum = 0.0;  	foreach (double val in Factor)  		sum += val;  	Dictionary<double' int> times = new Dictionary<double' int> ();  	foreach (MaxFlowElutionCurve curve in Curves)  		foreach (double timePoint in curve.eCurvePerMs.time)  			if (!times.ContainsKey (timePoint))  				times.Add (timePoint' 1);  			else  				times [timePoint]++;  	List<double> sortedTime = new List<double> (times.Keys);  	sortedTime.Sort ();  	List<double> interpolTime = ElutionCurve.GetTimePoints (128' false' sortedTime);  	MaxFlowElutionCurve newCurve = new MaxFlowElutionCurve (-1);  	foreach (double pt in interpolTime) {  		double intCount = 0;  		double intPerMs = 0;  		for (int i = 0; i < Curves.Count; i++) {  			intCount += Factor [i] * Curves [i].eCurveCount.InterpolateIntensity (pt);  			intPerMs += Factor [i] * Curves [i].eCurvePerMs.InterpolateIntensity (pt);  		}  		newCurve.eCurveCount.AddPoint (pt' intCount / sum);  		newCurve.eCurvePerMs.AddPoint (pt' intPerMs / sum);  	}  	newCurve.Compute ();  	return newCurve;  	/*                 Dictionary<double' int> times = new Dictionary<double' int>();                 foreach (MaxFlowElutionCurve curve in Curves)                     foreach (double timePoint in curve.eCurvePerMs.time)                         if (!times.ContainsKey(timePoint))                             times.Add(timePoint' 1);                         else                             times[timePoint]++;                 List<double> sortedTime = new List<double>(times.Keys);                 sortedTime.Sort();                  MaxFlowElutionCurve newCurve = new MaxFlowElutionCurve(-1);                 foreach (double key in sortedTime)                     if (times[key] > 1)                     {                         double cumulIntensityCount = 0.0;                         double cumulIntensityPerMs = 0.0;                         for (int i = 0; i < Curves.Count; i++)                         {                             cumulIntensityCount += Curves[i].eCurveCount.InterpolateIntensity(key) * Factor[i] / sum;                             cumulIntensityPerMs += Curves[i].eCurvePerMs.InterpolateIntensity(key) * Factor[i] / sum;                         }                         newCurve.eCurveCount.AddPoint(key' cumulIntensityCount);                         newCurve.eCurvePerMs.AddPoint(key' cumulIntensityPerMs);                     }                 return newCurve;//*/}  else if (Curves.Count == 1)  	return Curves [0];  
Magic Number,PeptidAce.Utilities,Gradior,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Gradior.cs,Distance,The following statement contains a magic number: return Math.Sqrt (a.Zip (b' (i' j) => Math.Pow (i - j' 2.0)).Sum ());  
Magic Number,PeptidAce.Utilities,Gradior,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Gradior.cs,Gradient,The following statement contains a magic number: return x => Enumerable.Range (0' x.Count).Select (i => (f (x.Select ((y' j) => j == i ? y + Precision : y).ToList ()) - f (x.Select ((y' j) => j == i ? y - Precision : y).ToList ())) / (2 * Precision)).ToList ();  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,GetTimePoints,The following statement contains a magic number: for (int i = 0; i < nbTimePoints; i++)  	points.Add (minTime + ((i + 0.5) / (double)nbTimePoints) * (maxTime - minTime));  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,GetTimePoints,The following statement contains a magic number: points.Add (minTime + ((i + 0.5) / (double)nbTimePoints) * (maxTime - minTime));  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (dicNoDupe != null && dicNoDupe.Count > 8)// time != null && time.Count > 8)   {  	time = new List<double> (dicNoDupe.Keys);  	intensityCount = new List<double> (dicNoDupe.Values);  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (time != null && (time.Count > 8 || (time.Count >= 4 && type == CurveType.LINEAR))) {  	double[] arrayTime = time.ToArray ();  	double[] arrayIntensity = intensityCount.ToArray ();  	Array.Sort (arrayTime' arrayIntensity);  	time = new List<double> (arrayTime);  	intensityCount = new List<double> (arrayIntensity);  	foreach (double val in intensityCount)  		if (val > PeakTop)  			PeakTop = val;  	double area1 = Utilities.CurveFitter.FitToPolynomial (time.ToArray ()' intensityCount.ToArray ()' out Coefficients);  	double area2 = Utilities.CurveFitter.AreaUnderTheCurve (time' intensityCount);  	Area = area2;  	try {  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			break;  		}  		//Area = interpole.Integrate(time[time.Count - 1]);  		//int nbPoints = time.Count / 2;  		//if (nbPoints)  		//    nbPoints = time.Count + 2;  		if (smooth) {  			int nbIter = 2;  			interpolatedTime = time;  			interpolatedIntensityCount = intensityCount;  			do {  				List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  				List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  				for (int i = 0; i < interpolatedTime.Count - 1; i++) {  					smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  					smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  				}  				interpolatedTime = smallerInterpolatedTime;  				interpolatedIntensityCount = smallerInterpolatedIntensityCount;  				nbIter--;  			}  			while (nbIter > 0);  			switch (cType) {  			case CurveType.AKIMA:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.LINEAR:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.SPLINE:  				interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			}  			double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  			if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  				Area = areaSmooth;  			else  				Console.WriteLine ("Contradiction");  			PeakTop = 0;  			foreach (double val in interpolatedIntensityCount)  				if (val > PeakTop)  					PeakTop = val;  		}  		//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  	}  	catch (Exception ex) {  		Console.WriteLine (ex.StackTrace);  	}  }  else {  	Area = 0;  	Coefficients = new double[0];  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (time != null && (time.Count > 8 || (time.Count >= 4 && type == CurveType.LINEAR))) {  	double[] arrayTime = time.ToArray ();  	double[] arrayIntensity = intensityCount.ToArray ();  	Array.Sort (arrayTime' arrayIntensity);  	time = new List<double> (arrayTime);  	intensityCount = new List<double> (arrayIntensity);  	foreach (double val in intensityCount)  		if (val > PeakTop)  			PeakTop = val;  	double area1 = Utilities.CurveFitter.FitToPolynomial (time.ToArray ()' intensityCount.ToArray ()' out Coefficients);  	double area2 = Utilities.CurveFitter.AreaUnderTheCurve (time' intensityCount);  	Area = area2;  	try {  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			break;  		}  		//Area = interpole.Integrate(time[time.Count - 1]);  		//int nbPoints = time.Count / 2;  		//if (nbPoints)  		//    nbPoints = time.Count + 2;  		if (smooth) {  			int nbIter = 2;  			interpolatedTime = time;  			interpolatedIntensityCount = intensityCount;  			do {  				List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  				List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  				for (int i = 0; i < interpolatedTime.Count - 1; i++) {  					smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  					smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  				}  				interpolatedTime = smallerInterpolatedTime;  				interpolatedIntensityCount = smallerInterpolatedIntensityCount;  				nbIter--;  			}  			while (nbIter > 0);  			switch (cType) {  			case CurveType.AKIMA:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.LINEAR:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.SPLINE:  				interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			}  			double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  			if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  				Area = areaSmooth;  			else  				Console.WriteLine ("Contradiction");  			PeakTop = 0;  			foreach (double val in interpolatedIntensityCount)  				if (val > PeakTop)  					PeakTop = val;  		}  		//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  	}  	catch (Exception ex) {  		Console.WriteLine (ex.StackTrace);  	}  }  else {  	Area = 0;  	Coefficients = new double[0];  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (time != null && (time.Count > 8 || (time.Count >= 4 && type == CurveType.LINEAR))) {  	double[] arrayTime = time.ToArray ();  	double[] arrayIntensity = intensityCount.ToArray ();  	Array.Sort (arrayTime' arrayIntensity);  	time = new List<double> (arrayTime);  	intensityCount = new List<double> (arrayIntensity);  	foreach (double val in intensityCount)  		if (val > PeakTop)  			PeakTop = val;  	double area1 = Utilities.CurveFitter.FitToPolynomial (time.ToArray ()' intensityCount.ToArray ()' out Coefficients);  	double area2 = Utilities.CurveFitter.AreaUnderTheCurve (time' intensityCount);  	Area = area2;  	try {  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			break;  		}  		//Area = interpole.Integrate(time[time.Count - 1]);  		//int nbPoints = time.Count / 2;  		//if (nbPoints)  		//    nbPoints = time.Count + 2;  		if (smooth) {  			int nbIter = 2;  			interpolatedTime = time;  			interpolatedIntensityCount = intensityCount;  			do {  				List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  				List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  				for (int i = 0; i < interpolatedTime.Count - 1; i++) {  					smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  					smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  				}  				interpolatedTime = smallerInterpolatedTime;  				interpolatedIntensityCount = smallerInterpolatedIntensityCount;  				nbIter--;  			}  			while (nbIter > 0);  			switch (cType) {  			case CurveType.AKIMA:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.LINEAR:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.SPLINE:  				interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			}  			double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  			if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  				Area = areaSmooth;  			else  				Console.WriteLine ("Contradiction");  			PeakTop = 0;  			foreach (double val in interpolatedIntensityCount)  				if (val > PeakTop)  					PeakTop = val;  		}  		//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  	}  	catch (Exception ex) {  		Console.WriteLine (ex.StackTrace);  	}  }  else {  	Area = 0;  	Coefficients = new double[0];  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (time != null && (time.Count > 8 || (time.Count >= 4 && type == CurveType.LINEAR))) {  	double[] arrayTime = time.ToArray ();  	double[] arrayIntensity = intensityCount.ToArray ();  	Array.Sort (arrayTime' arrayIntensity);  	time = new List<double> (arrayTime);  	intensityCount = new List<double> (arrayIntensity);  	foreach (double val in intensityCount)  		if (val > PeakTop)  			PeakTop = val;  	double area1 = Utilities.CurveFitter.FitToPolynomial (time.ToArray ()' intensityCount.ToArray ()' out Coefficients);  	double area2 = Utilities.CurveFitter.AreaUnderTheCurve (time' intensityCount);  	Area = area2;  	try {  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			break;  		}  		//Area = interpole.Integrate(time[time.Count - 1]);  		//int nbPoints = time.Count / 2;  		//if (nbPoints)  		//    nbPoints = time.Count + 2;  		if (smooth) {  			int nbIter = 2;  			interpolatedTime = time;  			interpolatedIntensityCount = intensityCount;  			do {  				List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  				List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  				for (int i = 0; i < interpolatedTime.Count - 1; i++) {  					smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  					smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  				}  				interpolatedTime = smallerInterpolatedTime;  				interpolatedIntensityCount = smallerInterpolatedIntensityCount;  				nbIter--;  			}  			while (nbIter > 0);  			switch (cType) {  			case CurveType.AKIMA:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.LINEAR:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.SPLINE:  				interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			}  			double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  			if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  				Area = areaSmooth;  			else  				Console.WriteLine ("Contradiction");  			PeakTop = 0;  			foreach (double val in interpolatedIntensityCount)  				if (val > PeakTop)  					PeakTop = val;  		}  		//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  	}  	catch (Exception ex) {  		Console.WriteLine (ex.StackTrace);  	}  }  else {  	Area = 0;  	Coefficients = new double[0];  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (time != null && (time.Count > 8 || (time.Count >= 4 && type == CurveType.LINEAR))) {  	double[] arrayTime = time.ToArray ();  	double[] arrayIntensity = intensityCount.ToArray ();  	Array.Sort (arrayTime' arrayIntensity);  	time = new List<double> (arrayTime);  	intensityCount = new List<double> (arrayIntensity);  	foreach (double val in intensityCount)  		if (val > PeakTop)  			PeakTop = val;  	double area1 = Utilities.CurveFitter.FitToPolynomial (time.ToArray ()' intensityCount.ToArray ()' out Coefficients);  	double area2 = Utilities.CurveFitter.AreaUnderTheCurve (time' intensityCount);  	Area = area2;  	try {  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			break;  		}  		//Area = interpole.Integrate(time[time.Count - 1]);  		//int nbPoints = time.Count / 2;  		//if (nbPoints)  		//    nbPoints = time.Count + 2;  		if (smooth) {  			int nbIter = 2;  			interpolatedTime = time;  			interpolatedIntensityCount = intensityCount;  			do {  				List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  				List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  				for (int i = 0; i < interpolatedTime.Count - 1; i++) {  					smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  					smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  				}  				interpolatedTime = smallerInterpolatedTime;  				interpolatedIntensityCount = smallerInterpolatedIntensityCount;  				nbIter--;  			}  			while (nbIter > 0);  			switch (cType) {  			case CurveType.AKIMA:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.LINEAR:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.SPLINE:  				interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			}  			double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  			if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  				Area = areaSmooth;  			else  				Console.WriteLine ("Contradiction");  			PeakTop = 0;  			foreach (double val in interpolatedIntensityCount)  				if (val > PeakTop)  					PeakTop = val;  		}  		//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  	}  	catch (Exception ex) {  		Console.WriteLine (ex.StackTrace);  	}  }  else {  	Area = 0;  	Coefficients = new double[0];  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (time != null && (time.Count > 8 || (time.Count >= 4 && type == CurveType.LINEAR))) {  	double[] arrayTime = time.ToArray ();  	double[] arrayIntensity = intensityCount.ToArray ();  	Array.Sort (arrayTime' arrayIntensity);  	time = new List<double> (arrayTime);  	intensityCount = new List<double> (arrayIntensity);  	foreach (double val in intensityCount)  		if (val > PeakTop)  			PeakTop = val;  	double area1 = Utilities.CurveFitter.FitToPolynomial (time.ToArray ()' intensityCount.ToArray ()' out Coefficients);  	double area2 = Utilities.CurveFitter.AreaUnderTheCurve (time' intensityCount);  	Area = area2;  	try {  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			break;  		}  		//Area = interpole.Integrate(time[time.Count - 1]);  		//int nbPoints = time.Count / 2;  		//if (nbPoints)  		//    nbPoints = time.Count + 2;  		if (smooth) {  			int nbIter = 2;  			interpolatedTime = time;  			interpolatedIntensityCount = intensityCount;  			do {  				List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  				List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  				for (int i = 0; i < interpolatedTime.Count - 1; i++) {  					smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  					smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  				}  				interpolatedTime = smallerInterpolatedTime;  				interpolatedIntensityCount = smallerInterpolatedIntensityCount;  				nbIter--;  			}  			while (nbIter > 0);  			switch (cType) {  			case CurveType.AKIMA:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.LINEAR:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.SPLINE:  				interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			}  			double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  			if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  				Area = areaSmooth;  			else  				Console.WriteLine ("Contradiction");  			PeakTop = 0;  			foreach (double val in interpolatedIntensityCount)  				if (val > PeakTop)  					PeakTop = val;  		}  		//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  	}  	catch (Exception ex) {  		Console.WriteLine (ex.StackTrace);  	}  }  else {  	Area = 0;  	Coefficients = new double[0];  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (time != null && (time.Count > 8 || (time.Count >= 4 && type == CurveType.LINEAR))) {  	double[] arrayTime = time.ToArray ();  	double[] arrayIntensity = intensityCount.ToArray ();  	Array.Sort (arrayTime' arrayIntensity);  	time = new List<double> (arrayTime);  	intensityCount = new List<double> (arrayIntensity);  	foreach (double val in intensityCount)  		if (val > PeakTop)  			PeakTop = val;  	double area1 = Utilities.CurveFitter.FitToPolynomial (time.ToArray ()' intensityCount.ToArray ()' out Coefficients);  	double area2 = Utilities.CurveFitter.AreaUnderTheCurve (time' intensityCount);  	Area = area2;  	try {  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			break;  		}  		//Area = interpole.Integrate(time[time.Count - 1]);  		//int nbPoints = time.Count / 2;  		//if (nbPoints)  		//    nbPoints = time.Count + 2;  		if (smooth) {  			int nbIter = 2;  			interpolatedTime = time;  			interpolatedIntensityCount = intensityCount;  			do {  				List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  				List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  				for (int i = 0; i < interpolatedTime.Count - 1; i++) {  					smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  					smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  				}  				interpolatedTime = smallerInterpolatedTime;  				interpolatedIntensityCount = smallerInterpolatedIntensityCount;  				nbIter--;  			}  			while (nbIter > 0);  			switch (cType) {  			case CurveType.AKIMA:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.LINEAR:  				interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  				//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  				break;  			case CurveType.SPLINE:  				interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  				//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  				break;  			}  			double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  			if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  				Area = areaSmooth;  			else  				Console.WriteLine ("Contradiction");  			PeakTop = 0;  			foreach (double val in interpolatedIntensityCount)  				if (val > PeakTop)  					PeakTop = val;  		}  		//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  	}  	catch (Exception ex) {  		Console.WriteLine (ex.StackTrace);  	}  }  else {  	Area = 0;  	Coefficients = new double[0];  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: try {  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		break;  	}  	//Area = interpole.Integrate(time[time.Count - 1]);  	//int nbPoints = time.Count / 2;  	//if (nbPoints)  	//    nbPoints = time.Count + 2;  	if (smooth) {  		int nbIter = 2;  		interpolatedTime = time;  		interpolatedIntensityCount = intensityCount;  		do {  			List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  			List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  			for (int i = 0; i < interpolatedTime.Count - 1; i++) {  				smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  				smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  			}  			interpolatedTime = smallerInterpolatedTime;  			interpolatedIntensityCount = smallerInterpolatedIntensityCount;  			nbIter--;  		}  		while (nbIter > 0);  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		}  		double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  		if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  			Area = areaSmooth;  		else  			Console.WriteLine ("Contradiction");  		PeakTop = 0;  		foreach (double val in interpolatedIntensityCount)  			if (val > PeakTop)  				PeakTop = val;  	}  	//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  }  catch (Exception ex) {  	Console.WriteLine (ex.StackTrace);  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: try {  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		break;  	}  	//Area = interpole.Integrate(time[time.Count - 1]);  	//int nbPoints = time.Count / 2;  	//if (nbPoints)  	//    nbPoints = time.Count + 2;  	if (smooth) {  		int nbIter = 2;  		interpolatedTime = time;  		interpolatedIntensityCount = intensityCount;  		do {  			List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  			List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  			for (int i = 0; i < interpolatedTime.Count - 1; i++) {  				smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  				smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  			}  			interpolatedTime = smallerInterpolatedTime;  			interpolatedIntensityCount = smallerInterpolatedIntensityCount;  			nbIter--;  		}  		while (nbIter > 0);  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		}  		double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  		if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  			Area = areaSmooth;  		else  			Console.WriteLine ("Contradiction");  		PeakTop = 0;  		foreach (double val in interpolatedIntensityCount)  			if (val > PeakTop)  				PeakTop = val;  	}  	//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  }  catch (Exception ex) {  	Console.WriteLine (ex.StackTrace);  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: try {  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		break;  	}  	//Area = interpole.Integrate(time[time.Count - 1]);  	//int nbPoints = time.Count / 2;  	//if (nbPoints)  	//    nbPoints = time.Count + 2;  	if (smooth) {  		int nbIter = 2;  		interpolatedTime = time;  		interpolatedIntensityCount = intensityCount;  		do {  			List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  			List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  			for (int i = 0; i < interpolatedTime.Count - 1; i++) {  				smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  				smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  			}  			interpolatedTime = smallerInterpolatedTime;  			interpolatedIntensityCount = smallerInterpolatedIntensityCount;  			nbIter--;  		}  		while (nbIter > 0);  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		}  		double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  		if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  			Area = areaSmooth;  		else  			Console.WriteLine ("Contradiction");  		PeakTop = 0;  		foreach (double val in interpolatedIntensityCount)  			if (val > PeakTop)  				PeakTop = val;  	}  	//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  }  catch (Exception ex) {  	Console.WriteLine (ex.StackTrace);  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: try {  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		break;  	}  	//Area = interpole.Integrate(time[time.Count - 1]);  	//int nbPoints = time.Count / 2;  	//if (nbPoints)  	//    nbPoints = time.Count + 2;  	if (smooth) {  		int nbIter = 2;  		interpolatedTime = time;  		interpolatedIntensityCount = intensityCount;  		do {  			List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  			List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  			for (int i = 0; i < interpolatedTime.Count - 1; i++) {  				smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  				smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  			}  			interpolatedTime = smallerInterpolatedTime;  			interpolatedIntensityCount = smallerInterpolatedIntensityCount;  			nbIter--;  		}  		while (nbIter > 0);  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		}  		double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  		if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  			Area = areaSmooth;  		else  			Console.WriteLine ("Contradiction");  		PeakTop = 0;  		foreach (double val in interpolatedIntensityCount)  			if (val > PeakTop)  				PeakTop = val;  	}  	//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  }  catch (Exception ex) {  	Console.WriteLine (ex.StackTrace);  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: try {  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		break;  	}  	//Area = interpole.Integrate(time[time.Count - 1]);  	//int nbPoints = time.Count / 2;  	//if (nbPoints)  	//    nbPoints = time.Count + 2;  	if (smooth) {  		int nbIter = 2;  		interpolatedTime = time;  		interpolatedIntensityCount = intensityCount;  		do {  			List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  			List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  			for (int i = 0; i < interpolatedTime.Count - 1; i++) {  				smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  				smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  			}  			interpolatedTime = smallerInterpolatedTime;  			interpolatedIntensityCount = smallerInterpolatedIntensityCount;  			nbIter--;  		}  		while (nbIter > 0);  		switch (cType) {  		case CurveType.AKIMA:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.LINEAR:  			interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  			//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  			break;  		case CurveType.SPLINE:  			interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  			//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  			break;  		}  		double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  		if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  			Area = areaSmooth;  		else  			Console.WriteLine ("Contradiction");  		PeakTop = 0;  		foreach (double val in interpolatedIntensityCount)  			if (val > PeakTop)  				PeakTop = val;  	}  	//Area = interpole.Integrate(interpolatedTime[interpolatedTime.Length - 1]);  }  catch (Exception ex) {  	Console.WriteLine (ex.StackTrace);  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (smooth) {  	int nbIter = 2;  	interpolatedTime = time;  	interpolatedIntensityCount = intensityCount;  	do {  		List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  		List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  		for (int i = 0; i < interpolatedTime.Count - 1; i++) {  			smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  			smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  		}  		interpolatedTime = smallerInterpolatedTime;  		interpolatedIntensityCount = smallerInterpolatedIntensityCount;  		nbIter--;  	}  	while (nbIter > 0);  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	}  	double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  	if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  		Area = areaSmooth;  	else  		Console.WriteLine ("Contradiction");  	PeakTop = 0;  	foreach (double val in interpolatedIntensityCount)  		if (val > PeakTop)  			PeakTop = val;  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (smooth) {  	int nbIter = 2;  	interpolatedTime = time;  	interpolatedIntensityCount = intensityCount;  	do {  		List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  		List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  		for (int i = 0; i < interpolatedTime.Count - 1; i++) {  			smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  			smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  		}  		interpolatedTime = smallerInterpolatedTime;  		interpolatedIntensityCount = smallerInterpolatedIntensityCount;  		nbIter--;  	}  	while (nbIter > 0);  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	}  	double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  	if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  		Area = areaSmooth;  	else  		Console.WriteLine ("Contradiction");  	PeakTop = 0;  	foreach (double val in interpolatedIntensityCount)  		if (val > PeakTop)  			PeakTop = val;  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (smooth) {  	int nbIter = 2;  	interpolatedTime = time;  	interpolatedIntensityCount = intensityCount;  	do {  		List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  		List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  		for (int i = 0; i < interpolatedTime.Count - 1; i++) {  			smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  			smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  		}  		interpolatedTime = smallerInterpolatedTime;  		interpolatedIntensityCount = smallerInterpolatedIntensityCount;  		nbIter--;  	}  	while (nbIter > 0);  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	}  	double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  	if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  		Area = areaSmooth;  	else  		Console.WriteLine ("Contradiction");  	PeakTop = 0;  	foreach (double val in interpolatedIntensityCount)  		if (val > PeakTop)  			PeakTop = val;  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (smooth) {  	int nbIter = 2;  	interpolatedTime = time;  	interpolatedIntensityCount = intensityCount;  	do {  		List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  		List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  		for (int i = 0; i < interpolatedTime.Count - 1; i++) {  			smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  			smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  		}  		interpolatedTime = smallerInterpolatedTime;  		interpolatedIntensityCount = smallerInterpolatedIntensityCount;  		nbIter--;  	}  	while (nbIter > 0);  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	}  	double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  	if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  		Area = areaSmooth;  	else  		Console.WriteLine ("Contradiction");  	PeakTop = 0;  	foreach (double val in interpolatedIntensityCount)  		if (val > PeakTop)  			PeakTop = val;  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (smooth) {  	int nbIter = 2;  	interpolatedTime = time;  	interpolatedIntensityCount = intensityCount;  	do {  		List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  		List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  		for (int i = 0; i < interpolatedTime.Count - 1; i++) {  			smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  			smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  		}  		interpolatedTime = smallerInterpolatedTime;  		interpolatedIntensityCount = smallerInterpolatedIntensityCount;  		nbIter--;  	}  	while (nbIter > 0);  	switch (cType) {  	case CurveType.AKIMA:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.LINEAR:  		interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  		//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  		break;  	case CurveType.SPLINE:  		interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  		//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  		break;  	}  	double areaSmooth = interpole.Integrate (interpolatedTime [interpolatedTime.Count - 1]);  	if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  		Area = areaSmooth;  	else  		Console.WriteLine ("Contradiction");  	PeakTop = 0;  	foreach (double val in interpolatedIntensityCount)  		if (val > PeakTop)  			PeakTop = val;  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: do {  	List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  	List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  	for (int i = 0; i < interpolatedTime.Count - 1; i++) {  		smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  		smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  	}  	interpolatedTime = smallerInterpolatedTime;  	interpolatedIntensityCount = smallerInterpolatedIntensityCount;  	nbIter--;  }  while (nbIter > 0);  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: do {  	List<double> smallerInterpolatedTime = new List<double> (interpolatedTime.Count - 1);  	List<double> smallerInterpolatedIntensityCount = new List<double> (interpolatedIntensityCount.Count - 1);  	for (int i = 0; i < interpolatedTime.Count - 1; i++) {  		smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  		smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  	}  	interpolatedTime = smallerInterpolatedTime;  	interpolatedIntensityCount = smallerInterpolatedIntensityCount;  	nbIter--;  }  while (nbIter > 0);  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: for (int i = 0; i < interpolatedTime.Count - 1; i++) {  	smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  	smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: for (int i = 0; i < interpolatedTime.Count - 1; i++) {  	smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  	smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: smallerInterpolatedTime.Add (0.5 * (interpolatedTime [i] + interpolatedTime [i + 1]));  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: smallerInterpolatedIntensityCount.Add (0.5 * (interpolatedIntensityCount [i] + interpolatedIntensityCount [i + 1]));  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  	Area = areaSmooth;  else  	Console.WriteLine ("Contradiction");  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following statement contains a magic number: if (areaSmooth > Area * 0.5 && areaSmooth < Area * 2)  	Area = areaSmooth;  else  	Console.WriteLine ("Contradiction");  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,GetLocalArea,The following statement contains a magic number: if (interpole != null) {  	double cumul = 0.0;  	double stepSize = (timeStop - timeStart) / 100.0;  	for (double k = timeStart; k <= timeStop; k += stepSize)  		cumul += interpole.Interpolate (k) * stepSize;  	return cumul;  }  else  	return 0;  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,AddPoint,The following statement contains a magic number: if (dicNoDupe == null) {  	dicNoDupe = new Dictionary<double' double> ();  	dicNoDupe.Add (newTimePoint' newIntensityPerMilliSeconds);  }  else {  	if (dicNoDupe.ContainsKey (newTimePoint))  		dicNoDupe [newTimePoint] = 0.5 * (dicNoDupe [newTimePoint] + newIntensityPerMilliSeconds);  	else  		dicNoDupe.Add (newTimePoint' newIntensityPerMilliSeconds);  }  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,AddPoint,The following statement contains a magic number: if (dicNoDupe.ContainsKey (newTimePoint))  	dicNoDupe [newTimePoint] = 0.5 * (dicNoDupe [newTimePoint] + newIntensityPerMilliSeconds);  else  	dicNoDupe.Add (newTimePoint' newIntensityPerMilliSeconds);  
Magic Number,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,AddPoint,The following statement contains a magic number: dicNoDupe [newTimePoint] = 0.5 * (dicNoDupe [newTimePoint] + newIntensityPerMilliSeconds);  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateMassError,The following statement contains a magic number: if (massErrorUnits == MassToleranceUnits.Da) {  	return experimental - theoretical;  }  else if (massErrorUnits == MassToleranceUnits.ppm) {  	return ((experimental - theoretical) / theoretical) * 1e6;  }  else {  	return double.NaN;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateMassError,The following statement contains a magic number: if (massErrorUnits == MassToleranceUnits.ppm) {  	return ((experimental - theoretical) / theoretical) * 1e6;  }  else {  	return double.NaN;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateMassError,The following statement contains a magic number: return ((experimental - theoretical) / theoretical) * 1e6;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: switch (aa) {  case 'A':  	return 92;  case 'C':  	return 106;  case 'D':  	return 125;  case 'E':  	return 155;  case 'F':  	return 203;  case 'G':  	return 66;  case 'H':  	return 167;  case 'I':  	return 169;  case 'K':  	return 171;  case 'L':  	return 168;  case 'M':  	return 171;  case 'N':  	return 135;  case 'P':  	return 129;  case 'Q':  	return 161;  case 'R':  	return 225;  case 'S':  	return 99;  case 'T':  	return 122;  case 'V':  	return 142;  case 'W':  	return 240;  case 'Y':  	return 203;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 92;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 106;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 125;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 155;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 203;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 66;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 167;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 169;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 171;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 168;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 171;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 135;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 129;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 161;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 225;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 99;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 122;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 142;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 240;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,AvgVolSideChain,The following statement contains a magic number: return 203;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: switch (aa) {  case 'A':  	return -0.5;  case 'C':  	return -1.0;  case 'D':  	return 3.0;  case 'E':  	return 3.0;  case 'F':  	return -2.5;  case 'G':  	return 0.0;  case 'H':  	return -0.5;  case 'I':  	return -1.8;  case 'K':  	return 3.0;  case 'L':  	return -1.8;  case 'M':  	return -1.3;  case 'N':  	return 0.2;  case 'P':  	return 0.0;  case 'Q':  	return 0.2;  case 'R':  	return 3.0;  case 'S':  	return 0.3;  case 'T':  	return -0.4;  case 'V':  	return -1.5;  case 'W':  	return -3.4;  case 'Y':  	return -2.3;  default:  	return 0.0;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -0.5;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return 3.0;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return 3.0;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -2.5;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -0.5;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -1.8;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return 3.0;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -1.8;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -1.3;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return 0.2;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return 0.2;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return 3.0;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return 0.3;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -0.4;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -1.5;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -3.4;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,Hydrophilicity,The following statement contains a magic number: return -2.3;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: for (pH = 6.5; !((pH - pHprev < E) && (pHnext - pH < E)) && pH < 14.0;) {  	// we are using pK values form Wikipedia as they give quite good approximation  	// if you want you can change it  	QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  	QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  	QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  	QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  	QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  	QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  	QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  	QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  	QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  	NQ = QN1 + QN2 + QN3 + QN4 + QN5 + QP1 + QP2 + QP3 + QP4;  	if (NQ < 0)//we are out of range' thus the new pH value must be smaller      	 {  		temp = pH;  		pH = pH - ((pH - pHprev) / 2);  		pHnext = temp;  	}  	else//we used to small pH value' so we have to increase it  	 {  		temp = pH;  		pH = pH + ((pHnext - pH) / 2);  		pHprev = temp;  	}  	if ((pH - pHprev < E) && (pHnext - pH < E))  		//terminal condition' finding isoelectric point with given precision  		break;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: pH = 6.5
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN1 = -1 / (1 + Math.Pow (10' (3.65 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN2 = -AspNumber / (1 + Math.Pow (10' (3.9 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN3 = -GluNumber / (1 + Math.Pow (10' (4.07 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN4 = -CysNumber / (1 + Math.Pow (10' (8.18 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QN5 = -TyrNumber / (1 + Math.Pow (10' (10.46 - pH)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QP1 = HisNumber / (1 + Math.Pow (10' (pH - 6.04)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QP2 = 1 / (1 + Math.Pow (10' (pH - 8.2)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QP3 = LysNumber / (1 + Math.Pow (10' (pH - 10.54)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: QP4 = ArgNumber / (1 + Math.Pow (10' (pH - 12.48)));  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: if (NQ < 0)//we are out of range' thus the new pH value must be smaller       {  	temp = pH;  	pH = pH - ((pH - pHprev) / 2);  	pHnext = temp;  }  else//we used to small pH value' so we have to increase it   {  	temp = pH;  	pH = pH + ((pHnext - pH) / 2);  	pHprev = temp;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: if (NQ < 0)//we are out of range' thus the new pH value must be smaller       {  	temp = pH;  	pH = pH - ((pH - pHprev) / 2);  	pHnext = temp;  }  else//we used to small pH value' so we have to increase it   {  	temp = pH;  	pH = pH + ((pHnext - pH) / 2);  	pHprev = temp;  }  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: pH = pH - ((pH - pHprev) / 2);  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following statement contains a magic number: pH = pH + ((pHnext - pH) / 2);  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateTolerance,The following statement contains a magic number: if (tolerance.Units == MassToleranceUnits.Da)  	return tolerance.Value;  else  	return ((MassTolerance.MzTop (experimental' tolerance) - experimental) / experimental) * 1e6;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateTolerance,The following statement contains a magic number: return ((MassTolerance.MzTop (experimental' tolerance) - experimental) / experimental) * 1e6;  
Magic Number,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,BinarySearchMZ,The following statement contains a magic number: while (low_index <= high_index) {  	int mid_index = low_index + ((high_index - low_index) / 2);  	int comparison = sortedMzs [mid_index].CompareTo (lowestPrecursorMz);  	if (comparison == 0) {  		while (mid_index > low_index && sortedMzs [mid_index - 1].CompareTo (lowestPrecursorMz) == 0)  			mid_index--;  		return mid_index;  	}  	if (comparison < 0)  		low_index = mid_index + 1;  	else  		high_index = mid_index - 1;  }  
Magic Number,PeptidAce.Utilities,vsCSV,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\vsCSV.cs,Split_HandleQuotes,The following statement contains a magic number: for (int i = 0; i < array.Length && iter + 1 < nbColMax; i++) {  	if (inQuotes)  		columns [iter] += "'" + array [i];  	else {  		iter++;  		columns.Add (array [i]);  	}  	if (Count (array [i]' "\"") % 2 != 0)  		inQuotes = !inQuotes;  }  
Magic Number,PeptidAce.Utilities,vsCSV,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\vsCSV.cs,Split_HandleQuotes,The following statement contains a magic number: if (Count (array [i]' "\"") % 2 != 0)  	inQuotes = !inQuotes;  
Magic Number,PeptidAce.Utilities,vsCSVWriter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\vsCSVWriter.cs,CountLength,The following statement contains a magic number: foreach (string str in m_strLines)  	cptChar += str.Length + 2;  
Magic Number,PeptidAce.Utilities,vsCSVWriter,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\vsCSVWriter.cs,CountLength,The following statement contains a magic number: cptChar += str.Length + 2;  
Magic Number,PeptidAce.Utilities.Interfaces,Logger,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Interfaces\ConSolBasic.cs,Logger,The following statement contains a magic number: objTimer.Change (0' 150000);  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: try {  	pwiz.CLI.msdata.MSDataFile msFileContaminant = new pwiz.CLI.msdata.MSDataFile (rawContaminants);  	int num_spectra = msFileContaminant.run.spectrumList.size ();  	for (int i = 0; i < num_spectra; i++) {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFileContaminant.run.spectrumList.spectrum (i' true);  		if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  			List<double> mzOk = new List<double> ();  			for (int k = 0; k < mz.data.Count; k++)  				if (intensities.data [k] > 500)  					mzOk.Add (mz.data [k]);  			if (mzOk.Count > 0) {  				mzOk.Sort ();  				contaminants.Add (retention_time' mzOk);  			}  		}  		spec.Dispose ();  		spec = null;  	}  	msFileContaminant.Dispose ();  	msFileContaminant = null;  	foreach (string file in raws) {  		pwiz.CLI.msdata.MSDataFile msFile = new pwiz.CLI.msdata.MSDataFile (file);  		pwiz.CLI.msdata.SpectrumListSimple editedSpec = new pwiz.CLI.msdata.SpectrumListSimple ();  		int nbSpec = msFile.run.spectrumList.size ();  		for (int i = 0; i < nbSpec; i++) {  			//Spectrum  			pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  			if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  			 {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				List<double> timePoints = new List<double> ();  				foreach (double time in contaminants.Keys) {  					if (Math.Abs (time - retention_time) < retentiontimTol)  						timePoints.Add (time);  				}  				pwiz.CLI.msdata.BinaryDataArray mzs = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  				List<double> mzFiltered = new List<double> (mzs.data.Count);  				List<double> intFiltered = new List<double> (intensities.data.Count);  				for (int k = 0; k < mzs.data.Count; k++) {  					bool found = false;  					double theMz = mzs.data [k];  					foreach (double t in timePoints)  						foreach (double mz in Numerics.GetValuesInRange (contaminants [t]' theMz' mt))  							if (Utilities.Numerics.MzDifference (mz' theMz' mt.Units) < mt.Value)  								found = true;  					if (!found) {  						mzFiltered.Add (theMz);  						intFiltered.Add (intensities.data [k]);  					}  				}  				spec.setMZIntensityArrays (mzFiltered' intFiltered);  			}  			editedSpec.setDataProcessing (msFile.run.spectrumList.dataProcessing ());  			editedSpec.spectra.Add (spec);  		}  		pwiz.CLI.msdata.MSDataFile.WriteConfig config = new pwiz.CLI.msdata.MSDataFile.WriteConfig ();  		config.format = pwiz.CLI.msdata.MSDataFile.Format.Format_mzML;  		//            config.compression = pwiz.CLI.msdata.MSDataFile.Compression.Compression_None;  		//            config.precision = pwiz.CLI.msdata.MSDataFile.Precision.Precision_32;  		msFile.run.spectrumList = editedSpec;  		msFile.write (vsCSV.GetFolder (file) + vsCSV.GetFileName_NoExtension (file) + "_DeContaminated.mzml"' config);  	}  }  catch (Exception ex) {  	Console.WriteLine (ex.StackTrace);  }  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: try {  	pwiz.CLI.msdata.MSDataFile msFileContaminant = new pwiz.CLI.msdata.MSDataFile (rawContaminants);  	int num_spectra = msFileContaminant.run.spectrumList.size ();  	for (int i = 0; i < num_spectra; i++) {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFileContaminant.run.spectrumList.spectrum (i' true);  		if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  			List<double> mzOk = new List<double> ();  			for (int k = 0; k < mz.data.Count; k++)  				if (intensities.data [k] > 500)  					mzOk.Add (mz.data [k]);  			if (mzOk.Count > 0) {  				mzOk.Sort ();  				contaminants.Add (retention_time' mzOk);  			}  		}  		spec.Dispose ();  		spec = null;  	}  	msFileContaminant.Dispose ();  	msFileContaminant = null;  	foreach (string file in raws) {  		pwiz.CLI.msdata.MSDataFile msFile = new pwiz.CLI.msdata.MSDataFile (file);  		pwiz.CLI.msdata.SpectrumListSimple editedSpec = new pwiz.CLI.msdata.SpectrumListSimple ();  		int nbSpec = msFile.run.spectrumList.size ();  		for (int i = 0; i < nbSpec; i++) {  			//Spectrum  			pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  			if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  			 {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				List<double> timePoints = new List<double> ();  				foreach (double time in contaminants.Keys) {  					if (Math.Abs (time - retention_time) < retentiontimTol)  						timePoints.Add (time);  				}  				pwiz.CLI.msdata.BinaryDataArray mzs = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  				List<double> mzFiltered = new List<double> (mzs.data.Count);  				List<double> intFiltered = new List<double> (intensities.data.Count);  				for (int k = 0; k < mzs.data.Count; k++) {  					bool found = false;  					double theMz = mzs.data [k];  					foreach (double t in timePoints)  						foreach (double mz in Numerics.GetValuesInRange (contaminants [t]' theMz' mt))  							if (Utilities.Numerics.MzDifference (mz' theMz' mt.Units) < mt.Value)  								found = true;  					if (!found) {  						mzFiltered.Add (theMz);  						intFiltered.Add (intensities.data [k]);  					}  				}  				spec.setMZIntensityArrays (mzFiltered' intFiltered);  			}  			editedSpec.setDataProcessing (msFile.run.spectrumList.dataProcessing ());  			editedSpec.spectra.Add (spec);  		}  		pwiz.CLI.msdata.MSDataFile.WriteConfig config = new pwiz.CLI.msdata.MSDataFile.WriteConfig ();  		config.format = pwiz.CLI.msdata.MSDataFile.Format.Format_mzML;  		//            config.compression = pwiz.CLI.msdata.MSDataFile.Compression.Compression_None;  		//            config.precision = pwiz.CLI.msdata.MSDataFile.Precision.Precision_32;  		msFile.run.spectrumList = editedSpec;  		msFile.write (vsCSV.GetFolder (file) + vsCSV.GetFileName_NoExtension (file) + "_DeContaminated.mzml"' config);  	}  }  catch (Exception ex) {  	Console.WriteLine (ex.StackTrace);  }  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: try {  	pwiz.CLI.msdata.MSDataFile msFileContaminant = new pwiz.CLI.msdata.MSDataFile (rawContaminants);  	int num_spectra = msFileContaminant.run.spectrumList.size ();  	for (int i = 0; i < num_spectra; i++) {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFileContaminant.run.spectrumList.spectrum (i' true);  		if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  			List<double> mzOk = new List<double> ();  			for (int k = 0; k < mz.data.Count; k++)  				if (intensities.data [k] > 500)  					mzOk.Add (mz.data [k]);  			if (mzOk.Count > 0) {  				mzOk.Sort ();  				contaminants.Add (retention_time' mzOk);  			}  		}  		spec.Dispose ();  		spec = null;  	}  	msFileContaminant.Dispose ();  	msFileContaminant = null;  	foreach (string file in raws) {  		pwiz.CLI.msdata.MSDataFile msFile = new pwiz.CLI.msdata.MSDataFile (file);  		pwiz.CLI.msdata.SpectrumListSimple editedSpec = new pwiz.CLI.msdata.SpectrumListSimple ();  		int nbSpec = msFile.run.spectrumList.size ();  		for (int i = 0; i < nbSpec; i++) {  			//Spectrum  			pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  			if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  			 {  				double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  				List<double> timePoints = new List<double> ();  				foreach (double time in contaminants.Keys) {  					if (Math.Abs (time - retention_time) < retentiontimTol)  						timePoints.Add (time);  				}  				pwiz.CLI.msdata.BinaryDataArray mzs = spec.getMZArray ();  				pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  				List<double> mzFiltered = new List<double> (mzs.data.Count);  				List<double> intFiltered = new List<double> (intensities.data.Count);  				for (int k = 0; k < mzs.data.Count; k++) {  					bool found = false;  					double theMz = mzs.data [k];  					foreach (double t in timePoints)  						foreach (double mz in Numerics.GetValuesInRange (contaminants [t]' theMz' mt))  							if (Utilities.Numerics.MzDifference (mz' theMz' mt.Units) < mt.Value)  								found = true;  					if (!found) {  						mzFiltered.Add (theMz);  						intFiltered.Add (intensities.data [k]);  					}  				}  				spec.setMZIntensityArrays (mzFiltered' intFiltered);  			}  			editedSpec.setDataProcessing (msFile.run.spectrumList.dataProcessing ());  			editedSpec.spectra.Add (spec);  		}  		pwiz.CLI.msdata.MSDataFile.WriteConfig config = new pwiz.CLI.msdata.MSDataFile.WriteConfig ();  		config.format = pwiz.CLI.msdata.MSDataFile.Format.Format_mzML;  		//            config.compression = pwiz.CLI.msdata.MSDataFile.Compression.Compression_None;  		//            config.precision = pwiz.CLI.msdata.MSDataFile.Precision.Precision_32;  		msFile.run.spectrumList = editedSpec;  		msFile.write (vsCSV.GetFolder (file) + vsCSV.GetFileName_NoExtension (file) + "_DeContaminated.mzml"' config);  	}  }  catch (Exception ex) {  	Console.WriteLine (ex.StackTrace);  }  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: for (int i = 0; i < num_spectra; i++) {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFileContaminant.run.spectrumList.spectrum (i' true);  	if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  		List<double> mzOk = new List<double> ();  		for (int k = 0; k < mz.data.Count; k++)  			if (intensities.data [k] > 500)  				mzOk.Add (mz.data [k]);  		if (mzOk.Count > 0) {  			mzOk.Sort ();  			contaminants.Add (retention_time' mzOk);  		}  	}  	spec.Dispose ();  	spec = null;  }  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: for (int i = 0; i < num_spectra; i++) {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFileContaminant.run.spectrumList.spectrum (i' true);  	if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  		List<double> mzOk = new List<double> ();  		for (int k = 0; k < mz.data.Count; k++)  			if (intensities.data [k] > 500)  				mzOk.Add (mz.data [k]);  		if (mzOk.Count > 0) {  			mzOk.Sort ();  			contaminants.Add (retention_time' mzOk);  		}  	}  	spec.Dispose ();  	spec = null;  }  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS   {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  	List<double> mzOk = new List<double> ();  	for (int k = 0; k < mz.data.Count; k++)  		if (intensities.data [k] > 500)  			mzOk.Add (mz.data [k]);  	if (mzOk.Count > 0) {  		mzOk.Sort ();  		contaminants.Add (retention_time' mzOk);  	}  }  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS   {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	pwiz.CLI.msdata.BinaryDataArray mz = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  	List<double> mzOk = new List<double> ();  	for (int k = 0; k < mz.data.Count; k++)  		if (intensities.data [k] > 500)  			mzOk.Add (mz.data [k]);  	if (mzOk.Count > 0) {  		mzOk.Sort ();  		contaminants.Add (retention_time' mzOk);  	}  }  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: for (int k = 0; k < mz.data.Count; k++)  	if (intensities.data [k] > 500)  		mzOk.Add (mz.data [k]);  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: if (intensities.data [k] > 500)  	mzOk.Add (mz.data [k]);  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: foreach (string file in raws) {  	pwiz.CLI.msdata.MSDataFile msFile = new pwiz.CLI.msdata.MSDataFile (file);  	pwiz.CLI.msdata.SpectrumListSimple editedSpec = new pwiz.CLI.msdata.SpectrumListSimple ();  	int nbSpec = msFile.run.spectrumList.size ();  	for (int i = 0; i < nbSpec; i++) {  		//Spectrum  		pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  		if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  		 {  			double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  			List<double> timePoints = new List<double> ();  			foreach (double time in contaminants.Keys) {  				if (Math.Abs (time - retention_time) < retentiontimTol)  					timePoints.Add (time);  			}  			pwiz.CLI.msdata.BinaryDataArray mzs = spec.getMZArray ();  			pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  			List<double> mzFiltered = new List<double> (mzs.data.Count);  			List<double> intFiltered = new List<double> (intensities.data.Count);  			for (int k = 0; k < mzs.data.Count; k++) {  				bool found = false;  				double theMz = mzs.data [k];  				foreach (double t in timePoints)  					foreach (double mz in Numerics.GetValuesInRange (contaminants [t]' theMz' mt))  						if (Utilities.Numerics.MzDifference (mz' theMz' mt.Units) < mt.Value)  							found = true;  				if (!found) {  					mzFiltered.Add (theMz);  					intFiltered.Add (intensities.data [k]);  				}  			}  			spec.setMZIntensityArrays (mzFiltered' intFiltered);  		}  		editedSpec.setDataProcessing (msFile.run.spectrumList.dataProcessing ());  		editedSpec.spectra.Add (spec);  	}  	pwiz.CLI.msdata.MSDataFile.WriteConfig config = new pwiz.CLI.msdata.MSDataFile.WriteConfig ();  	config.format = pwiz.CLI.msdata.MSDataFile.Format.Format_mzML;  	//            config.compression = pwiz.CLI.msdata.MSDataFile.Compression.Compression_None;  	//            config.precision = pwiz.CLI.msdata.MSDataFile.Precision.Precision_32;  	msFile.run.spectrumList = editedSpec;  	msFile.write (vsCSV.GetFolder (file) + vsCSV.GetFileName_NoExtension (file) + "_DeContaminated.mzml"' config);  }  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: for (int i = 0; i < nbSpec; i++) {  	//Spectrum  	pwiz.CLI.msdata.Spectrum spec = msFile.run.spectrumList.spectrum (i' true);  	if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS  	 {  		double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  		List<double> timePoints = new List<double> ();  		foreach (double time in contaminants.Keys) {  			if (Math.Abs (time - retention_time) < retentiontimTol)  				timePoints.Add (time);  		}  		pwiz.CLI.msdata.BinaryDataArray mzs = spec.getMZArray ();  		pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  		List<double> mzFiltered = new List<double> (mzs.data.Count);  		List<double> intFiltered = new List<double> (intensities.data.Count);  		for (int k = 0; k < mzs.data.Count; k++) {  			bool found = false;  			double theMz = mzs.data [k];  			foreach (double t in timePoints)  				foreach (double mz in Numerics.GetValuesInRange (contaminants [t]' theMz' mt))  					if (Utilities.Numerics.MzDifference (mz' theMz' mt.Units) < mt.Value)  						found = true;  			if (!found) {  				mzFiltered.Add (theMz);  				intFiltered.Add (intensities.data [k]);  			}  		}  		spec.setMZIntensityArrays (mzFiltered' intFiltered);  	}  	editedSpec.setDataProcessing (msFile.run.spectrumList.dataProcessing ());  	editedSpec.spectra.Add (spec);  }  
Magic Number,PeptidAce.Utilities.Methods,ContaminantRemoval,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\ContaminantRemoval.cs,FromRaw,The following statement contains a magic number: if (!(spec.precursors.Count > 0 || spec.cvParam (pwiz.CLI.cv.CVID.MS_ms_level).value > 1))//is an MSMS   {  	double retention_time = spec.scanList.scans [0].cvParam (pwiz.CLI.cv.CVID.MS_scan_start_time).timeInSeconds () / 60.0;  	List<double> timePoints = new List<double> ();  	foreach (double time in contaminants.Keys) {  		if (Math.Abs (time - retention_time) < retentiontimTol)  			timePoints.Add (time);  	}  	pwiz.CLI.msdata.BinaryDataArray mzs = spec.getMZArray ();  	pwiz.CLI.msdata.BinaryDataArray intensities = spec.getIntensityArray ();  	List<double> mzFiltered = new List<double> (mzs.data.Count);  	List<double> intFiltered = new List<double> (intensities.data.Count);  	for (int k = 0; k < mzs.data.Count; k++) {  		bool found = false;  		double theMz = mzs.data [k];  		foreach (double t in timePoints)  			foreach (double mz in Numerics.GetValuesInRange (contaminants [t]' theMz' mt))  				if (Utilities.Numerics.MzDifference (mz' theMz' mt.Units) < mt.Value)  					found = true;  		if (!found) {  			mzFiltered.Add (theMz);  			intFiltered.Add (intensities.data [k]);  		}  	}  	spec.setMZIntensityArrays (mzFiltered' intFiltered);  }  
Magic Number,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveFromGradientDescent,The following statement contains a magic number: if (seeds.Count == 1) {  	localMinima = new List<double> ();  	localMinima.Add (FindLocalMaxima (units [0]' mixed));  }  else  	localMinima = Gradior.Minimize (gdh.FCT' seeds' 0.01' 1' 1000' 0.05);  
Magic Number,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveFromGradientDescent,The following statement contains a magic number: if (seeds.Count == 1) {  	localMinima = new List<double> ();  	localMinima.Add (FindLocalMaxima (units [0]' mixed));  }  else  	localMinima = Gradior.Minimize (gdh.FCT' seeds' 0.01' 1' 1000' 0.05);  
Magic Number,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveFromGradientDescent,The following statement contains a magic number: if (seeds.Count == 1) {  	localMinima = new List<double> ();  	localMinima.Add (FindLocalMaxima (units [0]' mixed));  }  else  	localMinima = Gradior.Minimize (gdh.FCT' seeds' 0.01' 1' 1000' 0.05);  
Magic Number,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveFromGradientDescent,The following statement contains a magic number: localMinima = Gradior.Minimize (gdh.FCT' seeds' 0.01' 1' 1000' 0.05);  
Magic Number,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveFromGradientDescent,The following statement contains a magic number: localMinima = Gradior.Minimize (gdh.FCT' seeds' 0.01' 1' 1000' 0.05);  
Magic Number,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveFromGradientDescent,The following statement contains a magic number: localMinima = Gradior.Minimize (gdh.FCT' seeds' 0.01' 1' 1000' 0.05);  
Magic Number,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveMaxFlowStyle,The following statement contains a magic number: while (overError >= 1 && iterSize < 10000)//anything less than 1 is an acceptable solution   {  	for (int index = 0; index < bestIndexes.Length; index++)  		bestIndexes [index] = -1;  	for (int i = 0; i < units.Count; i++) {  		if (localFlows [i] > 0) {  			localFlows [i] -= stepSize * iterSize;  			virtualMixed = BuildVirtualDic (localFlows' units' mixed.Count);  			double tmpErrorOver = ComputeOver (virtualMixed' mixed);  			double tmpErrorUnder = ComputeUnder (virtualMixed' mixed);  			double tmpFlowRate = Math.Abs (overError - tmpErrorOver);  			double underDiff = 0;  			if (tmpErrorUnder > underError)  				underDiff = tmpErrorUnder - underError;  			if (underDiff >= 1)  				tmpFlowRate /= underDiff;  			bestIndexes [i] = tmpFlowRate;  			localFlows [i] += stepSize * iterSize;  		}  	}  	//Pick pseudo randomly best index  	double worstFlowRate = 0.0;  	for (int index = 0; index < bestIndexes.Length; index++)  		if (bestIndexes [index] > worstFlowRate) {  			worstFlowRate = bestIndexes [index];  		}  	if (worstFlowRate > 0) {  		int nbMatching = 0;  		for (int index = 0; index < bestIndexes.Length; index++)  			if (bestIndexes [index] >= worstFlowRate)  				nbMatching++;  		int iterChoice = rnd.Next (0' nbMatching - 1);  		int iterNb = 0;  		for (int index = 0; index < bestIndexes.Length; index++)  			if (bestIndexes [index] >= worstFlowRate) {  				if (iterChoice == iterNb) {  					localFlows [index] -= stepSize * iterSize;  					if (localFlows [index] < 0)  						localFlows [index] = 0.0;  				}  				iterNb++;  			}  		iterSize = 1;  	}  	else  		iterSize++;  	virtualMixed = BuildVirtualDic (localFlows' units' mixed.Count);  	overError = ComputeOver (virtualMixed' mixed);  	underError = ComputeUnder (virtualMixed' mixed);  	if (overError + underError < bestOverallError) {  		bestLocalFlows = new List<double> (localFlows);  		bestOverallError = overError + underError;  	}  }  
Magic Number,PeptidAce.Utilities.Methods,GradientDescent,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\GradientDescent.cs,SolveMaxFlowStyle_bkp,The following statement contains a magic number: while (overError >= 1 && iterSize < 10000)//anything less than 1 is an acceptable solution   {  	for (int index = 0; index < bestIndexes.Length; index++)  		bestIndexes [index] = -1;  	for (int i = 0; i < units.Count; i++) {  		if (localFlows [i] > 0) {  			localFlows [i] -= stepSize * iterSize;  			virtualMixed = BuildVirtualDic (localFlows' units' mixed.Count);  			double tmpErrorOver = ComputeOver (virtualMixed' mixed);  			double tmpErrorUnder = ComputeUnder (virtualMixed' mixed);  			double tmpFlowRate = Math.Abs (overError - tmpErrorOver);  			double underDiff = 0;  			if (tmpErrorUnder > underError)  				underDiff = tmpErrorUnder - underError;  			if (underDiff >= 1)  				tmpFlowRate /= underDiff;  			bestIndexes [i] = tmpFlowRate;  			localFlows [i] += stepSize * iterSize;  		}  	}  	//Pick pseudo randomly best index  	double worstFlowRate = 0.0;  	for (int index = 0; index < bestIndexes.Length; index++)  		if (bestIndexes [index] > worstFlowRate) {  			worstFlowRate = bestIndexes [index];  		}  	if (worstFlowRate > 0) {  		int nbMatching = 0;  		for (int index = 0; index < bestIndexes.Length; index++)  			if (bestIndexes [index] >= worstFlowRate)  				nbMatching++;  		int iterChoice = rnd.Next (0' nbMatching - 1);  		int iterNb = 0;  		for (int index = 0; index < bestIndexes.Length; index++)  			if (bestIndexes [index] >= worstFlowRate) {  				if (iterChoice == iterNb) {  					localFlows [index] -= stepSize * iterSize;  					if (localFlows [index] < 0)  						localFlows [index] = 0.0;  				}  				iterNb++;  			}  		iterSize = 1;  	}  	else  		iterSize++;  	virtualMixed = BuildVirtualDic (localFlows' units' mixed.Count);  	overError = ComputeOver (virtualMixed' mixed);  	underError = ComputeUnder (virtualMixed' mixed);  	if (overError + underError < bestOverallError) {  		bestLocalFlows = new List<double> (localFlows);  		bestOverallError = overError + underError;  	}  }  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,Run,The following statement contains a magic number: dbOptions.dMatchingProductFraction = seed [2];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,Run,The following statement contains a magic number: dbOptions.dMatchingProduct = seed [3];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,Run,The following statement contains a magic number: dbOptions.dIntensityFraction = seed [4];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,Run,The following statement contains a magic number: dbOptions.dIntensity = seed [5];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,Run,The following statement contains a magic number: dbOptions.dProtein = seed [6];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,Run,The following statement contains a magic number: dbOptions.dPeptideScore = seed [7];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,Run,The following statement contains a magic number: dbOptions.dFragmentScore = seed [8];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,FCT,The following statement contains a magic number: dbOptions.dMatchingProductFraction = scoreWeights [2];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,FCT,The following statement contains a magic number: dbOptions.dMatchingProduct = scoreWeights [3];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,FCT,The following statement contains a magic number: dbOptions.dIntensityFraction = scoreWeights [4];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,FCT,The following statement contains a magic number: dbOptions.dIntensity = scoreWeights [5];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,FCT,The following statement contains a magic number: dbOptions.dProtein = scoreWeights [6];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,FCT,The following statement contains a magic number: dbOptions.dPeptideScore = scoreWeights [7];  
Magic Number,PeptidAce.Utilities.Methods,UptimizeOptions,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Methods\Uptimize.cs,FCT,The following statement contains a magic number: dbOptions.dFragmentScore = scoreWeights [8];  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' string> protPair in proteins) {  	string protein = protPair.Value;  	foreach (string peptide in dicOfPeptides.Keys) {  		foreach (string[] occurance in dicOfPeptides [peptide]) {  			if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  				int index = protein.IndexOf (peptide);  				while (index < protein.Length && index >= 0) {  					if (index > 0) {  						int startIndex = index - 50;  						if (startIndex < 0)  							startIndex = 0;  						int length = peptide.Length + 40;  						if (startIndex + length >= protein.Length)  							length = protein.Length - startIndex;  						//int endIndex   = index + peptide.Length + 40;  						//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  						string subProt = protein.Substring (startIndex' length);  						foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  							foreach (Match match in pair.Value.Matches (subProt)) {  								string line = "";  								int otherIndexes = 0;  								int bestDistance = int.MaxValue;  								while (otherIndexes >= 0) {  									otherIndexes++;  									bool hasSP = false;  									bool hasPH = false;  									int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  									if (indexOfPh < 0)  										indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  									else  										hasSP = true;  									otherIndexes = indexOfPh;  									if (indexOfPh < 0)  										indexOfPh = peptide.Length / 2;  									else  										hasPH = true;  									indexOfPh += index + 1;  									int indexOfMotif = match.Index + startIndex + 1;  									int distance = Math.Abs (indexOfMotif - indexOfPh);  									if (distance < bestDistance) {  										bestDistance = distance;  										line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  									}  								}  								writer.AddLine (line);  							}  					}  					index = protein.IndexOf (peptide' index + 1);  				}  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' string> protPair in proteins) {  	string protein = protPair.Value;  	foreach (string peptide in dicOfPeptides.Keys) {  		foreach (string[] occurance in dicOfPeptides [peptide]) {  			if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  				int index = protein.IndexOf (peptide);  				while (index < protein.Length && index >= 0) {  					if (index > 0) {  						int startIndex = index - 50;  						if (startIndex < 0)  							startIndex = 0;  						int length = peptide.Length + 40;  						if (startIndex + length >= protein.Length)  							length = protein.Length - startIndex;  						//int endIndex   = index + peptide.Length + 40;  						//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  						string subProt = protein.Substring (startIndex' length);  						foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  							foreach (Match match in pair.Value.Matches (subProt)) {  								string line = "";  								int otherIndexes = 0;  								int bestDistance = int.MaxValue;  								while (otherIndexes >= 0) {  									otherIndexes++;  									bool hasSP = false;  									bool hasPH = false;  									int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  									if (indexOfPh < 0)  										indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  									else  										hasSP = true;  									otherIndexes = indexOfPh;  									if (indexOfPh < 0)  										indexOfPh = peptide.Length / 2;  									else  										hasPH = true;  									indexOfPh += index + 1;  									int indexOfMotif = match.Index + startIndex + 1;  									int distance = Math.Abs (indexOfMotif - indexOfPh);  									if (distance < bestDistance) {  										bestDistance = distance;  										line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  									}  								}  								writer.AddLine (line);  							}  					}  					index = protein.IndexOf (peptide' index + 1);  				}  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' string> protPair in proteins) {  	string protein = protPair.Value;  	foreach (string peptide in dicOfPeptides.Keys) {  		foreach (string[] occurance in dicOfPeptides [peptide]) {  			if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  				int index = protein.IndexOf (peptide);  				while (index < protein.Length && index >= 0) {  					if (index > 0) {  						int startIndex = index - 50;  						if (startIndex < 0)  							startIndex = 0;  						int length = peptide.Length + 40;  						if (startIndex + length >= protein.Length)  							length = protein.Length - startIndex;  						//int endIndex   = index + peptide.Length + 40;  						//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  						string subProt = protein.Substring (startIndex' length);  						foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  							foreach (Match match in pair.Value.Matches (subProt)) {  								string line = "";  								int otherIndexes = 0;  								int bestDistance = int.MaxValue;  								while (otherIndexes >= 0) {  									otherIndexes++;  									bool hasSP = false;  									bool hasPH = false;  									int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  									if (indexOfPh < 0)  										indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  									else  										hasSP = true;  									otherIndexes = indexOfPh;  									if (indexOfPh < 0)  										indexOfPh = peptide.Length / 2;  									else  										hasPH = true;  									indexOfPh += index + 1;  									int indexOfMotif = match.Index + startIndex + 1;  									int distance = Math.Abs (indexOfMotif - indexOfPh);  									if (distance < bestDistance) {  										bestDistance = distance;  										line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  									}  								}  								writer.AddLine (line);  							}  					}  					index = protein.IndexOf (peptide' index + 1);  				}  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' string> protPair in proteins) {  	string protein = protPair.Value;  	foreach (string peptide in dicOfPeptides.Keys) {  		foreach (string[] occurance in dicOfPeptides [peptide]) {  			if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  				int index = protein.IndexOf (peptide);  				while (index < protein.Length && index >= 0) {  					if (index > 0) {  						int startIndex = index - 50;  						if (startIndex < 0)  							startIndex = 0;  						int length = peptide.Length + 40;  						if (startIndex + length >= protein.Length)  							length = protein.Length - startIndex;  						//int endIndex   = index + peptide.Length + 40;  						//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  						string subProt = protein.Substring (startIndex' length);  						foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  							foreach (Match match in pair.Value.Matches (subProt)) {  								string line = "";  								int otherIndexes = 0;  								int bestDistance = int.MaxValue;  								while (otherIndexes >= 0) {  									otherIndexes++;  									bool hasSP = false;  									bool hasPH = false;  									int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  									if (indexOfPh < 0)  										indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  									else  										hasSP = true;  									otherIndexes = indexOfPh;  									if (indexOfPh < 0)  										indexOfPh = peptide.Length / 2;  									else  										hasPH = true;  									indexOfPh += index + 1;  									int indexOfMotif = match.Index + startIndex + 1;  									int distance = Math.Abs (indexOfMotif - indexOfPh);  									if (distance < bestDistance) {  										bestDistance = distance;  										line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  									}  								}  								writer.AddLine (line);  							}  					}  					index = protein.IndexOf (peptide' index + 1);  				}  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' string> protPair in proteins) {  	string protein = protPair.Value;  	foreach (string peptide in dicOfPeptides.Keys) {  		foreach (string[] occurance in dicOfPeptides [peptide]) {  			if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  				int index = protein.IndexOf (peptide);  				while (index < protein.Length && index >= 0) {  					if (index > 0) {  						int startIndex = index - 50;  						if (startIndex < 0)  							startIndex = 0;  						int length = peptide.Length + 40;  						if (startIndex + length >= protein.Length)  							length = protein.Length - startIndex;  						//int endIndex   = index + peptide.Length + 40;  						//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  						string subProt = protein.Substring (startIndex' length);  						foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  							foreach (Match match in pair.Value.Matches (subProt)) {  								string line = "";  								int otherIndexes = 0;  								int bestDistance = int.MaxValue;  								while (otherIndexes >= 0) {  									otherIndexes++;  									bool hasSP = false;  									bool hasPH = false;  									int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  									if (indexOfPh < 0)  										indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  									else  										hasSP = true;  									otherIndexes = indexOfPh;  									if (indexOfPh < 0)  										indexOfPh = peptide.Length / 2;  									else  										hasPH = true;  									indexOfPh += index + 1;  									int indexOfMotif = match.Index + startIndex + 1;  									int distance = Math.Abs (indexOfMotif - indexOfPh);  									if (distance < bestDistance) {  										bestDistance = distance;  										line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  									}  								}  								writer.AddLine (line);  							}  					}  					index = protein.IndexOf (peptide' index + 1);  				}  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' string> protPair in proteins) {  	string protein = protPair.Value;  	foreach (string peptide in dicOfPeptides.Keys) {  		foreach (string[] occurance in dicOfPeptides [peptide]) {  			if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  				int index = protein.IndexOf (peptide);  				while (index < protein.Length && index >= 0) {  					if (index > 0) {  						int startIndex = index - 50;  						if (startIndex < 0)  							startIndex = 0;  						int length = peptide.Length + 40;  						if (startIndex + length >= protein.Length)  							length = protein.Length - startIndex;  						//int endIndex   = index + peptide.Length + 40;  						//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  						string subProt = protein.Substring (startIndex' length);  						foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  							foreach (Match match in pair.Value.Matches (subProt)) {  								string line = "";  								int otherIndexes = 0;  								int bestDistance = int.MaxValue;  								while (otherIndexes >= 0) {  									otherIndexes++;  									bool hasSP = false;  									bool hasPH = false;  									int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  									if (indexOfPh < 0)  										indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  									else  										hasSP = true;  									otherIndexes = indexOfPh;  									if (indexOfPh < 0)  										indexOfPh = peptide.Length / 2;  									else  										hasPH = true;  									indexOfPh += index + 1;  									int indexOfMotif = match.Index + startIndex + 1;  									int distance = Math.Abs (indexOfMotif - indexOfPh);  									if (distance < bestDistance) {  										bestDistance = distance;  										line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  									}  								}  								writer.AddLine (line);  							}  					}  					index = protein.IndexOf (peptide' index + 1);  				}  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string peptide in dicOfPeptides.Keys) {  	foreach (string[] occurance in dicOfPeptides [peptide]) {  		if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  			int index = protein.IndexOf (peptide);  			while (index < protein.Length && index >= 0) {  				if (index > 0) {  					int startIndex = index - 50;  					if (startIndex < 0)  						startIndex = 0;  					int length = peptide.Length + 40;  					if (startIndex + length >= protein.Length)  						length = protein.Length - startIndex;  					//int endIndex   = index + peptide.Length + 40;  					//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  					string subProt = protein.Substring (startIndex' length);  					foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  						foreach (Match match in pair.Value.Matches (subProt)) {  							string line = "";  							int otherIndexes = 0;  							int bestDistance = int.MaxValue;  							while (otherIndexes >= 0) {  								otherIndexes++;  								bool hasSP = false;  								bool hasPH = false;  								int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  								if (indexOfPh < 0)  									indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  								else  									hasSP = true;  								otherIndexes = indexOfPh;  								if (indexOfPh < 0)  									indexOfPh = peptide.Length / 2;  								else  									hasPH = true;  								indexOfPh += index + 1;  								int indexOfMotif = match.Index + startIndex + 1;  								int distance = Math.Abs (indexOfMotif - indexOfPh);  								if (distance < bestDistance) {  									bestDistance = distance;  									line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  								}  							}  							writer.AddLine (line);  						}  				}  				index = protein.IndexOf (peptide' index + 1);  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string peptide in dicOfPeptides.Keys) {  	foreach (string[] occurance in dicOfPeptides [peptide]) {  		if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  			int index = protein.IndexOf (peptide);  			while (index < protein.Length && index >= 0) {  				if (index > 0) {  					int startIndex = index - 50;  					if (startIndex < 0)  						startIndex = 0;  					int length = peptide.Length + 40;  					if (startIndex + length >= protein.Length)  						length = protein.Length - startIndex;  					//int endIndex   = index + peptide.Length + 40;  					//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  					string subProt = protein.Substring (startIndex' length);  					foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  						foreach (Match match in pair.Value.Matches (subProt)) {  							string line = "";  							int otherIndexes = 0;  							int bestDistance = int.MaxValue;  							while (otherIndexes >= 0) {  								otherIndexes++;  								bool hasSP = false;  								bool hasPH = false;  								int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  								if (indexOfPh < 0)  									indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  								else  									hasSP = true;  								otherIndexes = indexOfPh;  								if (indexOfPh < 0)  									indexOfPh = peptide.Length / 2;  								else  									hasPH = true;  								indexOfPh += index + 1;  								int indexOfMotif = match.Index + startIndex + 1;  								int distance = Math.Abs (indexOfMotif - indexOfPh);  								if (distance < bestDistance) {  									bestDistance = distance;  									line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  								}  							}  							writer.AddLine (line);  						}  				}  				index = protein.IndexOf (peptide' index + 1);  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string peptide in dicOfPeptides.Keys) {  	foreach (string[] occurance in dicOfPeptides [peptide]) {  		if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  			int index = protein.IndexOf (peptide);  			while (index < protein.Length && index >= 0) {  				if (index > 0) {  					int startIndex = index - 50;  					if (startIndex < 0)  						startIndex = 0;  					int length = peptide.Length + 40;  					if (startIndex + length >= protein.Length)  						length = protein.Length - startIndex;  					//int endIndex   = index + peptide.Length + 40;  					//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  					string subProt = protein.Substring (startIndex' length);  					foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  						foreach (Match match in pair.Value.Matches (subProt)) {  							string line = "";  							int otherIndexes = 0;  							int bestDistance = int.MaxValue;  							while (otherIndexes >= 0) {  								otherIndexes++;  								bool hasSP = false;  								bool hasPH = false;  								int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  								if (indexOfPh < 0)  									indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  								else  									hasSP = true;  								otherIndexes = indexOfPh;  								if (indexOfPh < 0)  									indexOfPh = peptide.Length / 2;  								else  									hasPH = true;  								indexOfPh += index + 1;  								int indexOfMotif = match.Index + startIndex + 1;  								int distance = Math.Abs (indexOfMotif - indexOfPh);  								if (distance < bestDistance) {  									bestDistance = distance;  									line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  								}  							}  							writer.AddLine (line);  						}  				}  				index = protein.IndexOf (peptide' index + 1);  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string peptide in dicOfPeptides.Keys) {  	foreach (string[] occurance in dicOfPeptides [peptide]) {  		if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  			int index = protein.IndexOf (peptide);  			while (index < protein.Length && index >= 0) {  				if (index > 0) {  					int startIndex = index - 50;  					if (startIndex < 0)  						startIndex = 0;  					int length = peptide.Length + 40;  					if (startIndex + length >= protein.Length)  						length = protein.Length - startIndex;  					//int endIndex   = index + peptide.Length + 40;  					//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  					string subProt = protein.Substring (startIndex' length);  					foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  						foreach (Match match in pair.Value.Matches (subProt)) {  							string line = "";  							int otherIndexes = 0;  							int bestDistance = int.MaxValue;  							while (otherIndexes >= 0) {  								otherIndexes++;  								bool hasSP = false;  								bool hasPH = false;  								int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  								if (indexOfPh < 0)  									indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  								else  									hasSP = true;  								otherIndexes = indexOfPh;  								if (indexOfPh < 0)  									indexOfPh = peptide.Length / 2;  								else  									hasPH = true;  								indexOfPh += index + 1;  								int indexOfMotif = match.Index + startIndex + 1;  								int distance = Math.Abs (indexOfMotif - indexOfPh);  								if (distance < bestDistance) {  									bestDistance = distance;  									line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  								}  							}  							writer.AddLine (line);  						}  				}  				index = protein.IndexOf (peptide' index + 1);  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string peptide in dicOfPeptides.Keys) {  	foreach (string[] occurance in dicOfPeptides [peptide]) {  		if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  			int index = protein.IndexOf (peptide);  			while (index < protein.Length && index >= 0) {  				if (index > 0) {  					int startIndex = index - 50;  					if (startIndex < 0)  						startIndex = 0;  					int length = peptide.Length + 40;  					if (startIndex + length >= protein.Length)  						length = protein.Length - startIndex;  					//int endIndex   = index + peptide.Length + 40;  					//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  					string subProt = protein.Substring (startIndex' length);  					foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  						foreach (Match match in pair.Value.Matches (subProt)) {  							string line = "";  							int otherIndexes = 0;  							int bestDistance = int.MaxValue;  							while (otherIndexes >= 0) {  								otherIndexes++;  								bool hasSP = false;  								bool hasPH = false;  								int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  								if (indexOfPh < 0)  									indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  								else  									hasSP = true;  								otherIndexes = indexOfPh;  								if (indexOfPh < 0)  									indexOfPh = peptide.Length / 2;  								else  									hasPH = true;  								indexOfPh += index + 1;  								int indexOfMotif = match.Index + startIndex + 1;  								int distance = Math.Abs (indexOfMotif - indexOfPh);  								if (distance < bestDistance) {  									bestDistance = distance;  									line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  								}  							}  							writer.AddLine (line);  						}  				}  				index = protein.IndexOf (peptide' index + 1);  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string peptide in dicOfPeptides.Keys) {  	foreach (string[] occurance in dicOfPeptides [peptide]) {  		if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  			int index = protein.IndexOf (peptide);  			while (index < protein.Length && index >= 0) {  				if (index > 0) {  					int startIndex = index - 50;  					if (startIndex < 0)  						startIndex = 0;  					int length = peptide.Length + 40;  					if (startIndex + length >= protein.Length)  						length = protein.Length - startIndex;  					//int endIndex   = index + peptide.Length + 40;  					//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  					string subProt = protein.Substring (startIndex' length);  					foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  						foreach (Match match in pair.Value.Matches (subProt)) {  							string line = "";  							int otherIndexes = 0;  							int bestDistance = int.MaxValue;  							while (otherIndexes >= 0) {  								otherIndexes++;  								bool hasSP = false;  								bool hasPH = false;  								int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  								if (indexOfPh < 0)  									indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  								else  									hasSP = true;  								otherIndexes = indexOfPh;  								if (indexOfPh < 0)  									indexOfPh = peptide.Length / 2;  								else  									hasPH = true;  								indexOfPh += index + 1;  								int indexOfMotif = match.Index + startIndex + 1;  								int distance = Math.Abs (indexOfMotif - indexOfPh);  								if (distance < bestDistance) {  									bestDistance = distance;  									line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  								}  							}  							writer.AddLine (line);  						}  				}  				index = protein.IndexOf (peptide' index + 1);  			}  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string[] occurance in dicOfPeptides [peptide]) {  	if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  		int index = protein.IndexOf (peptide);  		while (index < protein.Length && index >= 0) {  			if (index > 0) {  				int startIndex = index - 50;  				if (startIndex < 0)  					startIndex = 0;  				int length = peptide.Length + 40;  				if (startIndex + length >= protein.Length)  					length = protein.Length - startIndex;  				//int endIndex   = index + peptide.Length + 40;  				//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  				string subProt = protein.Substring (startIndex' length);  				foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  					foreach (Match match in pair.Value.Matches (subProt)) {  						string line = "";  						int otherIndexes = 0;  						int bestDistance = int.MaxValue;  						while (otherIndexes >= 0) {  							otherIndexes++;  							bool hasSP = false;  							bool hasPH = false;  							int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  							if (indexOfPh < 0)  								indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  							else  								hasSP = true;  							otherIndexes = indexOfPh;  							if (indexOfPh < 0)  								indexOfPh = peptide.Length / 2;  							else  								hasPH = true;  							indexOfPh += index + 1;  							int indexOfMotif = match.Index + startIndex + 1;  							int distance = Math.Abs (indexOfMotif - indexOfPh);  							if (distance < bestDistance) {  								bestDistance = distance;  								line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  							}  						}  						writer.AddLine (line);  					}  			}  			index = protein.IndexOf (peptide' index + 1);  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string[] occurance in dicOfPeptides [peptide]) {  	if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  		int index = protein.IndexOf (peptide);  		while (index < protein.Length && index >= 0) {  			if (index > 0) {  				int startIndex = index - 50;  				if (startIndex < 0)  					startIndex = 0;  				int length = peptide.Length + 40;  				if (startIndex + length >= protein.Length)  					length = protein.Length - startIndex;  				//int endIndex   = index + peptide.Length + 40;  				//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  				string subProt = protein.Substring (startIndex' length);  				foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  					foreach (Match match in pair.Value.Matches (subProt)) {  						string line = "";  						int otherIndexes = 0;  						int bestDistance = int.MaxValue;  						while (otherIndexes >= 0) {  							otherIndexes++;  							bool hasSP = false;  							bool hasPH = false;  							int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  							if (indexOfPh < 0)  								indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  							else  								hasSP = true;  							otherIndexes = indexOfPh;  							if (indexOfPh < 0)  								indexOfPh = peptide.Length / 2;  							else  								hasPH = true;  							indexOfPh += index + 1;  							int indexOfMotif = match.Index + startIndex + 1;  							int distance = Math.Abs (indexOfMotif - indexOfPh);  							if (distance < bestDistance) {  								bestDistance = distance;  								line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  							}  						}  						writer.AddLine (line);  					}  			}  			index = protein.IndexOf (peptide' index + 1);  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string[] occurance in dicOfPeptides [peptide]) {  	if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  		int index = protein.IndexOf (peptide);  		while (index < protein.Length && index >= 0) {  			if (index > 0) {  				int startIndex = index - 50;  				if (startIndex < 0)  					startIndex = 0;  				int length = peptide.Length + 40;  				if (startIndex + length >= protein.Length)  					length = protein.Length - startIndex;  				//int endIndex   = index + peptide.Length + 40;  				//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  				string subProt = protein.Substring (startIndex' length);  				foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  					foreach (Match match in pair.Value.Matches (subProt)) {  						string line = "";  						int otherIndexes = 0;  						int bestDistance = int.MaxValue;  						while (otherIndexes >= 0) {  							otherIndexes++;  							bool hasSP = false;  							bool hasPH = false;  							int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  							if (indexOfPh < 0)  								indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  							else  								hasSP = true;  							otherIndexes = indexOfPh;  							if (indexOfPh < 0)  								indexOfPh = peptide.Length / 2;  							else  								hasPH = true;  							indexOfPh += index + 1;  							int indexOfMotif = match.Index + startIndex + 1;  							int distance = Math.Abs (indexOfMotif - indexOfPh);  							if (distance < bestDistance) {  								bestDistance = distance;  								line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  							}  						}  						writer.AddLine (line);  					}  			}  			index = protein.IndexOf (peptide' index + 1);  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string[] occurance in dicOfPeptides [peptide]) {  	if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  		int index = protein.IndexOf (peptide);  		while (index < protein.Length && index >= 0) {  			if (index > 0) {  				int startIndex = index - 50;  				if (startIndex < 0)  					startIndex = 0;  				int length = peptide.Length + 40;  				if (startIndex + length >= protein.Length)  					length = protein.Length - startIndex;  				//int endIndex   = index + peptide.Length + 40;  				//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  				string subProt = protein.Substring (startIndex' length);  				foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  					foreach (Match match in pair.Value.Matches (subProt)) {  						string line = "";  						int otherIndexes = 0;  						int bestDistance = int.MaxValue;  						while (otherIndexes >= 0) {  							otherIndexes++;  							bool hasSP = false;  							bool hasPH = false;  							int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  							if (indexOfPh < 0)  								indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  							else  								hasSP = true;  							otherIndexes = indexOfPh;  							if (indexOfPh < 0)  								indexOfPh = peptide.Length / 2;  							else  								hasPH = true;  							indexOfPh += index + 1;  							int indexOfMotif = match.Index + startIndex + 1;  							int distance = Math.Abs (indexOfMotif - indexOfPh);  							if (distance < bestDistance) {  								bestDistance = distance;  								line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  							}  						}  						writer.AddLine (line);  					}  			}  			index = protein.IndexOf (peptide' index + 1);  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string[] occurance in dicOfPeptides [peptide]) {  	if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  		int index = protein.IndexOf (peptide);  		while (index < protein.Length && index >= 0) {  			if (index > 0) {  				int startIndex = index - 50;  				if (startIndex < 0)  					startIndex = 0;  				int length = peptide.Length + 40;  				if (startIndex + length >= protein.Length)  					length = protein.Length - startIndex;  				//int endIndex   = index + peptide.Length + 40;  				//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  				string subProt = protein.Substring (startIndex' length);  				foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  					foreach (Match match in pair.Value.Matches (subProt)) {  						string line = "";  						int otherIndexes = 0;  						int bestDistance = int.MaxValue;  						while (otherIndexes >= 0) {  							otherIndexes++;  							bool hasSP = false;  							bool hasPH = false;  							int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  							if (indexOfPh < 0)  								indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  							else  								hasSP = true;  							otherIndexes = indexOfPh;  							if (indexOfPh < 0)  								indexOfPh = peptide.Length / 2;  							else  								hasPH = true;  							indexOfPh += index + 1;  							int indexOfMotif = match.Index + startIndex + 1;  							int distance = Math.Abs (indexOfMotif - indexOfPh);  							if (distance < bestDistance) {  								bestDistance = distance;  								line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  							}  						}  						writer.AddLine (line);  					}  			}  			index = protein.IndexOf (peptide' index + 1);  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (string[] occurance in dicOfPeptides [peptide]) {  	if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  		int index = protein.IndexOf (peptide);  		while (index < protein.Length && index >= 0) {  			if (index > 0) {  				int startIndex = index - 50;  				if (startIndex < 0)  					startIndex = 0;  				int length = peptide.Length + 40;  				if (startIndex + length >= protein.Length)  					length = protein.Length - startIndex;  				//int endIndex   = index + peptide.Length + 40;  				//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  				string subProt = protein.Substring (startIndex' length);  				foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  					foreach (Match match in pair.Value.Matches (subProt)) {  						string line = "";  						int otherIndexes = 0;  						int bestDistance = int.MaxValue;  						while (otherIndexes >= 0) {  							otherIndexes++;  							bool hasSP = false;  							bool hasPH = false;  							int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  							if (indexOfPh < 0)  								indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  							else  								hasSP = true;  							otherIndexes = indexOfPh;  							if (indexOfPh < 0)  								indexOfPh = peptide.Length / 2;  							else  								hasPH = true;  							indexOfPh += index + 1;  							int indexOfMotif = match.Index + startIndex + 1;  							int distance = Math.Abs (indexOfMotif - indexOfPh);  							if (distance < bestDistance) {  								bestDistance = distance;  								line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  							}  						}  						writer.AddLine (line);  					}  			}  			index = protein.IndexOf (peptide' index + 1);  		}  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  	int index = protein.IndexOf (peptide);  	while (index < protein.Length && index >= 0) {  		if (index > 0) {  			int startIndex = index - 50;  			if (startIndex < 0)  				startIndex = 0;  			int length = peptide.Length + 40;  			if (startIndex + length >= protein.Length)  				length = protein.Length - startIndex;  			//int endIndex   = index + peptide.Length + 40;  			//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  			string subProt = protein.Substring (startIndex' length);  			foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  				foreach (Match match in pair.Value.Matches (subProt)) {  					string line = "";  					int otherIndexes = 0;  					int bestDistance = int.MaxValue;  					while (otherIndexes >= 0) {  						otherIndexes++;  						bool hasSP = false;  						bool hasPH = false;  						int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  						if (indexOfPh < 0)  							indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  						else  							hasSP = true;  						otherIndexes = indexOfPh;  						if (indexOfPh < 0)  							indexOfPh = peptide.Length / 2;  						else  							hasPH = true;  						indexOfPh += index + 1;  						int indexOfMotif = match.Index + startIndex + 1;  						int distance = Math.Abs (indexOfMotif - indexOfPh);  						if (distance < bestDistance) {  							bestDistance = distance;  							line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  						}  					}  					writer.AddLine (line);  				}  		}  		index = protein.IndexOf (peptide' index + 1);  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  	int index = protein.IndexOf (peptide);  	while (index < protein.Length && index >= 0) {  		if (index > 0) {  			int startIndex = index - 50;  			if (startIndex < 0)  				startIndex = 0;  			int length = peptide.Length + 40;  			if (startIndex + length >= protein.Length)  				length = protein.Length - startIndex;  			//int endIndex   = index + peptide.Length + 40;  			//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  			string subProt = protein.Substring (startIndex' length);  			foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  				foreach (Match match in pair.Value.Matches (subProt)) {  					string line = "";  					int otherIndexes = 0;  					int bestDistance = int.MaxValue;  					while (otherIndexes >= 0) {  						otherIndexes++;  						bool hasSP = false;  						bool hasPH = false;  						int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  						if (indexOfPh < 0)  							indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  						else  							hasSP = true;  						otherIndexes = indexOfPh;  						if (indexOfPh < 0)  							indexOfPh = peptide.Length / 2;  						else  							hasPH = true;  						indexOfPh += index + 1;  						int indexOfMotif = match.Index + startIndex + 1;  						int distance = Math.Abs (indexOfMotif - indexOfPh);  						if (distance < bestDistance) {  							bestDistance = distance;  							line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  						}  					}  					writer.AddLine (line);  				}  		}  		index = protein.IndexOf (peptide' index + 1);  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  	int index = protein.IndexOf (peptide);  	while (index < protein.Length && index >= 0) {  		if (index > 0) {  			int startIndex = index - 50;  			if (startIndex < 0)  				startIndex = 0;  			int length = peptide.Length + 40;  			if (startIndex + length >= protein.Length)  				length = protein.Length - startIndex;  			//int endIndex   = index + peptide.Length + 40;  			//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  			string subProt = protein.Substring (startIndex' length);  			foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  				foreach (Match match in pair.Value.Matches (subProt)) {  					string line = "";  					int otherIndexes = 0;  					int bestDistance = int.MaxValue;  					while (otherIndexes >= 0) {  						otherIndexes++;  						bool hasSP = false;  						bool hasPH = false;  						int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  						if (indexOfPh < 0)  							indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  						else  							hasSP = true;  						otherIndexes = indexOfPh;  						if (indexOfPh < 0)  							indexOfPh = peptide.Length / 2;  						else  							hasPH = true;  						indexOfPh += index + 1;  						int indexOfMotif = match.Index + startIndex + 1;  						int distance = Math.Abs (indexOfMotif - indexOfPh);  						if (distance < bestDistance) {  							bestDistance = distance;  							line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  						}  					}  					writer.AddLine (line);  				}  		}  		index = protein.IndexOf (peptide' index + 1);  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  	int index = protein.IndexOf (peptide);  	while (index < protein.Length && index >= 0) {  		if (index > 0) {  			int startIndex = index - 50;  			if (startIndex < 0)  				startIndex = 0;  			int length = peptide.Length + 40;  			if (startIndex + length >= protein.Length)  				length = protein.Length - startIndex;  			//int endIndex   = index + peptide.Length + 40;  			//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  			string subProt = protein.Substring (startIndex' length);  			foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  				foreach (Match match in pair.Value.Matches (subProt)) {  					string line = "";  					int otherIndexes = 0;  					int bestDistance = int.MaxValue;  					while (otherIndexes >= 0) {  						otherIndexes++;  						bool hasSP = false;  						bool hasPH = false;  						int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  						if (indexOfPh < 0)  							indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  						else  							hasSP = true;  						otherIndexes = indexOfPh;  						if (indexOfPh < 0)  							indexOfPh = peptide.Length / 2;  						else  							hasPH = true;  						indexOfPh += index + 1;  						int indexOfMotif = match.Index + startIndex + 1;  						int distance = Math.Abs (indexOfMotif - indexOfPh);  						if (distance < bestDistance) {  							bestDistance = distance;  							line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  						}  					}  					writer.AddLine (line);  				}  		}  		index = protein.IndexOf (peptide' index + 1);  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  	int index = protein.IndexOf (peptide);  	while (index < protein.Length && index >= 0) {  		if (index > 0) {  			int startIndex = index - 50;  			if (startIndex < 0)  				startIndex = 0;  			int length = peptide.Length + 40;  			if (startIndex + length >= protein.Length)  				length = protein.Length - startIndex;  			//int endIndex   = index + peptide.Length + 40;  			//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  			string subProt = protein.Substring (startIndex' length);  			foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  				foreach (Match match in pair.Value.Matches (subProt)) {  					string line = "";  					int otherIndexes = 0;  					int bestDistance = int.MaxValue;  					while (otherIndexes >= 0) {  						otherIndexes++;  						bool hasSP = false;  						bool hasPH = false;  						int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  						if (indexOfPh < 0)  							indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  						else  							hasSP = true;  						otherIndexes = indexOfPh;  						if (indexOfPh < 0)  							indexOfPh = peptide.Length / 2;  						else  							hasPH = true;  						indexOfPh += index + 1;  						int indexOfMotif = match.Index + startIndex + 1;  						int distance = Math.Abs (indexOfMotif - indexOfPh);  						if (distance < bestDistance) {  							bestDistance = distance;  							line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  						}  					}  					writer.AddLine (line);  				}  		}  		index = protein.IndexOf (peptide' index + 1);  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if ((!string.IsNullOrEmpty (occurance [0]) && protPair.Key.Contains (occurance [0])) || (!string.IsNullOrEmpty (occurance [1]) && protPair.Key.Contains (occurance [1]))) {  	int index = protein.IndexOf (peptide);  	while (index < protein.Length && index >= 0) {  		if (index > 0) {  			int startIndex = index - 50;  			if (startIndex < 0)  				startIndex = 0;  			int length = peptide.Length + 40;  			if (startIndex + length >= protein.Length)  				length = protein.Length - startIndex;  			//int endIndex   = index + peptide.Length + 40;  			//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  			string subProt = protein.Substring (startIndex' length);  			foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  				foreach (Match match in pair.Value.Matches (subProt)) {  					string line = "";  					int otherIndexes = 0;  					int bestDistance = int.MaxValue;  					while (otherIndexes >= 0) {  						otherIndexes++;  						bool hasSP = false;  						bool hasPH = false;  						int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  						if (indexOfPh < 0)  							indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  						else  							hasSP = true;  						otherIndexes = indexOfPh;  						if (indexOfPh < 0)  							indexOfPh = peptide.Length / 2;  						else  							hasPH = true;  						indexOfPh += index + 1;  						int indexOfMotif = match.Index + startIndex + 1;  						int distance = Math.Abs (indexOfMotif - indexOfPh);  						if (distance < bestDistance) {  							bestDistance = distance;  							line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  						}  					}  					writer.AddLine (line);  				}  		}  		index = protein.IndexOf (peptide' index + 1);  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (index < protein.Length && index >= 0) {  	if (index > 0) {  		int startIndex = index - 50;  		if (startIndex < 0)  			startIndex = 0;  		int length = peptide.Length + 40;  		if (startIndex + length >= protein.Length)  			length = protein.Length - startIndex;  		//int endIndex   = index + peptide.Length + 40;  		//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  		string subProt = protein.Substring (startIndex' length);  		foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  			foreach (Match match in pair.Value.Matches (subProt)) {  				string line = "";  				int otherIndexes = 0;  				int bestDistance = int.MaxValue;  				while (otherIndexes >= 0) {  					otherIndexes++;  					bool hasSP = false;  					bool hasPH = false;  					int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  					if (indexOfPh < 0)  						indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  					else  						hasSP = true;  					otherIndexes = indexOfPh;  					if (indexOfPh < 0)  						indexOfPh = peptide.Length / 2;  					else  						hasPH = true;  					indexOfPh += index + 1;  					int indexOfMotif = match.Index + startIndex + 1;  					int distance = Math.Abs (indexOfMotif - indexOfPh);  					if (distance < bestDistance) {  						bestDistance = distance;  						line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  					}  				}  				writer.AddLine (line);  			}  	}  	index = protein.IndexOf (peptide' index + 1);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (index < protein.Length && index >= 0) {  	if (index > 0) {  		int startIndex = index - 50;  		if (startIndex < 0)  			startIndex = 0;  		int length = peptide.Length + 40;  		if (startIndex + length >= protein.Length)  			length = protein.Length - startIndex;  		//int endIndex   = index + peptide.Length + 40;  		//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  		string subProt = protein.Substring (startIndex' length);  		foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  			foreach (Match match in pair.Value.Matches (subProt)) {  				string line = "";  				int otherIndexes = 0;  				int bestDistance = int.MaxValue;  				while (otherIndexes >= 0) {  					otherIndexes++;  					bool hasSP = false;  					bool hasPH = false;  					int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  					if (indexOfPh < 0)  						indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  					else  						hasSP = true;  					otherIndexes = indexOfPh;  					if (indexOfPh < 0)  						indexOfPh = peptide.Length / 2;  					else  						hasPH = true;  					indexOfPh += index + 1;  					int indexOfMotif = match.Index + startIndex + 1;  					int distance = Math.Abs (indexOfMotif - indexOfPh);  					if (distance < bestDistance) {  						bestDistance = distance;  						line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  					}  				}  				writer.AddLine (line);  			}  	}  	index = protein.IndexOf (peptide' index + 1);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (index < protein.Length && index >= 0) {  	if (index > 0) {  		int startIndex = index - 50;  		if (startIndex < 0)  			startIndex = 0;  		int length = peptide.Length + 40;  		if (startIndex + length >= protein.Length)  			length = protein.Length - startIndex;  		//int endIndex   = index + peptide.Length + 40;  		//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  		string subProt = protein.Substring (startIndex' length);  		foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  			foreach (Match match in pair.Value.Matches (subProt)) {  				string line = "";  				int otherIndexes = 0;  				int bestDistance = int.MaxValue;  				while (otherIndexes >= 0) {  					otherIndexes++;  					bool hasSP = false;  					bool hasPH = false;  					int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  					if (indexOfPh < 0)  						indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  					else  						hasSP = true;  					otherIndexes = indexOfPh;  					if (indexOfPh < 0)  						indexOfPh = peptide.Length / 2;  					else  						hasPH = true;  					indexOfPh += index + 1;  					int indexOfMotif = match.Index + startIndex + 1;  					int distance = Math.Abs (indexOfMotif - indexOfPh);  					if (distance < bestDistance) {  						bestDistance = distance;  						line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  					}  				}  				writer.AddLine (line);  			}  	}  	index = protein.IndexOf (peptide' index + 1);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (index < protein.Length && index >= 0) {  	if (index > 0) {  		int startIndex = index - 50;  		if (startIndex < 0)  			startIndex = 0;  		int length = peptide.Length + 40;  		if (startIndex + length >= protein.Length)  			length = protein.Length - startIndex;  		//int endIndex   = index + peptide.Length + 40;  		//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  		string subProt = protein.Substring (startIndex' length);  		foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  			foreach (Match match in pair.Value.Matches (subProt)) {  				string line = "";  				int otherIndexes = 0;  				int bestDistance = int.MaxValue;  				while (otherIndexes >= 0) {  					otherIndexes++;  					bool hasSP = false;  					bool hasPH = false;  					int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  					if (indexOfPh < 0)  						indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  					else  						hasSP = true;  					otherIndexes = indexOfPh;  					if (indexOfPh < 0)  						indexOfPh = peptide.Length / 2;  					else  						hasPH = true;  					indexOfPh += index + 1;  					int indexOfMotif = match.Index + startIndex + 1;  					int distance = Math.Abs (indexOfMotif - indexOfPh);  					if (distance < bestDistance) {  						bestDistance = distance;  						line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  					}  				}  				writer.AddLine (line);  			}  	}  	index = protein.IndexOf (peptide' index + 1);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (index < protein.Length && index >= 0) {  	if (index > 0) {  		int startIndex = index - 50;  		if (startIndex < 0)  			startIndex = 0;  		int length = peptide.Length + 40;  		if (startIndex + length >= protein.Length)  			length = protein.Length - startIndex;  		//int endIndex   = index + peptide.Length + 40;  		//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  		string subProt = protein.Substring (startIndex' length);  		foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  			foreach (Match match in pair.Value.Matches (subProt)) {  				string line = "";  				int otherIndexes = 0;  				int bestDistance = int.MaxValue;  				while (otherIndexes >= 0) {  					otherIndexes++;  					bool hasSP = false;  					bool hasPH = false;  					int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  					if (indexOfPh < 0)  						indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  					else  						hasSP = true;  					otherIndexes = indexOfPh;  					if (indexOfPh < 0)  						indexOfPh = peptide.Length / 2;  					else  						hasPH = true;  					indexOfPh += index + 1;  					int indexOfMotif = match.Index + startIndex + 1;  					int distance = Math.Abs (indexOfMotif - indexOfPh);  					if (distance < bestDistance) {  						bestDistance = distance;  						line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  					}  				}  				writer.AddLine (line);  			}  	}  	index = protein.IndexOf (peptide' index + 1);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (index < protein.Length && index >= 0) {  	if (index > 0) {  		int startIndex = index - 50;  		if (startIndex < 0)  			startIndex = 0;  		int length = peptide.Length + 40;  		if (startIndex + length >= protein.Length)  			length = protein.Length - startIndex;  		//int endIndex   = index + peptide.Length + 40;  		//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  		string subProt = protein.Substring (startIndex' length);  		foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  			foreach (Match match in pair.Value.Matches (subProt)) {  				string line = "";  				int otherIndexes = 0;  				int bestDistance = int.MaxValue;  				while (otherIndexes >= 0) {  					otherIndexes++;  					bool hasSP = false;  					bool hasPH = false;  					int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  					if (indexOfPh < 0)  						indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  					else  						hasSP = true;  					otherIndexes = indexOfPh;  					if (indexOfPh < 0)  						indexOfPh = peptide.Length / 2;  					else  						hasPH = true;  					indexOfPh += index + 1;  					int indexOfMotif = match.Index + startIndex + 1;  					int distance = Math.Abs (indexOfMotif - indexOfPh);  					if (distance < bestDistance) {  						bestDistance = distance;  						line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  					}  				}  				writer.AddLine (line);  			}  	}  	index = protein.IndexOf (peptide' index + 1);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if (index > 0) {  	int startIndex = index - 50;  	if (startIndex < 0)  		startIndex = 0;  	int length = peptide.Length + 40;  	if (startIndex + length >= protein.Length)  		length = protein.Length - startIndex;  	//int endIndex   = index + peptide.Length + 40;  	//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  	string subProt = protein.Substring (startIndex' length);  	foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  		foreach (Match match in pair.Value.Matches (subProt)) {  			string line = "";  			int otherIndexes = 0;  			int bestDistance = int.MaxValue;  			while (otherIndexes >= 0) {  				otherIndexes++;  				bool hasSP = false;  				bool hasPH = false;  				int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  				if (indexOfPh < 0)  					indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  				else  					hasSP = true;  				otherIndexes = indexOfPh;  				if (indexOfPh < 0)  					indexOfPh = peptide.Length / 2;  				else  					hasPH = true;  				indexOfPh += index + 1;  				int indexOfMotif = match.Index + startIndex + 1;  				int distance = Math.Abs (indexOfMotif - indexOfPh);  				if (distance < bestDistance) {  					bestDistance = distance;  					line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  				}  			}  			writer.AddLine (line);  		}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if (index > 0) {  	int startIndex = index - 50;  	if (startIndex < 0)  		startIndex = 0;  	int length = peptide.Length + 40;  	if (startIndex + length >= protein.Length)  		length = protein.Length - startIndex;  	//int endIndex   = index + peptide.Length + 40;  	//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  	string subProt = protein.Substring (startIndex' length);  	foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  		foreach (Match match in pair.Value.Matches (subProt)) {  			string line = "";  			int otherIndexes = 0;  			int bestDistance = int.MaxValue;  			while (otherIndexes >= 0) {  				otherIndexes++;  				bool hasSP = false;  				bool hasPH = false;  				int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  				if (indexOfPh < 0)  					indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  				else  					hasSP = true;  				otherIndexes = indexOfPh;  				if (indexOfPh < 0)  					indexOfPh = peptide.Length / 2;  				else  					hasPH = true;  				indexOfPh += index + 1;  				int indexOfMotif = match.Index + startIndex + 1;  				int distance = Math.Abs (indexOfMotif - indexOfPh);  				if (distance < bestDistance) {  					bestDistance = distance;  					line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  				}  			}  			writer.AddLine (line);  		}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if (index > 0) {  	int startIndex = index - 50;  	if (startIndex < 0)  		startIndex = 0;  	int length = peptide.Length + 40;  	if (startIndex + length >= protein.Length)  		length = protein.Length - startIndex;  	//int endIndex   = index + peptide.Length + 40;  	//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  	string subProt = protein.Substring (startIndex' length);  	foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  		foreach (Match match in pair.Value.Matches (subProt)) {  			string line = "";  			int otherIndexes = 0;  			int bestDistance = int.MaxValue;  			while (otherIndexes >= 0) {  				otherIndexes++;  				bool hasSP = false;  				bool hasPH = false;  				int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  				if (indexOfPh < 0)  					indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  				else  					hasSP = true;  				otherIndexes = indexOfPh;  				if (indexOfPh < 0)  					indexOfPh = peptide.Length / 2;  				else  					hasPH = true;  				indexOfPh += index + 1;  				int indexOfMotif = match.Index + startIndex + 1;  				int distance = Math.Abs (indexOfMotif - indexOfPh);  				if (distance < bestDistance) {  					bestDistance = distance;  					line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  				}  			}  			writer.AddLine (line);  		}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if (index > 0) {  	int startIndex = index - 50;  	if (startIndex < 0)  		startIndex = 0;  	int length = peptide.Length + 40;  	if (startIndex + length >= protein.Length)  		length = protein.Length - startIndex;  	//int endIndex   = index + peptide.Length + 40;  	//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  	string subProt = protein.Substring (startIndex' length);  	foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  		foreach (Match match in pair.Value.Matches (subProt)) {  			string line = "";  			int otherIndexes = 0;  			int bestDistance = int.MaxValue;  			while (otherIndexes >= 0) {  				otherIndexes++;  				bool hasSP = false;  				bool hasPH = false;  				int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  				if (indexOfPh < 0)  					indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  				else  					hasSP = true;  				otherIndexes = indexOfPh;  				if (indexOfPh < 0)  					indexOfPh = peptide.Length / 2;  				else  					hasPH = true;  				indexOfPh += index + 1;  				int indexOfMotif = match.Index + startIndex + 1;  				int distance = Math.Abs (indexOfMotif - indexOfPh);  				if (distance < bestDistance) {  					bestDistance = distance;  					line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  				}  			}  			writer.AddLine (line);  		}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if (index > 0) {  	int startIndex = index - 50;  	if (startIndex < 0)  		startIndex = 0;  	int length = peptide.Length + 40;  	if (startIndex + length >= protein.Length)  		length = protein.Length - startIndex;  	//int endIndex   = index + peptide.Length + 40;  	//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  	string subProt = protein.Substring (startIndex' length);  	foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  		foreach (Match match in pair.Value.Matches (subProt)) {  			string line = "";  			int otherIndexes = 0;  			int bestDistance = int.MaxValue;  			while (otherIndexes >= 0) {  				otherIndexes++;  				bool hasSP = false;  				bool hasPH = false;  				int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  				if (indexOfPh < 0)  					indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  				else  					hasSP = true;  				otherIndexes = indexOfPh;  				if (indexOfPh < 0)  					indexOfPh = peptide.Length / 2;  				else  					hasPH = true;  				indexOfPh += index + 1;  				int indexOfMotif = match.Index + startIndex + 1;  				int distance = Math.Abs (indexOfMotif - indexOfPh);  				if (distance < bestDistance) {  					bestDistance = distance;  					line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  				}  			}  			writer.AddLine (line);  		}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if (index > 0) {  	int startIndex = index - 50;  	if (startIndex < 0)  		startIndex = 0;  	int length = peptide.Length + 40;  	if (startIndex + length >= protein.Length)  		length = protein.Length - startIndex;  	//int endIndex   = index + peptide.Length + 40;  	//if (endIndex >= protein.Length) endIndex = protein.Length - 1;  	string subProt = protein.Substring (startIndex' length);  	foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  		foreach (Match match in pair.Value.Matches (subProt)) {  			string line = "";  			int otherIndexes = 0;  			int bestDistance = int.MaxValue;  			while (otherIndexes >= 0) {  				otherIndexes++;  				bool hasSP = false;  				bool hasPH = false;  				int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  				if (indexOfPh < 0)  					indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  				else  					hasSP = true;  				otherIndexes = indexOfPh;  				if (indexOfPh < 0)  					indexOfPh = peptide.Length / 2;  				else  					hasPH = true;  				indexOfPh += index + 1;  				int indexOfMotif = match.Index + startIndex + 1;  				int distance = Math.Abs (indexOfMotif - indexOfPh);  				if (distance < bestDistance) {  					bestDistance = distance;  					line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  				}  			}  			writer.AddLine (line);  		}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  	foreach (Match match in pair.Value.Matches (subProt)) {  		string line = "";  		int otherIndexes = 0;  		int bestDistance = int.MaxValue;  		while (otherIndexes >= 0) {  			otherIndexes++;  			bool hasSP = false;  			bool hasPH = false;  			int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  			if (indexOfPh < 0)  				indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  			else  				hasSP = true;  			otherIndexes = indexOfPh;  			if (indexOfPh < 0)  				indexOfPh = peptide.Length / 2;  			else  				hasPH = true;  			indexOfPh += index + 1;  			int indexOfMotif = match.Index + startIndex + 1;  			int distance = Math.Abs (indexOfMotif - indexOfPh);  			if (distance < bestDistance) {  				bestDistance = distance;  				line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  			}  		}  		writer.AddLine (line);  	}  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  	foreach (Match match in pair.Value.Matches (subProt)) {  		string line = "";  		int otherIndexes = 0;  		int bestDistance = int.MaxValue;  		while (otherIndexes >= 0) {  			otherIndexes++;  			bool hasSP = false;  			bool hasPH = false;  			int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  			if (indexOfPh < 0)  				indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  			else  				hasSP = true;  			otherIndexes = indexOfPh;  			if (indexOfPh < 0)  				indexOfPh = peptide.Length / 2;  			else  				hasPH = true;  			indexOfPh += index + 1;  			int indexOfMotif = match.Index + startIndex + 1;  			int distance = Math.Abs (indexOfMotif - indexOfPh);  			if (distance < bestDistance) {  				bestDistance = distance;  				line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  			}  		}  		writer.AddLine (line);  	}  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  	foreach (Match match in pair.Value.Matches (subProt)) {  		string line = "";  		int otherIndexes = 0;  		int bestDistance = int.MaxValue;  		while (otherIndexes >= 0) {  			otherIndexes++;  			bool hasSP = false;  			bool hasPH = false;  			int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  			if (indexOfPh < 0)  				indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  			else  				hasSP = true;  			otherIndexes = indexOfPh;  			if (indexOfPh < 0)  				indexOfPh = peptide.Length / 2;  			else  				hasPH = true;  			indexOfPh += index + 1;  			int indexOfMotif = match.Index + startIndex + 1;  			int distance = Math.Abs (indexOfMotif - indexOfPh);  			if (distance < bestDistance) {  				bestDistance = distance;  				line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  			}  		}  		writer.AddLine (line);  	}  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (KeyValuePair<string' Regex> pair in dicOfMotifs)  	foreach (Match match in pair.Value.Matches (subProt)) {  		string line = "";  		int otherIndexes = 0;  		int bestDistance = int.MaxValue;  		while (otherIndexes >= 0) {  			otherIndexes++;  			bool hasSP = false;  			bool hasPH = false;  			int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  			if (indexOfPh < 0)  				indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  			else  				hasSP = true;  			otherIndexes = indexOfPh;  			if (indexOfPh < 0)  				indexOfPh = peptide.Length / 2;  			else  				hasPH = true;  			indexOfPh += index + 1;  			int indexOfMotif = match.Index + startIndex + 1;  			int distance = Math.Abs (indexOfMotif - indexOfPh);  			if (distance < bestDistance) {  				bestDistance = distance;  				line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  			}  		}  		writer.AddLine (line);  	}  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (Match match in pair.Value.Matches (subProt)) {  	string line = "";  	int otherIndexes = 0;  	int bestDistance = int.MaxValue;  	while (otherIndexes >= 0) {  		otherIndexes++;  		bool hasSP = false;  		bool hasPH = false;  		int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  		if (indexOfPh < 0)  			indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  		else  			hasSP = true;  		otherIndexes = indexOfPh;  		if (indexOfPh < 0)  			indexOfPh = peptide.Length / 2;  		else  			hasPH = true;  		indexOfPh += index + 1;  		int indexOfMotif = match.Index + startIndex + 1;  		int distance = Math.Abs (indexOfMotif - indexOfPh);  		if (distance < bestDistance) {  			bestDistance = distance;  			line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  		}  	}  	writer.AddLine (line);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (Match match in pair.Value.Matches (subProt)) {  	string line = "";  	int otherIndexes = 0;  	int bestDistance = int.MaxValue;  	while (otherIndexes >= 0) {  		otherIndexes++;  		bool hasSP = false;  		bool hasPH = false;  		int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  		if (indexOfPh < 0)  			indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  		else  			hasSP = true;  		otherIndexes = indexOfPh;  		if (indexOfPh < 0)  			indexOfPh = peptide.Length / 2;  		else  			hasPH = true;  		indexOfPh += index + 1;  		int indexOfMotif = match.Index + startIndex + 1;  		int distance = Math.Abs (indexOfMotif - indexOfPh);  		if (distance < bestDistance) {  			bestDistance = distance;  			line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  		}  	}  	writer.AddLine (line);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (Match match in pair.Value.Matches (subProt)) {  	string line = "";  	int otherIndexes = 0;  	int bestDistance = int.MaxValue;  	while (otherIndexes >= 0) {  		otherIndexes++;  		bool hasSP = false;  		bool hasPH = false;  		int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  		if (indexOfPh < 0)  			indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  		else  			hasSP = true;  		otherIndexes = indexOfPh;  		if (indexOfPh < 0)  			indexOfPh = peptide.Length / 2;  		else  			hasPH = true;  		indexOfPh += index + 1;  		int indexOfMotif = match.Index + startIndex + 1;  		int distance = Math.Abs (indexOfMotif - indexOfPh);  		if (distance < bestDistance) {  			bestDistance = distance;  			line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  		}  	}  	writer.AddLine (line);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: foreach (Match match in pair.Value.Matches (subProt)) {  	string line = "";  	int otherIndexes = 0;  	int bestDistance = int.MaxValue;  	while (otherIndexes >= 0) {  		otherIndexes++;  		bool hasSP = false;  		bool hasPH = false;  		int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  		if (indexOfPh < 0)  			indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  		else  			hasSP = true;  		otherIndexes = indexOfPh;  		if (indexOfPh < 0)  			indexOfPh = peptide.Length / 2;  		else  			hasPH = true;  		indexOfPh += index + 1;  		int indexOfMotif = match.Index + startIndex + 1;  		int distance = Math.Abs (indexOfMotif - indexOfPh);  		if (distance < bestDistance) {  			bestDistance = distance;  			line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  		}  	}  	writer.AddLine (line);  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (otherIndexes >= 0) {  	otherIndexes++;  	bool hasSP = false;  	bool hasPH = false;  	int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  	if (indexOfPh < 0)  		indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  	else  		hasSP = true;  	otherIndexes = indexOfPh;  	if (indexOfPh < 0)  		indexOfPh = peptide.Length / 2;  	else  		hasPH = true;  	indexOfPh += index + 1;  	int indexOfMotif = match.Index + startIndex + 1;  	int distance = Math.Abs (indexOfMotif - indexOfPh);  	if (distance < bestDistance) {  		bestDistance = distance;  		line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (otherIndexes >= 0) {  	otherIndexes++;  	bool hasSP = false;  	bool hasPH = false;  	int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  	if (indexOfPh < 0)  		indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  	else  		hasSP = true;  	otherIndexes = indexOfPh;  	if (indexOfPh < 0)  		indexOfPh = peptide.Length / 2;  	else  		hasPH = true;  	indexOfPh += index + 1;  	int indexOfMotif = match.Index + startIndex + 1;  	int distance = Math.Abs (indexOfMotif - indexOfPh);  	if (distance < bestDistance) {  		bestDistance = distance;  		line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (otherIndexes >= 0) {  	otherIndexes++;  	bool hasSP = false;  	bool hasPH = false;  	int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  	if (indexOfPh < 0)  		indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  	else  		hasSP = true;  	otherIndexes = indexOfPh;  	if (indexOfPh < 0)  		indexOfPh = peptide.Length / 2;  	else  		hasPH = true;  	indexOfPh += index + 1;  	int indexOfMotif = match.Index + startIndex + 1;  	int distance = Math.Abs (indexOfMotif - indexOfPh);  	if (distance < bestDistance) {  		bestDistance = distance;  		line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: while (otherIndexes >= 0) {  	otherIndexes++;  	bool hasSP = false;  	bool hasPH = false;  	int indexOfPh = occurance [3].IndexOf ("S(ph)P"' otherIndexes);  	if (indexOfPh < 0)  		indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  	else  		hasSP = true;  	otherIndexes = indexOfPh;  	if (indexOfPh < 0)  		indexOfPh = peptide.Length / 2;  	else  		hasPH = true;  	indexOfPh += index + 1;  	int indexOfMotif = match.Index + startIndex + 1;  	int distance = Math.Abs (indexOfMotif - indexOfPh);  	if (distance < bestDistance) {  		bestDistance = distance;  		line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  	}  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if (indexOfPh < 0)  	indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  else  	hasSP = true;  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: indexOfPh = occurance [3].IndexOf ("(ph)"' otherIndexes);  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if (indexOfPh < 0)  	indexOfPh = peptide.Length / 2;  else  	hasPH = true;  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: indexOfPh = peptide.Length / 2;  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: if (distance < bestDistance) {  	bestDistance = distance;  	line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  }  
Magic Number,CMinor.Custom,ERKMotifFindor,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Tools\MotifFindor.cs,Find,The following statement contains a magic number: line = vsCSV.GetLineFromColumns (occurance' 0) + "'" + (index + 1) + "'" + indexOfPh + "'" + pair.Key + "'" + indexOfMotif + "'" + subProt.Substring (match.Index' 4) + "'" + distance + "'" + hasSP;  
Missing Default,PeptidAce,DBOptions,C:\repos\olivierlizotte_PeptidAce.Library\DBOptions.cs,Load,The following switch statement is missing a default case: switch (splits [0]) {  case "MinimumPrecursorChargeState":  	options.MinimumPrecursorChargeState = int.Parse (splits [1]);  	break;  case "MaximumPrecursorChargeState":  	options.MaximumPrecursorChargeState = int.Parse (splits [1]);  	break;  case "MaximumNumberOfFragmentsPerSpectrum":  	options.MaximumNumberOfFragmentsPerSpectrum = int.Parse (splits [1]);  	break;  case "MaximumPeptideMass":  	options.MaximumPeptideMass = double.Parse (splits [1]);  	break;  case "DecoyFusion":  	options.DecoyFusion = bool.Parse (splits [1]);  	break;  //case "DigestionEnzyme":                    options.DigestionEnzyme = double.Parse(splits[1]); break;   //case "ToleratedMissedCleavages":                    options.ToleratedMissedCleavages = double.Parse(splits[1]); break;   case "PSMFalseDiscoveryRate":  	options.PSMFalseDiscoveryRate = double.Parse (splits [1]);  	break;  case "NbPSMToKeep":  	options.NbPSMToKeep = int.Parse (splits [1]);  	break;  case "OutputFolder":  	options.OutputFolder = splits [1];  	break;  case "MinimumPSMScore":  	options.MinimumPSMScore = double.Parse (splits [1]);  	break;  case "MinimumPeptideLength":  	options.MinimumPeptideLength = int.Parse (splits [1]);  	break;  case "MaximumPeptideLength":  	options.MaximumPeptideLength = int.Parse (splits [1]);  	break;  case "fullFragment":  	List<FragmentGen> frags = new List<FragmentGen> ();  	foreach (string frag in splits [1].Split (';'))  		if (!string.IsNullOrEmpty (frag))  			frags.Add (FullFragments.AllFragments [frag]);  	options.fullFragment = new FullFragments (frags);  	break;  //public Fragments fragments = double.Parse(splits[1]); break;   case "NbMinProducts":  	options.NbMinProducts = int.Parse (splits [1]);  	break;  case "addFragmentLoss":  	options.addFragmentLoss = bool.Parse (splits [1]);  	break;  case "addFragmentMods":  	options.addFragmentMods = bool.Parse (splits [1]);  	break;  case "WriteMaxQuantPeakFile":  	options.WriteMaxQuantPeakFile = bool.Parse (splits [1]);  	break;  case "SaveMS1Peaks":  	options.SaveMS1Peaks = bool.Parse (splits [1]);  	break;  case "SaveMSMSPeaks":  	options.SaveMSMSPeaks = bool.Parse (splits [1]);  	break;  case "LoadSpectraIfFound":  	options.LoadSpectraIfFound = bool.Parse (splits [1]);  	break;  case "ComputedRetentionTimeDiff":  	options.ComputedRetentionTimeDiff = double.Parse (splits [1]);  	break;  //TODO compute this after alignment step' based on common identifications  case "EffectiveIsolationWindowRatio":  	options.EffectiveIsolationWindowRatio = double.Parse (splits [1]);  	break;  //TODO optimize this value   case "MinimumPrecursorIntensityRatioInIsolationWindow":  	options.MinimumPrecursorIntensityRatioInIsolationWindow = double.Parse (splits [1]);  	break;  case "dProduct":  	options.dProduct = double.Parse (splits [1]);  	break;  case "dPrecursor":  	options.dPrecursor = double.Parse (splits [1]);  	break;  case "dMatchingProductFraction":  	options.dMatchingProductFraction = double.Parse (splits [1]);  	break;  case "dMatchingProduct":  	options.dMatchingProduct = double.Parse (splits [1]);  	break;  case "dIntensityFraction":  	options.dIntensityFraction = double.Parse (splits [1]);  	break;  case "dIntensity":  	options.dIntensity = double.Parse (splits [1]);  	break;  case "dProtein":  	options.dProtein = double.Parse (splits [1]);  	break;  case "dPeptideScore":  	options.dPeptideScore = double.Parse (splits [1]);  	break;  case "dFragmentScore":  	options.dFragmentScore = double.Parse (splits [1]);  	break;  ///Values kept from the original Morpheus source code  //case "initiatorMethionineBehavior ":                    options.initiatorMethionineBehavior = double.Parse(splits[1]); break;   case "fixedModifications":  	options.fixedModifications = new List<Modification> ();  	foreach (string mod in splits [1].Split (';'))  		if (!string.IsNullOrEmpty (mod))  			options.fixedModifications.Add (ModificationDictionary.Instance [mod]);  	break;  case "variableModifications":  	options.variableModifications = new List<Modification> ();  	foreach (string mod in splits [1].Split (';'))  		if (!string.IsNullOrEmpty (mod))  			options.fixedModifications.Add (ModificationDictionary.Instance [mod]);  	break;  case "maximumVariableModificationIsoforms":  	options.maximumVariableModificationIsoforms = int.Parse (splits [1]);  	break;  case "precursorMassTolerance":  	options.precursorMassTolerance = new MassTolerance (double.Parse (splits [1])' MassToleranceUnits.ppm);  	break;  case "productMassTolerance":  	options.productMassTolerance = new MassTolerance (double.Parse (splits [1])' MassToleranceUnits.Da);  	break;  case "dicOfMinPrecursorThr":  	options.dicOfMinPrecursorThr = StrToDic (splits [1]);  	break;  case "dicOfMaxPrecursorThr":  	options.dicOfMaxPrecursorThr = StrToDic (splits [1]);  	break;  case "dicOfMinFragmentThr":  	options.dicOfMinFragmentThr = StrToDic (splits [1]);  	break;  case "dicOfMaxFragmentThr":  	options.dicOfMaxFragmentThr = StrToDic (splits [1]);  	break;  case "FastaFiles":  	options.FastaFiles = TxtToArray (splits [1]);  	break;  case "FastaFilesMinors":  	options.FastaFilesMinors = TxtToArray (splits [1]);  	break;  case "MS2s":  	options.MS2s = TxtToArray (splits [1]);  	break;  }  
Missing Default,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following switch statement is missing a default case: switch (cType) {  case CurveType.AKIMA:  	interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  	//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  	//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(time' intensityCount);  	break;  case CurveType.LINEAR:  	interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  	break;  case CurveType.SPLINE:  	interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  	break;  }  
Missing Default,PeptidAce.Utilities,ElutionCurve,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Curves\Curve.cs,Compute,The following switch statement is missing a default case: switch (cType) {  case CurveType.AKIMA:  	interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  	//interpole = new MathNet.Numerics.Interpolation.NevillePolynomialInterpolation(time' intensityCount);  	//interpole = new MathNet.Numerics.Interpolation.Algorithms.AkimaSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  	break;  case CurveType.LINEAR:  	interpole = MathNet.Numerics.Interpolation.LinearSpline.Interpolate (time' intensityCount);  	//interpole = MathNet.Numerics.Interpolation.Interpolate.LinearBetweenPoints(interpolatedTime' interpolatedIntensityCount);  	break;  case CurveType.SPLINE:  	interpole = new MathNet.Numerics.Interpolation.BulirschStoerRationalInterpolation (time' intensityCount);  	//interpole = new MathNet.Numerics.Interpolation.Algorithms.CubicSplineInterpolation(interpolatedTime' interpolatedIntensityCount);  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateHydrophobicity,The following switch statement is missing a default case: switch (c) {  case 'I':  case 'L':  case 'V':  case 'M':  case 'C':  case 'A':  case 'T':  case 'F':  case 'Y':  case 'W':  case 'H':  case 'K':  	nbHydro++;  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateAromaticity,The following switch statement is missing a default case: switch (c) {  case 'F':  case 'Y':  case 'W':  case 'H':  	nbAroma++;  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculatePolarity,The following switch statement is missing a default case: switch (c) {  case 'C':  case 'T':  case 'S':  case 'N':  case 'Q':  case 'D':  case 'E':  case 'H':  case 'K':  case 'R':  case 'W':  case 'Y':  	nbPolar++;  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateSulfuricity,The following switch statement is missing a default case: switch (c) {  case 'M':  case 'C':  	nbSulfure++;  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateAliphaticity,The following switch statement is missing a default case: switch (c) {  case 'I':  case 'L':  case 'V':  	nbAli++;  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateHydroxylicity,The following switch statement is missing a default case: switch (c) {  case 'T':  case 'S':  	nbHydroxyl++;  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateAcidity,The following switch statement is missing a default case: switch (c) {  case 'N':  case 'Q':  	nbAcid++;  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateBasic,The following switch statement is missing a default case: switch (c) {  case 'H':  case 'K':  case 'R':  	nbAcid++;  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateNetCharge,The following switch statement is missing a default case: switch (c) {  case 'D':  case 'E':  	sum--;  	break;  case 'R':  case 'K':  case 'H':  	sum++;  	break;  }  
Missing Default,PeptidAce.Utilities,Numerics,C:\repos\olivierlizotte_PeptidAce.Library\Utilities\Numerics.cs,CalculateIsoElectricPoint,The following switch statement is missing a default case: switch (aa) {  case 'D':  	++AspNumber;  	break;  case 'E':  	++GluNumber;  	break;  case 'C':  	++CysNumber;  	break;  case 'Y':  	++TyrNumber;  	break;  case 'H':  	++HisNumber;  	break;  case 'K':  	++LysNumber;  	break;  case 'R':  	++ArgNumber;  	break;  }  
