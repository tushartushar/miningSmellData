Implementation smell,Namespace,Class,File,Method,Description
Long Method,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The method has 131 lines of code.
Complex Method,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,Cyclomatic complexity of the method is 29
Complex Method,Ctl.Data,FixedReader,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedReader.cs,FixedReader,Cyclomatic complexity of the method is 8
Complex Method,Ctl.Data,FixedReader,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedReader.cs,ReadRowImpl,Cyclomatic complexity of the method is 11
Complex Method,Ctl.Data,FixedWriter,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedWriter.cs,FixedWriter,Cyclomatic complexity of the method is 10
Complex Method,Ctl.Data,FixedWriter,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedWriter.cs,WriteLine,Cyclomatic complexity of the method is 10
Long Parameter List,Ctl.Data,FixedWriter,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedWriter.cs,FixedWriter,The method has 5 parameters.
Long Parameter List,Ctl.Data,HeaderedObjectReader,C:\repos\ctl-global_ctl-data\Ctl.Data\HeaderedObjectReader.cs,HeaderedObjectReader,The method has 5 parameters.
Long Parameter List,Ctl.Data,SerializationException,C:\repos\ctl-global_ctl-data\Ctl.Data\SerializationException.cs,SerializationException,The method has 5 parameters.
Long Parameter List,Ctl.Data.Infrastructure,SerializedType,C:\repos\ctl-global_ctl-data\Ctl.Data\Infrastructure\SerializedType.cs,GetHeaderIndexes,The method has 5 parameters.
Long Parameter List,Ctl.Data.Infrastructure,SerializedType,C:\repos\ctl-global_ctl-data\Ctl.Data\Infrastructure\SerializedType.cs,GetHeaderIndexes,The method has 5 parameters.
Long Statement,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The length of the statement  "				throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1); " is 141.
Long Statement,Ctl.Data,FixedWriter,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedWriter.cs,WriteLine,The length of the statement  "				throw new ArgumentOutOfRangeException ("row"' string.Format ("FixedWriter has not been configured with enough item positions to write this row. Items starting at index {0} would be truncated during writing."' idx)); " is 215.
Long Statement,Ctl.Data,FixedWriter,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedWriter.cs,WriteLine,The length of the statement  "				throw new ArgumentOutOfRangeException ("row"' string.Format ("Item at index {0} would be truncated during writing."' idx)); " is 123.
Long Statement,Ctl.Data,HeaderedObjectReader,C:\repos\ctl-global_ctl-data\Ctl.Data\HeaderedObjectReader.cs,InitHeaders,The length of the statement  "		if (t.IsClass || Nullable.GetUnderlyingType (t) != null || c.Names.Intersect (reader.CurrentRow.Select (x => x.Value)' headerComparer ?? StringComparer.InvariantCultureIgnoreCase).Any ()) { " is 189.
Long Statement,Ctl.Data,HeaderedObjectReader,C:\repos\ctl-global_ctl-data\Ctl.Data\HeaderedObjectReader.cs,InitHeaders,The length of the statement  "		vrs.Add (new ValidationResult (c.MemberInfo.GetCustomAttribute<RequiredAttribute> ().FormatErrorMessage (c.MemberInfo.Name)' new[] { " is 132.
Long Statement,Ctl.Data,ObjectValue,C:\repos\ctl-global_ctl-data\Ctl.Data\ObjectValue.cs,GetValueForMember,The length of the statement  "		throw new ArgumentException (string.Format ("Member '{0}' does not support deserialization."' e.Member.Name)' "memberAccess"); " is 126.
Long Statement,Ctl.Data.Infrastructure,SerializedType,C:\repos\ctl-global_ctl-data\Ctl.Data\Infrastructure\SerializedType.cs,GetReadMap,The length of the statement  "	Dictionary<string' int> newMap = new Dictionary<string' int> (cols.Length' comparer ?? StringComparer.InvariantCultureIgnoreCase); " is 130.
Magic Number,Ctl.Data,CsvOptions,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvOptions.cs,CsvOptions,The following statement contains a magic number: BufferLength = 4096;  
Magic Number,Ctl.Data,IgnoreSpacesComparer,C:\repos\ctl-global_ctl-data\Ctl.Data\IgnoreSpacesComparer.cs,StripSpaces,The following statement contains a magic number: for (int i = 0; i < s.Length; i += charLen) {  	charLen = char.IsSurrogatePair (s' i) ? 2 : 1;  	if (!char.IsWhiteSpace (s' i)) {  		sb.Append (s' i' charLen);  	}  }  
Magic Number,Ctl.Data,IgnoreSpacesComparer,C:\repos\ctl-global_ctl-data\Ctl.Data\IgnoreSpacesComparer.cs,StripSpaces,The following statement contains a magic number: charLen = char.IsSurrogatePair (s' i) ? 2 : 1;  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,CsvReader,The following statement contains a magic number: if (bufferLength < 3)  	bufferLength = 3;  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,CsvReader,The following statement contains a magic number: if (bufferLength < 3)  	bufferLength = 3;  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,CsvReader,The following statement contains a magic number: bufferLength = 3;  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == separator) {  		colNumber += idx - position + 1;  		Take (idx - position' 1);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		colNumber += idx - position;  		Take (idx - position' 0);  		if (idx + 1 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 1);  			goto haveRow;  		}  		Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	++idx;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == '\r' || ch == '\n') {  	colNumber += idx - position;  	Take (idx - position' 0);  	if (idx + 1 == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		Take (0' 1);  		goto haveRow;  	}  	Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  	colNumber = 0;  	++lineNumber;  	goto haveRow;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: while (idx < length) {  	ch = buffer [idx];  	if (ch == '\r' || ch == '\n') {  		if (idx + 1 == length) {  			Take (idx - position' 0);  			break;  		}  		idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  		colNumber = 0;  		++lineNumber;  		continue;  	}  	if (ch != '"') {  		++idx;  		++colNumber;  		continue;  	}  	if (idx + 1 == length) {  		colNumber += endOfStream ? 1 : 0;  		Take (idx - position' endOfStream ? 1 : 0);  		goto needMoreOrEnd;  	}  	ch = buffer [idx + 1];  	if (ch == '"') {  		Take (idx - position + 1' 1);  		idx += 2;  		colNumber += 2;  		continue;  	}  	if (ch == separator) {  		colNumber += 2;  		Take (idx - position' 2);  		AddCurrentItem ();  		state = ParseState.Begin;  		goto case ParseState.Begin;  	}  	if (ch == '\r' || ch == '\n') {  		Take (idx - position' 0);  		if (idx + 2 == length) {  			if (!endOfStream) {  				return ParseResult.NeedMore;  			}  			Take (0' 2);  			goto haveRow;  		}  		Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  		colNumber = 0;  		++lineNumber;  		goto haveRow;  	}  	if (!parseMidQuotes) {  		// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  		throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  	}  	++idx;  	++colNumber;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == '\r' || ch == '\n') {  	if (idx + 1 == length) {  		Take (idx - position' 0);  		break;  	}  	idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  	colNumber = 0;  	++lineNumber;  	continue;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == '"') {  	Take (idx - position + 1' 1);  	idx += 2;  	colNumber += 2;  	continue;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == '"') {  	Take (idx - position + 1' 1);  	idx += 2;  	colNumber += 2;  	continue;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: idx += 2;  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: colNumber += 2;  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == separator) {  	colNumber += 2;  	Take (idx - position' 2);  	AddCurrentItem ();  	state = ParseState.Begin;  	goto case ParseState.Begin;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == separator) {  	colNumber += 2;  	Take (idx - position' 2);  	AddCurrentItem ();  	state = ParseState.Begin;  	goto case ParseState.Begin;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: colNumber += 2;  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: Take (idx - position' 2);  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == '\r' || ch == '\n') {  	Take (idx - position' 0);  	if (idx + 2 == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		Take (0' 2);  		goto haveRow;  	}  	Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  	colNumber = 0;  	++lineNumber;  	goto haveRow;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == '\r' || ch == '\n') {  	Take (idx - position' 0);  	if (idx + 2 == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		Take (0' 2);  		goto haveRow;  	}  	Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  	colNumber = 0;  	++lineNumber;  	goto haveRow;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == '\r' || ch == '\n') {  	Take (idx - position' 0);  	if (idx + 2 == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		Take (0' 2);  		goto haveRow;  	}  	Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  	colNumber = 0;  	++lineNumber;  	goto haveRow;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == '\r' || ch == '\n') {  	Take (idx - position' 0);  	if (idx + 2 == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		Take (0' 2);  		goto haveRow;  	}  	Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  	colNumber = 0;  	++lineNumber;  	goto haveRow;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (ch == '\r' || ch == '\n') {  	Take (idx - position' 0);  	if (idx + 2 == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		Take (0' 2);  		goto haveRow;  	}  	Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  	colNumber = 0;  	++lineNumber;  	goto haveRow;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (idx + 2 == length) {  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	Take (0' 2);  	goto haveRow;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: if (idx + 2 == length) {  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	Take (0' 2);  	goto haveRow;  }  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: Take (0' 2);  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  
Magic Number,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following statement contains a magic number: Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  
Magic Number,Ctl.Data,FixedReader,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedReader.cs,FixedReader,The following statement contains a magic number: buflen = checked(buflen + (readNewLines ? 2 : 0));  
Magic Number,Ctl.Data,FixedReader,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedReader.cs,ReadRowImpl,The following statement contains a magic number: if (readNewLines && len > (buffer.Length - 2)) {  	int off = buffer.Length - 2;  	char ch = buffer [off];  	if (ch == '\r' || ch == '\n') {  		lineNumber = bufferLines [off];  		columnNumber = bufferColumns [off];  		++off;  		if (off < buffer.Length && buffer [off] == (ch ^ newlineMask)) {  			len = 0;  		}  		else {  			len = buffer.Length - off;  		}  	}  	else {  		lineNumber = bufferLines [off - 1];  		columnNumber = bufferColumns [off - 1];  		len = buffer.Length - off;  	}  	if (len != 0) {  		Array.Copy (buffer' off' buffer' 0' len);  	}  }  else {  	lineNumber = bufferLines [len - 1];  	columnNumber = bufferColumns [len - 1];  	len = 0;  }  
Magic Number,Ctl.Data,FixedReader,C:\repos\ctl-global_ctl-data\Ctl.Data\FixedReader.cs,ReadRowImpl,The following statement contains a magic number: if (readNewLines && len > (buffer.Length - 2)) {  	int off = buffer.Length - 2;  	char ch = buffer [off];  	if (ch == '\r' || ch == '\n') {  		lineNumber = bufferLines [off];  		columnNumber = bufferColumns [off];  		++off;  		if (off < buffer.Length && buffer [off] == (ch ^ newlineMask)) {  			len = 0;  		}  		else {  			len = buffer.Length - off;  		}  	}  	else {  		lineNumber = bufferLines [off - 1];  		columnNumber = bufferColumns [off - 1];  		len = buffer.Length - off;  	}  	if (len != 0) {  		Array.Copy (buffer' off' buffer' 0' len);  	}  }  else {  	lineNumber = bufferLines [len - 1];  	columnNumber = bufferColumns [len - 1];  	len = 0;  }  
Missing Default,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Read,The following switch statement is missing a default case: switch (Parse ()) {  case ParseResult.Row:  	prevItemCount = items.Count;  	CurrentRow = items;  	items = null;  	return true;  case ParseResult.Done:  	return false;  }  
Missing Default,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,ReadAsync,The following switch statement is missing a default case: switch (Parse ()) {  case ParseResult.Row:  	prevItemCount = items.Count;  	CurrentRow = items;  	items = null;  	return Constants.TrueTask;  case ParseResult.Done:  	return Constants.FalseTask;  }  
Missing Default,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,ReadAsyncImpl,The following switch statement is missing a default case: switch (Parse ()) {  case ParseResult.Row:  	prevItemCount = items.Count;  	CurrentRow = items;  	items = null;  	return true;  case ParseResult.Done:  	return false;  }  
Missing Default,Ctl.Data,CsvReader,C:\repos\ctl-global_ctl-data\Ctl.Data\CsvReader.cs,Parse,The following switch statement is missing a default case: switch (state) {  case ParseState.Begin:  	if (position == length) {  		if (!endOfStream) {  			return ParseResult.NeedMore;  		}  		if (colNumber == 0) {  			return ParseResult.Done;  		}  		items.Add (new ColumnValue (null' lineNumber + 1' colNumber + 1));  		return ParseResult.Row;  	}  	startLineNumber = lineNumber;  	startColNumber = colNumber;  	ch = buffer [position];  	if (ch == '"') {  		++position;  		++colNumber;  		state = ParseState.QuotedEnd;  		goto case ParseState.QuotedEnd;  	}  	state = ParseState.End;  	goto case ParseState.End;  case ParseState.End:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == separator) {  			colNumber += idx - position + 1;  			Take (idx - position' 1);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			colNumber += idx - position;  			Take (idx - position' 0);  			if (idx + 1 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 1);  				goto haveRow;  			}  			Take (0' buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		++idx;  	}  	colNumber += idx - position;  	Take (idx - position' 0);  	needMoreOrEnd:  	if (!endOfStream) {  		return ParseResult.NeedMore;  	}  	haveRow:  	AddCurrentItem ();  	state = ParseState.Begin;  	return ParseResult.Row;  case ParseState.QuotedEnd:  	idx = position;  	while (idx < length) {  		ch = buffer [idx];  		if (ch == '\r' || ch == '\n') {  			if (idx + 1 == length) {  				Take (idx - position' 0);  				break;  			}  			idx += buffer [idx + 1] == (ch ^ NewlineMask) ? 2 : 1;  			colNumber = 0;  			++lineNumber;  			continue;  		}  		if (ch != '"') {  			++idx;  			++colNumber;  			continue;  		}  		if (idx + 1 == length) {  			colNumber += endOfStream ? 1 : 0;  			Take (idx - position' endOfStream ? 1 : 0);  			goto needMoreOrEnd;  		}  		ch = buffer [idx + 1];  		if (ch == '"') {  			Take (idx - position + 1' 1);  			idx += 2;  			colNumber += 2;  			continue;  		}  		if (ch == separator) {  			colNumber += 2;  			Take (idx - position' 2);  			AddCurrentItem ();  			state = ParseState.Begin;  			goto case ParseState.Begin;  		}  		if (ch == '\r' || ch == '\n') {  			Take (idx - position' 0);  			if (idx + 2 == length) {  				if (!endOfStream) {  					return ParseResult.NeedMore;  				}  				Take (0' 2);  				goto haveRow;  			}  			Take (0' buffer [idx + 2] == (ch ^ NewlineMask) ? 3 : 2);  			colNumber = 0;  			++lineNumber;  			goto haveRow;  		}  		if (!parseMidQuotes) {  			// free-floating quote. no way to know if it's a typo or intentional' so err on the side of caution.  			throw new ParseException ("Quoted value contains an unescaped quote not followed by a separator or newline."' lineNumber + 1' colNumber + 1);  		}  		++idx;  		++colNumber;  	}  	Take (idx - position' 0);  	if (endOfStream) {  		throw new ParseException ("Unexpected end of stream in middle of quoted value."' lineNumber + 1' colNumber + 1);  	}  	return ParseResult.NeedMore;  }  
