Implementation smell,Namespace,Class,File,Method,Description
Long Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The method has 125 lines of code.
Long Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The method has 106 lines of code.
Long Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The method has 122 lines of code.
Long Method,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,VisitMember,The method has 104 lines of code.
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8String,Cyclomatic complexity of the method is 8
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,Cyclomatic complexity of the method is 10
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,Cyclomatic complexity of the method is 16
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,Cyclomatic complexity of the method is 15
Complex Method,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,Cyclomatic complexity of the method is 17
Complex Method,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,AppendConstraints,Cyclomatic complexity of the method is 12
Complex Method,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatField,Cyclomatic complexity of the method is 8
Complex Method,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatMethod,Cyclomatic complexity of the method is 18
Complex Method,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatProperty,Cyclomatic complexity of the method is 15
Complex Method,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatTypeSig,Cyclomatic complexity of the method is 13
Complex Method,PeterO.DocGen,TestGenerator,C:\repos\peteroupc_CBOR\CBORDocs\TestGenerator.cs,GenerateTests,Cyclomatic complexity of the method is 16
Long Parameter List,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The method has 5 parameters. Parameters: str' offset' length' stream' replace
Long Parameter List,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The method has 6 parameters. Parameters: str' offset' length' stream' replace' lenientLineBreaks
Long Parameter List,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The method has 5 parameters. Parameters: data' offset' bytesCount' builder' replace
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The conditional expression  "(c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff"  is complex.
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointAt,The conditional expression  "(c & 0xfc00) == 0xd800 && index + 1 < str.Length &&           str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The conditional expression  "(ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The conditional expression  "(cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The conditional expression  "(c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff"  is complex.
Complex Conditional,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatProperty,The conditional expression  "(getter != null && getter.IsPublic) ||             (setter != null && setter.IsPublic)"  is complex.
Complex Conditional,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatProperty,The conditional expression  "(getter != null && getter.IsAssembly) ||                    (setter != null && setter.IsAssembly)"  is complex.
Complex Conditional,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatProperty,The conditional expression  "(getter != null && getter.IsFamily) ||                    (setter != null && setter.IsFamily)"  is complex.
Complex Conditional,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatProperty,The conditional expression  "(getter != null && getter.IsStatic) ||             (setter != null && setter.IsStatic)"  is complex.
Complex Conditional,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatProperty,The conditional expression  "(getter != null && getter.IsAbstract) ||             (setter != null && setter.IsAbstract)"  is complex.
Complex Conditional,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatProperty,The conditional expression  "(getter != null && getter.IsFinal) ||             (setter != null && setter.IsFinal)"  is complex.
Complex Conditional,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,FormatProperty,The conditional expression  "(getter != null && getter.IsVirtual) ||                    (setter != null && setter.IsVirtual)"  is complex.
Complex Conditional,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,GetTypeID,The conditional expression  "cat == UnicodeCategory.UppercaseLetter ||             cat == UnicodeCategory.LowercaseLetter ||             cat == UnicodeCategory.TitlecaseLetter ||             cat == UnicodeCategory.OtherLetter ||             cat == UnicodeCategory.DecimalDigitNumber ||             cp == '_' || cp == '.'"  is complex.
Complex Conditional,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,VisitUnknownElement,The conditional expression  "xmlName.Equals("b") ||         xmlName.Equals("i") || xmlName.Equals("a") ||         xmlName.Equals("sup") || xmlName.Equals("i")"  is complex.
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Bytes,The following statement contains a magic number: if (!lenientLineBreaks && str.Length == 1) {         int c = str[0];         if ((c & 0xf800) == 0xd800) {           if (replace) {  c = 0xfffd; } else {  throw new ArgumentException("Unpaired surrogate code point"); }         }         if (c <= 0x80) {           return new byte[] { (byte)c };         } else if (c <= 0x7ff) {           return new byte[] { (byte)(0xc0 | ((c >> 6) & 0x1f))'             (byte)(0x80 | (c & 0x3f)) };         } else {           return new byte[] { (byte)(0xe0 | ((c >> 12) & 0x0f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         }       } else if (str.Length == 2) {         int c = str[0];         int c2 = str[1];         if ((c & 0xfc00) == 0xd800 && (c2 & 0xfc00) == 0xdc00) {           c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);           return new byte[] { (byte)(0xf0 | ((c >> 18) & 0x07))'             (byte)(0x80 | ((c >> 12) & 0x3f))'             (byte)(0x80 | ((c >> 6) & 0x3f))'             (byte)(0x80 | (c & 0x3f)) };         } else if (!lenientLineBreaks && c <= 0x80 && c2 <= 0x80) {           return new byte[] { (byte)c' (byte)c2 };         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,GetUtf8Length,The following statement contains a magic number: for (var i = 0; i < str.Length; ++i) {         int c = str[i];         if (c <= 0x7f) {           ++size;         } else if (c <= 0x7ff) {           size += 2;         } else if (c <= 0xd7ff || c >= 0xe000) {           size += 3;         } else if (c <= 0xdbff) {  // UTF-16 leading surrogate           ++i;           if (i >= str.Length || str[i] < 0xdc00 || str[i] > 0xdfff) {             if (replace) {               size += 3;               --i;             } else {               return -1;             }           } else {             size += 4;           }         } else {           if (replace) {             size += 3;           } else {             return -1;           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointBefore,The following statement contains a magic number: if ((c & 0xfc00) == 0xdc00 && index - 2 >= 0 &&           str[index - 2] >= 0xd800 && str[index - 2] <= 0xdbff) {         // Get the Unicode code point for the surrogate pair         return 0x10000 + ((str[index - 2] - 0xd800) << 10) + (c - 0xdc00);       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointAt,The following statement contains a magic number: if ((c & 0xfc00) == 0xd800 && index + 1 < str.Length &&           str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {         // Get the Unicode code point for the surrogate pair         c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);         ++index;       } else if ((c & 0xf800) == 0xd800) {         // unpaired surrogate         return (surrogateBehavior == 0) ? 0xfffd : ((surrogateBehavior == 1) ?                     c : (-1));       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: for (var i = 0; i < len; ++i) {          ca = strA[i];          cb = strB[i];         if (ca == cb) {           // normal code units and illegal surrogates           // are treated as single code points           if ((ca & 0xf800) != 0xd800) {             continue;           }           var incindex = false;           if (i + 1 < strA.Length && strA[i + 1] >= 0xdc00 && strA[i + 1] <=               0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);             incindex = true;           }           if (i + 1 < strB.Length && strB[i + 1] >= 0xdc00 && strB[i + 1] <=               0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);             incindex = true;           }           if (ca != cb) {             return ca - cb;           }           if (incindex) {             ++i;           }         } else {           if ((ca & 0xf800) != 0xd800 && (cb & 0xf800) != 0xd800) {             return ca - cb;           }           if ((ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);           }           if ((cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);           }           return ca - cb;         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: for (var i = 0; i < len; ++i) {          ca = strA[i];          cb = strB[i];         if (ca == cb) {           // normal code units and illegal surrogates           // are treated as single code points           if ((ca & 0xf800) != 0xd800) {             continue;           }           var incindex = false;           if (i + 1 < strA.Length && strA[i + 1] >= 0xdc00 && strA[i + 1] <=               0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);             incindex = true;           }           if (i + 1 < strB.Length && strB[i + 1] >= 0xdc00 && strB[i + 1] <=               0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);             incindex = true;           }           if (ca != cb) {             return ca - cb;           }           if (incindex) {             ++i;           }         } else {           if ((ca & 0xf800) != 0xd800 && (cb & 0xf800) != 0xd800) {             return ca - cb;           }           if ((ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);           }           if ((cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);           }           return ca - cb;         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: for (var i = 0; i < len; ++i) {          ca = strA[i];          cb = strB[i];         if (ca == cb) {           // normal code units and illegal surrogates           // are treated as single code points           if ((ca & 0xf800) != 0xd800) {             continue;           }           var incindex = false;           if (i + 1 < strA.Length && strA[i + 1] >= 0xdc00 && strA[i + 1] <=               0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);             incindex = true;           }           if (i + 1 < strB.Length && strB[i + 1] >= 0xdc00 && strB[i + 1] <=               0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);             incindex = true;           }           if (ca != cb) {             return ca - cb;           }           if (incindex) {             ++i;           }         } else {           if ((ca & 0xf800) != 0xd800 && (cb & 0xf800) != 0xd800) {             return ca - cb;           }           if ((ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);           }           if ((cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);           }           return ca - cb;         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,CodePointCompare,The following statement contains a magic number: for (var i = 0; i < len; ++i) {          ca = strA[i];          cb = strB[i];         if (ca == cb) {           // normal code units and illegal surrogates           // are treated as single code points           if ((ca & 0xf800) != 0xd800) {             continue;           }           var incindex = false;           if (i + 1 < strA.Length && strA[i + 1] >= 0xdc00 && strA[i + 1] <=               0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);             incindex = true;           }           if (i + 1 < strB.Length && strB[i + 1] >= 0xdc00 && strB[i + 1] <=               0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);             incindex = true;           }           if (ca != cb) {             return ca - cb;           }           if (incindex) {             ++i;           }         } else {           if ((ca & 0xf800) != 0xd800 && (cb & 0xf800) != 0xd800) {             return ca - cb;           }           if ((ca & 0xfc00) == 0xd800 && i + 1 < strA.Length &&               strA[i + 1] >= 0xdc00 && strA[i + 1] <= 0xdfff) {             ca = 0x10000 + ((ca - 0xd800) << 10) + (strA[i + 1] - 0xdc00);           }           if ((cb & 0xfc00) == 0xd800 && i + 1 < strB.Length &&               strB[i + 1] >= 0xdc00 && strB[i + 1] <= 0xdfff) {             cb = 0x10000 + ((cb - 0xd800) << 10) + (strB[i + 1] - 0xdc00);           }           return ca - cb;         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,WriteUtf8,The following statement contains a magic number: for (int index = offset; index < endIndex; ++index) {          c = str[index];         if (c <= 0x7f) {           if (lenientLineBreaks) {             if (c == 0x0d && (index + 1 >= endIndex || str[index + 1] !=                     0x0a)) {               // bare CR' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             } else if (c == 0x0d) {               // CR-LF pair               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               ++index;               continue;             }             if (c == 0x0a) {               // bare LF' convert to CRLF               if (byteIndex + 2 > StreamedStringBufferLength) {                 // Write bytes retrieved so far                 stream.Write(bytes' 0' byteIndex);                 byteIndex = 0;               }               bytes[byteIndex++] = 0x0d;               bytes[byteIndex++] = 0x0a;               continue;             }           }           if (byteIndex >= StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)c;         } else if (c <= 0x7ff) {           if (byteIndex + 2 > StreamedStringBufferLength) {             // Write bytes retrieved so far             stream.Write(bytes' 0' byteIndex);             byteIndex = 0;           }           bytes[byteIndex++] = (byte)(0xc0 | ((c >> 6) & 0x1f));           bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));         } else {           if ((c & 0xfc00) == 0xd800 && index + 1 < endIndex &&               str[index + 1] >= 0xdc00 && str[index + 1] <= 0xdfff) {             // Get the Unicode code point for the surrogate pair             c = 0x10000 + ((c - 0xd800) << 10) + (str[index + 1] - 0xdc00);             ++index;           } else if ((c & 0xf800) == 0xd800) {             // unpaired surrogate             if (!replace) {               retval = -1;               break;  // write bytes read so far             }             c = 0xfffd;           }           if (c <= 0xffff) {             if (byteIndex + 3 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xe0 | ((c >> 12) & 0x0f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           } else {             if (byteIndex + 4 > StreamedStringBufferLength) {               // Write bytes retrieved so far               stream.Write(bytes' 0' byteIndex);               byteIndex = 0;             }             bytes[byteIndex++] = (byte)(0xf0 | ((c >> 18) & 0x07));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 12) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | ((c >> 6) & 0x3f));             bytes[byteIndex++] = (byte)(0x80 | (c & 0x3f));           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8FromBytes,The following statement contains a magic number: while (pointer < endpointer) {          b = data[pointer] & (int)0xff;         ++pointer;         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             --pointer;             builder.Append((char)0xfffd);             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;            ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO,DataUtilities,C:\repos\peteroupc_CBOR\CBOR\PeterO\DataUtilities.cs,ReadUtf8,The following statement contains a magic number: while (pointer < bytesCount || bytesCount < 0) {         b = stream.ReadByte();         if (b < 0) {           if (bytesNeeded != 0) {             bytesNeeded = 0;             if (replace) {               builder.Append((char)0xfffd);               if (bytesCount >= 0) {                 return -2;               }               break;  // end of stream             }             return -1;           }           if (bytesCount >= 0) {             return -2;           }           break;  // end of stream         }         if (bytesCount > 0) {           ++pointer;         }         if (bytesNeeded == 0) {           if ((b & 0x7f) == b) {             builder.Append((char)b);           } else if (b >= 0xc2 && b <= 0xdf) {             bytesNeeded = 1;             cp = (b - 0xc0) << 6;           } else if (b >= 0xe0 && b <= 0xef) {             lower = (b == 0xe0) ? 0xa0 : 0x80;             upper = (b == 0xed) ? 0x9f : 0xbf;             bytesNeeded = 2;             cp = (b - 0xe0) << 12;           } else if (b >= 0xf0 && b <= 0xf4) {             lower = (b == 0xf0) ? 0x90 : 0x80;             upper = (b == 0xf4) ? 0x8f : 0xbf;             bytesNeeded = 3;             cp = (b - 0xf0) << 18;           } else {             if (replace) {               builder.Append((char)0xfffd);             } else {               return -1;             }           }           continue;         }         if (b < lower || b > upper) {           cp = bytesNeeded = bytesSeen = 0;           lower = 0x80;           upper = 0xbf;           if (replace) {             builder.Append((char)0xfffd);             // "Read" the last byte again             if (b < 0x80) {               builder.Append((char)b);             } else if (b >= 0xc2 && b <= 0xdf) {               bytesNeeded = 1;               cp = (b - 0xc0) << 6;             } else if (b >= 0xe0 && b <= 0xef) {               lower = (b == 0xe0) ? 0xa0 : 0x80;               upper = (b == 0xed) ? 0x9f : 0xbf;               bytesNeeded = 2;               cp = (b - 0xe0) << 12;             } else if (b >= 0xf0 && b <= 0xf4) {               lower = (b == 0xf0) ? 0x90 : 0x80;               upper = (b == 0xf4) ? 0x8f : 0xbf;               bytesNeeded = 3;               cp = (b - 0xf0) << 18;             } else {               builder.Append((char)0xfffd);             }             continue;           }           return -1;         } else {           lower = 0x80;           upper = 0xbf;           ++bytesSeen;           cp += (b - 0x80) << (6 * (bytesNeeded - bytesSeen));           if (bytesSeen != bytesNeeded) {             continue;           }           int ret' ch' lead' trail;           ret = cp;           cp = 0;           bytesSeen = 0;           bytesNeeded = 0;           if (ret <= 0xffff) {             builder.Append((char)ret);           } else {              ch = ret - 0x10000;              lead = (ch >> 10) + 0xd800;              trail = (ch & 0x3ff) + 0xdc00;             builder.Append((char)lead);             builder.Append((char)trail);           }         }       }
Magic Number,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,GetTypeID,The following statement contains a magic number: for (var i = 0; i < name.Length; ++i) {         var cat = CharUnicodeInfo.GetUnicodeCategory(name' i);         var cp = DataUtilities.CodePointAt(name' i);         if (cp >= 0x10000) {           ++i;         }         if (cat == UnicodeCategory.UppercaseLetter ||             cat == UnicodeCategory.LowercaseLetter ||             cat == UnicodeCategory.TitlecaseLetter ||             cat == UnicodeCategory.OtherLetter ||             cat == UnicodeCategory.DecimalDigitNumber ||             cp == '_' || cp == '.') {           if (cp >= 0x10000) {             builder.Append(name' i' 2);           } else {             builder.Append(name[i]);           }         } else {           builder.Append(' ');         }       }
Magic Number,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,VisitException,The following statement contains a magic number: using (var ch = this.Change(this.exceptionStr)) {         var cref = exception.Cref;         if (cref.StartsWith("T:"' StringComparison.Ordinal)) {           cref = cref.Substring(2);         }         this.WriteLine(" * " + cref + ": ");         base.VisitException(exception);         this.WriteLine("\r\n\r\n");       }
Magic Number,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,VisitSee,The following statement contains a magic number: if (cref.Substring(0' 2).Equals("T:")) {         string typeName = TypeNameUtil.UndecorateTypeName(cref.Substring(2));         string content = HtmlEscape(see.Content);         if (String.IsNullOrEmpty(content)) {           content = HtmlEscape(see.ToText());         }         this.Write("[" + content + "]");         this.Write("(" + typeName + ".md)");         base.VisitSee(see);       } else {         base.VisitSee(see);       }
Magic Number,PeterO.DocGen,DocVisitor,C:\repos\peteroupc_CBOR\CBORDocs\DocVisitor.cs,VisitSee,The following statement contains a magic number: if (cref.Substring(0' 2).Equals("T:")) {         string typeName = TypeNameUtil.UndecorateTypeName(cref.Substring(2));         string content = HtmlEscape(see.Content);         if (String.IsNullOrEmpty(content)) {           content = HtmlEscape(see.ToText());         }         this.Write("[" + content + "]");         this.Write("(" + typeName + ".md)");         base.VisitSee(see);       } else {         base.VisitSee(see);       }
Magic Number,PeterO.DocGen,TestGenerator,C:\repos\peteroupc_CBOR\CBORDocs\TestGenerator.cs,GenerateTests,The following statement contains a magic number: foreach (var method in type.GetMethods()) {         if (!method.IsPublic) {           continue;         }         if (!method.DeclaringType.Equals(method.ReflectedType)) {           continue;         }         var methodName = method.Name;         if (methodName.StartsWith("get_"' StringComparison.Ordinal)) {           methodName = methodName.Substring(4);         } else if (methodName.StartsWith("set_"' StringComparison.Ordinal)) {           methodName = methodName.Substring(4);         } else if (methodName.StartsWith("op_"' StringComparison.Ordinal)) {           methodName = "Operator" + methodName.Substring(3);         }         if (methodName.StartsWith(".ctor"' StringComparison.Ordinal)) {           methodName = "Constructor";         }         if (methodName.StartsWith(".cctor"' StringComparison.Ordinal)) {           methodName = "StaticConstructor";         }         if (methodName.Length == 0) {           continue;         }    methodName = methodName.Substring(0' 1).ToUpper() +           methodName.Substring(1);         methods.Add(methodName);       }
Magic Number,PeterO.DocGen,TestGenerator,C:\repos\peteroupc_CBOR\CBORDocs\TestGenerator.cs,GenerateTests,The following statement contains a magic number: foreach (var method in type.GetMethods()) {         if (!method.IsPublic) {           continue;         }         if (!method.DeclaringType.Equals(method.ReflectedType)) {           continue;         }         var methodName = method.Name;         if (methodName.StartsWith("get_"' StringComparison.Ordinal)) {           methodName = methodName.Substring(4);         } else if (methodName.StartsWith("set_"' StringComparison.Ordinal)) {           methodName = methodName.Substring(4);         } else if (methodName.StartsWith("op_"' StringComparison.Ordinal)) {           methodName = "Operator" + methodName.Substring(3);         }         if (methodName.StartsWith(".ctor"' StringComparison.Ordinal)) {           methodName = "Constructor";         }         if (methodName.StartsWith(".cctor"' StringComparison.Ordinal)) {           methodName = "StaticConstructor";         }         if (methodName.Length == 0) {           continue;         }    methodName = methodName.Substring(0' 1).ToUpper() +           methodName.Substring(1);         methods.Add(methodName);       }
Magic Number,PeterO.DocGen,TestGenerator,C:\repos\peteroupc_CBOR\CBORDocs\TestGenerator.cs,GenerateTests,The following statement contains a magic number: foreach (var method in type.GetMethods()) {         if (!method.IsPublic) {           continue;         }         if (!method.DeclaringType.Equals(method.ReflectedType)) {           continue;         }         var methodName = method.Name;         if (methodName.StartsWith("get_"' StringComparison.Ordinal)) {           methodName = methodName.Substring(4);         } else if (methodName.StartsWith("set_"' StringComparison.Ordinal)) {           methodName = methodName.Substring(4);         } else if (methodName.StartsWith("op_"' StringComparison.Ordinal)) {           methodName = "Operator" + methodName.Substring(3);         }         if (methodName.StartsWith(".ctor"' StringComparison.Ordinal)) {           methodName = "Constructor";         }         if (methodName.StartsWith(".cctor"' StringComparison.Ordinal)) {           methodName = "StaticConstructor";         }         if (methodName.Length == 0) {           continue;         }    methodName = methodName.Substring(0' 1).ToUpper() +           methodName.Substring(1);         methods.Add(methodName);       }
